
/*                  - Mellanox Confidential and Proprietary -
 *
 *  Copyright (C) 2010-2011, Mellanox Technologies Ltd.  ALL RIGHTS RESERVED.
 *
 *  Except as specifically permitted herein, no portion of the information,
 *  including but not limited to object code and source code, may be reproduced,
 *  modified, distributed, republished or otherwise exploited in any form or by
 *  any means for any purpose without the prior written permission of Mellanox
 *  Technologies Ltd. Use of software subject to the terms and conditions
 *  detailed in the file "LICENSE.txt".
 *
 */
 

/***
         *** This file was generated at "2017-01-10 22:27:58"
         *** by:
         ***    > /mswg/release/eat_me/last_release/adabe_plugins/adb2c/adb2pack.py --input adb/connectx4lx/connectx4lx.adb --file-prefix connectx4lx --prefix connectx4lx_
         ***/
#ifndef CONNECTX4LX_LAYOUTS_H
#define CONNECTX4LX_LAYOUTS_H


#ifdef __cplusplus
extern "C" {
#endif

#include "adb_to_c_utils.h"/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_cmdif_ctx_special_qp_commands_uapp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - uapp_qp_buf_id */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t uapp_qp_buf_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - used when qp is attached to xrq- MUST BE AT LAST DWORD OF SPECIAL CTX */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sw_wq_mkn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - used when qp is attached to xrq- MUST BE AT LAST DWORD OF SPECIAL CTX */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t num_nim_indicies_allocated;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_cmdif_ctx_special_qp_commands_underlay {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t ste_ix;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pddr_advanced_opcode {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Status opcode: 
PHY FW indication (0 - 999):
0 - No issue observed
1 - Port is close by command (see PAOS).
2 - AN no partner detected.
3 - AN ack not received. 
4 - AN next-page exchange failed. 
5 - KR frame lock not acquired.
6 - KR link inhibit timeout 
7 - KR Link partner didn't set receiver ready
8 - KR tuning didn't completed 
9 - PCS didn't acquire block lock. 
10 - PCS didn't acquire AM lock (NO FEC) 
11 - PCS didn't get align_status.
12 - FC FEC isn't locked
13 - RS FEC isn't locked
14 - Remote fault received
15 - Bad SI / Poor tuning grade 
16 - Compliance code mismatch (protocol mismatch between 
cable and port)
17 - Large number of physical errors (high BER). 
18 - Port is disabled by Ekey
19- Phase EO failure
20- stamping of Non Mellanox Cables/Modules
21 - Down by PortInfo MAD
22 - Disabled by Verification
23 - Calibration failure
MNG FW issues (1000 - 1999):
1000 - Cable is unplugged/powered off
1001 - 
Long Range for non MLNX cable/module .
1002 - 
Bus stuck (I2C Data or clock shorted) 
1003 - 
bad/unsupported EEPROM 
1004 - 
part number list
1005 - 
unsupported cable.
1006 - module temperature shutdown
1007 - Shorted cable
1008 - 
Power Budget Exceeded
1009 - Management force down the port
Core/Driver (2000 - 2999): */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t advenced_opcode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pddr_monitor_opcode {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Status opcode: 
PHY FW indication (0 - 1023):
0 - No issue observed
1 - Port is close by command (see PAOS).
2 - AN failure 
5 - Link training failure. 
9 - Logical mismatch between
 
link partners
14 - Remote fault received
15 - Bad SI / Poor tuning grade 
16 - Cable Compliance code mismatch (protocol mismatch 
between cable and port) 
23- Boot sequence error
1023- Other issue
MNG FW issues (1024 - 2047):
1024 - Cable is unplugged/powered off
1025 - 
Long Range for non MLNX cable/module .
1026 - 
Bus stuck (I2C Data or clock shorted) 
1027 - 
bad/unsupported EEPROM 
1028 - 
part number list
1029 - 
unsupported cable.
1030 - module temperature shutdown
1031 - Shorted cable
1032 - 
Power Budget Exceeded
1033 - Management forced down the port
Core/Driver (2048 - 3071): */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t monitor_opcode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_regular_qp_eth {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - points to head qp that holds the rq state */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t rq_head_qpn;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t lag_tx_port_affinity;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_regular_qp_ipoib {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t underlay_qp_ste_ix;
};

/* Description -  // Created Manually by alonb At Mon Aug 1 2016  */
/* Size in bytes - 16 */
struct connectx4lx_ste_flex_parser_tnl_header_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t flex_parser_tunneling_header_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t flex_parser_tunneling_header_31_0;
};

/* Description -  // Created At Mon Oct  6 15:04:29 IDT 2014, By the following script (revision 1.46): /verification/utils/decoder2adb.tcl -f steering_gre_tag_decoder.v */
/* Size in bytes - 16 */
struct connectx4lx_ste_gre_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t gre_first_dw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t gre_key;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l3_ipv6_src_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t sip_127_96;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sip_95_64;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t sip_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t sip_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l3_ipv6_des_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dip_127_96;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t dip_95_64;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t dip_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t dip_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dip;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sip;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t dport;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t sport;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t protocol;
	/* Description - TODO: need to align this field to 8.  */
	/* 0xc.10 - 0xc.15 */
	 u_int8_t dscp;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t tcp_fin;
	/* Description -  */
	/* 0xc.17 - 0xc.17 */
	 u_int8_t tcp_syn;
	/* Description -  */
	/* 0xc.18 - 0xc.18 */
	 u_int8_t tcp_rst;
	/* Description -  */
	/* 0xc.19 - 0xc.19 */
	 u_int8_t tcp_psh;
	/* Description -  */
	/* 0xc.20 - 0xc.20 */
	 u_int8_t tcp_ack;
	/* Description -  */
	/* 0xc.21 - 0xc.21 */
	 u_int8_t tcp_urg;
	/* Description -  */
	/* 0xc.22 - 0xc.22 */
	 u_int8_t tcp_ece;
	/* Description -  */
	/* 0xc.23 - 0xc.23 */
	 u_int8_t tcp_cwr;
	/* Description -  */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t tcp_ns;
	/* Description - TODO: need to align this field to 2.  */
	/* 0xc.25 - 0xc.26 */
	 u_int8_t ecn;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t fragmented;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l4_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t dport;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t protocol;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t fragmented;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t sport;
	/* Description -  */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t tcp_fin;
	/* Description -  */
	/* 0x4.17 - 0x4.17 */
	 u_int8_t tcp_syn;
	/* Description -  */
	/* 0x4.18 - 0x4.18 */
	 u_int8_t tcp_rst;
	/* Description -  */
	/* 0x4.19 - 0x4.19 */
	 u_int8_t tcp_psh;
	/* Description -  */
	/* 0x4.20 - 0x4.20 */
	 u_int8_t tcp_ack;
	/* Description -  */
	/* 0x4.21 - 0x4.21 */
	 u_int8_t tcp_urg;
	/* Description -  */
	/* 0x4.22 - 0x4.22 */
	 u_int8_t tcp_ece;
	/* Description -  */
	/* 0x4.23 - 0x4.23 */
	 u_int8_t tcp_cwr;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t tcp_ns;
	/* Description - TODO: need to align this field to 2.  */
	/* 0x4.25 - 0x4.26 */
	 u_int8_t ecn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - TODO: need to align this field to 8.  */
	/* 0x8.2 - 0x8.7 */
	 u_int8_t dscp;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t flow_label;
};

/* Description -  // Created At Tue Oct  7 08:47:30 IDT 2014, By the following script (revision 1.46): /verification/utils/decoder2adb.tcl -f rxt_steering_eth_l2_tnl_tag_decoder.v */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l2_tnl_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dmac_47_16;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t l3_ethertype;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t dmac_15_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t l2_tunneling_network_id;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.11 */
	 u_int16_t vlan_id;
	/* Description -  */
	/* 0xc.14 - 0xc.15 */
	 u_int8_t vlan_qualifier;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t gre_key_flag;
	/* Description -  */
	/* 0xc.20 - 0xc.20 */
	 u_int8_t cfi;
	/* Description - TODO: need to align this field to 4.  */
	/* 0xc.21 - 0xc.23 */
	 u_int8_t prio;
	/* Description -  */
	/* 0xc.24 - 0xc.25 */
	 u_int8_t l4_type;
	/* Description -  */
	/* 0xc.26 - 0xc.27 */
	 u_int8_t l3_type;
	/* Description -  */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t encapsulation_type;
	/* Description -  */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t tcp_syn;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t ip_fragment;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l2_src_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t smac_47_16;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t l3_ethertype;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t smac_15_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t first_vlan_id;
	/* Description -  */
	/* 0x8.14 - 0x8.15 */
	 u_int8_t first_vlan_qualifier;
	/* Description -  */
	/* 0x8.16 - 0x8.16 */
	 u_int8_t first_vlan_cfi;
	/* Description - TODO: need to align this field to 4.  */
	/* 0x8.17 - 0x8.19 */
	 u_int8_t first_vlan_prio;
	/* Description -  */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t port;
	/* Description -  */
	/* 0x8.25 - 0x8.25 */
	 u_int8_t functional_loopback;
	/* Description -  */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t force_loopback;
	/* Description -  */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t sx_sniffer;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t ethertype_filter;
	/* Description -  */
	/* 0x8.30 - 0x8.31 */
	 u_int8_t qp_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.11 */
	 u_int16_t second_vlan_id;
	/* Description -  */
	/* 0xc.14 - 0xc.15 */
	 u_int8_t second_vlan_qualifier;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t second_vlan_cfi;
	/* Description - TODO: need to align this field to 4.  */
	/* 0xc.17 - 0xc.19 */
	 u_int8_t second_vlan_prio;
	/* Description -  */
	/* 0xc.24 - 0xc.25 */
	 u_int8_t l4_type;
	/* Description -  */
	/* 0xc.26 - 0xc.27 */
	 u_int8_t l3_type;
	/* Description -  */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t encapsulation_type;
	/* Description -  */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t tcp_syn;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t ip_fragment;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ste_eth_l2_des_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dmac_47_16;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t l3_ethertype;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t dmac_15_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t first_vlan_id;
	/* Description -  */
	/* 0x8.14 - 0x8.15 */
	 u_int8_t first_vlan_qualifier;
	/* Description -  */
	/* 0x8.16 - 0x8.16 */
	 u_int8_t first_vlan_cfi;
	/* Description - TODO: need to align this field to 4.  */
	/* 0x8.17 - 0x8.19 */
	 u_int8_t first_vlan_prio;
	/* Description -  */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t port;
	/* Description -  */
	/* 0x8.25 - 0x8.25 */
	 u_int8_t functional_loopback;
	/* Description -  */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t force_loopback;
	/* Description -  */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t sx_sniffer;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t ethertype_filter;
	/* Description -  */
	/* 0x8.30 - 0x8.31 */
	 u_int8_t qp_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.11 */
	 u_int16_t second_vlan_id;
	/* Description -  */
	/* 0xc.14 - 0xc.15 */
	 u_int8_t second_vlan_qualifier;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t second_vlan_cfi;
	/* Description - TODO: need to align this field to 4.  */
	/* 0xc.17 - 0xc.19 */
	 u_int8_t second_vlan_prio;
	/* Description -  */
	/* 0xc.24 - 0xc.25 */
	 u_int8_t l4_type;
	/* Description -  */
	/* 0xc.26 - 0xc.27 */
	 u_int8_t l3_type;
	/* Description -  */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t encapsulation_type;
	/* Description -  */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t tcp_syn;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t ip_fragment;
};

/* Description -  // Created At Thu Aug 29 11:21:50 IDT 2013, By the following script (revision 1.45): /verification/utils/decoder2adb.tcl -f rxt_steering_ib_l4_tag_decoder.v -adbfile steering.adb -o steering_ib_l4_tag */
/* Size in bytes - 16 */
struct connectx4lx_ste_ib_l4_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t dest_qp;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t pkey;
};

/* Description -  // Created At Wed Jul 29 11:42:21 IDT 2015, By the following script (revision 1.48): /verification/utils/decoder2adb.tcl -f rxt_steering_ib_l3_extended_tag_decoder.v */
/* Size in bytes - 16 */
struct connectx4lx_ste_ib_l3_extended_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t flow_label;
	/* Description -  */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t sl;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t traffic_class;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t pkey;
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t dcceth_present;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t deth_present;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t bth_present;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t ip_ver;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t qkey_dc_access_key_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t qkey_dc_access_key_31_0;
};

/* Description -  // Created At Mon Jul 15 10:33:36 IDT 2013, By the following script (revision 1.45): /verification/utils/decoder2adb.tcl -f rxt_steering_ib_l3_tag_decoder.v -adbfile steering.adb -o steering_ib_l3_tag */
/* Size in bytes - 16 */
struct connectx4lx_ste_ib_l3_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dgid_127_96;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t dgid_95_64;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t dgid_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t dgid_31_0;
};

/* Description -  // Created At Mon Jul 15 10:35:18 IDT 2013, By the following script (revision 1.45): /verification/utils/decoder2adb.tcl -f rxt_steering_port_ib_l2_tag_decoder.v -adbfile steering.adb -o steering_port_ib_l2_tag */
/* Size in bytes - 16 */
struct connectx4lx_ste_port_ib_l2_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t dlid;
	/* Description -  */
	/* 0x0.18 - 0x0.19 */
	 u_int8_t qp_type;
	/* Description -  */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t sl;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t grh;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t bth;
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t func_lb;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t force_lb;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t sx_sniffer;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t port_num;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t flow_label;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t rwh_ethertype;
};

/* Description -  // Created At Thu Aug 29 11:23:10 IDT 2013, By the following script (revision 1.45): /verification/utils/decoder2adb.tcl -f rxt_steering_loopback_tag_decoder.v -adbfile steering.adb -o steering_loopback_tag */
/* Size in bytes - 16 */
struct connectx4lx_ste_loopback_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.13 */
	 u_int16_t source_gvmi;
	/* Description - old lb syndrome (like Shomron) */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t loopback_synd;
	/* Description - new lb syndrome (bitmask) */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t loopback_syndrome;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t source_qp;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t source_is_requestor;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_ste_tag_bulk {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -   */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t tag_127_96;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -   */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t tag_95_64;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -   */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tag_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -   */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t tag_31_0;
};

/* Description -   */
/* Size in bytes - 12 */
union connectx4lx_cmdif_ctx_special_qp_commands_inner {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_cmdif_ctx_special_qp_commands_underlay underlay_qp;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_cmdif_ctx_special_qp_commands_uapp uapp;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pmlp_code_style_lane {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t module_num;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to a local port. */
	/* 0x0.16 - 0x0.17 */
	 u_int8_t module_lane;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_dw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dw;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_nvlog {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t parameter_index;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t sub_class;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_eswitch {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t parameter_index;
	/* Description -  */
	/* 0x0.16 - 0x0.17 */
	 u_int8_t port;
	/* Description -  */
	/* 0x0.18 - 0x0.23 */
	 u_int8_t host;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_per_host {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t parameter_index;
	/* Description -  */
	/* 0x0.10 - 0x0.17 */
	 u_int8_t function;
	/* Description -  */
	/* 0x0.18 - 0x0.23 */
	 u_int8_t host;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_bmc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.12 */
	 u_int16_t parameter_index;
	/* Description -  */
	/* 0x0.13 - 0x0.17 */
	 u_int8_t channel;
	/* Description -  */
	/* 0x0.18 - 0x0.23 */
	 u_int8_t host;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_physical_port {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t parameter_index;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_type_global {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t parameter_index;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t class_;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_pddr_monitor_opcode pddr_monitor_opcode;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_pddr_advanced_opcode pddr_advanced_opcode;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_regular_qp_sub_type {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_regular_qp_ipoib ipoib;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_regular_qp_eth eth;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_hw_ste_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_hw_ste_tag_bulk bulk;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_loopback_tag source_gvmi_qp;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_port_ib_l2_tag ibl2;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_ib_l3_tag ibl3;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_ib_l3_extended_tag ibl3_ext;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_ib_l4_tag ibl4;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l2_des_tag ethl2_des;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l2_src_tag ethl2_src;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l2_tnl_tag ethl2_tnl;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l4_tag ethl4;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag eth_ipv4_5touple;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l3_ipv6_des_tag eth_ipv6_des;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_eth_l3_ipv6_src_tag eth_ipv6_src;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_gre_tag gre;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ste_flex_parser_tnl_header_tag flex_parser_tnl;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_mlx_phy_speed_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Standard LL RS-FEC - RS(271,257)
Bit 4 - Mellanox Strong RS-FEC - RS(277,257)
Bit 5 - Mellanox LL RS-FEC - RS(163,155)
Bit 6 - Mellanox COD
 */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t fec_mode;
	/* Description - Bit 0 - LLR
Bit 1 - PLR
 */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t retransmission_mode;
	/* Description - 0 - optimize robustness
1 - optimize latency
2 - optimize bandwidth */
	/* 0x0.10 - 0x0.11 */
	 u_int8_t link_mode_policy;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_cmdif_ctx_special_qp_commands_other {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - next sqn to allocate pages in sq qplist hop3  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t next_sqn_for_4page_allocate;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x10.31 */
	 union connectx4lx_cmdif_ctx_special_qp_commands_inner inner;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - rts2rts:  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t new_cqn_rcv;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - rts2rts:  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t new_srqn_rmpn;
	/* Description - rts2rts:  */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t srq_cre_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - rts2rts: union params2assign_u qp_params */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t qp_params;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_ip_filter_mode {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 00: MAC address is used and IP address is ignored on pass-through
01: MAC address is used and IP address is used on pass-through
10: MAC address is ignored and IP address is used on pass-through
11: Reserved */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t filter_by_ip_address;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t ipv4_enable;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t ipv6_link_local_address_enable;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t ipv6_global_address_enable;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_pmlp_code_style {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - unmap local port
1 - x1 (lane 0 is used)
2 - x2 (lanes 0,1 are used)
4 - x4 (lanes 0,  1,2 and 3 are used)
Other - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t width;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_pmlp_code_style_lane local_lane[4];
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_pmlp_prm_style {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - unmap local port
1 - x1 (lane 0 is used)
2 - x2 (lanes 0,1 are used)
4 - x4 (lanes 0,  1,2 and 3 are used)
Other - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t width;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t module0;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to a local port. */
	/* 0x4.16 - 0x4.17 */
	 u_int8_t lane0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t module1;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to a local port. */
	/* 0x8.16 - 0x8.17 */
	 u_int8_t lane1;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t module2;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to a local port. */
	/* 0xc.16 - 0xc.17 */
	 u_int8_t lane2;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t module3;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to a local port. */
	/* 0x10.16 - 0x10.17 */
	 u_int8_t lane3;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_access_data_reduced {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Real size can be larger than 0x20. Size is extracted from TLV */
	/* 0x0.0 - 0x10.31 */
	 u_int32_t dword[4];
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_nv_tlv_hdr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Size of configuration item data in bytes (not including header). Must be between 0 and 256 */
	/* 0x0.0 - 0x0.8 */
	 u_int16_t length;
	/* Description - tlv writer host index */
	/* 0x0.9 - 0x0.11 */
	 u_int8_t writer_host_id;
	/* Description - Configuration item version - defines the data structure following the header (together with the type field). See configuration items definitions */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t version;
	/* Description - Writer ID */
	/* 0x0.16 - 0x0.20 */
	 u_int8_t writer_id;
	/* Description - Choose - read current values or user defined values: 0x0 - user defined values
 0x1 - current values ( values that are loaded in last boot)
 */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t read_current;
	/* Description - Choose - read default values or user defined values: 0x0 - user defined values
 0x1 - default values
 */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t read_default;
	/* Description - Controls the read operation of non-FW entities.
0 - TLV can be read.
1 - TLV cannot be read */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t rd_en;
	/* Description - Enables overwriting a TLV by lower priorities.
00 - Only written during equal or higher priority.
01 - Allowed to be over-written by the next level priority.
10 - Allowed to be overwritten at any stage */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t ovr_en;
	/* Description - Encodes the storage element Header Format
00 - Only Header is protected by CRC
01 - Header and Data are protected by CRC
10 - reserved
11 - reserved */
	/* 0x0.26 - 0x0.27 */
	 u_int8_t header_type;
	/* Description - Defines the allowed access to the data element
00 - Written only during Mellanox production stage
01 - Written during Mellanox production and OEM production stage
10 - written at any stage
11 - Reserved */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t priority;
	/* Description - Encodes the data element validity
11 - Free (no data esists)
10 - Valid data
00 - Invalidated data element, should be skipped
01 - Illegal, treated as Invalidated data element */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Configuration item type */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Encodes the data integrity check of the data element.
Note: in some elements only encodes the header into the CRC16, as defined in the header type field */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t crc16;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_nv_tlv_type {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_global global;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_physical_port physical_port;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_bmc bmc;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_per_host per_host;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_eswitch eswitch;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_type_nvlog nvlog;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_dw as_dw;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_register_access_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Real size can be larger than 0x20. Size is extracted from TLV */
	/* 0x0.0 - 0x20.31 */
	 u_int32_t dword[8];
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_mfba_header {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Transaction size */
	/* 0x4.0 - 0x4.8 */
	 u_int16_t size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - address in bytes */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t address;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_pmmp_sfp_protocol_override_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 10G Ethernet Compliance Codes
Override byte3 per SFF-8472:
Bit 7 - 10G Base-ER 
Bit 6 - 10G Base-LRM 
Bit 5 - 10G Base-LR 
Bit 4 - 10G Base-SR */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t tengig_ethernet_compliance_code;
	/* Description - SFP+ Cable Technology
Override byte8 per SFF-8472:
Bit 3 - Active Cable
Bit 2 - Passive Cable */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t cable_technology;
	/* Description - Override byte12 per SFF-8472
The nominal bit (signaling) rate (BR, nominal) is specified in 
units of 100 MBd, rounded off to the nearest 100 MBd.
A value of FFh indicates the bit rate is greater than 25.0Gb/s */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t bit_rate;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Ethernet Compliance Codes 
Override byte6 per SFF-8472:
Bit 7 - BASE-PX 
Bit 6 - BASE-BX10 
Bit 5 - 100BASE-FX 
Bit 4 - 100BASE-LX/LX10 
Bit 3 - 1000BASE-T 
Bit 2 - 1000BASE-CX 
Bit 1 - 1000BASE-LX 
Bit 0 - 1000BASE-SX */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t ethernet_compliance_code;
	/* Description - Extended Specification Compliance Codes (25GE) 
Override byte36 per SFF-8472:
0 - Unspecified
1 - 100G AOC (Active Optical Cable) or 25GAUI C2M AOC 
with FEC
2 - 100GBASE-SR4 or 25GBASE-SR
3 - 100GBASE-LR4 or 25GBASE-LR
4 - 100GBASE-ER4 or 25GBASE-ER
5 - 100GBASE-SR10
6 - 100G CWDM4
7 - 100G PSM4 Parallel SMF
8 - 100G ACC (Active Copper Cable) or 25GAUI C2M ACC. 
with FEC
11 - 100GBASE-CR4 or 25GBASE-CR CA-L
12 - 25GBASE-CR CA-S
13 - 25GBASE-CR CA-N
16 - 40GBASE-ER4
17 - 4 x 10GBASE-SR
18 - 40G PSM4 Parallel SMF
19 - G959.1 profile P1I1-2D1 (10709 MBd, 2km, 1310nm SM)
20 - G959.1 profile P1S1-2D2 (10709 MBd, 40km, 1550nm SM)
21 - G959.1 profile P1L1-2D2 (10709 MBd, 80km, 1550nm SM)
22 - 10GBASE-T with SFI electrical interface
23 - 100G CLR4
24 - 100G AOC or 25GAUI C2M AOC. No FEC
25 - 100G ACC or 25GAUI C2M ACC. No FEC */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ext_ethernet_compliance_code;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_pmmp_qsfp_protocol_override_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Ethernet Compliance Codes bit mask (10/40G/100G)
Override byte131 per SFF-8636:
Bit 7 - Extended Specification Compliance valid
Bit 6 - 10GBASE-LRM
Bit 5 - 10GBASE-LR
Bit 4 - 10GBASE-SR
Bit 3 - 40GBASE-CR4
Bit 2 - 40GBASE-SR4
Bit 1 - 40GBASE-LR4
Bit 0 - 40G Active Cable (XLPPI) */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t ethernet_compliance_code;
	/* Description - Override of byte113 per SFF-8636:
Bit 6-4 (Far End):
0 - Far end is unspecified
1 - Cable with single far end with 4 channels implemented, or 
separable module with 4-channel connector
2 - Cable with single far end with 2 channels implemented, or 
separable module with 2-channel connector
3 - Cable with single far end with 1 channel implemented, or sep
arable module with 1-channel connector
4 - 4 far ends with 1 channel implemented in each (i.e. 4x1 break 
out)
5 - 2 far ends with 2 channels implemented in each (i.e. 2x2 
break out)
6 - 2 far ends with 1 channel implemented in each (i.e. 2x1 break 
out)
Bit 3-0 (Near End)
Bit 0 - Channel 1 implementation 
Bit 1 - Channel 2 implementation
Bit 2 - Channel 3 implementation
Bit 3 - Channel 4 implementation
for each channel:
0 - Channel implemented 
1 - Channel not - implemented */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t cable_breakout;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Gigabit Ethernet Compliance Codes 
Override byte134 per SFF-8636:
Bit 3 - 1000BASE-T
Bit 2 - 1000BASE-CX
Bit 1 - 1000BASE-LX
Bit 0 - 1000BASE-SX */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t giga_ethernet_compliance_code;
	/* Description - Extended Specification Compliance Codes 
Override byte192 per SFF-8636:
0 - Unspecified
1 - 100G AOC (Active Optical Cable) or 25GAUI C2M AOC 
with FEC
2 - 100GBASE-SR4 or 25GBASE-SR
3 - 100GBASE-LR4 or 25GBASE-LR
4 - 100GBASE-ER4 or 25GBASE-ER
5 - 100GBASE-SR10
6 - 100G CWDM4
7 - 100G PSM4 Parallel SMF
8 - 100G ACC (Active Copper Cable) or 25GAUI C2M ACC. 
with FEC
11 - 100GBASE-CR4 or 25GBASE-CR CA-L
12 - 25GBASE-CR CA-S
13 - 25GBASE-CR CA-N
16 - 40GBASE-ER4
17 - 4 x 10GBASE-SR
18 - 40G PSM4 Parallel SMF
19 - G959.1 profile P1I1-2D1 (10709 MBd, 2km, 1310nm SM)
20 - G959.1 profile P1S1-2D2 (10709 MBd, 40km, 1550nm SM)
21 - G959.1 profile P1L1-2D2 (10709 MBd, 80km, 1550nm SM)
22 - 10GBASE-T with SFI electrical interface
23 - 100G CLR4
24 - 100G AOC or 25GAUI C2M AOC. No FEC
25 - 100G ACC or 25GAUI C2M ACC. No FEC */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ext_ethernet_compliance_code;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pddr_module_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - QSFP:
E
thernet Compliance Codes bit mask (10/40G/100G
)
Byt
e131 per SFF-8636
 
Bit 7 - Extended Specification Compliance valid
Bit 6 - 10GBASE-LRM
Bit 5 - 10GBASE-LR
Bit 4 - 10GBASE-SR
Bit 3 - 40GBASE-CR4
Bit 2 - 40GBASE-SR4
Bit 1 - 40GBASE-LR4
Bit 0 - 40G Active Cable (XLPPI)
SFP : 
10G Ethernet Compliance Codes
Byte3 per SFF-8472:
Bit 7 - 10G Base-ER 
Bit 6 - 10G Base-LRM 
Bit 5 - 10G Base-LR 
Bit 4 - 10G Base-SR */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t ethernet_compliance_code;
	/* Description - E
xtended Specification Compliance Codes 
b
yte192 per SFF-8636
 (QSFP28) / byte 36 per SFF-8472 (SFP28) */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t ext_ethernet_compliance_code;
	/* Description - Reserved for SFP. 
By
te113 per SFF-863
6 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t cable_breakout;
	/* Description - QSFP: 
Byte 147 per SFF-8636.
SFP:
S
FP+ Cable Technology
: 
b
yte8 per SFF-8472:
Bit 3 - Active Cable
Bit 2 - Passive Cable */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t cable_technology;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Module maximum power consumption:
0 - Power Class 0 (1.0 W max)
1 - Power Class 1 (1.5 W max)
2 - Power Class 2 (2.0 W max)
3 - Power Class 3 (2.5 W max)
4 - Power Class 4 (3.5 W max)
5 - Power Class 5 (4.0 W max)
6 - Power Class 6 (4.5 W max)
7 - Power Class 7 (5.0 W max) */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t cable_power_class;
	/* Description - 0 - QSFP28
1 - QSFP+
2 - SFP28/SFP+
3 - QSA (QSFP->SFP)
4 - Backplane */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t cable_identifier;
	/* Description - Cable length in 1m units. */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t cable_length;
	/* Description - Cable vendor:
0 - Other 
1 - Mellanox
2 - Known OUI */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t cable_vendor;
	/* Description - Cable/module type:
0 - Unidentified
1 - Active cable (active copper / optics)
2 - Optical Module (separated).
2 - Passive copper cable
3 - Cable unplugged */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t cable_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t cable_tx_equalization;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t cable_rx_emphasis;
	/* Description - Reserved for SFP */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t cable_rx_amp;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Reserved for SFP */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t cable_attenuation_5g;
	/* Description - Reserved for SFP */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t cable_attenuation_7g;
	/* Description - Reserved
 
for SFP */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t cable_attenuation_12g;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Bit 0 -
 
TX CDR on/off on channel 0 
Bit 1 - TX CDR on/off on channel 1 
Bit 2 - TX CDR on/off on channel 2 
Bit 3 - TX CDR on/off on channel 3 
CDR on - when bit is set.
CDR off - when bit is clear. */
	/* 0x10.0 - 0x10.3 */
	 u_int8_t tx_cdr_state;
	/* Description - Bit 0 -
 
RX CDR on/off on channel 0 
Bit 1 - RX CDR on/off on channel 1 
Bit 2 - RX CDR on/off on channel 2 
Bit 3 - RX CDR on/off on channel 3 
CDR on - when bit is set.
CDR off - when bit is clear. */
	/* 0x10.8 - 0x10.11 */
	 u_int8_t rx_cdr_state;
	/* Description - 0 - No CDR
1 - Build-in CDR with on/off control 
2 - Build-in CDR without on/off control */
	/* 0x10.16 - 0x10.19 */
	 u_int8_t tx_cdr_cap;
	/* Description - 0 - No CDR
1 - Build-in CDR with on/off control 
2 - Build-in CDR without on/off control */
	/* 0x10.20 - 0x10.23 */
	 u_int8_t rx_cdr_cap;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x24.23 */
	 u_int8_t vendor_name[16];
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Vendor Part Number */
	/* 0x24.24 - 0x34.23 */
	 u_int8_t vendor_pn[16];
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t vendor_rev;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t fw_version;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Vendor Serial Number */
	/* 0x3c.24 - 0x4c.23 */
	 u_int8_t vendor_sn[16];
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - Internally measured supply voltage in V */
	/* 0x4c.0 - 0x4c.15 */
	 u_int16_t voltage;
	/* Description - module temperature in C */
	/* 0x4c.16 - 0x4c.31 */
	 u_int16_t temperature;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - RX measured power channel 1 in dBm */
	/* 0x50.0 - 0x50.15 */
	 u_int16_t rx_power_lane1;
	/* Description - RX measured power channel 0 in dBm */
	/* 0x50.16 - 0x50.31 */
	 u_int16_t rx_power_lane0;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - RX measured power channel 3 in dBm */
	/* 0x54.0 - 0x54.15 */
	 u_int16_t rx_power_lane3;
	/* Description - RX measured power channel 2 in dBm */
	/* 0x54.16 - 0x54.31 */
	 u_int16_t rx_power_lane2;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - TX measured power channel 1 in dBm */
	/* 0x60.0 - 0x60.15 */
	 u_int16_t tx_power_lane1;
	/* Description - TX measured power channel 0 in dBm */
	/* 0x60.16 - 0x60.31 */
	 u_int16_t tx_power_lane0;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - TX measured power channel 3 in dBm */
	/* 0x64.0 - 0x64.15 */
	 u_int16_t tx_power_lane3;
	/* Description - TX measured power channel 2 in dBm */
	/* 0x64.16 - 0x64.31 */
	 u_int16_t tx_power_lane2;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - TX measured bias current on channel 1 in 2uA */
	/* 0x70.0 - 0x70.15 */
	 u_int16_t tx_bias_lane1;
	/* Description - TX measured bias current on channel 0 in 2uA */
	/* 0x70.16 - 0x70.31 */
	 u_int16_t tx_bias_lane0;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - TX measured bias current on channel 3 in 2uA */
	/* 0x74.0 - 0x74.15 */
	 u_int16_t tx_bias_lane3;
	/* Description - TX measured bias current on channel 2 in 2uA */
	/* 0x74.16 - 0x74.31 */
	 u_int16_t tx_bias_lane2;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - Alarm low temperature threshold in C */
	/* 0x80.0 - 0x80.15 */
	 u_int16_t temperature_low_th;
	/* Description - Alarm high temperature threshold in C */
	/* 0x80.16 - 0x80.31 */
	 u_int16_t temperature_high_th;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description - Alarm low Voltage threshold in V */
	/* 0x84.0 - 0x84.15 */
	 u_int16_t voltage_low_th;
	/* Description - Alarm high Voltage threshold in V */
	/* 0x84.16 - 0x84.31 */
	 u_int16_t voltage_high_th;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description - Alarm low RX Power threshold in dBm. 
Taking only from channel 0. */
	/* 0x88.0 - 0x88.15 */
	 u_int16_t rx_power_low_th;
	/* Description - Alarm high
 
RX Power threshold in dBm. 
Taking only from channel 0. */
	/* 0x88.16 - 0x88.31 */
	 u_int16_t rx_power_high_th;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - Alarm low TX Power threshold in dBm. 
Taking only from channel 0. */
	/* 0x8c.0 - 0x8c.15 */
	 u_int16_t tx_power_low_th;
	/* Description - Alarm high
 
TX Power threshold in dBm. 
Taking only from channel 0. */
	/* 0x8c.16 - 0x8c.31 */
	 u_int16_t tx_power_high_th;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description - Alarm low TX Bias current threshold in 2 uA. */
	/* 0x90.0 - 0x90.15 */
	 u_int16_t tx_bias_low_th;
	/* Description - Alarm high
 
TX Bias current threshold in 2 uA. */
	/* 0x90.16 - 0x90.31 */
	 u_int16_t tx_bias_high_th;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description - Nominal laser wavelength in nm */
	/* 0x94.0 - 0x94.15 */
	 u_int16_t wavelength;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pddr_troubleshooting_page {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - Monitor opcodes */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t group_opcode;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Status opcode
 
described in:
See Table  613, "PDDR - Monitor opcodes layout," on page  706
[Internal] 
See Table  615, "PDDR - Advanced opcodes layout," on 
page  707 */
	/* 0x4.0 - 0x8.31 */
	 union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto status_opcode;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - TBD */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t user_feedback_index;
	/* Description - TBD */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t user_feedback_data;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - ASCII code message
All Messages are terminated by a Null character '\0' */
	/* 0xc.24 - 0xf8.23 */
	 u_int8_t status_message[236];
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pddr_phy_info_page {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port notifications bit mask
Bit 0 - Link partner advertised capabilities 
Bit 1 - Speed degradation */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_notifications;
	/* Description - Remote device type: 
0 - Unknown (3rd party , Force , legacy MLPN)  
1 - CX4
2 - CX4_LX
3 - CX5
4 - CX5_LX
5 - CX6
6 - CX6_LX
7-99 Reserved
100 - SwitchIB
101 - Spectrum 
102 - SwitchIB-2
103 - SwitchIB-3
104 - Spectrum-2
105-255 Reserved */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t remote_device_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Link partner IB TS revision */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t lp_ib_revision;
	/* Description - IB TS revision */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ib_revision;
	/* Description - Negotiation attempt counter */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t num_of_negotiation_attempts;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Phy manager disable bit mask: 
Bit 0 - Module not present (module absence/cage power off)
Bit 1 - PAOS command
Bit 2 - MAD IB PortInfo down command
Bit 3 - Long range cable (Non Mellanox) 
Bit 4 - Verification command
Bit 5 - ekey command
Bit 6 - High power - cable require higher power than allowed.
Bit 7 - Unknown Identifier (Module)
Bit 8 - PAOS up once 
Bit 9 - Stamping failure
Bit 10 - Calibration not done */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t phy_manger_disable_mask;
	/* Description - IBP HW FSM Reflected State:
0x10 - sleeping delay
0x11 - sleeping quiet
0x20 - polling active
0x21 - polling quiet
0x30 - disable
0x40 - config debounce
0x41 - config receiver
0x42 - config wait remote
0x43 - config tx reverse lanes
0x44 - config enhanced    
0x45 - config test
0x46 - confg wait remote test
0x47 - config wait cfg enhanced
0x48 - config idle
0x50 - linkup
0x60 - recover retrain
0x61 - recover wait remote
0x62 - recover idle
0x70 - test
Force Modes:
0x80 - Force     send ts1 (command may be given only on disable 
state)
0x90 - Force send ts2
0xA0 - Force Sent Idle
0xB0 -  Force send ts Mlnx
0xC0 - Force send ts3
0xD0 - Force LinkUp */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t hw_link_phy_state;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - PCS HW state:
Bits 0-3: Block lock
Bits 4-7: Reserved 
Bits 8-11: AM lock
Bits 12-15: Reserved
Bits 16-19: FEC lock
Bits 20-23: Reserved
Bits 24: Align_status
Bits 25: Hi_BER */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t pcs_phy_state;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - IB ports : 
Link partner advertised speeds (first TS3)
See ib_link_speed_enabled encoding.
Ethernet ports:
Link partner advertised Ethernet protocols active state: see 
PTYS.lp_advertise */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t lp_proto_enabled;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Reserved when negotiation wasn't performed according to 
port_notifications.Link partner advertised capabilities
 value.
Advertised link partner FEC mode request */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t lp_fec_mode_request;
	/* Description - Reserved when negotiation wasn't performed according to 
port_notifications.Link partner advertised capabilities
 value.
Advertised link partner FEC mode support
Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Standard LL RS-FEC - RS(271,257)
Bit 4 - Mellanox Strong RS-FEC - RS(277,257)
Bit 5 - Mellanox LL RS-FEC - RS(163,155)
Bit 6 - Zero Latency FEC (ZLF)
for supported retransmission mode see 
PPLM.
fec_mode_capability */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t lp_fec_mode_support;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Bit 0 - heartbeat_ack_received
Bit 1 - heartbeat_send_received
Bit 2 - heartbeat_err
Bit 3 - tx_width_reduction_done_1x
Bit 4 - tx_width_reduction_done_full
Bit 5 - rx_width_reduction_done_1x
Bit 6 - rx_width_reduction_done_full
Bit 7 - width_reduction_timeout
Bit 8 - ibl_link_retrain
Bit 9 - rx_comskp_timeout
Bit 10 - fifo_full_err
Bit 11 - ts_at_linkup
Bit 12 - minor_threshold_reached
Bit 13 - link_fail
Bit 14 - rx_eb_full_r
Bit 15 - rx_8_10_lane_err
Bit 16 - llr_link_retrain_set
Bit 17 - fc_timeout
Bit 18 - phy_error
Bit 19 - lli_err
Bit 20 - excessive_buffer_err
Bit 21 - remote_init
Bits 31-22 - Reserved */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t ib_last_link_down_reason;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Bit 0 - block_lock_failed
Bit 1 - skip_detected
Bit 2 - fec_sync_failed
Bit 3 - fec_block_sync
Bit 4 - fec_block_sync_lost */
	/* 0x1c.24 - 0x20.23 */
	 u_int8_t eth_last_link_down_lane[4];
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Bit 0 - Speed degradation database Valid
Bit 1 - Speed degradation Serdes Rx database valid
BIts 3-2 - reserved
Bit 4 - rx_reversal
Bit 5 - tx_reversal
Bit 7-6 - reserved
Bits 11:8 - failed_qdr/fdr10 - bit per lane.
Bits 15:12 - failed_fdr - bit per lane.
Bits 19:16- failed_edr - bit per lane.
Bits 24:20 - peer_failed_test
Bits 26-25 - reserved
Bit 27 - first_test_speed */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t speed_deg_db;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Valid only when 
port_notifications.Speed degradation
 is asserted */
	/* 0x28.0 - 0x28.23 */
	 u_int32_t degrade_grade_lane0;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Valid only when 
port_notifications.Speed degradation
 is asserted */
	/* 0x2c.0 - 0x2c.23 */
	 u_int32_t degrade_grade_lane1;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Valid only when 
port_notifications.Speed degradation
 is asserted */
	/* 0x30.0 - 0x30.23 */
	 u_int32_t degrade_grade_lane2;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - Valid only when 
port_notifications.Speed degradation
 is asserted */
	/* 0x34.0 - 0x34.23 */
	 u_int32_t degrade_grade_lane3;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - Per lane KR startup state:
0 - KR_FSM_INITIALIZE
1 - KR_FSM_SEND_TRAINING
2 - KR_FSM_TRAIN_LOCAL_TX
3 - KR_FSM_TRAIN_LOCAL_RX
4 - KR_FSM_TRAIN_REMOTE
5 - KR_FSM_LINK_READY
6 - KR_FSM_SEND_DATA */
	/* 0x48.24 - 0x4c.23 */
	 u_int8_t kr_startup_fsm_lane[4];
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - eth_an_debug bit mask:
Bit 0 - Force link up
Bit 1 - No HCD
Bit 2 - Entered ACK_detect
Bit 3 - Entered Good
Bit 4 - Entered Good_Check
Bit 5 - Entered Extra_tune
Bit 6 - Entered Fix_Reversals
Bit 7 - Entered Next_Page
Bit 8 - Entered Sub-FSM Fail
Bit 9 - Tuning timeout
Bit 10 - No markers detected (during Good check)
Bit 11 - Do KR-startup
Bits 15:18 - KR startup failure mask */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t eth_an_debug_indication;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - FW IB state machine:
Bit 0 - entered IB_AN_FSM_DISABLED
Bit 1 - entered IB_AN_FSM_INITIALY
Bit 2 - entered IB_AN_FSM_RCVR_CFG
Bit 3 - entered IB_AN_FSM_CFG_TEST
Bit 4 - entered IB_AN_FSM_WAIT_RMT_TEST
Bit 5 - entered IB_AN_FSM_WAIT_CFG_ENHANCED
Bit 6 - entered IB_AN_FSM_CFG_IDLE
Bit 7 - entered IB_AN_FSM_LINK_UP
Bit 8 - Failed from CFG_IDLE */
	/* 0x54.0 - 0x54.15 */
	 u_int16_t ib_phy_fsm_state_trace;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - kr_stratup_debug_indication_<i> bit mask:
Bit 0 - PRBS lock failed
Bit 1 - Entered send training
Bit 2 - Entered train local RX
Bit 3 - Entered train remote 
Bit 4 - Entered link ready
Bit 5 - Entered Send_Data
Bit 6 - Didn't get receiver ready 
Bit 7 - tuning timeout
Bit 8 - No frame lock
Bit 9 - No response from peer
Bit 10 - frames lock tuning not done */
	/* 0x58.16 - 0x60.15 */
	 u_int16_t kr_startup_debug_indications[4];
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x68.3 */
	 u_int8_t irisc_status;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - Bit 0 - com_codes_is_zero 
Bit 1- rx_cdr_check_force_mode 
Bit 2- com_code_complaince 
Bit 3- eth_56g_stamped
Bit 4- non_mlx_qsfp_tranciver
Bit 5- "non_mlx_sfp_tranciver"
Bit 6-ib_comp_codes
Bit 7-edr_comp
Bit 8-fdr_comp */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t stamping_reason;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pddr_operation_info_page {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - protocol was not negotiated (force mode)
1 - mlpn rev 0 negotiated
2 - CL73 Ethernet negotiated (no MLPN)
3 - protocol according to Parallel detect (remote port in force mode)
4 - Standard IB negotiated (no MLPN) */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t neg_mode_active;
	/* Description - Active protocol:
Bit 0: InfiniBand
Bit 2: Ethernet */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t proto_active;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - FW IB state machine:
0x0 - IB_AN_FSM_DISABLED
0x1 - IB_AN_FSM_INITIALY
0x2 - IB_AN_FSM_RCVR_CFG
0x3 - IB_AN_FSM_CFG_TEST
0x4 - IB_AN_FSM_WAIT_RMT_TEST
0x5 - IB_AN_FSM_WAIT_CFG_ENHANCED
0x6 - IB_AN_FSM_CFG_IDLE
0x7 - IB_AN_FSM_LINK_UP */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ib_phy_fsm_state;
	/* Description - Ethernet (CL73) Auto-negotiation FSM state:
0x0 - ETH_AN_FSM_ENABLE
0x1 - ETH_AN_FSM_XMIT_DISABLE
0x2 - ETH_AN_FSM_ABILITY_DETECT
0x3 - ETH_AN_FSM_ACK_DETECT
0x4 - ETH_AN_FSM_COMPLETE_ACK
0x5 - ETH_AN_FSM_AN_GOOD_CHECK
0x6 - ETH_AN_FSM_AN_GOOD
0x7 - ETH_AN_FSM_NEXT_PAGE_WAIT
0x8 - ETH_AN_FSM_LINK_STAT_CHECK
0x9 - ETH_AN_FSM_EXTRA_TUNE
0xa - ETH_AN_FSM_FIX_REVERSALS
0xb - ETH_AN_FSM_IB_FAIL */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t eth_an_fsm_state;
	/* Description - FW Phy Manager FSM state:
0 - Disabled 
1 - Open port
2 - Polling
3 - Active / Linkup
4 - Close port */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t phy_mngr_fsm_state;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - IB ports : 
ib link width enabled bits 31:16
Bit 0 - 1x
Bit 1 - 2x
Bit 2 - 4x
Bit 3 - 8x
Other - reserved
ib link speed enabled bits 15:0
Bit 0 - SDR
Bit 1 - DDR
Bit 2 - QDR
Bit 3 - FDR10
Bit 4 - FDR
Bit 5 - EDR
[Internal]Bit 6 - HDR
[Internal]Bit 7 - NDR
Ethernet ports:
Ethernet protocols admin state: see PTYS.eth_proto_admin */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t phy_manager_link_proto_enabled;
	/* Description - IB ports : 
ib link width enabled bits 31:16
Bit 0 - 1x
Bit 1 - 2x
Bit 2 - 4x
Bit 3 - 8x
Other - reserved
ib link speed enabled bits 15:0
Bit 0 - SDR
Bit 1 - DDR
Bit 2 - QDR
Bit 3 - FDR10
Bit 4 - FDR
Bit 5 - EDR
[Internal]Bit 6 - HDR
[Internal]Bit 7 - NDR
Ethernet ports:
Ethernet protocols admin state: see PTYS.eth_proto_admin */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t phy_manager_link_width_enabled;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - IB ports : 
ib link width enabled bits 31:16
Bit 0 - 1x
Bit 1 - 2x
Bit 2 - 4x
Bit 3 - 8x
Other - reserved
ib link speed enabled bits 15:0
Bit 0 - SDR
Bit 1 - DDR
Bit 2 - QDR
Bit 3 - FDR10
Bit 4 - FDR
Bit 5 - EDR
[Internal]Bit 6 - HDR
[Internal]Bit 7 - NDR
Ethernet ports:
Ethernet protocols admin state: see PTYS.eth_proto_admin */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t core_to_phy_link_proto_enabled;
	/* Description - IB ports : 
ib link width enabled bits 31:16
Bit 0 - 1x
Bit 1 - 2x
Bit 2 - 4x
Bit 3 - 8x
Other - reserved
ib link speed enabled bits 15:0
Bit 0 - SDR
Bit 1 - DDR
Bit 2 - QDR
Bit 3 - FDR10
Bit 4 - FDR
Bit 5 - EDR
[Internal]Bit 6 - HDR
[Internal]Bit 7 - NDR
Ethernet ports:
Ethernet protocols admin state: see PTYS.eth_proto_admin */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t core_to_phy_link_width_enabled;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - IB ports : 
Cable IB speeds support 
See ib_link_speed_enabled encoding.
Ethernet ports:
Link partner advertised Ethernet protocols active state: see
 
encod
ing PTYS.eth_proto_admin */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t cable_proto_cap;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - IB ports : 
ib link speed / width active
See ib_link_width_enabled, ib_link_speed_enabled encoding.
Ethernet ports:
Ethernet protocols active state: see PTYS.eth_proto_active */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t link_speed_active;
	/* Description - IB ports : 
ib link speed / width active
See ib_link_width_enabled, ib_link_speed_enabled encoding.
Ethernet ports:
Ethernet protocols active state: see PTYS.eth_proto_active */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t link_width_active;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - 0 - Phy remote loopback 
2 - Phy local loopback. When set the port's egress traffic is looped back to 
the receiver and the port transmitter is disabled. 
4 - External local loopback. Enables the port's transmitter to link with the 
port's receiver using an external loopback connector. Bits 3-7 are reserved. */
	/* 0x18.0 - 0x18.3 */
	 u_int8_t loopback_mode;
	/* Description - Retransmission mode requested 
0 - No retransmission
1 - LLR
2 - PLR
for supported retransmission mode see 
PPLM.
retransmission_capa
bility */
	/* 0x18.16 - 0x18.23 */
	 u_int8_t retran_mode_request;
	/* Description - Retransmission active
0 - No retransmission
1 - LLR
2 - PLR
for supported retransmission mode see 
PPLM.
retransmission_capa
bility */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t retran_mode_active;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - FEC mode request
See fec_mode_active
for supported retransmission mode see 
PPLM.
fec_mode_capability */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t fec_mode_request;
	/* Description - FEC mode active
0 - No FEC
1 - Firecode FEC
2 - Standard RS-FEC - RS(528,514)
3 - Standard LL RS-FEC - RS(271,257)
4 - Mellanox Strong RS-FEC - RS(277,257)
5 - Mellanox LL RS-FEC - RS(163,155)
6 - Zero Latency FEC (ZLF)
for supported retransmission mode see 
PPLM.
fec_mode_capability */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t fec_mode_active;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - 25g_50g - supported fec include override masking */
	/* 0x20.0 - 0x20.3 */
	 u_int8_t eth_25g_50g_fec_support;
	/* Description - 100g - supported fec include override masking */
	/* 0x20.4 - 0x20.7 */
	 u_int8_t eth_100g_fec_support;
	/* Description - The profile that has been selected: 
Bit 0 - IB spec / legacy (See profiles description) 
Bit 1 - Internal ports (Backplane) 
Bit 2 - Passive copper - Short 
Bit 3 - Passive copper - Medium 
Bit 4 - Passive copper - Long 
Bit 5 - Active optics / copper short reach (<20m) 
Bit 6 - Optics long reach (>20m) 
Bit 7 - NO-FEC 
Bit 8 - FEC-ON */
	/* 0x20.16 - 0x20.31 */
	 u_int16_t profile_fec_in_use;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pcie_timers_states {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - [Internal] 
Life time counter - can't be cleared. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t life_time_counter_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - [Internal] 
Life time counter - can't be cleared. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t life_time_counter_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Time form start until FW boot image starts running in 
usec. 
Note: can't be cleared. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t time_to_boot_image_start;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Time form start until FW pci_link image starts running 
in usec. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t time_to_link_image;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Time it took FW to do calibration in usec. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t calibration_time;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Time form start until FW handle first prest */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t time_to_first_perst;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Time form start until first transition to LTSSM.Detect_Q */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t time_to_detect_state;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Time form start until first transition to LTSSM.L0 */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t time_to_l0;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Time form start until crs is enabled */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t time_to_crs_en;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Time form start until FW plastic image starts running in 
usec. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t time_to_plastic_image_start;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Time form start until FW iron image starts running in 
usec. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t time_to_iron_image_start;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Number of persts arrived */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t perst_handler;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Number of times LTSSM entered L1 flow */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t times_in_l1;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - Number of times LTSSM entered L23 flow */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t times_in_l23;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - Number of moves for DL_active to DL_down */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t dl_down;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Number of configuration requests that FW handled in 
less then 1 usec */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t config_cycle1usec;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - Number of configuration requests that FW handled 
within 2 to 7 usec */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t config_cycle2to7usec;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - Number of configuration requests that FW handled 
within 8 to 15 usec */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t config_cycle8to15usec;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - Number of configuration requests that FW handled 
within 16 to 63 usec */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t config_cycle16to63usec;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - Number of configuration requests that FW handled took 
more than 64 usec */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t config_cycle64usec;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - Number of correctable error msg sent */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t correctable_err_msg_sent;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - Number of Non-Fatal error msg sent */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t non_fatal_err_msg_sent;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - Number of Fatal error msg sent */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t fatal_err_msg_sent;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_pcie_lanes_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - [Internal] 
Life time counter - can't be cleared. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t life_time_counter_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - [Internal] 
Life time counter - can't be cleared. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t life_time_counter_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Number of errors detected on logical lane 0 */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t error_counter_lane0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Number of errors detected on logical lane 1 */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t error_counter_lane1;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Number of errors detected on logical lane 2 */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t error_counter_lane2;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Number of errors detected on logical lane 3 */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t error_counter_lane3;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Number of errors detected on logical lane 4 */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t error_counter_lane4;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Number of errors detected on logical lane 5 */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t error_counter_lane5;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Number of errors detected on logical lane 6 */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t error_counter_lane6;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Number of errors detected on logical lane 7 */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t error_counter_lane7;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Number of errors detected on logical lane 8 */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t error_counter_lane8;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Number of errors detected on logical lane 9 */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t error_counter_lane9;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Number of errors detected on logical lane 10 */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t error_counter_lane10;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - Number of errors detected on logical lane 11 */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t error_counter_lane11;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - Number of errors detected on logical lane 12 */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t error_counter_lane12;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Number of errors detected on logical lane 13 */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t error_counter_lane13;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - Number of errors detected on logical lane 14 */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t error_counter_lane14;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - Number of errors detected on logical lane 15 */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t error_counter_lane15;
};

/* Description -   */
/* Size in bytes - 200 */
struct connectx4lx_pcie_perf_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Life time counter - can't be cleared. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t life_time_counter_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Life time counter - can't be cleared. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t life_time_counter_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Number of transitions to recovery due to Framing errors 
and CRC
 
(dlp and tlp) errors. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rx_errors;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Number of transitions to recovery due to EIEOS and TS 
errors. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t tx_errors;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t l0_to_recovery_eieos;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t l0_to_recovery_ts;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t l0_to_recovery_framing;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t l0_to_recovery_retrain;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t crc_error_dllp;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t crc_error_tlp;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_phys_layer_stat_cntrs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The time passed since the last counters clear event in 
msec. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t time_since_last_clear_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The time passed since the last counters clear event in 
msec. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t time_since_last_clear_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - This counter provides information on the total amount of 
traffic (bits) received. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t phy_received_bits_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This counter provides information on the total amount of 
traffic (bits) received. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t phy_received_bits_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - This counter provides information on errors bits that 
wasn't corrected by FEC correction algorithm or that 
FEC is not active. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t phy_symbol_errors_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - This counter provides information on errors bits that 
wasn't corrected by FEC correction algorithm or that 
FEC is not active. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t phy_symbol_errors_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Corrected bits by FEC engine. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t phy_corrected_bits_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Corrected bits by FEC engine. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t phy_corrected_bits_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - TBD */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t phy_corrected_bits_lane0_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - TBD */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t phy_corrected_bits_lane0_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - TBD */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t phy_corrected_bits_lane1_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - TBD */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t phy_corrected_bits_lane1_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - TBD */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t phy_corrected_bits_lane2_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - TBD */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t phy_corrected_bits_lane2_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - TBD */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t phy_corrected_bits_lane3_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - TBD */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t phy_corrected_bits_lane3_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - Raw_BER = 
raw_ber_coef*
10^(-
raw_ber_magnitude) */
	/* 0x60.0 - 0x60.3 */
	 u_int8_t raw_ber_coef;
	/* Description - Raw_BER = 
raw_ber_coef*
10^(-
raw_ber_magnitude) */
	/* 0x60.8 - 0x60.15 */
	 u_int8_t raw_ber_magnitude;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - Effective_BER = 
effective_ber_coef*
10^(-
effective_ber_magnitude) */
	/* 0x64.0 - 0x64.3 */
	 u_int8_t effective_ber_coef;
	/* Description - Effective_BER = 
effective_ber_coef*
10^(-
effective_ber_magnitude) */
	/* 0x64.8 - 0x64.15 */
	 u_int8_t effective_ber_magnitude;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_per_traffic_congestion_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t wred_discard_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t wred_discard_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_ib_port_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Total number of times the Port Training state machine has failed the link error recovery process and downed the link. Refer to the InfiniBand Architecture Specification, Volume 2, Link/Phy Interface. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t link_downed_counter;
	/* Description - Total number of times the Port Training state machine has successfully completed the link error recovery. */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t link_error_recovery_counter;
	/* Description - Total number of minor link errors detected on one or more physical lanes. */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t symbol_error_counter;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Total number of packets marked with the EBP delimiter received on the port. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t port_rcv_remote_physical_errors;
	/* Description - Total number of packets containing an error that were received on the port. */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t port_rcv_errors;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t port_xmit_discards;
	/* Description - Total number of packets received on the port that were discarded because they could not be forwarded by the switch relay. */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t port_rcv_switch_relay_errors;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The number of times that OverrunErrors consecutive flow control update periods occurred., each having at least one overrun error. */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t excessive_buffer_overrun_errors;
	/* Description - The number of times that the count of local physical errors exceeded the threshold */
	/* 0xc.4 - 0xc.7 */
	 u_int8_t local_link_integrity_errors;
	/* Description - Total number of packets received on the port that are discarded. */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t port_rcv_constraint_errors;
	/* Description - Total number of packets not transmitted from the port for the following reasons: " FilterRawOutbound is true and packet is raw " PartitionEnforcementOutbound is true and packet fails partition key check or IP version check */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t port_xmit_constraint_errors;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Number of incoming VL15 packets dropped due to resource limitations (e.g., lack of buffers) in the port */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t vl15_dropped;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Optional; shall be zero if not implemented. Total number of data octets, divided by 4, transmitted on all VLs from the port. This includes all octets between (and not including) the start of packet delimiter and the VCRC, and may include packets containing errors. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t port_xmit_data;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Optional; shall be zero if not implemented. Total number of data octets, divided by 4, received on all VLs at the port. This includes all octets between (and not including) the start of packet delimiter and the VCRC, and may include packets containing errors. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t port_rcv_data;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Optional; shall be zero if not implemented. Total number of packets transmitted on all VLs from the port. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t port_xmit_pkts;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Optional; shall be zero if not implemented. Total number of packets, including packets containing errors */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t port_rcv_pkts;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - If ClassPortInfo:CapabilityMask.PortCountersXmitWaitSupported
is set to 1, the number of ticks during which the port
selected by PortSelect had data to transmit but no data was sent
during the entire tick either because of insufficient credits or
because of lack of arbitration.
Otherwise, undefined. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t port_xmit_wait;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_llr_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The total number of cells recieved (including bad cells) */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t llr_rx_cells_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t llr_rx_cells_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The total number of bad cells recieved (including CRC error) */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t llr_rx_error_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t llr_rx_error_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The total number of cells recieved with CRC error */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t llr_rx_crc_error_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t llr_rx_crc_error_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The total number of cells transmitted (including retransmitted cells) */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t llr_tx_cells_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t llr_tx_cells_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The total number of cells retransmitted */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t llr_tx_ret_cells_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t llr_tx_ret_cells_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - The total number of retransmission events */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t llr_tx_ret_events_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t llr_tx_ret_events_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_discard_cntrs_grp_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t ingress_general_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t ingress_general_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ingress_policy_engine_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ingress_policy_engine_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t ingress_vlan_membership_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t ingress_vlan_membership_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t ingress_tag_frame_type_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t ingress_tag_frame_type_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t egress_vlan_membership_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t egress_vlan_membership_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t loopback_filter_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t loopback_filter_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t egress_general_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t egress_general_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t egress_link_down_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t egress_link_down_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t egress_hoq_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t egress_hoq_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t port_isolation_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t port_isolation_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t egress_policy_engine_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t egress_policy_engine_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t ingress_tx_link_down_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t ingress_tx_link_down_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t egress_stp_filter_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t egress_stp_filter_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t egress_hoq_stall_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t egress_hoq_stall_low;
};

/* Description -   */
/* Size in bytes - 200 */
struct connectx4lx_phys_layer_cntrs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The time passed since the last counters clear event in 
msec. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t time_since_last_clear_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The time passed since the last counters clear event in 
msec. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t time_since_last_clear_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Perf.PortCounters(SymbolErrorCounter)
 = Perf.Port
Counters(UnknownSymbol) */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t symbol_errors_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Perf.PortCounters(SymbolErrorCounter)
 = Perf.Port
Counters(UnknownSymbol) */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t symbol_errors_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(SynchHeaderError
Counter) */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t sync_headers_errors_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(SynchHeaderError
Counter) */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t sync_headers_errors_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane0Counter) / BIP error 
counter, lane 0
In PRBS test mode, indicates the number of PRBS errors 
on lane 0 */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t edpl_bip_errors_lane0_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane0Counter) / BIP error 
counter, lane 0
In PRBS test mode, indicates the number of PRBS errors 
on lane 0 */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t edpl_bip_errors_lane0_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane1Counter) / BIP error 
counter, lane 1
In PRBS test mode, indicates the number of PRBS errors 
on lane 1 */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t edpl_bip_errors_lane1_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane1Counter) / BIP error 
counter, lane 1
In PRBS test mode, indicates the number of PRBS errors 
on lane 1 */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t edpl_bip_errors_lane1_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane2Counter) / BIP error 
counter, lane 2
In PRBS test mode, indicates the number of PRBS errors 
on lane 2 */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t edpl_bip_errors_lane2_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane2Counter) / BIP error 
counter, lane 2
In PRBS test mode, indicates the number of PRBS errors 
on lane 2 */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t edpl_bip_errors_lane2_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane3Counter) / BIP error 
counter, lane 3
In PRBS test mode, indicates the number of PRBS errors 
on lane 3 */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t edpl_bip_errors_lane3_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(ErrorDetectionPerLane3Counter) / BIP error 
counter, lane 3
In PRBS test mode, indicates the number of PRBS errors 
on lane 3 */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t edpl_bip_errors_lane3_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane0) */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t fc_fec_corrected_blocks_lane0_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane0) */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t fc_fec_corrected_blocks_lane0_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane1) */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t fc_fec_corrected_blocks_lane1_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane1) */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t fc_fec_corrected_blocks_lane1_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane2) */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t fc_fec_corrected_blocks_lane2_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane2) */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t fc_fec_corrected_blocks_lane2_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane3) */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t fc_fec_corrected_blocks_lane3_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane3) */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t fc_fec_corrected_blocks_lane3_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane0) */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane0_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane0) */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane0_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane1) */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane1_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane1) */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane1_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane2) */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane2_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane2) */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane2_low;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane3) */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane3_high;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - Perf.PortExtendedSpeed
sCounters(FECCorrectableBlockCounterLane3) */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t fc_fec_uncorrectable_blocks_lane3_low;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(FECCorrecable
BlockCounter) */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t rs_fec_corrected_blocks_high;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(FECCorrecable
BlockCounter) */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t rs_fec_corrected_blocks_low;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(FEUncorrecable
BlockCounter) */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t rs_fec_uncorrectable_blocks_high;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description - Perf.PortExtendedSpeedsCounters(FEUncorrecable
BlockCounter) */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t rs_fec_uncorrectable_blocks_low;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description - The number of RS-FEC blocks received that had no 
errors.
Note: Total rs_fec blocks received = 
rs_fec_corrected_blocks + rs_fec_uncorrectable_blocks 
+ rs_fec_no_errors_blocks */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t rs_fec_no_errors_blocks_high;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - The number of RS-FEC blocks received that had no 
errors.
Note: Total rs_fec blocks received = 
rs_fec_corrected_blocks + rs_fec_uncorrectable_blocks 
+ rs_fec_no_errors_blocks */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t rs_fec_no_errors_blocks_low;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description - The number of corrected RS-FEC blocks received that 
had exactly 1 error symbol. 
Note: A FEC block that is counted by 
rs_fec_single_error_blocks is counted also by 
rs_fec_corrected_blocks */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t rs_fec_single_error_blocks_high;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description - The number of corrected RS-FEC blocks received that 
had exactly 1 error symbol. 
Note: A FEC block that is counted by 
rs_fec_single_error_blocks is counted also by 
rs_fec_corrected_blocks */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t rs_fec_single_error_blocks_low;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description - Perf.PortExtendedSpeedCounters(PortFECCorrect
edSymbolCounter) */
	/* 0x98.0 - 0x9c.31 */
	 u_int32_t rs_fec_corrected_symbols_total_high;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description - Perf.PortExtendedSpeedCounters(PortFECCorrect
edSymbolCounter) */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t rs_fec_corrected_symbols_total_low;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane0) */
	/* 0xa0.0 - 0xa4.31 */
	 u_int32_t rs_fec_corrected_symbols_lane0_high;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane0) */
	/* 0xa4.0 - 0xa8.31 */
	 u_int32_t rs_fec_corrected_symbols_lane0_low;
/*---------------- DWORD[42] (Offset 0xa8) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane1) */
	/* 0xa8.0 - 0xac.31 */
	 u_int32_t rs_fec_corrected_symbols_lane1_high;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane1) */
	/* 0xac.0 - 0xb0.31 */
	 u_int32_t rs_fec_corrected_symbols_lane1_low;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane2) */
	/* 0xb0.0 - 0xb4.31 */
	 u_int32_t rs_fec_corrected_symbols_lane2_high;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane2) */
	/* 0xb4.0 - 0xb8.31 */
	 u_int32_t rs_fec_corrected_symbols_lane2_low;
/*---------------- DWORD[46] (Offset 0xb8) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane3) */
	/* 0xb8.0 - 0xbc.31 */
	 u_int32_t rs_fec_corrected_symbols_lane3_high;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description - Perf.PortExtendedSpeed
Counters(FECCorrectedSymbolCounterLane3) */
	/* 0xbc.0 - 0xc0.31 */
	 u_int32_t rs_fec_corrected_symbols_lane3_low;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description - Perf.PortCounters(LinkDownedCounter) */
	/* 0xc0.0 - 0xc4.31 */
	 u_int32_t link_down_events;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description - Perf.PortCounters(LinkErrorRecoveryCounter) */
	/* 0xc4.0 - 0xc8.31 */
	 u_int32_t successful_recovery_events;
};

/* Description -   */
/* Size in bytes - 56 */
struct connectx4lx_correct_on_demand_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The number of all rewind events */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rewind_counter_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The number of all rewind events */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rewind_counter_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The amount of data that were rewinded */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t data_rewinded_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The amount of data that were rewinded */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t data_rewinded_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The amount of packets that were rewinded */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t pkt_rewinded_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The amount of packets that were rewinded */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t pkt_rewinded_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The total number of received data - both good and rewinded data */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t total_rcv_data_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - The total number of received data - both good and rewinded data */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t total_rcv_data_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The total number of received packets - both good and rewinded packets */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t total_rcv_pkt_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - The total number of received packets - both good and rewinded packets */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t total_rcv_pkt_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_per_traffic_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Contains the transmit queue depth in bytes on traffic class selected 
by 
traffic_class
 of the port selected by 
local_port
. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t transmit_queue_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Contains the transmit queue depth in bytes on traffic class selected 
by 
traffic_class
 of the port selected by 
local_port
. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t transmit_queue_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t no_buffer_discard_uc_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t no_buffer_discard_uc_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_per_prio_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The total number of octets received, including framing characters. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rx_octets_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The total number of octets received, including framing characters. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rx_octets_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The total number of packets received for this priority (including control 
frames). */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t rx_frames_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - The total number of packets received for this priority (including control 
frames). */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t rx_frames_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - The total number of octets transmitted, including framing characters. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t tx_octets_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - The total number of octets transmitted, including framing characters. */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t tx_octets_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - The total number of packets transmitted. */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t tx_frames_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - The total number of packets transmitted. */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t tx_frames_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - The total number of PAUSE frames received from the far-end port. */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t rx_pause_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - The total number of PAUSE frames received from the far-end port. */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t rx_pause_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - The total time in microseconds that transmission of packets to the far-end 
port have been paused. */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t rx_pause_duration_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - The total time in microseconds that transmission of packets to the far-end 
port have been paused. */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t rx_pause_duration_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - The total number of PAUSE frames sent to the far-end port. */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t tx_pause_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - The total number of PAUSE frames sent to the far-end port. */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t tx_pause_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - The total time in microseconds that the far-end port have been requested 
to paused. */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t tx_pause_duration_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - The total time in microseconds that the far-end port have been requested 
to paused. */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t tx_pause_duration_low;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - Counts the number of transitions from Xoff to Xon. */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t rx_pause_transition_high;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - Counts the number of transitions from Xoff to Xon. */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t rx_pause_transition_low;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - The number of inbound packets which were chosen to be dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t rx_discards_high;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - The number of inbound packets which were chosen to be dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t rx_discards_low;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t device_stall_minor_watermark_cnt_high;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t device_stall_minor_watermark_cnt_low;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description -  */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t device_stall_critical_watermark_cnt_high;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description -  */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t device_stall_critical_watermark_cnt_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_extended_cntrs_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The number of ticks during which the port selected had data to 
transmit but no data was sent during the entire tick either because 
of insufficient credits or because of lack of arbitration.
A tick is a multiple of the time needed to transfer one byte on a 
single lane, that is, the symbol time. 
For example, for links operating at IBA SDR (single data rate), 
the symbol time is 4nsec. independent of the width of the link. 
For links operating at Ethernet 10GE on a single lane or 40GE on 
4 lanes, the symbol time is 0.8nSec. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t port_transmit_wait_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The number of ticks during which the port selected had data to 
transmit but no data was sent during the entire tick either because 
of insufficient credits or because of lack of arbitration.
A tick is a multiple of the time needed to transfer one byte on a 
single lane, that is, the symbol time. 
For example, for links operating at IBA SDR (single data rate), 
the symbol time is 4nsec. independent of the width of the link. 
For links operating at Ethernet 10GE on a single lane or 40GE on 
4 lanes, the symbol time is 0.8nSec. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t port_transmit_wait_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ecn_marked_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ecn_marked_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t no_buffer_discard_mc_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t no_buffer_discard_mc_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_3635_cntrs_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - A count of frames received that are not an integral number 
of octets in length and do not pass the FCS check. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dot3stats_alignment_errors_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - A count of frames received that are not an integral number 
of octets in length and do not pass the FCS check. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t dot3stats_alignment_errors_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - A count of frames received that are an integral number of 
octets in length but do not pass the FCS check. This count 
does not include frames received with frame-too-long or 
frame-too-short errors. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t dot3stats_fcs_errors_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - A count of frames received that are an integral number of 
octets in length but do not pass the FCS check. This count 
does not include frames received with frame-too-long or 
frame-too-short errors. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t dot3stats_fcs_errors_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - A count of frames that are involved in a single collision, 
and are subsequently transmitted successfully.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t dot3stats_single_collision_frames_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - A count of frames that are involved in a single collision, 
and are subsequently transmitted successfully.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t dot3stats_single_collision_frames_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - A count of frames that are involved in more than one colli
sion and are subsequently transmitted successfully. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t dot3stats_multiple_collision_frames_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - A count of frames that are involved in more than one colli
sion and are subsequently transmitted successfully. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t dot3stats_multiple_collision_frames_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - A count of times that the SQE TEST ERROR is received 
on a particular interface.
This counter does not increment on interfaces operating at 
speeds greater than 10 Mb/s, or on interfaces operating in 
full-duplex mode. */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t dot3stats_sqe_test_errors_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - A count of times that the SQE TEST ERROR is received 
on a particular interface.
This counter does not increment on interfaces operating at 
speeds greater than 10 Mb/s, or on interfaces operating in 
full-duplex mode. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t dot3stats_sqe_test_errors_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - A count of frames for which the first transmission attempt 
on a particular interface is delayed because the medium is 
busy. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t dot3stats_deferred_transmissions_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - A count of frames for which the first transmission attempt 
on a particular interface is delayed because the medium is 
busy. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t dot3stats_deferred_transmissions_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - The number of times that a collision is detected on a par
ticular interface later than one slotTime into the transmis
sion of a packet.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t dot3stats_late_collisions_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - The number of times that a collision is detected on a par
ticular interface later than one slotTime into the transmis
sion of a packet.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t dot3stats_late_collisions_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - A count of frames for which transmission on a particular 
interface fails due to excessive collisions.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t dot3stats_excessive_collisions_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - A count of frames for which transmission on a particular 
interface fails due to excessive collisions.
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t dot3stats_excessive_collisions_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - A count of frames for which transmission failed and were 
discarded even though no errors had been detected to pre
vent their being deliverable to a higher-layer protocol. */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t dot3stats_internal_mac_transmit_errors_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - A count of frames for which transmission failed and were 
discarded even though no errors had been detected to pre
vent their being deliverable to a higher-layer protocol. */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t dot3stats_internal_mac_transmit_errors_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - The number of times that the carrier sense condition was 
lost or never asserted when attempting to transmit a frame 
on a particular interface. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t dot3stats_carrier_sense_errors_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - The number of times that the carrier sense condition was 
lost or never asserted when attempting to transmit a frame 
on a particular interface. 
This counter does not increment when the interface is 
operating in full-duplex mode. */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t dot3stats_carrier_sense_errors_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - A count of frames received that exceed the maximum per
mitted frame size. */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t dot3stats_frame_too_longs_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - A count of frames received that exceed the maximum per
mitted frame size. */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t dot3stats_frame_too_longs_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - A count of frames for which reception failed and were dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t dot3stats_internal_mac_receive_errors_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - A count of frames for which reception failed and were dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t dot3stats_internal_mac_receive_errors_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - The number of times the receiving media is non-idle (a 
carrier event) for a period of time equal to or greater than 
minFrameSize, and during which there was at least one 
occurrence of an event that causes the PHY to indicate 
"Receive Error". */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t dot3stats_symbol_errors_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - The number of times the receiving media is non-idle (a 
carrier event) for a period of time equal to or greater than 
minFrameSize, and during which there was at least one 
occurrence of an event that causes the PHY to indicate 
"Receive Error". */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t dot3stats_symbol_errors_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - A count of MAC Control frames received that contain an 
opcode that is not supported. */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t dot3control_in_unknown_opcodes_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - A count of MAC Control frames received that contain an 
opcode that is not supported. */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t dot3control_in_unknown_opcodes_low;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - A count of MAC Control frames received with an opcode 
indicating the PAUSE operation. */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t dot3in_pause_frames_high;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - A count of MAC Control frames received with an opcode 
indicating the PAUSE operation. */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t dot3in_pause_frames_low;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - A count of MAC Control frames transmitted with an 
opcode indicating the PAUSE operation. */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t dot3out_pause_frames_high;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - A count of MAC Control frames transmitted with an 
opcode indicating the PAUSE operation. */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t dot3out_pause_frames_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_2819_cntrs_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The total number of events in which packets were 
dropped by the probe due to lack of resources. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t ether_stats_drop_events_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The total number of events in which packets were 
dropped by the probe due to lack of resources. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t ether_stats_drop_events_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The total number of octets of data (including those in 
bad packets) received (excluding framing bits but 
including FCS octets). */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ether_stats_octets_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The total number of octets of data (including those in 
bad packets) received (excluding framing bits but 
including FCS octets). */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ether_stats_octets_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The total number of packets (including bad packets, 
broadcast packets, and multicast packets) received. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t ether_stats_pkts_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The total number of packets (including bad packets, 
broadcast packets, and multicast packets) received. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t ether_stats_pkts_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The total number of good packets received that were 
directed to the broadcast address. 
Note: This does not include multicast packets. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t ether_stats_broadcast_pkts_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - The total number of good packets received that were 
directed to the broadcast address. 
Note: This does not include multicast packets. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t ether_stats_broadcast_pkts_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The total number of good packets received that were 
directed to a multicast MAC address. 
Note: This number does not include packets directed 
to the broadcast address. */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t ether_stats_multicast_pkts_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - The total number of good packets received that were 
directed to a multicast MAC address. 
Note: This number does not include packets directed 
to the broadcast address. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t ether_stats_multicast_pkts_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - The total number of packets received that had a length 
(excluding framing bits, but including FCS octets) of 
between 64 and MTU
 octets, inclusive, but had either 
a bad frame check sequence (FCS) with an integral 
number of octets (FCS error) or a bad FCS with a 
non-integral number of octets (alignment error). */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t ether_stats_crc_align_errors_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - The total number of packets received that had a length 
(excluding framing bits, but including FCS octets) of 
between 64 and MTU
 octets, inclusive, but had either 
a bad frame check sequence (FCS) with an integral 
number of octets (FCS error) or a bad FCS with a 
non-integral number of octets (alignment error). */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t ether_stats_crc_align_errors_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - The total number of packets received that were less 
than 64 octets long (excluding framing bits, but 
including FCS octets) and were otherwise well 
formed. */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t ether_stats_undersize_pkts_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - The total number of packets received that were less 
than 64 octets long (excluding framing bits, but 
including FCS octets) and were otherwise well 
formed. */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t ether_stats_undersize_pkts_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - The total number of packets received that were longer 
than MTU octets (excluding framing bits, but includ
ing FCS octets) but were otherwise well formed. */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t ether_stats_oversize_pkts_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - The total number of packets received that were longer 
than MTU octets (excluding framing bits, but includ
ing FCS octets) but were otherwise well formed. */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t ether_stats_oversize_pkts_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - The total number of packets received that were less 
than 64 octets in length (excluding framing bits but 
including FCS octets) and had either a bad FCS with 
an integral number of octets (FCS error) or a bad FCS 
with a non-integral number of octets (alignment 
error). */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t ether_stats_fragments_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - The total number of packets received that were less 
than 64 octets in length (excluding framing bits but 
including FCS octets) and had either a bad FCS with 
an integral number of octets (FCS error) or a bad FCS 
with a non-integral number of octets (alignment 
error). */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t ether_stats_fragments_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - The total number of packets received that were longer 
than MTU octets (excluding framing bits, but includ
ing FCS octets), and had either a bad FCS with an 
integral number of octets (FCS error) or a bad FCS 
with a non-integral number of octets (alignment 
error). */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t ether_stats_jabbers_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - The total number of packets received that were longer 
than MTU octets (excluding framing bits, but includ
ing FCS octets), and had either a bad FCS with an 
integral number of octets (FCS error) or a bad FCS 
with a non-integral number of octets (alignment 
error). */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t ether_stats_jabbers_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - The best estimate of the total number of collisions on 
this Ethernet segment. */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t ether_stats_collisions_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - The best estimate of the total number of collisions on 
this Ethernet segment. */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t ether_stats_collisions_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were 64 octets in length (excluding 
framing bits but including FCS octets). */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t ether_stats_pkts64octets_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were 64 octets in length (excluding 
framing bits but including FCS octets). */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t ether_stats_pkts64octets_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 65 and 127 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t ether_stats_pkts65to127octets_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 65 and 127 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t ether_stats_pkts65to127octets_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 128 and 255 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t ether_stats_pkts128to255octets_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 128 and 255 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t ether_stats_pkts128to255octets_low;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 256 and 511 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t ether_stats_pkts256to511octets_high;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 256 and 511 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t ether_stats_pkts256to511octets_low;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 512 and 1023 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t ether_stats_pkts512to1023octets_high;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 512 and 1023 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t ether_stats_pkts512to1023octets_low;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1024 and 1518 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t ether_stats_pkts1024to1518octets_high;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1024 and 1518 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t ether_stats_pkts1024to1518octets_low;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t ether_stats_pkts1519to2047octets_high;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t ether_stats_pkts1519to2047octets_low;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t ether_stats_pkts2048to4095octets_high;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t ether_stats_pkts2048to4095octets_low;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x98.0 - 0x9c.31 */
	 u_int32_t ether_stats_pkts4096to8191octets_high;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t ether_stats_pkts4096to8191octets_low;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0xa0.0 - 0xa4.31 */
	 u_int32_t ether_stats_pkts8192to10239octets_high;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description - The total number of packets (including bad packets) 
received that were between 1519 and 2047 octets in 
length (excluding framing bits but including FCS 
octets). */
	/* 0xa4.0 - 0xa8.31 */
	 u_int32_t ether_stats_pkts8192to10239octets_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_2863_cntrs_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The total number of octets received, including framing charac
ters. Including MAC control frames. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t if_in_octets_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The total number of octets received, including framing charac
ters. Including MAC control frames. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t if_in_octets_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The number of packets successfully received, which were not 
addressed to a multicast or broadcast MAC address. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t if_in_ucast_pkts_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The number of packets successfully received, which were not 
addressed to a multicast or broadcast MAC address. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t if_in_ucast_pkts_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The number of inbound packets which were chosen to be dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t if_in_discards_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The number of inbound packets which were chosen to be dis
carded even though no errors had been detected to prevent 
their being deliverable to a higher-layer protocol. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t if_in_discards_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The number of inbound packets that contained errors prevent
ing them from being deliverable to a higher-layer protocol. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t if_in_errors_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - The number of inbound packets that contained errors prevent
ing them from being deliverable to a higher-layer protocol. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t if_in_errors_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The number of packets received via the interface which were 
discarded because of an unknown or unsupported protocol. */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t if_in_unknown_protos_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - The number of packets received via the interface which were 
discarded because of an unknown or unsupported protocol. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t if_in_unknown_protos_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - The total number of octets transmitted out of the interface, 
including framing characters. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t if_out_octets_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - The total number of octets transmitted out of the interface, 
including framing characters. */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t if_out_octets_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted and were not addressed to a multicast 
or broadcast MAC address, including those that were discarded 
or not sent. */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t if_out_ucast_pkts_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted and were not addressed to a multicast 
or broadcast MAC address, including those that were discarded 
or not sent. */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t if_out_ucast_pkts_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - The number of outbound packets which were chosen to be dis
carded, even though no errors had been detected to prevent 
their being transmitted. */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t if_out_discards_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - The number of outbound packets which were chosen to be dis
carded, even though no errors had been detected to prevent 
their being transmitted. */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t if_out_discards_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - The number of outbound packets that could not be transmitted 
because of errors. */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t if_out_errors_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - The number of outbound packets that could not be transmitted 
because of errors. */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t if_out_errors_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - The number of packets successfully received, which were 
addressed to a multicast MAC address. */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t if_in_multicast_pkts_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - The number of packets successfully received, which were 
addressed to a multicast MAC address. */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t if_in_multicast_pkts_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - The number of packets successfully received, which were 
addressed to a broadcast MAC address. */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t if_in_broadcast_pkts_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - The number of packets successfully received, which were 
addressed to a broadcast MAC address. */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t if_in_broadcast_pkts_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted, and which were addressed to a multi
cast MAC address, including those that were discarded or not 
sent. */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t if_out_multicast_pkts_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted, and which were addressed to a multi
cast MAC address, including those that were discarded or not 
sent. */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t if_out_multicast_pkts_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted, and which were addressed to a broad
cast MAC address, including those that were discarded or not 
sent. */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t if_out_broadcast_pkts_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - The total number of packets that higher-level protocols 
requested be transmitted, and which were addressed to a broad
cast MAC address, including those that were discarded or not 
sent. */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t if_out_broadcast_pkts_low;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_eth_802_3_cntrs_grp_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - A count of frames that are successfully transmitted. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t a_frames_transmitted_ok_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - A count of frames that are successfully transmitted. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t a_frames_transmitted_ok_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - A count of frames that are successfully received. This 
does not include frames received with frame-too-long, 
frame check sequence (FCS), length or alignment errors, 
or frames lost due to other MAC errors. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t a_frames_received_ok_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - A count of frames that are successfully received. This 
does not include frames received with frame-too-long, 
frame check sequence (FCS), length or alignment errors, 
or frames lost due to other MAC errors. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t a_frames_received_ok_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - A count of receive frames that are an integral number of 
octets in length and do not pass the FCS check. This 
does not include frames received with frame-too-long, or 
frame-too-short (frame fragment) errors. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t a_frame_check_sequence_errors_high;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - A count of receive frames that are an integral number of 
octets in length and do not pass the FCS check. This 
does not include frames received with frame-too-long, or 
frame-too-short (frame fragment) errors. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t a_frame_check_sequence_errors_low;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - A count of frames that are not an integral number of 
octets in length and do not pass the FCS check. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t a_alignment_errors_high;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - A count of frames that are not an integral number of 
octets in length and do not pass the FCS check. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t a_alignment_errors_low;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - A count of data and padding octets of frames that are 
successfully transmitted. */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t a_octets_transmitted_ok_high;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - A count of data and padding octets of frames that are 
successfully transmitted. */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t a_octets_transmitted_ok_low;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - A count of data and padding octets in frames that are 
successfully received. This does not include octets in 
frames received with frame-too-long, FCS, length or 
alignment errors, or frames lost due to other MAC 
errors. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t a_octets_received_ok_high;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - A count of data and padding octets in frames that are 
successfully received. This does not include octets in 
frames received with frame-too-long, FCS, length or 
alignment errors, or frames lost due to other MAC 
errors. */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t a_octets_received_ok_low;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - A count of frames that are successfully transmitted to a 
group destination address other than broadcast. */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t a_multicast_frames_xmitted_ok_high;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - A count of frames that are successfully transmitted to a 
group destination address other than broadcast. */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t a_multicast_frames_xmitted_ok_low;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - A count of the frames that were successfully transmitted 
to the broadcast address. Frames transmitted to multicast 
addresses are not broadcast frames and are excluded. */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t a_broadcast_frames_xmitted_ok_high;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - A count of the frames that were successfully transmitted 
to the broadcast address. Frames transmitted to multicast 
addresses are not broadcast frames and are excluded. */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t a_broadcast_frames_xmitted_ok_low;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - A count of frames that are successfully received and 
directed to an active nonbroadcast group address. This 
does not include frames received with frame-too-long, 
FCS, length or alignment errors, or frames lost due to 
internal MAC sublayer error. */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t a_multicast_frames_received_ok_high;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - A count of frames that are successfully received and 
directed to an active nonbroadcast group address. This 
does not include frames received with frame-too-long, 
FCS, length or alignment errors, or frames lost due to 
internal MAC sublayer error. */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t a_multicast_frames_received_ok_low;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - A count of the frames that were successfully transmitted 
to the broadcast address. Frames transmitted to multicast 
addresses are not broadcast frames and are excluded. */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t a_broadcast_frames_recieved_ok_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - A count of the frames that were successfully transmitted 
to the broadcast address. Frames transmitted to multicast 
addresses are not broadcast frames and are excluded. */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t a_broadcast_frames_recieved_ok_low;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - A count of frames with a length/type field value between 
the minimum unpadded MAC client data size and the 
maximum allowed MAC client data size, inclusive, that 
does not match the number of MAC client data octets 
received. The counter also increments for frames whose 
length/type field value is less than the minimum allowed 
unpadded MAC client data size and the number of MAC 
client data octets received is greater than the minimum 
unpadded MAC client data size. */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t a_in_range_length_errors_high;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - A count of frames with a length/type field value between 
the minimum unpadded MAC client data size and the 
maximum allowed MAC client data size, inclusive, that 
does not match the number of MAC client data octets 
received. The counter also increments for frames whose 
length/type field value is less than the minimum allowed 
unpadded MAC client data size and the number of MAC 
client data octets received is greater than the minimum 
unpadded MAC client data size. */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t a_in_range_length_errors_low;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - A count of frames with a length field value greater than 
the maximum allowed LLC data size. */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t a_out_of_range_length_field_high;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - A count of frames with a length field value greater than 
the maximum allowed LLC data size. */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t a_out_of_range_length_field_low;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - A count of frames received that exceed the maximum 
permitted frame size by IEEE 802.3 (
MTU size). */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t a_frame_too_long_errors_high;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - A count of frames received that exceed the maximum 
permitted frame size by IEEE 802.3 (
MTU size). */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t a_frame_too_long_errors_low;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - For full duplex operation at 1000 Mb/s, it is a count of 
the number of times the receiving media is non-idle (a 
carrier event) for a period of time equal to or greater than 
minFrameSize, and during which there was at least one 
occurrence of an event that causes the PHY to indicate 
"Data reception error". */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t a_symbol_error_during_carrier_high;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - For full duplex operation at 1000 Mb/s, it is a count of 
the number of times the receiving media is non-idle (a 
carrier event) for a period of time equal to or greater than 
minFrameSize, and during which there was at least one 
occurrence of an event that causes the PHY to indicate 
"Data reception error". */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t a_symbol_error_during_carrier_low;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - A count of MAC Control frames passed to the MAC 
sublayer for transmission. */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t a_mac_control_frames_transmitted_high;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - A count of MAC Control frames passed to the MAC 
sublayer for transmission. */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t a_mac_control_frames_transmitted_low;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - A count of MAC Control frames passed by the MAC 
sublayer to the MAC Control sublayer. */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t a_mac_control_frames_received_high;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - A count of MAC Control frames passed by the MAC 
sublayer to the MAC Control sublayer. */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t a_mac_control_frames_received_low;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - A count of MAC Control frames received that contain an 
opcode that is not supported by the device. */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t a_unsupported_opcodes_received_high;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description - A count of MAC Control frames received that contain an 
opcode that is not supported by the device. */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t a_unsupported_opcodes_received_low;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description - A count of MAC PAUSE frames passed by the MAC 
sublayer to the MAC Control sublayer. */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t a_pause_mac_ctrl_frames_received_high;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - A count of MAC PAUSE frames passed by the MAC 
sublayer to the MAC Control sublayer. */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t a_pause_mac_ctrl_frames_received_low;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description - A count of PAUSE frames passed to the MAC sublayer 
for transmission. */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t a_pause_mac_ctrl_frames_transmitted_high;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description - A count of PAUSE frames passed to the MAC sublayer 
for transmission. */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t a_pause_mac_ctrl_frames_transmitted_low;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_dct_qp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - idle, 1 - pending, 2- armed */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t dc_access_key_violation_count_state;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t dc_access_key_violation_count;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_dcr_qp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t gb_first_psn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t gb_last_psn;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t is_gb;
	/* Description -  */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t drtl_cause_dcr_cleanup;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t reconnect_ack_psn;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - tells when DCR cleanup turned off the heartbeat of this DCR */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t dcr_heartbeat_clr_timestamp;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_regular_qp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Counter for retries (FW attempts recovery) on DS_EXCEEDS_PI error. this is a WA for and ordering issue seen with recovery DBs getting wrong PI */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t ds_exceeds_pi_retries;
	/* Description - is current requester retransmission first wqe rdma read */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t req_retrans_is_rdma_read;
	/* Description - deth qpn was taken from SW */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t use_deth_sqpn;
	/* Description - automatic path migration state
    APM_STATE_ARMED = 0x0,
    APM_STATE_REARM = 0x1,
    APM_STATE_MIGRATED = 0x3
 */
	/* 0x0.6 - 0x0.7 */
	 u_int8_t pm_state;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t xport_retry_counter;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t xport_retry_limit;
	/* Description -  */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t rnr_retry_counter;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t rnr_retry_limit;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t sw_uar;
	/* Description - exponential backoff retry log */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t log_rtm;
	/* Description - exponential backoff retry log */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t sw_log_rtm;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 union connectx4lx_regular_qp_sub_type sub_type_fields;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t ib_ft_root_id;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t sw_xport_retry_limit;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_schedint_cause {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t clear_all_causes;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t schedint_destroy_qp;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t schedint_qp_flush;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t schedint_apm;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t schedint_duplicate;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t schedint_sl_diff;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t schedint_pp_diff;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_qpc_ib {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t oldest_non_acked_psn;
	/* Description - issi=1 and old user lib, getting user_index=ffffff from sw */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t invalid_user_index;
	/* Description - is max read atomic in reduced state */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t max_read_atomic_reduced;
	/* Description - 0 - none. 1 - basic. 2 - enhanced */
	/* 0x0.26 - 0x0.27 */
	 u_int8_t ulp_stateless_offload_mode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_qpc_eth {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t tis_num;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t sq_in_lb_block;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t reg_umr;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_hw_msix_context_data1 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t process_index;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t interrupt_number;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_hw_msix_context_data0 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t data;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_ste_iterator_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t num_of_iterations;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t iterations_table_pointer;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t counter_index;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t decapsulate_packet;
	/* Description -  */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t iterations_table_rank;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t miss_address_39_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t miss_address_63_48;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t miss_rank;
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t match_polarity;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.6 - 0x10.31 */
	 u_int32_t miss_address_31_6;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x24.31 */
	 union connectx4lx_hw_ste_tag tag_data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -   */
	/* 0x24.0 - 0x34.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_ste_rss_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.17 */
	 u_int8_t ip_src_type;
	/* Description -  */
	/* 0x0.18 - 0x0.19 */
	 u_int8_t ip_dest_type;
	/* Description -  */
	/* 0x0.20 - 0x0.21 */
	 u_int8_t l4_src_type;
	/* Description -  */
	/* 0x0.22 - 0x0.23 */
	 u_int8_t l4_dest_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t indirection_table_pointer;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t indirection_table_base_qpn;
	/* Description -  */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t log2_indirection_table_size;
	/* Description -  */
	/* 0x8.28 - 0x8.29 */
	 u_int8_t qpn_size;
	/* Description -  */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t symmetric_tcp_udp_address;
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t symmetric_ip_address;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t key_319_288;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t key_287_256;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t key_255_224;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t key_223_192;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t key_191_160;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t key_159_128;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t key_127_96;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t key_95_64;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t key_63_32;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t key_31_0;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_ste_inline_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t inline_qpn;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t inline_force_responder;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t counter_index;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t decapsulate_packet;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t miss_address_39_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t miss_address_63_48;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t miss_rank;
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t match_polarity;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.6 - 0x10.31 */
	 u_int32_t miss_address_31_6;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x24.31 */
	 union connectx4lx_hw_ste_tag tag_data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -   */
	/* 0x24.0 - 0x34.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_ste_multiple_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t member_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t qp_list_pointer;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t counter_index;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t decapsulate_packet;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t miss_address_39_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t miss_address_63_48;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t miss_rank;
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t match_polarity;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.6 - 0x10.31 */
	 u_int32_t miss_address_31_6;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x24.31 */
	 union connectx4lx_hw_ste_tag tag_data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -   */
	/* 0x24.0 - 0x34.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_ste_sx_transmit_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t encapsulation_gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.21 */
	 u_int8_t encapsulation_offset;
	/* Description -  */
	/* 0x0.22 - 0x0.23 */
	 u_int8_t encapsulation_additional_size;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t encapsulation_en;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t sx_sniffer_enable;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t sx_functional_loopback_enable;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t sx_wire_enable;
	/* Description -  */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t sx_sniffer;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t sx_functional_loopback;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t sx_wire;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t encapsulation_pointer;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t counter_index;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t loopback_syndrome;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t loopback_syndrome_en;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t miss_address_39_6_39_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t miss_address_63_48;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t match_polarity;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.6 - 0x10.31 */
	 u_int32_t miss_address_39_6_31_6;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x24.31 */
	 union connectx4lx_hw_ste_tag tag_data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -   */
	/* 0x24.0 - 0x34.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_data_bulk {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bulk_415_384;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t bulk_383_352;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t bulk_351_320;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t bulk_319_288;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t bulk_287_256;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t bulk_255_224;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t bulk_223_192;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t bulk_191_160;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t bulk_159_128;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t bulk_127_96;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t bulk_95_64;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t bulk_63_32;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t bulk_31_0;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_shared_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t counter_index;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t decapsulate_packet;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t miss_address_39_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t miss_address_63_48;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t miss_rank;
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t match_polarity;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.6 - 0x10.31 */
	 u_int32_t miss_address_31_6;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x24.31 */
	 union connectx4lx_hw_ste_tag tag_data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -   */
	/* 0x24.0 - 0x34.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sd_params_tx_set {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t ob_tap0;
	/* Description -  */
	/* 0x0.7 - 0x0.13 */
	 u_int8_t ob_tap1;
	/* Description -  */
	/* 0x0.14 - 0x0.19 */
	 u_int8_t ob_bias;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t ob_tap2;
	/* Description - 0 - pd1_md0_md2
1 - md1_pd0_pd0
2 - md1_pd0_md2
3 - pd0_pd0_pd0
4 - md4_pd2_md0
5 - pd0_pd0_md2
6 - md0_pd2_pd2
7 - md4_md2_pd0
8 - pd0_md2_md3
9 - pd4_md8_md0
10 - md4_pd0_pd0
11 - pd0_md8_pd0
12-15 - reserved */
	/* 0x4.7 - 0x4.10 */
	 u_int8_t tx_mode;
	/* Description -  */
	/* 0x4.11 - 0x4.15 */
	 u_int8_t ref_txcml100;
	/* Description -  */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t ref_cml100_leva;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_subroutine {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t start_line;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t end_line;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_profile_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit 0 - 10G: FDR10 / 10GE / 40GE
Bit 1 - 14G: FDR / 56GE 
Bit 2 - 25G: EDR / 100GE / 25GE / 50GE
 */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_mlx_phy_speed_ini speed[3];
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_cmdif_ctx_special_qp_commands_specific {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts rts2rts;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_cmdif_ctx_special_qp_commands_other other;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_nic_part_capa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t wol;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t virtual_link_ctrl;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t rcv_flow_ctrl;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t xmt_flow_ctrl;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t xmt_bw_ctrl_max;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t xmt_bw_ctrl_min;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_e_switch_capa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t veb;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t bpe;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t open_flow;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_cap_15_0 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t virtual_address;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t link_tuning;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t remote_phy;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t option_rom;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t uefi;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t wol;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t net_mng_pt;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t os_bmc_pt;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t eee;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t thermal_sensor;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t tcp_offld;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t iscsi_offld;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t fcoe;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t fibrechannel;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_dcb_capa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ets;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t pfc;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t cn;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t dcbxp;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_cap_31_16 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t infiniband;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t pxe;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t iscsi_boot;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t fcoe_boot;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t storage_boot_param;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t nic_partitioning;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t sriov;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t lled_lic_mng;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t ipsec_offld;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t macsec;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t rdma;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_lled_get_interface_sensor_resp_qsfp {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t rx2_input_power_value;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t rx1_input_power_value;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t rx4_input_power_value;
	/* Description -  */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t rx3_input_power_value;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t tx2_bias_current_value;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t tx1_bias_current_value;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t tx4_bias_current_value;
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t tx3_bias_current_value;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.15 */
	 u_int16_t tx2_output_power_value;
	/* Description -  */
	/* 0x20.16 - 0x20.31 */
	 u_int16_t tx1_output_power_value;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t tx4_output_power_value;
	/* Description -  */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t tx3_output_power_value;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.7 */
	 u_int8_t fs_int_flag10;
	/* Description -  */
	/* 0x28.8 - 0x28.15 */
	 u_int8_t fs_int_flag9;
	/* Description -  */
	/* 0x28.16 - 0x28.23 */
	 u_int8_t fs_int_flag7;
	/* Description -  */
	/* 0x28.24 - 0x28.31 */
	 u_int8_t fs_int_flag6;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.7 */
	 u_int8_t fs_int_flag14;
	/* Description -  */
	/* 0x2c.8 - 0x2c.15 */
	 u_int8_t fs_int_flag13;
	/* Description -  */
	/* 0x2c.16 - 0x2c.23 */
	 u_int8_t fs_int_flag12;
	/* Description -  */
	/* 0x2c.24 - 0x2c.31 */
	 u_int8_t fs_int_flag11;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_lled_get_interface_sensor_resp_sfp {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t tx_output_power_value;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t tx_bias_current_value;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t flag_byte2;
	/* Description -  */
	/* 0x14.8 - 0x14.15 */
	 u_int8_t flag_byte1;
	/* Description -  */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t rx_input_power_value;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t pad;
	/* Description -  */
	/* 0x18.16 - 0x18.23 */
	 u_int8_t flag_byte4;
	/* Description -  */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t flag_byte3;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_get_interface_sensor_resp_common_fields {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t identifier;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t temp_high_warning_threshold;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t temp_high_alarm_threshold;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t vcc_voltage_value;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t temperature_value;
};

/* Description -   */
/* Size in bytes - 52 */
struct connectx4lx_affinity {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t mac_31_16;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t mac_47_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t smbus_eid;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t supported_medias_status;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t mac_15_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t pcie_indx;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t pcie_eid;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t smbus_address;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t smbus_indx;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 struct connectx4lx_ip_filter_mode ip_filter_mode;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t pcie_address;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t ipv4_address;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t ipv6_link_local_127_96;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t ipv6_link_local_95_64;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t ipv6_link_local_63_32;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t ipv6_link_local_31_0;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t ipv6_global_127_96;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t ipv6_global_95_64;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t ipv6_global_63_32;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t ipv6_global_31_0;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_pmcr_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Module CDR override control:
0:Auto
1:Keep Module Configuration
2:Override */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t cdr_override_cntl;
	/* Description - Valid only in case CDR is configured to override by cdr_override_cntl:
0 - RX OFF,TX OFF
1 - RX ON ,TX OFF
2 - RX OFF,TX ON
3 - RX ON,TX ON */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t cdr_override_value;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Module Rx Amplitude override control:
0:Auto
1:Keep Module Configuration
2:Override  */
	/* 0x8.0 - 0x8.1 */
	 u_int8_t rx_amp_override_cntl;
	/* Description - Valid only in case RX amplitude is configured to override mode by rx_amp_override_cnt */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t rx_amp_override_value;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Module Rx Emphasis  override control:
0:Auto
1:Keep Module Configuration
2:Override  */
	/* 0xc.0 - 0xc.1 */
	 u_int8_t rx_emp_override_cntl;
	/* Description - Valid only in case RX emphasis is configured to override mode by rx_emp_override_cntl */
	/* 0xc.8 - 0xc.11 */
	 u_int8_t rx_emp_override_value;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Module Tx Equalization override control:
0:Auto
1:Keep Module Configuration
2:Override */
	/* 0x10.0 - 0x10.1 */
	 u_int8_t tx_equ_override_cntl;
	/* Description - Valid only in case TX equalization is configured to override mode by tx_equ_override_cntl */
	/* 0x10.8 - 0x10.11 */
	 u_int8_t tx_equ_override_value;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Module Rate Select override control: 0 - Auto (default) 1 - Use Module Rate Select value 2 - Override */
	/* 0x14.0 - 0x14.1 */
	 u_int8_t rs_override_cntl;
	/* Description - Valid only in case Rate Select is configured to override mode by rs_override_cntl */
	/* 0x14.8 - 0x14.11 */
	 u_int8_t rs_override_value;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_mpein_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - PCIE index number
Reserved when access is from the host */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t pcie_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t capability_mask;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Max Link Speed:
Bit 0 - 2.5G (Gen1)
Bit 1 - 5G (Gen2)
Bit 2 - 8G (Gen3)
Bit 4- 16G (Gen4) */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t link_speed_enabled;
	/* Description - Maximum Link Width enabled:
0 - 1x
1 - 2x
2 - 4x
3 - 8x
4 - 16x */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t link_width_enabled;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Current Link Speed:
Bit 0 - 2.5G (Gen1)
Bit 1 - 5G (Gen2)
Bit 2 - 8G (Gen3)
Bit 4- 16G (Gen4) */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t link_speed_active;
	/* Description - Negotiated Link Width, pcie_link_width active:
0 - 1x
1 - 2x
2 - 4x
3 - 8x
4 - 16x */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t link_width_active;
	/* Description - The physical lane position of logical lane0 */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t lane0_physical_position;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Number of Total Virtual Functions (for all PFs) */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t num_of_vfs;
	/* Description - Number of Physical Functions (PFs) */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t num_of_pfs;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Bus Device Function - only for function0 */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t bdf0;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Reversal mode of the link:
0 - straight 
1 - reversal
Note: together with 
lane0_physical_position
 provide the physical 
lane. */
	/* 0x18.0 - 0x18.0 */
	 u_int8_t lane_reversal;
	/* Description - Indicates the specific type of this PCI 
Express Function. Note that 
different Functions in a multi-Function device can generally be of 
different types.
0 - 
PCI Express Endpoint port
5 - Upstream port
6 - Downstream port */
	/* 0x18.12 - 0x18.15 */
	 u_int8_t port_type;
	/* Description - Max payload size in bytes:
0 - 128B
1 - 256B
2 - 512B
3 - 1024B
4 - 2048B
5 - 4096B */
	/* 0x18.24 - 0x18.27 */
	 u_int8_t max_payload_size;
	/* Description - Max read request size in bytes:
0 - 128B
1 - 256B
2 - 512B
3 - 1024B
4 - 2048B
5 - 4096B */
	/* 0x18.28 - 0x18.31 */
	 u_int8_t max_read_request_size;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - [Internal] Indicates the status of the PCIE state machine:
0x00 - Disable TS1
0x01 - Disable Ack
0x02 - Disable Wait
0x10 - RESET
0x20 - Loop Back Master Active
0x21 - Loop Back Master Exit
0x31 - Loop Back Slave Entry
0x32 - Loop Back Slave Align
0x33 - Loop Back Slave EB Threshold
0x34 - Loop Back Slave Active
0x35 - Loop Back Slave Idle
0x36 - Loop Back Slave Exit
0x40 - Detect Quiet
0x41 - Detect Active 1
0x42 - Detect Active 2
0x50 - Polling Active 
0x51 - Polling Compliance Entry 
0x52 - Polling Compliance 
0x53 - Polling Compliance Exit
0x54 - Polling Config
0x60 - Config Width Start
0x61 - Config Width Ack
0x62 - Config Lane Wait
0x63 - Config Lane Ack
0x64 - Config Complete
0x65 - Config Idle
0x70 - L0_UP
0x71:0x7F - L0s 
0x80 - L1 ENTER
0x81 - L1 ACTIVE
0x90 - L1 EXIT
0xA0 - Recover Receiver Lock 
0xA1 - Recover Speed 
0xA2 - Recover Config 
0xA2 - Recover Idle 
0xA5 - Recover ESpeed 
0xA8 - Recover Equalization Phase 0
0xA9 - Recover Equalization Phase 1
0xAA - Recover Equalization Phase 2
0xAB - Recover Equalization Phase 3
0xAC - Recover Equalization Idle
0xB0 - Force TS1
0xC0 - Force TS2
0xD0 - Force IDLE
0xE0 - Force COMP
0xF0 - Force disable */
	/* 0x24.8 - 0x24.15 */
	 u_int8_t port_state;
	/* Description - device_status bit mask:
Bit 0 - Correctable error
Bit 1 - Non-Fatal Error detection 
Bit 2 - Fatal Error detected
Bit 3 - Unsupported request detected
Bit 4 - AUX power 
Bit 5 - Transaction Pending */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t device_status;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - [Internal] receiver detect result bit mask per lane */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t receiver_detect_result;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_mvts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - A SET operation with this flag set will only check if the new timestamp can be configured without updating NVRAM */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t check_timestamp_flag;
	/* Description - A GET operation with this flag set, will return the running FW version instead */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t running_flag;
	/* Description - A SET operation with this flag on will clear the running and other bank timestamps */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t clear_all_ts_flag;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - fw_version_major */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t fw_ver_major;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - fw version subminor */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t fw_ver_subminor;
	/* Description - fw_version_minor */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t fw_ver_minor;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Timestamp day     - 2 packed BCD */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t ts_day;
	/* Description - Timestamp month   - 2 packed BCD */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t ts_month;
	/* Description - Timestamp year    - 4 packed BCD */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t ts_year;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Timestamp seconds - 2 packed BCD */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t ts_seconds;
	/* Description - Timestamp minotes - 2 packed BCD */
	/* 0x10.16 - 0x10.23 */
	 u_int8_t ts_minutes;
	/* Description - Timestamp hour    - 2 packed BCD */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t ts_hour;
};

/* Description -   */
/* Size in bytes - 36 */
union connectx4lx_pmlp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_pmlp_prm_style prm_style;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_pmlp_code_style code_style;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_pplm_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The port"s active Profile ID. 
0xFF - unassigned - set when Media based port profile is set and no 
medium is connected. */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t active_port_profile;
	/* Description - Valid when Media based port profile is cleared, used to set the static port"s 
profile index. */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t static_port_profile;
	/* Description - Port profile modes (bitmask):
Bit 0 - Port type based port profile
When set the profile will be selected according to the connected port type. 
When cleared the port"s profile will be set according to the static_port_pro
file field 
Bit 1 - Legacy / IB spec profile enable (default set)
When set, the IB spec / legacy profile will be applied on the port when con
nected to a peer non-Mellanox or legacy port.
Note, when Legacy / IB spec profile enable bit is cleared, some of the con
figurations may not be supported by the peer port and will be ignored in the 
negotiation.
Bit 2 - Ethernet Enhanced FEC (default cleared)
TBD exact text - 
When auto mode (no override) is set on Mellanox links 
select the FEC based on the profile including Mellanox Phy modes
 
Bits 7:3 - Reserved */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t port_profile_mode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Active FEC (bitmask)
Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Standard LL RS-FEC - RS(271,257)
[Internal] Bit 4 - Mellanox Strong RS-FEC - RS(277,257)
[Internal] Bit 5 - Mellanox LL RS-FEC - RS(163,155)
[Internal] Bit 6- Correct On Demand (COD) */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t fec_mode_active;
	/* Description - Active Retransmission (bitmask)
Bit 0 - LLR
Bit 1 - PLR */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t retransmission_active;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - 10GE/40GE Ethernet FEC override capability bitmask:
Bit 0 - No-FEC
Bit 1- Firecode FEC
Bit 2- Reserved
Bit 3- Reserved */
	/* 0x10.0 - 0x10.3 */
	 u_int8_t fec_override_cap_10g_40g;
	/* Description - 25GE Ethernet FEC override capability bitmask:
Bit 0 - No-FEC
Bit 1- Firecode FEC
Bit 2- RS-FEC
Bit 3- Reserved */
	/* 0x10.4 - 0x10.7 */
	 u_int8_t fec_override_cap_25g;
	/* Description - 50GE Ethernet FEC override capability bitmask:
Bit 0 - No-FEC
Bit 1- Firecode FEC
Bit 2- RS-FEC
Bit 3- Reserved */
	/* 0x10.8 - 0x10.11 */
	 u_int8_t fec_override_cap_50g;
	/* Description - 100GE Ethernet FEC override capability bitmask:
Bit 0 - No-FEC
Bit 1 - Reserved
Bit 2 - RS-FEC(528,514)
Bit 3 - Reserved */
	/* 0x10.12 - 0x10.15 */
	 u_int8_t fec_override_cap_100g;
	/* Description - 56GE Ethernet FEC override capability bitmask:
Bit 0 - No-FEC
Bit 1 - Firecode FEC
Bit 2 - Reserved
Bit 3 - Reserved */
	/* 0x10.16 - 0x10.19 */
	 u_int8_t fec_override_cap_56g;
	/* Description - RS-FEC correction bypass override capability:
0 - NO correction bypass
1 - RS-FEC correction bypass */
	/* 0x10.28 - 0x10.31 */
	 u_int8_t rs_fec_correction_bypass_cap;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - 10GE/40GE Ethernet FEC override admin, see 10g_40g_fec_override_cap.
0 - Auto, no override
1 - No FEC
2 - Firecode FEC */
	/* 0x14.0 - 0x14.3 */
	 u_int8_t fec_override_admin_10g_40g;
	/* Description - 25GE Ethernet FEC override admin, see 25g_fec_override_cap.
0 - Auto, no override
1 - No FEC
2 - Firecode FEC
4 - RS-FEC
Note: 
25g_fec_override_admin
 and 
50g_fec_override_admin
 must be set 
with the same value. */
	/* 0x14.4 - 0x14.7 */
	 u_int8_t fec_override_admin_25g;
	/* Description - 50GE Ethernet FEC override admin, see 50g_fec_override_cap.
0 - Auto, no override
1 - No FEC
2 - Firecode FEC
4 - RS-FEC
Note: 
25g_fec_override_admin
 and 
50g_fec_override_admin
 must be set 
with the same value. */
	/* 0x14.8 - 0x14.11 */
	 u_int8_t fec_override_admin_50g;
	/* Description - 100GE Ethernet FEC override admin, see 100g_fec_override_cap.
0 - Auto, no override
1 - No FEC
4 - RS-FEC */
	/* 0x14.12 - 0x14.15 */
	 u_int8_t fec_override_admin_100g;
	/* Description - 56GE Ethernet FEC override admin, see 56g_fec_override_cap.
0 - Auto, no override
1 - No FEC
2 - Firecode FEC */
	/* 0x14.16 - 0x14.19 */
	 u_int8_t fec_override_admin_56g;
	/* Description - RS-FEC correction bypass override admin:
0 - Auto, no override 
1 - NO correction bypass
2 - RS-FEC correction bypass */
	/* 0x14.28 - 0x14.31 */
	 u_int8_t rs_fec_correction_bypass_admin;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_plpc_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Protocol Mask. Indicates which of the protocol data is valid
Bit 0: InfiniBand
Bit 2: Ethernet
Note: setting multiple bits will apply the setting to all the set protocols */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t proto_mask;
	/* Description - Profile ID (bitmask)
Bit 0 - IB spec / legacy (See profiles description)
Bit 1 - Internal ports (Backplane)
Bit 2 - Passive copper - Short
Bit 3 - Passive copper - Medium
Bit 4 - Passive copper - Long
Bit 5 - Active optics / copper short reach (<30m)
Bit 6 - Optics long reach (>30m)
Bit 7 - NO-FEC
Bit 8 - FEC-ON
Bit 9 - User defined 1 (not supported)
Bit 10-11 - Reserved
Note: setting multiple bits will apply the setting to multiple profile ids.
Note: Short, Medium, Long are functions of the cable length and attenua
tion. */
	/* 0x0.16 - 0x0.27 */
	 u_int16_t profile_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Per lane speed (bitmask)
Bit 0 - Reserved
Bit 1 - Reserved
Bit 2 - Reserved
Bit 3 - FDR10 (10GE / 40GE)
Bit 4 - FDR (56GE)
Bit 5 - EDR (25GE / 50GE / 100GE)
Note: setting multiple bits will apply the setting to all the set speeds */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t lane_speed;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - FEC decision policy:
0 - optimize robustness
1 - optimize latency
2 - optimize bandwidth */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t fec_mode_policy;
	/* Description - Link Performance Based FEC
When set, only FEC types that are applicable for the link performance will 
be used. When cleared, the link performance is ignored for the FEC selec
tion and the FEC is selected only according to the policy. If the selected 
FEC is not applicable for the link performance, the speed may be consid
ered as non-operational. */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t lpbf;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - FEC capability (bitmask)
Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Standard LL RS-FEC - RS(271,257)
Bit 4 - Mellanox Strong RS-FEC - RS(277,257)
Bit 5 - Mellanox LL RS-FEC - RS(163,155)
Bit 6 - Correct on Demand (COD) */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t fec_mode_capability;
	/* Description - Retransmission capability (bitmask)
Bit 0 - LLR
Bit 1 - PLR */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t retransmission_capability;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - FEC s
upport admin (bitmask)
Valid only for Mellanox Phy only, when cleared peer ports requests to 
enable the FEC mode will be ignored.
Uses the same encoding as fec_mode_capability.
Writing 0 to the filed keeps the current setting. */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t fec_mode_support_admin;
	/* Description - Retransmission support admin (bitmask)
When cleared peer ports requests to enable the retransmission mode will be 
ignored.
Uses the same encoding as retransmission_capability. */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t retransmission_support_admin;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - FEC request admin (bitmask)
Sets the FEC modes which are administratively enabled.
Uses the same encoding as retransmission_capability.
Writing 0 to the filed keeps the current setting.
The fec_mode_request_admin must be a subset of fec_mode_support_ad
min */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t fec_mode_request_admin;
	/* Description - Retransmission request admin (bitmask)
Sets the retransmission modes which are administratively enabled.
Uses the same encoding as retransmission_capability.
The retransmission_request_admin must be a subset of retransmission_sup
port_admin */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t retransmission_request_admin;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pplr_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Loopback enable - bitmask.
See lb_cap bits description. */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t lb_en;
	/* Description - Loopback capability - bitmask
Bit 1 - Phy local loopback. When set the port's egress traffic is looped back 
yo the receiver and the port transmitter is disabled.
Bit 2 - External local loopback. Enables the port's transmitter to link with 
the port's receiver using an external loopback connector.
Bits 3-7 are reserved. */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t lb_cap;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_project_nvgn {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t nv_pointer;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x1c.31 */
	 struct connectx4lx_nv_tlv_hdr tlv_header;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x2c.31 */
	 struct connectx4lx_register_access_data_reduced tlv_data;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_project_nvia {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - ALL - all NVRAM parameters-0, NVLOG-1 */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t target;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_project_nvgc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NVDA read factory settings, 0=unsupported, 1=supported */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t nvda_read_factory_settings;
	/* Description - NVDA read current settings, 0=unsupported, 1=supported */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t nvda_read_current_settings;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_project_nvqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Configuration item type */
	/* 0x0.0 - 0x4.31 */
	 union connectx4lx_nv_tlv_type type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t support_rd;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t support_wr;
	/* Description -  */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t version;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_project_nvda {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_nv_tlv_hdr tlv_header;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x2c.31 */
	 struct connectx4lx_register_access_data nvda_data;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_pmtu_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Maximum MTU supported on the port (Read Only).
MTU depends on the port type. When port type (Eth/IB/FC) is configured, 
the relevant MTU is reported. When the port type is not configured, the 
minimum between the 
max_mtu
 for the different types (Eth/IB/FC) is 
reported. */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t max_mtu;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Administratively configured MTU on the port. Must be smaller or equal to 
max_mtu
. */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t admin_mtu;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Operational MTU. This is the actual MTU configured on the ports. Packets 
exceeding this size will be dropped.
Note: In Ethernet or FC, 
oper_mtu
 is equal to 
admin_mtu
. In InfiniBand, 
the actual operational MTU is reported which may be smaller than 
admin
_mtu
. */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t oper_mtu;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_pamp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Determines the opamp group type which opamp_group points to:
0 - Network ports OpAMPs.
When selected the network ports' OpAMPs are accessed. 
The opamp_group holds an index to the network port's 4X Serdes.
1 - PCI OpAMPs
When selected the PCI's OpAMPs are accessed. 
The opamp_group holds an index to the PCI 4X Serdes. 
2 - PLL OpAMPs
When selected the PLL's OpAMPs are accessed. 
The opamp_group indicates the PLL index that is accessed.
When set, opamp_group indicates:
0 - PCI PLLs group
1 - Network ports PLL group 0
2 - Network ports PLL group 1 (if valid) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t opamp_group_type;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t opamp_group;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - number of opamp indices to access */
	/* 0x4.0 - 0x4.11 */
	 u_int16_t num_of_indices;
	/* Description - Start index for the block of opamp data */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t start_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The maximum OpAmp index valid for the opamp_group. */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t max_num_of_indices;
	/* Description - The maximum opamp_group index valid for the opamp_group_type. A value of 0xFF indicates that the opamp_group_type is not supproted */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t max_opamp_group;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Opamp index i data.
Even indices are in offset 31:16, odd indices are in offsets 15:0. */
	/* 0xc.16 - 0x2c.15 */
	 u_int16_t index_data[16];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ppaos_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port extended down status:
0 - port down
1 - phy test mode
Valid only when PAOS.admin_status=2 and PAOS.oper_status=2(i.e port is down) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t phy_test_mode_status;
	/* Description - Port extended administrative status:
0 - regular operation (port down/up according to PAOS) 
1 - phy test mode
The phy test mode(1) can be set only when PAOS.admin_status=2(i.e port configuration is down). */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t phy_test_mode_admin;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - For HCA: must be always 0.
Switch partition ID with which to associate the port.
Switch partitions are numbered from 0 to 7 inclusively.
The 
swid
 field is only valid when the 
local_port
 is the router port. 
In this case, the 
swid
 indicates which of the router ports to config
ure/query. */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t swid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - rx phy status:
0 - rx phy down
1 - rx phy up
Note: The phy up indication is according to protocol ( up == align_status=true) 
i.g In PRBS test mode phy is up when PRN is locked ( up == prbs_lock) */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t phy_status;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_pprt_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port number access type. determines the way 
local_port
 
is inter
preted:
0 - Local port number
1 - IB / label port number */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - local_port */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - Tuning operation bit:
1 - start Rx_tuning based on the PRBS. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t s;
	/* Description - Enable PRBS test mode bit:
0 - Port in regular operation.
1 - Port in PRBS test mode. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t e;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - PRBS capability (bitmask)
Bit 0 - 
PRBS31 (x^31 + x^28 + 1)
Bit 1 - PRBS23A (x^23 + x^18 + 1)
Bit 
2 
- PRBS
23B
 (x^
23
 + x^
18
 + 
x^
12+ 
x^
6 
+ 1)
Bit 3 - PRBS23
C
 (x^23 + x^
22
 + x^
19
+ x^
18
 + 1)
Bit 4 - PRBS23D (x^23 + x^1
9
 + x^1
8
+ x^
11
 + 1)
Bit 
5
 - PRBS7
 (x^
7
 + x^
6
 + 1)
Bit 
6
 - PRBS
11
 (x^
11
 + x^
9
 + 1)
Bit 7 - PRBS
11
A
 (x^11 + x^10 + x^6+ x^5 + 1)
Bit 8 - PRBS
11
B (x^11 + x^9 + x^6+ x^5 + 1)
Bit 9 - PRBS
11
C (x^11 + x^8 + x^6+ x^4 + 1)
Bit 10 - PRBS
11
D (x^11 + x^7 + x^6+ x^4 + 1)
Bit 
11
 - PRBS
9 
(x^
9
 + x^
5
 + 1)
Bit 12 - IDLE using scramble58 (x^58+ x^39 + 1) */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t prbs_modes_cap;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - see 
prbs_mode_cap: 
0x
0 - PRBS31 (x^31 + x^28 + 1)
0x
1 - PRBS23A (x^23 + x^18 + 1)
0x
2 - PRBS23B (x^23 + x^18 + x^12+ x^6 + 1)
0x
3 - PRBS23C (x^23 + x^22 + x^19+ x^18 + 1)
0x
4 - PRBS23D (x^23 + x^19 + x^18+ x^11 + 1)
0x
5 - PRBS7 (x^7 + x^6 + 1)
0x
6 - PRBS11 (x^11 + x^9 + 1)
0x
7 - PRBS11A (x^11 + x^10 + x^6+ x^5 + 1)
0x
8 - PRBS11B (x^11 + x^9 + x^6+ x^5 + 1)
0x
9 - PRBS11C (x^11 + x^8 + x^6+ x^4 + 1)
0xA
 - PRBS11D (x^11 + x^7 + x^6+ x^4 + 1)
0xB
 - PRBS9 (x^9 + x^5 + 1)
0xC - IDLEs using scramble58 (x^58+ x^39 + 1) */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t prbs_mode_admin;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - per lane rate capability (bitmask)
Bit 0 - 
1GE (
1.25 Gb/s
)
Bit 1 - 
SDR (
2.5 Gb/s
)
 
Bit 2 - XAUI/2.5GE (3.125 Gb/s)
Bit 
3
- 
DDR (
5 Gb/s
)
 
Bit 
4
- 
QDR (
10 Gb/s
)
 
Bit 
5
- 
FDR10 / 10GE/40GE (
10.3125 Gb/s
)
 
Bit 
6
-
 FDR (
14.0625 Gb/s
)
 
Bit 
7
- 
EDR / 25GE / 50GE / 100GE (
25.78125 Gb/s
)
 */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t lane_rate_cap;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - lane rate be used in PRBS , see 
lane_rate_cap:
0 - 
SDR (2.5 Gb/s)
1 - 
DDR (5 Gb/s) 
2 - 
QDR (10 Gb/s)
3 - 
FDR10 / 10GE/4 0GE (10.3125 Gb/s)
4 - 
FDR (14.0625 Gb/s) 
5 - 
EDR / 25GE / 50GE / 100GE (25.78125 Gb/s)
6 - 9 - reserved
10 - 
1GE (1.25 Gb/s)
11 - 
XAUI/2.5GE (3.125 Gb/s)
12 - 15 - reserved */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t lane_rate_oper;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - PRBS lock on PRBS pattern status: 
0 - Not locked 
1 - Locked
 Note: Once exiting prbs test mode the prbs_rx_tuning_status will return to 0 (Not locked). */
	/* 0x14.24 - 0x14.27 */
	 u_int8_t prbs_rx_lock_status;
	/* Description - Tuning status: 
0 - 
PRBS mode 
tuning was not performed.
1 - Performing
 
PRBS mode tuning.
2 - PRBS mode tuning completed.
Note: Once the link is up the 
prbs_rx_tuning_status
 will return 
0. */
	/* 0x14.28 - 0x14.31 */
	 u_int8_t prbs_rx_tuning_status;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_pptt_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port number access type. determines the way 
local_port
 
is inter
preted:
0 - Local port number
1 - IB / label port number */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - local_port */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - E
n
able PRBS test mode bit:
0 - Port in 
regular
 operation.
1 - Port in PRBS
 
test mode. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t e;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - PRBS
 capability (bitmask)
Bit 0 - 
PRBS31 (x^31 + x^28 + 1)
Bit 1 - PRBS23A (x^23 + x^18 + 1)
Bit 
2 
- PRBS
23B
 (x^
23
 + x^
18
 + 
x^
12+ 
x^
6 
+ 1)
Bit 3 - PRBS23
C
 (x^23 + x^
22
 + x^
19
+ x^
18
 + 1)
Bit 4 - PRBS23D (x^23 + x^1
9
 + x^1
8
+ x^
11
 + 1)
Bit 
5
 - PRBS
7
 (x^
7
 + x^
6
 + 1)
Bit 
6
 - PRBS
11
 (x^
11
 + x^
9
 + 1)
Bit 7 - PRBS
11
A
 (x^11 + x^10 + x^6+ x^5 + 1)
Bit 8 - PRBS
11
B (x^11 + x^9 + x^6+ x^5 + 1)
Bit 9 - PRBS
11
C (x^11 + x^8 + x^6+ x^4 + 1)
Bit 10 - PRBS
11
D (x^11 + x^7 + x^6+ x^4 + 1)
Bit 
11
 - PRBS
9 
(x^
9
 + x^
5
 + 1)
Bit 
12
 - 
IDLE using scramble58 (
x^
58
+ x^
39
 + 1) */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t prbs_modes_cap;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - See 
prbs_mode_cap
: 
0x
0 - PRBS31 (x^31 + x^28 + 1)
0x
1 - PRBS23A (x^23 + x^18 + 1)
0x
2 - PRBS23B (x^23 + x^18 + x^12+ x^6 + 1)
0x
3 - PRBS23C (x^23 + x^22 + x^19+ x^18 + 1)
0x
4 - PRBS23D (x^23 + x^19 + x^18+ x^11 + 1)
0x
5 - PRBS7 (x^7 + x^6 + 1)
0x
6 - PRBS11 (x^11 + x^9 + 1)
0x
7 - PRBS11A (x^11 + x^10 + x^6+ x^5 + 1)
0x
8 - PRBS11B (x^11 + x^9 + x^6+ x^5 + 1)
0x
9 - PRBS11C (x^11 + x^8 + x^6+ x^4 + 1)
0xA
 - PRBS11D (x^11 + x^7 + x^6+ x^4 + 1)
0xB
 - PRBS9 (x^9 + x^5 + 1)
0xC
 - IDLEs using scramble58 (x^58+ x^39 + 1) */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t prbs_mode_admin;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Per
 lane rate capability (bitmask)
Bit 0 - 1GE (1.25 Gb/s)
Bit 1 - SDR (2.5 Gb/s) 
Bit 2 - XAUI/2.5GE (3.125 Gb/s)
Bit 3- DDR (5 Gb/s) 
Bit 4- QDR (10 Gb/s) 
Bit 5- FDR10 / 10GE/40GE (10.3125 Gb/s) 
Bit 6- FDR (14.0625 Gb/s) 
Bit 7- EDR / 25GE / 50GE / 100GE (25.78125 Gb/s) */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t lane_rate_cap;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - L
ane rate be used in PRBS, see 
lane_rate_cap
:
0 - 
SDR (2.5 Gb/s)
1 - 
DDR (5 Gb/s) 
2 - 
QDR (10 Gb/s)
3 - 
FDR10 / 10GE/4 0GE (10.3125 Gb/s)
4 - 
FDR (14.0625 Gb/s) 
5 - 
EDR / 25GE / 50GE / 100GE (25.78125 Gb/s)
6 - 9 - reserved
10 - 
1GE (1.25 Gb/s)
11 - 
XAUI/2.5GE (3.125 Gb/s)
12 - 15 - reserved */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t lane_rate_oper;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_slrg_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - physical lane number. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - Port number access type. determines the way 
local_port
 
is inter
preted:
0 - Local port number
1 - IB / label port number
[Internal] 3 - Out of band / PCI */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - 0 - 40nm products
1 - 28nm products */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t version;
	/* Description - 0 - Invalid
1 - Valid */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t status;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The lane speed on which the grade was measured:
0 - SDR
1 - DDR
2 - QDR
3 - FDR10 (10GE / 40GE)
4 - FDR (56GE)
5 - EDR (25GE / 50GE / 100GE)
6 - 9 - reserved
10 - 1GE
11 - 2.5GE (XAUI)
12 - 15 - reserved */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t grade_lane_speed;
	/* Description - The time that took took to bring up the link in msec.
FW internal field - to move in the next PR */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t time_to_link_up;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t grade;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t grade_version;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t height_grade;
	/* Description - 0 - BER Bath
1 - 1s ratio
2 - EO
3 - 1s ratio + NDEO */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t height_grade_type;
	/* Description - Determine the units of phase_eo_pos and phase_eo_neg:
0 - psec
1 - ticks */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t phase_units;
	/* Description - Determine the units of offset_eo_pos and offset_eo_neg:
0 - mV after slicer (including A2D sample)
1 - mV before slicer */
	/* 0xc.30 - 0xc.31 */
	 u_int8_t offset_units;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - N/A */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t height_dv;
	/* Description - When height_grade_type = EO holds height_eo_pos */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t height_dz;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t height_sigma;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t offset_eo_neg;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t offset_eo_pos;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t phase_grade;
	/* Description - 0 - Reserved
1 - Reserved
2 - EO */
	/* 0x1c.24 - 0x1c.27 */
	 u_int8_t phase_grade_type;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The offset from the eye center to the negative side. Valid when 
phase_grade_type = 2 */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t phase_eo_neg;
	/* Description - The offset from the eye center to the positive side. Valid when 
phase_grade_type = 2 */
	/* 0x20.16 - 0x20.23 */
	 u_int8_t phase_eo_pos;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Number of bit errors measured after the tuning has completed [BER].
The time window for the test is defined in PTAS [ber_test_time] */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t test_errors_per_lane;
	/* Description - The number of space search steps performed during the lane tuning.
0 - N/A - no search was performed. */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t ffe_set_tested;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_ptas_reg {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Number height grade measurement repetitions */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_repetitions;
	/* Description - 0 - Average
1 - MInimum
2 - Median */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t repetitions_mode;
	/* Description - Bit 0 - calib_for_each_conf_en
When set perform calibration for each set
Bit 1- adaptive_tap_offset_en
When set perform adaptive tap tuning, when cleared use a pre-
defined tap offset.
BIt 2 - phase_measuring_en
When set perform also phase measuring as part of the tuning grade. */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t algorithm_options;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t phase_grade_weight;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t height_grade_weight;
	/* Description - 0 - Reserved
1 - Reserved
2 - EO */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t phase_grade_type;
	/* Description - 0 - BER Bath
1 - 1s ratio
2 - EO
3 - 3 - 1s ratio + NDEO */
	/* 0x8.20 - 0x8.23 */
	 u_int8_t height_grade_type;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t grade_version;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t adaptive_tap_measure_bits;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t gisim_measure_bits;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t ber_bath_mid_error_threshold;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t ber_bath_high_error_threshold;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t one_ratio_high_threshold;
	/* Description -  */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t ber_bath_low_error_threshold;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t one_ratio_low_mid_threshold;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t one_ratio_high_mid_threshold;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t ndeo_error_threshold;
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t one_ratio_low_threshold;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t mix90_phase_for_voltage_bath;
	/* Description -  */
	/* 0x20.16 - 0x20.31 */
	 u_int16_t mixer_offset_step_size;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t mixer_offset_end;
	/* Description -  */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t mixer_offset_start;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - BER test time in 1msec units. */
	/* 0x28.0 - 0x28.10 */
	 u_int16_t ber_test_time;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_sltp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - copy transmit parameters to Data Base */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t c_db;
	/* Description - physical lane speed. */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t speed_lane;
	/* Description - physical lane number. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - Port number access type. determines the way 
local_port
is interpreted:
0 - Local port number
1 - IB / label port number
[Internal] 3 - Out of band / PCI */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - 0 - 40nm products
1 - 28nm products */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t version;
	/* Description - 0 - Invalid
1 - Valid */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t status;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t ob_tap2;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t ob_tap1;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t ob_tap0;
	/* Description - Tx lane polarity */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t polarity;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t ob_bias;
	/* Description - (ref_txcml100_reg) */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t ob_reg;
	/* Description - Concatenation of taps polarity + preemp_sel */
	/* 0xc.16 - 0xc.19 */
	 u_int8_t ob_preemp_mode;
	/* Description -  */
	/* 0xc.20 - 0xc.23 */
	 u_int8_t ob_leva;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Bitmask for bad SET status:Bit 0 - Illegal ob_bais value,Bit 1 - Illegal ob taps polarity (distance between taps) */
	/* 0x10.29 - 0x10.30 */
	 u_int8_t ob_bad_stat;
	/* Description - OB Normalization status */
	/* 0x10.31 - 0x10.31 */
	 u_int8_t ob_norm;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_slrp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Physical lane number */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - Port number access type. determines the way local_port is interpreted:
0 - Local port number
1 - IB port number
3 - OOB/PCI */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - 0 - 40nm products, 1 - 28nm products */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t version;
	/* Description - 0 - Invalid, 1 - Valid */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t status;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t mix90phase;
	/* Description -  */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t dp90sel;
	/* Description - datapath select, indicates the input buffer connected to the data path. */
	/* 0x4.12 - 0x4.12 */
	 u_int8_t dp_sel;
	/* Description - input buffer select:
0 - Active
1 - Inactive
2 - IB0
3 - IB1 */
	/* 0x4.30 - 0x4.31 */
	 u_int8_t ib_sel;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t ffe_tap3;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t ffe_tap2;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t ffe_tap1;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t ffe_tap0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t ffe_tap7;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t ffe_tap6;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t ffe_tap5;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t ffe_tap4;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.8 */
	 u_int16_t ffe_tap_en;
	/* Description -  */
	/* 0x10.16 - 0x10.23 */
	 u_int8_t mixerbias_tap_amp;
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t ffe_tap8;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t slicer_offset;
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t ffe_tap_offset1;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t ffe_tap_offset0;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t mixer_offset1;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t mixer_offset0;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.7 */
	 u_int8_t mixerbgn_refn;
	/* Description -  */
	/* 0x1c.8 - 0x1c.15 */
	 u_int8_t mixerbgn_refp;
	/* Description -  */
	/* 0x1c.16 - 0x1c.23 */
	 u_int8_t mixerbgn_inn;
	/* Description -  */
	/* 0x1c.24 - 0x1c.31 */
	 u_int8_t mixerbgn_inp;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t mixer_offset_cm1;
	/* Description -  */
	/* 0x20.8 - 0x20.15 */
	 u_int8_t lctrl_input;
	/* Description -  */
	/* 0x20.16 - 0x20.23 */
	 u_int8_t slicer_gctrl;
	/* Description -  */
	/* 0x20.24 - 0x20.28 */
	 u_int8_t ref_mixer_vreg;
	/* Description -  */
	/* 0x20.30 - 0x20.30 */
	 u_int8_t sel_slicer_lctrl_l;
	/* Description -  */
	/* 0x20.31 - 0x20.31 */
	 u_int8_t sel_slicer_lctrl_h;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.8 */
	 u_int16_t slicer_offset_cm;
	/* Description -  */
	/* 0x24.16 - 0x24.24 */
	 u_int16_t mixer_offset_cm0;
	/* Description -  */
	/* 0x24.26 - 0x24.31 */
	 u_int8_t common_mode;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_paos_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port operational state:
1 - up
2 - down
4 - down by port failure (transitioned by the hardware) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t oper_status;
	/* Description - Port administrative state (the desired state of the interface):
1 - up
2 - down by configuration
3 - up once - if the port goes up and then down, the operational 
status should go to "down by port failure" and can only go back 
up upon explicit command
4 - disabled by system - this mode cannot be set by the software, 
only by the hardware.
[Internal] Default should come from ini. Up for unmanaged sys
tems and Down for managed
[Internal] For InfiniBand ports, this holds the local admin status. 
SM status does not overide this one and should be held in a tem
porary register.
[Internal] if 
ext_down_admin is in test_mode 
admin_status 
must 
remain down. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t admin_status;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - For HCA: must always be 0.
Switch partition ID with which to associate the port.
Switch partitions are numbered from 0 to 7 inclusively.
The 
swid
 field is only valid when the 
local_port
 is the router port. 
In this case, the 
swid
 indicates which of the router ports to config
ure/query. */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t swid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Event generation on operational state change:
0
 - Do not generate event
1
 - Generate Event 
2
 - Generate Single Event
Not Supported for HCA. */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t e;
	/* Description - Event update enable. If this bit is set, event generation will be 
updated based on the 
e
 field. Only relevant on Set operations.
Not Supported for HCA. */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t ee;
	/* Description - Admin state update enable. If this bit is set, admin state will be 
updated based on 
admin_state
 field. Only relevant on Set() opera
tions. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t ase;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_mjtag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Size of operation - relevant for JTAG interface access com
mands only, indicating the number of transaction bytes to exe
cute. Maximum size supported is 40.
Note:
 when size=0, no operation is performed (clock is not tog
gled). The 
tdo
 is sampled and provided in the response at 
jtag_transaction_set_0
. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t size;
	/* Description - Command sequence number - to prevent re-execution of the 
same command due to command retransmission, this command 
includes a sequence number.
The enable and disable commands MUST be issues with 
sequence_number
 = 0 while any JTAG access command must 
increase the 
sequence_number
 by 1 (the first JTAG access com
mand should start at 
sequence_number
 = 1). */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t sequence_number;
	/* Description - Command
0 - JTAG interface disable - JTAG interface is disabled
1 - JTAG interface enable - enabling JTAG interface
2 - JTAG interface access */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t cmd;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Transactions */
	/* 0x4.0 - 0x2c.31 */
	 u_int32_t dword[10];
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_mqis_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Type of information string to be queried:
0x0: VPD
0x1: MODEL_NAME
0x2: MODEL_DESCRIPTION
other values are reserved. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t info_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Total size of the information string, according to 
info_type
. 
Value given in bytes. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t info_length;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Number of bytes requested. The device returns the number 
of bytes actually read. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t read_length;
	/* Description - Offset in bytes of the first byte requested to read. */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t read_offset;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Information string accessed, according to 
info_type
. If the 
information is not available, a NULL string is returned. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t info_string[1];
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_mcda_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Update handle registered when the FSM was activated. */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t update_handle;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Offset of accessed address relative to component start. 
Accesses must be in accordance to 
log_mcda_word_size
 in 
Table 671, "
MCQI CAPABILITIES Info Layout
," on 
page 758 */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t offset;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Size of the data accessed, given in bytes */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Data block accessed */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t data[1];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_mcc_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Command to be executed by the FSM
0x1: LOCK_UPDATE_HANDLE
0x2: RELEASE_UPDATE_HANDLE 
0x3: UPDATE_COMPONENT
0x4: VERIFY_COMPONENT
0x5: ACTIVATE_COMPONENET 
0x6: ACTIVATE
0x7: READ_COMPONENT
0x8: CANCEL
0x9: CHECK_UPDATE_HANDLE
0xA: FORCE_HANDLE_RELEASE
0xB: READ_PENDING_COMPONENT
Other values are reserved. Applicable for write operation 
only. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t instruction;
	/* Description - The number of seconds elapsed since the update_handle 
owner last issued a command. The time saturates at 0xFFF. */
	/* 0x0.16 - 0x0.27 */
	 u_int16_t time_elapsed_since_last_cmd;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Index of the accessed component. Valid for 
UPDATE_COMPONENT, ACTIVATE_COMPONENET, 
READ_COMPONENT and READ_PENDING_COMPO
NENT instructions. Otherwise, this field is reserved. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t component_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Token representing the current flow executed by the FSM.
See 
"Update Handle" on page 429 */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t update_handle;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Current Update FSM state, See 
"FSM States" on page 
431
 
0x0: IDLE
0x1: LOCKED
0x2: INITIALIZE
0x3: DOWNLOAD
0x4: VERIFY
0x5: APPLY
0x6: ACTIVATE
0x7: UPLOAD
0x8: UPLOAD_PENDING
Other values are reserved */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t control_state;
	/* Description - Indicates the successful completion of the 
instruction
, or 
the reason it failed. See 
"Error Handling" on page 431
0x0: OK
0x1: ERROR
0x2: REJECTED_DIGEST_ERR
0x3: REJECTED_NOT_APPLICABLE
0x4: REJECTED_UNKNOWN_KEY
0x5: REJECTED_AUTH_FAILED
0x6: REJECTED_UNSIGNED
0x7: REJECTED_KEY_NOT_APPLICABLE
0x8: REJECTED_BAD_FORMAT
0x9: BLOCKED_PENDING_RESET
Other values should be treated as an unknown error. */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t error_code;
	/* Description - Indicates the estimated progress status of the current opera
tion executed by the FSM. Valid values are 0..100.
101 indicates that progress reporting is not supported for 
this update state. */
	/* 0xc.16 - 0xc.22 */
	 u_int8_t control_progress;
	/* Description - For 
handle_owner_type
 BMC, command-interface and 
ICMD, indicates the identifier of the host of the handle 
owner.
Otherwise reserved */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t handle_owner_host_id;
	/* Description - Type of entity holding the update handle:
0x0: unspecified
0x1: Chassis BMC
0x2: MAD
0x3: BMC
0x4: command interface
0x5: ICMD 
Other values are reserved. */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t handle_owner_type;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Component size in bytes. 
Valid for UPDATE_COMPONENT instruction. Specifying 
the size may shorten the update time.
Value 0x0 means that size is unspecified. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t component_size;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_mcqi_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Component index gathered by 
"MCQS - Management 
Component Query Status" */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t component_index;
	/* Description - When set, the register will return information about the 
pending component (if available) */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t read_pending_component;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Component properties set.
0x0: CAPABILITIES
0x1: VERSION
0x5: ACTIVATION_METHOD
Other values are reserved */
	/* 0x8.0 - 0x8.4 */
	 u_int8_t info_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Properties set structure size, given in bytes. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t info_size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The requested/returned data offset from the section start, 
given in bytes.
Must be DWORD aligned. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t offset;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The requested/returned data size, given in bytes. 
If 
data_size
 is not DWORD aligned, the last bytes are zero 
padded. */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t data_size;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Properties set structure according to 
info_type
.
CAPABILITIES - See 
Table 671, "
MCQI CAPABILITIES 
Info Layout
," on page 758
VERSION - See 
Table 673, "
MCQI VERSION Info Lay
out
," on page 760
ACTIVATION_METHOD - See 
Table 677, "
MCQI ACTI
VATION_METHOD Info Layout
," on page 761 */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t data[1];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_mcqs_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Component Index. Values range from 1 to the last compo
nent indicated by 
last_index_flag
. */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t component_index;
	/* Description - When set, this component is the last component (highest 
component_index
). */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t last_index_flag;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This field uniquely identifies a specific component type. 
0x1: BOOT_IMG_CX4
0x2: RUNTIME_IMG_CX4
0x3: USER_NVCONFIG
0x4: OEM_NVCONFIG
0x5: MLNX_NVCONFIG
0x6: CS_TOKEN
0x7: DBG_TOKEN
0x8: DEV_INFO
0x9: PACKAGE_INFO
Other values are reserved */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t identifier;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Component statue in update flow, see 
"Component update 
state" on page 428
: 
0x0: IDLE
0x1: IN_PROGRESS
0x2: APPLIED
0x3: ACTIVE 
0x4: ACTIVE_PENDING_RESET
0x5: FAILED
0x6: CANCELED
0x7: BUSY
Other values are reserved */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t component_update_state;
	/* Description - The status of the component:
0x0: NOT_PRESENT - The component is supported by the 
device but, currently not present
0x1: PRESENT - This component is present.
0x2: IN_USE - The component is present and currently in 
use.
Other values are reserved */
	/* 0x8.4 - 0x8.8 */
	 u_int8_t component_status;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - For 
last_update_state_changer_type
 BMC, command-
interface and ICMD, indicates the identifier of the host of 
the handle owner. Otherwise reserved. */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t last_update_state_changer_host_id;
	/* Description - Indicates which entity was the last to change the 
compo
nent_update_state
 of this component.
0x0: unspecified
0x1: Chassis BMC
0x2: MAD
0x3: BMC
0x4: command interface
0x5: ICMD
Other values are reserved */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t last_update_state_changer_type;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_mfbe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
	/* Description - erase a 64KB bulk */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t bulk_64kb_erase;
	/* Description - erase a 32KB bulk */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t bulk_32kb_erase;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - address in bytes */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t address;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_project_mfba {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_mfba_header mfba_header;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x2c.31 */
	 struct connectx4lx_register_access_data mfba_data;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_register_misc_counters {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - When performing a WRITE operation - , the counter select bitmask deter
mines which registers are set:
Bit 0 - ECC
Bit 1 - LDB silent drop */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t counter_select;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Counts number of arrays which encountered a bit error */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ecc;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Counts number of packets silently dropped due to LDB error */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t ldb_silent_drop;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_mtmp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Sensors index to access */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t sensor_index;
	/* Description - query the internal diodes */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t internal_diodes_query;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Temperature reading from the sensor. Reading in 0.125 Celsius degrees. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t temperature;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The highest measured temperature from the sensor. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t max_temperture;
	/* Description - Max Temperature Reset - clears the value of the max temperature register */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t mtr;
	/* Description - Max Temperature Enable - enables measuring the max temperature on a sensor */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t mte;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - If the sensor temperature measurement is above the threshold (and events are enabled), an event
will be generated */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t temperature_threshold_hi;
	/* Description - Temperature Event Enable
00 - Do not generate event
01 - Generate Event
10 - Generate single event */
	/* 0xc.30 - 0xc.31 */
	 u_int8_t tee;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t temperature_threshold_lo;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t name_hi;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t name_lo;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_mfrl {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - on Read, required reset level. On write, minimum requested reset level
 0-Full ISFU
 1-Driver down but link is up
 2-driver and link down
 3-driver down, link down pci disable/enable
 7-server warm reboot
 8-server cold reboot */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t reset_level;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_mfai {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t address;
	/* Description - if set make image permamnent */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t permanent;
	/* Description - if set use address */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t use_address;
	/* Description - if set use image id and not address */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t use_image_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t image_id;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_mfpa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - address in bytes */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t boot_address;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - number of flash devices connected */
	/* 0x10.0 - 0x10.3 */
	 u_int8_t flash_num;
	/* Description - If set, MFMC register supports setting write protect with sub-sector blocks
Sub-sector block size is available in MFMC.sub_sector_protect_size */
	/* 0x10.16 - 0x10.16 */
	 u_int8_t sub_sector_wrp_en;
	/* Description - If set, MFMC register supports setting write protect with sector blocks
Sector block size is available in MFMC.sector_protect_size */
	/* 0x10.17 - 0x10.17 */
	 u_int8_t sector_wrp_en;
	/* Description - supports 64KB bulk erase operation */
	/* 0x10.29 - 0x10.29 */
	 u_int8_t bulk_64kb_erase_en;
	/* Description - supports 32KB bulk erase operation */
	/* 0x10.30 - 0x10.30 */
	 u_int8_t bulk_32kb_erase_en;
	/* Description - reflection of wip bit from flash */
	/* 0x10.31 - 0x10.31 */
	 u_int8_t wip;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Flash JEDEC ID */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t jedec_id;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Flash sectore size */
	/* 0x18.0 - 0x18.9 */
	 u_int16_t sector_size;
	/* Description -  */
	/* 0x18.16 - 0x18.23 */
	 u_int8_t block_allignment;
	/* Description -  */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t block_size;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Bitmask indicates which capabilities are supported.
Bit 15-0: reserved
Bit 16: Set write protect supported (register MFMC supports setting write protection)
Bit 17: quad enable read write is supported (register MFMC supports setting quad enable)
Bit 18: set dummy cycle supported (register MFMC supports setting dummy cycles) */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t capability_mask;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fpga_shell_caps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Total size of shared QP buffer size in granularity of 2 KB. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t total_rcv_credits;
	/* Description - Maximum number of supported QPs. */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t max_num_qps;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - If set, RC transport service is supported. */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t rc;
	/* Description - If set, UC transport service is supported. */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t uc;
	/* Description - If set, UD transport service is supported. */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t ud;
	/* Description - If set, DC transport service is supported. */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t dc;
	/* Description - If set, RDMA READ operation is supported. */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t rre;
	/* Description - If set, RDMA WRITE operation is supported. */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t rwe;
	/* Description - If set, RDMA atomic operation is supported. */
	/* 0x4.10 - 0x4.10 */
	 u_int8_t rae;
	/* Description - Bit mask indicates which QP types are supported
Bit 0: Shell_qp - Shell QP supported
Bit 1: Sandbox_qp - Sandbox QP supported */
	/* 0x4.16 - 0x4.17 */
	 u_int8_t qp_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Log (base 2) of the DDR size in granularity of GB. */
	/* 0x8.0 - 0x8.5 */
	 u_int8_t log_ddr_size;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The maximum size of message size supported by FPGA Shell QP. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t max_fpga_qp_msg_size;
};

/* Description -   */
/* Size in bytes - 12 */
union connectx4lx_pmmp_sfp_protocol_override_layout_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_pmmp_sfp_protocol_override_layout pmmp_sfp_protocol_override_layout;
};

/* Description -   */
/* Size in bytes - 12 */
union connectx4lx_pmmp_qsfp_protocol_override_layout_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_pmmp_qsfp_protocol_override_layout pmmp_qsfp_protocol_override_layout;
};

/* Description -   */
/* Size in bytes - 248 */
union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pddr_operation_info_page pddr_operation_info_page;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pddr_phy_info_page pddr_phy_info_page;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pddr_troubleshooting_page pddr_troubleshooting_page;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pddr_module_info pddr_module_info;
};

/* Description -   */
/* Size in bytes - 248 */
union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc8.31 */
	 struct connectx4lx_pcie_perf_counters pcie_perf_counters;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pcie_lanes_counters pcie_lanes_counters;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_pcie_timers_states pcie_timers_states;
};

/* Description -   */
/* Size in bytes - 248 */
union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_802_3_cntrs_grp_data_layout eth_802_3_cntrs_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_2863_cntrs_grp_data_layout eth_2863_cntrs_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_2819_cntrs_grp_data_layout eth_2819_cntrs_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_3635_cntrs_grp_data_layout eth_3635_cntrs_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_extended_cntrs_grp_data_layout eth_extended_cntrs_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_per_prio_grp_data_layout eth_per_prio_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_per_traffic_grp_data_layout eth_per_traffic_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0x38.31 */
	 struct connectx4lx_correct_on_demand_layout correct_on_demand;
	/* Description -  */
	/* 0x0.0 - 0xc8.31 */
	 struct connectx4lx_phys_layer_cntrs phys_layer_cntrs;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_discard_cntrs_grp_data discard;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_llr_counters llr_counters;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_ib_port_counters ib_port_counters;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_eth_per_traffic_congestion_grp_data_layout eth_per_traffic_congestion_grp_data_layout;
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_phys_layer_stat_cntrs phys_layer_stat_cntrs;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_access_register_unit_perf_counters_data_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t value;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_access_register_unit_perf_counters_cfg_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Counter selector configuration.
If set to 0 on even-numbered selectors, extends the consecutively (odd-numbered) counter to 64 bits.
If set to 0 on odd-numbered selectors, count core clock cycles. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t select;
	/* Description - 0 = SKIP: do not modify this counter selector
1 = SET: set this counter selector, and reset the counter */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t cmd;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_node_description {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t d[16];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_application_prio_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - According to 802.1Q application priority TLV */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t protocol_id;
	/* Description - According to 802.1Q application priority TLV */
	/* 0x0.16 - 0x0.18 */
	 u_int8_t sel;
	/* Description - This field is reserved when HCA_CAP.num_ports ==1. 
 See Table 739, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 801
. 
According to 
802.1Q application priority TLV */
	/* 0x0.21 - 0x0.23 */
	 u_int8_t priority;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_tc_qos_configuration {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The percentage of bandwidth guaranteed to TClass within its TClass Group */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t bw_allocation;
	/* Description - TClass Group assigned to a TClass. */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t group;
	/* Description - Rate limit update. Enables update of the rate limiter (with the max_bw_units, max_bw_value) */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t r;
	/* Description - Bandwidth allocation update. Enables update of the ETS bandwidth allocation (with the bw_allocation). */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t b;
	/* Description - Group update. Enables update of the group assigned to the TClass. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t g;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The maximal bandwidth allowed for the use TClass */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t max_bw_value;
	/* Description - 0 - rate limiter disbled, 0b0011 - 100 Mbps, 0b0100 - 1 Gbps  */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t max_bw_units;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_ref_count {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.27 */
	 u_int32_t ref_counter;
	/* Description - NOT_VALID = 0x0
MISC = 0x1
QP = 0x2
SQ = 0x3
MEMORY_RQ = 0x4
SRQ = 0x5
XRC_SRQ = 0x6
RMP = 0x7
TIR = 0x8
TIS = 0x9
DCT = 0xa
NO_LRO_QP = 0xb */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t ref_valid_cre_type;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_mac_address_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Upper bits of mac address. */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t mac_addr_47_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Lower bits of mac address. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mac_addr_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_tir_dmfs {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - resource index of the STE of TIR context */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t tir_ste_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - resource index of the hash filter */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t hash_filter_base_ix;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - resource index of the hash entries */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t hash_entries_base_ix;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_rx_hash_field_select {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bitmask which sets which packets headers fields should be 
selected for RX Hash.
Each bit represents a field as described below
0: SRC_IP
1: DST_IP
2: L4_SPORT
3: L4_DPORT
4: IPSEC_SPI
5-29: reserved
Only packets which contain the enabled fields can be delivered 
to that TIR, this must be done with proper Flow Table rules.
For example if L4_SPORT is enabled and l4_protocol_type == 
TCP only TCP packets are allowed to reach this TIR.
Note that if this field refers to tunneling packets only tunneling 
packets with proper inner headers are allowed to reach this TIR. */
	/* 0x0.0 - 0x0.29 */
	 u_int32_t selected_fields;
	/* Description - This field sets the L4 protocol type (TCP or UDP) L4_SPORT 
and L4_DPORT fields refer to:
0: TCP
1: UDP
If both L4_SPORT and L4_DPORT are disabled this field is 
ignored and it does not impact the RX hash behavior. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t l4_prot_type;
	/* Description - This field sets the L3 protocol type (IPv4 or IPv6) SRC_IP and 
DST_IP fields refer to:
0: IPv4
1: IPv6
If both SRC_IP and DST_IP are disabled this field is ignored and 
it does not impact the RX hash behavior. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t l3_prot_type;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_fw_qpc_special {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_regular_qp regular_qp;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_dcr_qp dcr_qp;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_dct_qp dct_qp;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fw_qpc_q {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -   FW_QP_STATE_RESET     = 0,
  FW_QP_STATE_INIT      = 1,
  FW_QP_STATE_RTR_UNUSED       = 2,
  FW_QP_STATE_RTS_UNUSED       = 3,
  FW_QP_STATE_SQER_UNUSED      = 4,
  FW_QP_STATE_SQD_UNUSED       = 5,
  FW_QP_STATE_ERR       = 6,
  FW_QP_STATE_DRAINING_UNUSED  = 7,
  FW_QP_STATE_BUSY_UNUSED      = 8,
  FW_QP_STATE_SUSPENDED_UNUSED = 9,
  FW_QP_STATE_READY     = 10,
  FW_QP_STATE_FLUSHING  = 11,
  FW_QP_STATE_CHILLING  = 12,
  FW_QP_STATE_NACK      = 13
 */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t qp_state;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 struct connectx4lx_schedint_cause schedint_cause;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t sxdc_valid;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t qpc_valid;
	/* Description - relevant for DCT only. DCT_CLEANUP_IDLE = 0
 DCT_CLEANUP_DCRS_NOT_FOUND = 1
 DCT_CLEANUP_DCRS_FOUND = 2 */
	/* 0x0.18 - 0x0.19 */
	 u_int8_t dct_cleanup_state;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t qp_in_linked_list;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t cmdif_awaiting;
	/* Description - kill qp arbiter was disabled as part of duplicate_sx_flush flow */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t dup_sx_flush_kill_qp_arb_disabled;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t broken_wq_buffer;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t broken_cq;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t catas_event_generated;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t last_wqe_event_generated;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t async_event_generated;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t flushed_in_error;
	/* Description -  */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t sl_diff_flow_done;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t all_connections_closed_event_req;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t disable_flushed_in_error;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t packet_pacing_rate_limit_index;
	/* Description - extends rx heartbeat for use with ODP */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t rx_heartbeat_odp_ext;
	/* Description - extends rx heartbeat */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t rx_heartbeat_gnrl_ext;
	/* Description - extends rx heartbeat */
	/* 0x4.10 - 0x4.10 */
	 u_int8_t rx_heartbeat_retry_cntr_ext;
	/* Description - extends sx heartbeat for use with ODP */
	/* 0x4.12 - 0x4.12 */
	 u_int8_t sx_heartbeat_odp_ext;
	/* Description - extends sx heartbeat */
	/* 0x4.13 - 0x4.13 */
	 u_int8_t sx_heartbeat_gnrl_ext;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t vendor_syndrome;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t hw_syndrome;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t trap_reason;
	/* Description - for DCR cleanup */
	/* 0xc.5 - 0xc.5 */
	 u_int8_t connect_sent_to_ctrl_dct;
	/* Description - QP generated all needed events, or does need to */
	/* 0xc.6 - 0xc.6 */
	 u_int8_t needed_events_generated;
	/* Description - used in responder only */
	/* 0xc.8 - 0xc.11 */
	 u_int8_t retransmission_state;
	/* Description -  */
	/* 0xc.12 - 0xc.12 */
	 u_int8_t rx_fault_event_fired;
	/* Description -  */
	/* 0xc.14 - 0xc.14 */
	 u_int8_t sx_fault_event_fired;
	/* Description - (fw_trap_reason = SET_LIMIT) -> limit value.For DCR, requestor is used for odp gvmi */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t trap_data_odp_gvmi;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_fw_qpc_ts_special {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_qpc_eth eth_qp;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_qpc_ib ib_qp;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_fw_xrqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t num_offloads;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t nsq_log_page_size;
	/* Description -  */
	/* 0x4.8 - 0x4.12 */
	 u_int8_t ncq_log_page_size;
	/* Description -  */
	/* 0x4.16 - 0x4.20 */
	 u_int8_t stg_log_page_size;
	/* Description -  */
	/* 0x4.24 - 0x4.28 */
	 u_int8_t memory_page_size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t tgt_num;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - notice this cq num is 16 bit field */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t send_cq_num;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t ioccsize;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t log_match_list_size;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_hw_msix_context_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_hw_msix_context_data0 regular;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_hw_msix_context_data1 proidx;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_steering_qp_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t qp_number;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t force_responder;
};

/* Description -   */
/* Size in bytes - 52 */
union connectx4lx_entry_data_union {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_shared_data shared;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_data_bulk nop;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_ste_sx_transmit_decoder sx_transmit;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_ste_multiple_decoder rx_steering_multiple;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_ste_inline_decoder rx_steering_inline;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_ste_rss_decoder rx_rss;
	/* Description -  */
	/* 0x0.0 - 0x34.31 */
	 struct connectx4lx_ste_iterator_decoder rx_iterator;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cvlan_to_cqe {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.0 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_vlan_prio {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.28 - 0x18.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_e2e_lack_call_fw {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.27 - 0x18.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_force_ecn {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.26 - 0x18.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cqe_tip_source {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.24 - 0x18.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_force_dscp {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.23 - 0x18.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cntag_enable {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.22 - 0x18.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_can_use_reserved_lkey {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.21 - 0x18.21 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_force_sl {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.20 - 0x18.20 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_sl {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.19 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cntag_flowid {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_link_type_mac {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.31 - 0x1c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_allow_grh_type {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.29 - 0x1c.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_allow_roce_type {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x1c.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cqe_qpn {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cache_alignment_end {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.30 - 0x20.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_max_encapsulation_size {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.28 - 0x20.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_force_cnack {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.27 - 0x20.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_port_number {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.26 - 0x20.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_adaptive_routing {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.25 - 0x20.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_tcu_trap {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.24 - 0x20.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_tcu_drop {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.23 - 0x20.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_dc_access_key_log_num_byte {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.20 - 0x20.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_fast_path {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.19 - 0x20.19 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_mtu {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.16 - 0x20.18 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_read_enable {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.15 - 0x20.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_send_with_invalidate_enable {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.14 - 0x20.14 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_ignore_pkey_check {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.13 - 0x20.13 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_max_message_size {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.8 - 0x20.12 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_inline_scatter {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.6 - 0x20.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_write_enable {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.5 - 0x20.5 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_rnr_timer {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.4 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_atomic_like_write {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.31 - 0x24.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_my_lid {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.24 - 0x24.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_qp_valid {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.23 - 0x24.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_max_read_atomic {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.20 - 0x24.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_flow_label {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.19 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_counter_index {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.24 - 0x28.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_srq_number {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_ts {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.28 - 0x2c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_ipd {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_my_gid_mac_index {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.16 - 0x2c.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_extended_atomic {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.12 - 0x2c.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_pkey_table_index {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.11 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_hop_limit {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.24 - 0x30.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_cq_number {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_tclass {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.24 - 0x34.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_context_number {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_dc_access_key_63_32 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_dct_dc_access_key_31_0 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_fcs_check_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_fcs_scatter {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_cvlan_valid {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_tunnel_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_timer_granularity {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.22 - 0x4.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_tunnel {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.21 - 0x4.21 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rx_strip_cntag {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.20 - 0x4.20 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_cvlan_to_cqe {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.19 - 0x4.19 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_tunnel_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.18 - 0x4.18 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_grh_to_cqe {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.17 - 0x4.17 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_drop_my_self_multicast {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_responder_session_id_23_16 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_responder_session_id_15_0 {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hds_first_segment_empty {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_atomic_like_write {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hds_split_en {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.14 - 0x4.14 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_write_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.14 - 0x4.14 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hds_lookahead_en {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.13 - 0x4.13 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_send_with_invalidate_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.13 - 0x4.13 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_opaque_vld {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.12 - 0x4.12 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_read_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.12 - 0x4.12 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_post_receive_slave_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.11 - 0x4.11 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_fetch_enable {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.10 - 0x4.10 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_no_direct_access {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_ignore_pkey_check {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rx_heartbeat {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_tcu_drop {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_tcu_trap {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rnr_timer {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_qp_valid {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.28 - 0x8.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_fast_path {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_can_use_reserved_lkey {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rwq_type {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_cqe_tip {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_first_non_acked_psn {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_credits_enabled {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_ack_type {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.28 - 0xc.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_sx_heartbeat {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.27 - 0xc.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_coalesce_segment {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_max_read_atomic {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.24 - 0xc.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_max_message_size {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_cvlan {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_expected_psn {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rdb_write_pointer {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_opaque2 {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_opaque1 {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rx_length_committed {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_enable {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.26 - 0x14.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_allow_grh_type {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_allow_roce_type {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_no_wqe_drop_count {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_write_rkey {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_rx_length_committed {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_inline_scatter {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.30 - 0x18.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_connection_state {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.28 - 0x18.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_last_opcode {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.27 - 0x18.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_mtu_byte {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.29 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_sqn {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.26 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rwqe_limit_event {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rdb_read_pointer {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x1c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_opaque3 {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_requestor_session_id {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_tenant_id {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_tcp_sn {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_write_va_63_32 {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_write_va_31_0 {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.16 - 0x28.26 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rcyclic_producer {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_msn {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_ts {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.28 - 0x2c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_context_exist {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.27 - 0x2c.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_extended_atomic {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_lack_call_fw {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.23 - 0x2c.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.20 - 0x2c.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_cntag_enable {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.16 - 0x2c.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.19 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_cntag_flowid {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rwqe_consumer_index {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.16 - 0x30.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rwqe_producer_index {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_rcyclic_consumer {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_counter_index {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.24 - 0x34.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_cq_number {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_dct_gvmi {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_cache_alignment_end {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.30 - 0x38.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_dct_number {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_srq_number {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_hand_shake_done {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.25 - 0x3c.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_dcr_connected {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.24 - 0x3c.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_next_dcr {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_mpi_uar {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_xrc_domain {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_pa_63_34 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.29 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_r_qpc_e2e_pa_33_2 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pf_vf_vpd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NO_DESCR */
	/* 0x0.16 - 0x0.30 */
	 u_int16_t vpd_address;
	/* Description - NO_DESCR */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t F;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - NO_DESCR */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t vpd_data;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pf_vf_sriov {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NO_DESCR */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t vf_enable;
	/* Description - RO */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t vf_migration_en;
	/* Description - RO */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t vf_migration_int_en;
	/* Description - NO_DESCR */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t vf_mse;
	/* Description - NO_DESCR */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t ari_capable_hierarchy;
	/* Description - log value of system page size mask. no need to store more than 1 bit */
	/* 0x0.8 - 0x0.12 */
	 u_int8_t log_system_page_size;
	/* Description - number of vfs in this sr */
	/* 0x0.16 - 0x0.25 */
	 u_int16_t num_vfs;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - just a place holder */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t not_in_use;
};

/* Description -   */
/* Size in bytes - 248 */
struct connectx4lx_lane_const_sd_params_tx_preset_speed {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xf8.31 */
	 struct connectx4lx_sd_params_tx_set set[31];
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_sd_params_rx_set {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t ffe_tap0;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t ffe_tap1;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t ffe_tap2;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ffe_tap3;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t ffe_tap4;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t ffe_tap5;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t ffe_tap6;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t ffe_tap7;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t ffe_tap8;
	/* Description -  */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t lctrl_input;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_sd_params_tx_active_set {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t ob_tap0;
	/* Description -  */
	/* 0x0.7 - 0x0.13 */
	 u_int8_t ob_tap1;
	/* Description -  */
	/* 0x0.14 - 0x0.19 */
	 u_int8_t ob_bias;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t ob_tap2;
	/* Description - 0 - pd1_md0_md2
1 - md1_pd0_pd0
2 - md1_pd0_md2
3 - pd0_pd0_pd0
4 - md4_pd2_md0
5 - pd0_pd0_md2
6 - md0_pd2_pd2
7 - md4_md2_pd0
8 - pd0_md2_md3
9 - pd4_md8_md0
10 - md4_pd0_pd0
11 - pd0_md8_pd0
12-15 - reserved */
	/* 0x4.7 - 0x4.10 */
	 u_int8_t tx_mode;
	/* Description -  */
	/* 0x4.11 - 0x4.15 */
	 u_int8_t ref_txcml100;
	/* Description -  */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t ref_cml100_leva;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t input_eq;
	/* Description -  */
	/* 0x8.4 - 0x8.7 */
	 u_int8_t out_emp;
	/* Description -  */
	/* 0x8.8 - 0x8.9 */
	 u_int8_t rx_amp;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_sd_params_tx_aba_speed {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_sd_params_tx_set set[32];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_local_num_local_lane_and_serdes {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - local port number associated to this module.lane
up to 4 local ports can be routed to single module.
values 1-64
0 - reserved
 */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t local_port;
	/* Description - local port lane associated with this module.lane
0-3 */
	/* 0x0.7 - 0x0.8 */
	 u_int8_t local_lane;
	/* Description - serdes number associated to this module.lane
values 0-143
 */
	/* 0x0.9 - 0x0.16 */
	 u_int8_t serdes;
	/* Description - 0 - there is no polarity 
1 - there is polarity  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t polarity;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pf_array_default_ones {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.31 - 0x8.30 */
	 u_int8_t ix[64];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_nv_wol_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Enable server Wake-on-LAN upon reception of WOL magic packet.
Support for this feature is indicated by the corresponding bit in the Wake 
on LAN Capabilities TL
V */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t en_wol_magic;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_nv_ets_tcN_config_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - See QETCR bw_allocation field. Valid values are 1-100. */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t bw_allocation;
	/* Description - See group in the QETCR register */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t group;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - See max_bw_value in the QETCR register. */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t max_bw_value;
	/* Description - See max_bw_unit in the QETCR register.
0x0: DISABLED - rate lim
it
0x3: HUNDREDS_MBPS - max_bw_value is in 100 Mbps units
 
iter disabled
0x4: GBPS - max_bw_value is in 1 Gbps unit
s */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t max_bw_units;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_subroutines_db_index {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_subroutine subroutine[64];
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_subroutines_db_name {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_subroutine subroutine_errors_count_higher_than_low_thr;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_subroutine subroutine_errors_count_higher_than_mid_thr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_subroutine subroutine_errors_count_lower_than_mid_thr;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_subroutine subroutine_process_errors_count;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_subroutine subroutine_init_bath;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_subroutine subroutine_bath_measure;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_subroutine subroutine_phase_eye_opener;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 struct connectx4lx_subroutine subroutine_grade;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 struct connectx4lx_subroutine subroutine_normalize_rx_set_and_config_to_serdes;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 struct connectx4lx_subroutine subroutine_init_bracketing;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 struct connectx4lx_subroutine subroutine_digital_calibration;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 struct connectx4lx_subroutine subroutine_analog_calibration;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 struct connectx4lx_subroutine subroutine_calibration;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 struct connectx4lx_subroutine subroutine_search_tap_offset1;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 struct connectx4lx_subroutine subroutine_set_tap_offset1;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 struct connectx4lx_subroutine subroutine_process_rx_set;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 struct connectx4lx_subroutine subroutine_search_one_radius_step_per_start_point;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 struct connectx4lx_subroutine subroutine_update_curr_start_point_best;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 struct connectx4lx_subroutine subroutine_copy_curr_best_rx_set_to_shadow;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x50.31 */
	 struct connectx4lx_subroutine subroutine_search_best_set_per_start_point;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x54.31 */
	 struct connectx4lx_subroutine subroutine_copy_curr_start_point_best_to_best;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 struct connectx4lx_subroutine subroutine_zeroing_best;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 struct connectx4lx_subroutine subroutine_update_best;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 struct connectx4lx_subroutine subroutine_copy_rx_set_to_shadow;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x64.31 */
	 struct connectx4lx_subroutine subroutine_voltage_eo_search_mixeroffset1;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x68.31 */
	 struct connectx4lx_subroutine subroutine_space_search;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x6c.31 */
	 struct connectx4lx_subroutine subroutine_similarity_test;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x70.31 */
	 struct connectx4lx_subroutine subroutine_run_grade_validity_and_similarity;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x74.31 */
	 struct connectx4lx_subroutine subroutine_wait;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description -  */
	/* 0x74.0 - 0x78.31 */
	 struct connectx4lx_subroutine subroutine_process_best_rx_set;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 struct connectx4lx_subroutine subroutine_nope;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description -  */
	/* 0x7c.0 - 0x80.31 */
	 struct connectx4lx_subroutine subroutine_static_calibration;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x84.31 */
	 struct connectx4lx_subroutine subroutine_init_search;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x88.31 */
	 struct connectx4lx_subroutine subroutine_write_serdes;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description -  */
	/* 0x88.0 - 0x8c.31 */
	 struct connectx4lx_subroutine subroutine_read_serdes;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description -  */
	/* 0x8c.0 - 0x90.31 */
	 struct connectx4lx_subroutine subroutine_linear_search;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description -  */
	/* 0x90.0 - 0x94.31 */
	 struct connectx4lx_subroutine subroutine_binary_search;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0x98.31 */
	 struct connectx4lx_subroutine subroutine_calibration_and_grade_one_set;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description -  */
	/* 0x98.0 - 0x9c.31 */
	 struct connectx4lx_subroutine subroutine_init_analog_calibration;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description -  */
	/* 0x9c.0 - 0xa0.31 */
	 struct connectx4lx_subroutine subroutine_mixer_calibration;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description -  */
	/* 0xa0.0 - 0xa4.31 */
	 struct connectx4lx_subroutine subroutine_slicer_calibration;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description -  */
	/* 0xa4.0 - 0xa8.31 */
	 struct connectx4lx_subroutine subroutine_update_best_calibration;
/*---------------- DWORD[42] (Offset 0xa8) ----------------*/
	/* Description -  */
	/* 0xa8.0 - 0xac.31 */
	 struct connectx4lx_subroutine subroutine_update_serdes_from_best_calibration;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description -  */
	/* 0xac.0 - 0xb0.31 */
	 struct connectx4lx_subroutine subroutine_read_errors_counter;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description -  */
	/* 0xb0.0 - 0xb4.31 */
	 struct connectx4lx_subroutine subroutine_initiate_ones_ratio;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description -  */
	/* 0xb4.0 - 0xb8.31 */
	 struct connectx4lx_subroutine subroutine_configure_frame_lock_set_calib_to_serdes;
/*---------------- DWORD[46] (Offset 0xb8) ----------------*/
	/* Description -  */
	/* 0xb8.0 - 0xbc.31 */
	 struct connectx4lx_subroutine subroutine_initiate_nondestructive;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description -  */
	/* 0xbc.0 - 0xc0.31 */
	 struct connectx4lx_subroutine subroutine_terminate_nondestructive;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0xc4.31 */
	 struct connectx4lx_subroutine subroutine_powerup_input_buffer1;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc8.31 */
	 struct connectx4lx_subroutine subroutine_powerdown_input_buffer1;
/*---------------- DWORD[50] (Offset 0xc8) ----------------*/
	/* Description -  */
	/* 0xc8.0 - 0xcc.31 */
	 struct connectx4lx_subroutine subroutine_initiate_xor;
/*---------------- DWORD[51] (Offset 0xcc) ----------------*/
	/* Description -  */
	/* 0xcc.0 - 0xd0.31 */
	 struct connectx4lx_subroutine subroutine_align_clkeo_clk00;
/*---------------- DWORD[52] (Offset 0xd0) ----------------*/
	/* Description -  */
	/* 0xd0.0 - 0xd4.31 */
	 struct connectx4lx_subroutine subroutine_calc_best_rx_set_voltage_eo_grade;
/*---------------- DWORD[53] (Offset 0xd4) ----------------*/
	/* Description -  */
	/* 0xd4.0 - 0xd8.31 */
	 struct connectx4lx_subroutine subroutine_switch_lcl_best_with_shadow_set;
/*---------------- DWORD[54] (Offset 0xd8) ----------------*/
	/* Description -  */
	/* 0xd8.0 - 0xdc.31 */
	 struct connectx4lx_subroutine subroutine_calculate_eye;
/*---------------- DWORD[55] (Offset 0xdc) ----------------*/
	/* Description -  */
	/* 0xdc.0 - 0xe0.31 */
	 struct connectx4lx_subroutine subroutine_search_mix90phase_or_mixeroffset1;
/*---------------- DWORD[56] (Offset 0xe0) ----------------*/
	/* Description -  */
	/* 0xe0.0 - 0xe4.31 */
	 struct connectx4lx_subroutine subroutine_phase_eye_opener_for_rs_fec;
/*---------------- DWORD[57] (Offset 0xe4) ----------------*/
	/* Description -  */
	/* 0xe4.0 - 0xe8.31 */
	 struct connectx4lx_subroutine subroutine_phase_eye_opener_from_center;
/*---------------- DWORD[58] (Offset 0xe8) ----------------*/
	/* Description -  */
	/* 0xe8.0 - 0xec.31 */
	 struct connectx4lx_subroutine subroutine_post_am_lock_tune;
/*---------------- DWORD[59] (Offset 0xec) ----------------*/
	/* Description -  */
	/* 0xec.0 - 0xf0.31 */
	 struct connectx4lx_subroutine subroutine_voltage_eye_opener;
/*---------------- DWORD[60] (Offset 0xf0) ----------------*/
	/* Description -  */
	/* 0xf0.0 - 0xf4.31 */
	 struct connectx4lx_subroutine subroutine_copy_dp_sd_to_lm_best_rx_set;
/*---------------- DWORD[61] (Offset 0xf4) ----------------*/
	/* Description -  */
	/* 0xf4.0 - 0xf8.31 */
	 struct connectx4lx_subroutine subroutine_update_link_maintenance_best;
/*---------------- DWORD[62] (Offset 0xf8) ----------------*/
	/* Description -  */
	/* 0xf8.0 - 0xfc.31 */
	 struct connectx4lx_subroutine subroutine_link_maintenance_search;
/*---------------- DWORD[63] (Offset 0xfc) ----------------*/
	/* Description -  */
	/* 0xfc.0 - 0x100.31 */
	 struct connectx4lx_subroutine subroutine_free0;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_phy_profile_ini_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_profile_ini ib;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x18.31 */
	 struct connectx4lx_profile_ini eth;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_fpga_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Next Fpga Caps Field to read */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t state;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - in Bytes */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mailbox_write_offset;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - in Bytes */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t mailbox_write_size;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_fpga_access_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - i2c master handler state */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t state;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_create_lag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t tx_remap_affinity_1;
	/* Description -  */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t tx_remap_affinity_2;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_modify_sq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - syndrom of qp flush */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t qp_flush_syndrom;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_modify_rq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - syndrom of qp flush */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t qp_flush_syndrom;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - low wather mark */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t lwm;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_l2_table {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t hw_rx_ix;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t hw_sx_ix;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_dmfs_ft {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vport_num;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t log_size;
	/* Description - flow level is 0 */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t ft_in_level0;
	/* Description - flow table is the root */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t ft_is_root;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t next_table_id;
	/* Description -  */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t table_miss_mode;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t lag_demux;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t decap_en;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t encap_en;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t table_id;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t table_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rx_head_ix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t sx_head_ix;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_dmfs_fg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vport_num;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t table_id;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t table_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t vst_root_hash_meta_ix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rx_end_ste_ix;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t sx_end_ste_ix;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t rx_root_hash_meta_ix;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t sx_root_hash_meta_ix;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_dmfs_fte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vport_num;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - last flow list item that its ref_count was increased (for rollback) */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t copied_items_cntr;
	/* Description - hierarchy index of the next steering table to be allocated */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t next_hierarchy_to_alloc;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t fte_use_iterator;
	/* Description -  */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t src_port_ext_match_exists;
	/* Description -  */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t modify_flow_list;
	/* Description - fte points to external port */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t external_dest_vport;
	/* Description - fte points to internal port */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t internal_dest_vport;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t uc_match_exists;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t mc_match_exists;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t fte_add_remove_;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t table_id;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t table_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t iterator_ix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t fte_rx_ix;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t fte_sx_ix;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t fte_rx2_ix;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t fte_sx2_ix;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_create_mtt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t mtt_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t num_mtts;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_psv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t num_psv;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t num_alloced_psv;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t pd;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 u_int32_t psv_ix[4];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_mcg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rx_mcg_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sx_mcg_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t gid_msb;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x18.31 */
	 u_int64_t gid_lsb;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t member_count;
	/* Description - The attached QP ulp stateless offload mode */
	/* 0x18.16 - 0x18.17 */
	 u_int8_t ulp;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t iterator_ix;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_sniffer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port_0_1;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_modify_rmp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t bitmask;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t lwm;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_arm_rq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t lwm;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_mkey {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t hw_addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t fw_addr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t octoword_actual_size_mtt;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_modify_cq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t mtt_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t producer_index;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t cqe_128b_size;
	/* Description -  */
	/* 0xc.1 - 0xc.5 */
	 u_int8_t log2_size;
	/* Description -  */
	/* 0xc.6 - 0xc.10 */
	 u_int8_t log_page_size;
	/* Description -  */
	/* 0xc.11 - 0xc.16 */
	 u_int8_t cq_page_offset;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t fence_slice;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t old_sw_eqn;
	/* Description -  */
	/* 0x14.8 - 0x14.8 */
	 u_int8_t modify_fields_c_eqn;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create_cq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t fw_addr;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create_eq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t fw_eqc_addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - has either mtt_ix or PA address */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t mtt_ix_pas;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x18.31 */
	 u_int64_t event_bitmask;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t hw_eqn;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.7 */
	 u_int8_t offset_in_page;
	/* Description -  */
	/* 0x1c.8 - 0x1c.13 */
	 u_int8_t log_page_size;
	/* Description - set to 1 if PA mode, set 0 if MTT mode */
	/* 0x1c.16 - 0x1c.16 */
	 u_int8_t is_pa_mode;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_rqt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rqt_fw_data_ix;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rqt_hw_data_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - base qp_number */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t rss_indirection_table_base_qpn;
	/* Description - defines the size of qp_numbers in the HW rqt */
	/* 0x8.30 - 0x8.31 */
	 u_int8_t rss_qpn_size;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - for rollback */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t num_rqs_to_dec;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t rqt_max_size;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t rqt_actual_size;
	/* Description - only for modify_rqt */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t rqt_actual_size_old;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - only for modify_rqt */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t rqt_fw_data_ix_old;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - only for modify_rqt */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t rqt_hw_data_ix_old;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create_xrq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - mtt offset from the initial ix - we create all xrq buffers mtts together */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t curr_mtt_offset;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t fw_srqn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t tgt_num;
	/* Description - 0- None, 1- tag_matching */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t offload;
	/* Description - 0- None, 1-rndv, 2-NVMf */
	/* 0x8.28 - 0x8.31 */
	 u_int8_t topology;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - nvmf only */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t nvme_sq_mkn;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - nvmf only */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t nvme_cq_mkn;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - nvmf only */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t uapp_data_mkn;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t uapp_ctrl_mkn;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - MUST BE AT OFFSET 0x1c */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t num_nim_indicies_allocated;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create_srq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t fw_addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t srqi;
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t cont_srq;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t pas_offset;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create_rq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t fw_qpc_addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t no_lro_qpn;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - copy of hca_params->log_max_qp */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t log_max_qp;
	/* Description -  */
	/* 0xc.8 - 0xc.11 */
	 u_int8_t wq_type;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_qp_commands {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t fw_qpc_addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t qpi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - copy of hca_params->log_max_qp */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t log_max_qp;
	/* Description -  */
	/* 0xc.5 - 0xc.5 */
	 u_int8_t is_dci;
	/* Description -  */
	/* 0xc.6 - 0xc.6 */
	 u_int8_t is_enhanced_ipoib;
	/* Description -  */
	/* 0xc.7 - 0xc.7 */
	 u_int8_t is_xrq;
	/* Description - 0-none, 1-rendezvous, 2-nvme */
	/* 0xc.8 - 0xc.10 */
	 u_int8_t offload_xrq_type;
	/* Description -  */
	/* 0xc.11 - 0xc.11 */
	 u_int8_t is_tag_matching_xrq;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 union connectx4lx_cmdif_ctx_special_qp_commands_specific specific;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_modify_tis {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t transport_domain;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t underlay_qpn;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_modify_tir {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bitmask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t tir_ste_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t hash_filter_base_ix;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t hash_entries_base_ix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t rqt_number;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t old_rqt_number;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t inline_rqn;
	/* Description -  */
	/* 0x18.24 - 0x18.27 */
	 u_int8_t disp_type;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t transport_domain;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_cmdif_ctx_special_create {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t num_mapped_mtts;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_flush_type_bitmask {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dword;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_flush_type_bits {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t mkey_flush;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t qp_s_flush;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t qp_r_flush;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t rx_flush;
};

/* Description -   */
/* Size in bytes - 96 */
struct connectx4lx_get_oem_ph_host_network_parameters_response {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t host_visible_fw_string_length;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t capabilities;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t oem_cmd;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t payload_version;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t host_mac_byte_3_2;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t host_mac_byte_5_4;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t host_v_mac_byte_5_4;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t host_mac_byte_1_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t host_v_mac_byte_1_0;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t host_v_mac_byte_3_2;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t iscsi_mac_byte_3_2;
	/* Description -  */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t iscsi_mac_byte_5_4;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t iscsi_v_mac_byte_5_4;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t iscsi_mac_byte_1_0;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t iscsi_v_mac_byte_1_0;
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t iscsi_v_mac_byte_3_2;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x60.31 */
	 u_int32_t host_visible_fw_string[16];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lled_oem_hdr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t manufacturer_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t cmd_id;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t payload_version;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_lled_get_ext_cap_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 struct connectx4lx_cap_31_16 cap_31_16;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 struct connectx4lx_dcb_capa dcb_capa;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 struct connectx4lx_cap_15_0 cap_15_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t num_of_vf;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t num_of_pf;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 struct connectx4lx_e_switch_capa e_switch_capa;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 struct connectx4lx_nic_part_capa nic_part_capa;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_lled_get_part_info_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t partition_id;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t num_pf_enabled;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0 LAN
1 iSCSI
2 FCoE
3 RDMA
4 FCFC */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t part_type;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t part_length;
	/* Description - 0..2 Number of personalities configured
3    LAN
4    iSOE
5    FCoE
6    RDMA
7    FC */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t part_status;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Interface name - first dword */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t str_start;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_tlvs;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_lled_set_iscsi_boot_init_config_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_get_iscsi_boot_init_config_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_tlvs;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lled_pt_control_cmd_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t pt_status;
	/* Description -  */
	/* 0x4.9 - 0x4.15 */
	 u_int8_t pt_type;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_lled_set_address_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t length;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t mac_47_24;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.31 */
	 u_int32_t mac_23_0;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lled_set_address_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_lled_get_sup_ver_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t supported_ver;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_lled_get_rdma_stat_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t counters_cleared;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t packets_received_hi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t packets_received_lo;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t packets_transmitted_hi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t packets_transmitted_lo;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t bytes_received_hi;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t bytes_received_lo;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t bytes_transmitted_hi;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t bytes_transmitted_lo;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t transmitted_read_req_pkts_hi;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t transmitted_read_req_pkts_lo;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t transmitted_send_pkts_hi;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t transmitted_send_pkts_lo;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t transmitted_write_pkts_hi;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t transmitted_write_pkts_lo;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t protocol_errors;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t protection_errors;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_lled_get_os_driver_version_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_active_drivers;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_lled_get_temperature_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t curr_temp;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t max_temp;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_lled_get_teaming_info_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t network_teaming_status;
	/* Description -  */
	/* 0x4.1 - 0x4.7 */
	 u_int8_t team_id;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlv;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_lled_get_inventory_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t media_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t ffv_sub_build;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t ffv_build;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t ffv_minor;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t ffv_major;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t fdv_sub_build;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t fdv_build;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t fdv_minor;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t fdv_major;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_get_lldp_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_tlvs;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 56 */
union connectx4lx_lled_get_interface_sensor_resp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_get_interface_sensor_resp_common_fields common_fields;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_lled_get_interface_sensor_resp_sfp sfp;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_lled_get_interface_sensor_resp_qsfp qsfp;
};

/* Description -   */
/* Size in bytes - 104 */
struct connectx4lx_lled_get_interface_info_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t interface_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t data;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_mellanox_aen_control {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t mlx_package_aen_31_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t mlx_channel_aen_31_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t aen_type;
	/* Description -  */
	/* 0x10.8 - 0x10.11 */
	 u_int8_t aen_sel;
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t aen_group;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_temperature_control_data {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t sensor_index;
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t sp;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t temperature_threshold_low;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t temperature_threshold_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t res_mtr;
	/* Description -  */
	/* 0xc.1 - 0xc.1 */
	 u_int8_t ten;
	/* Description -  */
	/* 0xc.2 - 0xc.2 */
	 u_int8_t teg;
	/* Description -  */
	/* 0xc.3 - 0xc.3 */
	 u_int8_t tes;
	/* Description -  */
	/* 0xc.4 - 0xc.4 */
	 u_int8_t tec;
	/* Description -  */
	/* 0xc.5 - 0xc.5 */
	 u_int8_t trt;
	/* Description -  */
	/* 0xc.6 - 0xc.6 */
	 u_int8_t tevnt;
};

/* Description -   */
/* Size in bytes - 136 */
struct connectx4lx_get_flex_filter_data_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t filters_bank;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t data_127_124;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t data_123_120;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t data_119_116;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t data_115_112;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t data_111_108;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t data_107_104;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t data_103_100;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t data_99_96;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t data_95_92;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t data_91_88;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t data_87_84;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t data_83_80;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t data_79_76;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t data_75_72;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t data_71_68;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t data_67_64;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t data_63_60;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t data_59_56;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t data_55_52;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t data_51_48;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t data_47_44;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t data_43_40;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t data_39_36;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t data_35_32;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t data_31_28;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t data_27_24;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t data_23_20;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description -  */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t data_19_16;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t data_15_12;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description -  */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t data_11_8;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t data_7_4;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t data_3_0;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_get_flex_filter_mask_length_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t filters_bank;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t length;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t mask_15_12;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t mask_11_8;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t mask_7_4;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t mask_3_0;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_set_pf_mac_address_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t pf_index;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_get_addresses_groups_count_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Number of PFs on this port */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t groups_count;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_set_port_led_control_resp {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - in seconds */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t beacon_duration;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_get_port_led_control_resp {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - in seconds */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t remaining_beacon_duration;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_mlnx_oem_resp_get_set_addresses {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t group_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t address_tlv;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t address_cnt;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_mlnx_oem_resp_get_temperature {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t sensor_ix;
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t sp;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t curr_temp;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t max_temp;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x14.31 */
	 u_int8_t str[8];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_reset_nic {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t mode;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_get_pf_mac_address_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t pf_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t mac_31_16;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t mac_47_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t rate_limiter;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t mac_15_0;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_get_allocated_management_address_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t host_number;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t status;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t mac_31_16;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t mac_47_32;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t mac_15_0;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_set_mc_affinity_resp {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t host_number;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_mlnx_oem_hdr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t manufacturer_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t parameter;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t cmd_id;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t cmd_rev;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_aen_control_support_field {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t link_status_change_aen;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t configuration_required_aen;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t host_nc_driver_status_change_aen;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t oem_specific_aen;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_multicast_filter_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ipv6_neighbor_advertisement;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t ipv6_router_advertisement;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t dhcpv6_relay_and_server_multicast;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t dhcpv6_multicasts_from_server_to_clients_listening_on_well_known_udp_ports;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t ipv6_mld;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t ipv6_neighbor_solicitation;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_broadcast_filter_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t arp_packets;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t dhcp_client_packets;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t dhcp_server_packets;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t netbios_packets;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_capability_flags {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t hardware_arbitration;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t os_presence;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t net_2_mng_supp;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t mng_2_net_supp;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t all_mc_addresses;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_configuration_flags {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t broadcast_packet_filter_status;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t channel_enabled;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t channel_network_tx_enabled;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t global_multicast_packet_filter_status;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_link_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t autoneg;
	/* Description -  */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t link_speed;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t half_duplex_en;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t full_duplex_en;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t pause_capability;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t asym_pause_capability;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t oem_link_settings_field_valid;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_link_status_field {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t link_flag;
	/* Description -  */
	/* 0x0.1 - 0x0.4 */
	 u_int8_t speed_and_duplex;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t auto_negotiate_flag;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t auto_negotiate_complete;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t parallel_detection_flag;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t link_partner_advertised_1000tfd;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t link_partner_advertised_1000thd;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t link_partner_advertised_100t4;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t link_partner_advertised_100txfd;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t link_partner_advertised_100txhd;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t link_partner_advertised_10tfd;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t link_partner_advertised_10thd;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t tx_flow_control_flag;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t rx_flow_control_flag;
	/* Description -  */
	/* 0x0.18 - 0x0.19 */
	 u_int8_t link_partner_advertised;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t serdes_link;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t oem_link_speed_valid;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_get_oem_ph_host_network_parameters_request {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t oem_cmd;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t payload_version;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_tlvs;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lled_set_iscsi_boot_init_config_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t num_of_tlvs;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t tlvs;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_lled_get_iscsi_boot_init_config_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_lled_get_teaming_info_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lled_get_address_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t address_type;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lled_get_rdma_stat_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_lled_get_os_driver_version_cmd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t partition_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_get_mellanox_aen_control {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t aen_group;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_get_flex_filter_data {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t filters_bank;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_get_flex_filter_mask_length {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t filters_bank;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_set_pf_mac_address {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t pf_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t mac_39_24;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t mac_47_40;
	/* Description -  */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t mac_addr_valid;
	/* Description -  */
	/* 0x8.25 - 0x8.25 */
	 u_int8_t rate_limiter_valid;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t rate_limiter_1;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t mac_7_0;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t mac_23_8;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t rate_limiter_2;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_set_port_led_control {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - in seconds */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t beacon_duration;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_get_port_led_control {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t options;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_mlnx_oem_cmd_set_addresses {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t group_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t address_tlv;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_mlnx_oem_cmd_get_addresses {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t group_ix;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_mlnx_oem_cmd_get_temperature {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t sensor_ix;
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t sp;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_get_pf_mac_address {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t pf_index;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_get_allocated_management_address {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t host_number;
};

/* Description -   */
/* Size in bytes - 60 */
struct connectx4lx_set_mc_affinity {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t host_number;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x3c.31 */
	 struct connectx4lx_affinity info;
};

/* Description -   */
/* Size in bytes - 44 */
union connectx4lx_reg_access_reg_tlv_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_mfpa mfpa;
	/* Description - misc flash activate image */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_mfai mfai;
	/* Description - misc flash reset level */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_mfrl mfrl;
	/* Description - misc temperature */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_mtmp mtmp;
	/* Description - misc_counters */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_register_misc_counters misc_counters;
	/* Description - misc flash block access */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_project_mfba mfba;
	/* Description - misc flash block erase */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_mfbe mfbe;
	/* Description - Secure Firmware Cmd: Management Component Query Status */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_mcqs_reg mcqs;
	/* Description - Secure Firmware Cmd: Management Component Query Information */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_mcqi_reg mcqi;
	/* Description - Secure Firmware Cmd: Management Component Control */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_mcc_reg mcc;
	/* Description - Secure Firmware Cmd: Management Component Data Access */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mcda_reg mcda;
	/* Description - Secure Firmware Cmd: Management Query Information Strings */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mqis_reg mqis;
	/* Description - mjtag - master jtag register */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_mjtag mjtag;
	/* Description - Table 236 - PAOS - Ports Administrative and Operational Status Register Layout */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_paos_reg paos;
	/* Description - Serdes Lane Receive Parameters */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_slrp_reg slrp;
	/* Description - Table 305 - [Internal] SLTP - Serdes Lane Transmit Parameters Register Layout */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_sltp_reg sltp;
	/* Description - Table 309 - PTAS - Phy Tuning Algorithm Settings Register Layout */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_ptas_reg ptas;
	/* Description - Table 307 - SLRG - Serdes Lane Receive Grade Register Layou */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_slrg_reg slrg;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_pptt_reg pptt;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_pprt_reg pprt;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ppaos_reg ppaos;
	/* Description - Table 301 - [Internal] PPAMP - Port Phy opAMP data Register Layout */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_pamp_reg ppamp;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pmtu_reg pmtu;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_project_nvda nvda;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_nv_tlv_hdr nvdi;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_project_nvqc nvqc;
	/* Description - Table 267 NVGC Register Layout */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_project_nvgc nvgc;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_project_nvia nvia;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_project_nvgn nvgn;
	/* Description - Table 291 - PPLR - Port Physical Loopback Register Layout */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_pplr_reg pplr;
	/* Description - Table 297 - PLPC - Phy Link Profiles Control Register Layout */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_plpc_reg plpc;
	/* Description - Table 299 - PPLM - Port Phy Link Mode Register Layout */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_pplm_reg pplm;
	/* Description - Table 303 - PMLP - Port Module to Local Port Register */
	/* 0x0.0 - 0x24.31 */
	 union connectx4lx_pmlp pmlp;
	/* Description - Management Version Time Stamp */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mvts mvts;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_mpein_reg mpein;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_pmcr_reg pmcr;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_pmaos_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Module state (reserved while 
admin_status
 is disabled):
0 - initializing
1 - plugged, enabled
2 - unplugged
3 - module plugged, error (details in 
error_type
).
4 - plugged, disabled */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t oper_status;
	/* Description - Module administrative state (the desired state of the module):
1- enabled
2- disabled by configuration
3- enabled once - if the module is active and then unplugged, the 
operational status should go to "disabled" and can only be enabled 
up upon explicit enable command.
Note: To disable a module, all ports associated with the port must 
be disabled first. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t admin_status;
	/* Description - Module number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Event Generation on operational state change:
00 - Do not generate event
01 - Generate Event 
10 - Generate Single Event */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t e;
	/* Description - Module error details:
0x0 - Power Budget Exceeded
0x1 - Long Range for non MLNX cable/module
0x2 - Bus stuck (I2C Data or clock shorted)
0x3 - bad/ unsupported EEPROM
0x4 - Enforce part number list. 
0x5 - unsupported cable
0x6 - High Temperature
0x7 - bad cable (Module/Cable is shorted)
Valid only when 
oper_status 
= 4'b0011. */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t error_type;
	/* Description - Event update enable. If this bit is set, event generation will be 
updated based on the 
e
 field. Only relevant on Set operations. */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t ee;
	/* Description - Admin state update enable. If this bit is set, admin state will be 
updated based on 
admin_state
 field. Only relevant on Set() opera
tions. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t ase;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_mtppse_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Pin to be configured or queried out of the supported pins. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t pin;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Event generation mode.
0x0: disable - no event is generated.(default mode). 
0x1: repetitive events - generate event on each event regardless 
event arming 
0x2: once till arm - generate a single event and wait for rearming */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t event_generation_mode;
	/* Description - If set, 
a
rm the event mechanism to generate event. 
Valid only for event_gen_mode == once_till_arm. 
Note that by default the event is not armed. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t event_arm;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_mtpps_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Maximum number of pps out pins supported on device. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t cap_max_num_of_pps_out_pins;
	/* Description - Maximum number of pps in pins supported on device. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t cap_max_num_of_pps_in_pins;
	/* Description - Total number of pps pins supported on device. */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t cap_number_of_pps_pins;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Capability of PPS pin # 0
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t cap_pin_0_mode;
	/* Description - Capability of PPS pin # 1
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t cap_pin_1_mode;
	/* Description - Capability of PPS pin # 2
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t cap_pin_2_mode;
	/* Description - Capability of PPS pin # 3
0x0: not_supporting_pps.
0x1
:
 ptp_in 
0x2
:
 ptp_out 
0x3
:
 ptp_in_or_ptp out  */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t cap_pin_3_mode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Capability of PPS pin # 4
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t cap_pin_4_mode;
	/* Description - Capability of PPS pin # 5
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0xc.8 - 0xc.11 */
	 u_int8_t cap_pin_5_mode;
	/* Description - Capability of PPS pin # 6
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0xc.16 - 0xc.19 */
	 u_int8_t cap_pin_6_mode;
	/* Description - Capability of PPS pin # 7
0x0: not_supporting_pps.
0x1: ptp_in 
0x2: ptp_out 
0x3: ptp_in_or_ptp out  */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t cap_pin_7_mode;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Pin to be 
configured or queried out of the supported pins. */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t pin;
	/* Description - Pin mode to be used. The mode must comply with the supported 
modes 
of
 the requested pin.
0x0: pps_in .
0x1
:
 pps_out .
Operation will fail if pin does not support the required mode. */
	/* 0x20.8 - 0x20.11 */
	 u_int8_t pin_mode;
	/* Description - When pin_mode==pps_in:
0x0: Rising edge 
0x1: Falling edge 
When pin_mode==pps_out:
0
x0:
 Pulse (one shot) - the device will generate a pulse with pulse 
duration of out_pulse_duration. The pulse will be generated at 
out_time time 
0x1: 
periodic - the device will generate periodical pulses with 
pulse duration of out_pulse_duration every 1 second according 
to internal clock. The 1st pulse will be generated at out_time time 
Reserved when pin_mode is not equal to ptp_out. */
	/* 0x20.16 - 0x20.19 */
	 u_int8_t pattern;
	/* Description - Enables the PPS functionality the the specific pin.
0x0
:
 
D
isable 
0x1
:
 Enable  */
	/* 0x20.31 - 0x20.31 */
	 u_int8_t enable;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - When pin_mode==pps_in, 
t
he latched device time when it was 
triggered from the external GPIO pin. 
When pin_mode==pps_
out
, 
t
he target time to generate 
next output signal. 
Time is in units of 
device clock
. Device clock frequency 
can be fetched from HCA_CAP.device_frequency */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t time_stamp_hi;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - When pin_mode==pps_in, 
t
he latched device time when it was 
triggered from the external GPIO pin. 
When pin_mode==pps_
out
, 
t
he target time to generate 
next output signal. 
Time is in units of 
device clock
. Device clock frequency 
can be fetched from HCA_CAP.device_frequency */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t time_stamp_lo;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Adjustment of offset from nominal frequency 
 
in units of 
nsec
c. 
Range is from -32768 to +32767 
The hardware does consecutive frequency adjustment 
Reserved when pin_mode != ptp_out */
	/* 0x30.0 - 0x30.15 */
	 u_int16_t out_periodic_adjustment;
	/* Description - Output pulse duration 
in 
u
nits of msec. 
Range is 1 to 1000. 
Reserved when pin_mode 
!=
 ptp_out */
	/* 0x30.16 - 0x30.31 */
	 u_int16_t out_pulse_duration;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fpga_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Status of the last operation.
0x0: Success
0x1: Failure
0x2: In_progress
Valid only for query operation. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t status;
	/* Description - Indicates the control operation to be performed. Allowed only when 
FPGA_CAP.fpga_ctrl_modify==1. 
 See Table 390, "
FPGA_CAP Register 
Layout
," on page 563
.
0x1: LOAD - when set, the FPGA will be forced to reload the image from 
flash according to 
image_select_admin
 value.
0x2: RESET - when set, the FPGA internal logic state (BRAMs, FFs, etc.) 
will be reset to the original state at loading time.
0x3: 
FLASH
_SELECT - when set, map the flash GW according to 
flash
_se
lect_admin
 value.
0x4: 
Sandbox_Bypass_On
 - If set, sandbox logic is inactive until 
Sandbox
_Bypass_Off
 
is set. Packets will skip the sandbox logic.
0x5: 
Sandbox_Bypass_Off - 
If set, sandbox logic is active. Packets will 
be 
processed by 
the sandbox logic. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t operation;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Current 
flash
that 
is 
used to 
l
oad
images 
t
o FPGA.
0x0: Factory_default
0x1: User
Valid only if status is ok. */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t flash_select_oper;
	/* Description - Used to select next 
flash
 to be 
used
to load the images
.
0x0: Factory_default
0x1: User
Valid only for 
FLASH
_SELECT and LOAD operations. */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t flash_select_admin;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_fpga_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - FPGA device type.
0x0: KU040
0x1: KU060 */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t fpga_device;
	/* Description - FPGA identifier.
0x0: unknown
0x1: Newton_X */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t fpga_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Shell registers space file version. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t register_file_ver;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Indicates the MODIFY operation's permissions of FPGA_ACCESS_REG.
0x0: Not_allowed - modify registers by FPGA_ACCESS_REG not allowed.
0x1: All_range_allowed- modify registers by FPGA_ACCESS_REG 
allowed for all addresses. */
	/* 0x8.16 - 0x8.17 */
	 u_int8_t access_reg_modify_mode;
	/* Description - Indicates the QUERY operation's permissions of FPGA_ACCESS_REG.
0x0: Not_allowed - Query registers by FPGA_ACCESS_REG not allowed.
0x1: All_range_allowed- Query registers by FPGA_ACCESS_REG allowed 
for all addresses. */
	/* 0x8.24 - 0x8.25 */
	 u_int8_t access_reg_query_mode;
	/* Description - If set, SW is allowed to modify FPGA_CTRL register. See
 Table 394, 
"
FPGA_CTRL Register Layout
," on page 567 */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t fpga_ctrl_modify;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Image version. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t image_version;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Creation date of current running image.
Format: DDMMYYYY.
For example:
0x12011995 means 12/01/1995 in DD/MM/YY. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t image_date;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Creation time of current running image.
Format: 00HHMMSS.
For example:
0x00015324 means 01:53:24 in HH:MM:SS */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t image_time;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Shell image version. */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t shell_version;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Shell capabilities. */
	/* 0x30.0 - 0x70.31 */
	 struct connectx4lx_fpga_shell_caps shell_caps;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - IEEE Vendor ID of sandbox user.
0x2C9: Mellanox */
	/* 0x70.0 - 0x70.23 */
	 u_int32_t ieee_vendor_id;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - Sandbox product ID.
For Mellanox sandbox products
0x0: unknown
0x
1
:
 example
0x
2
:
 IPsec
0x
3
:
 TLS */
	/* 0x74.0 - 0x74.15 */
	 u_int16_t sandbox_product_id;
	/* Description - Sandbox version. */
	/* 0x74.16 - 0x74.31 */
	 u_int16_t sandbox_product_version;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - Sandbox basic capabilities per sandbox product ID.
For Mellanox sandbox products, see
 Table 347, "
IPsec_Basic_Capabilities 
Structure Layout
," on page 535
. */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t sandbox_basic_caps;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - The length (in DWORDs) of sandbox extended capability (equals 0 when 
such capability is not present). */
	/* 0x7c.0 - 0x7c.15 */
	 u_int16_t sandbox_extended_caps_len;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - Bits [63:32] of the extended capabilities address.;For Mellanox sandbox products See ;Table 335, ";IPSec_extended_ca;pabilities Structure Layout;," on page 550;. */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t sandbox_extended_caps_addr_h;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description - Bits [31:0] of the extended capabilities address. */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t sandbox_extended_caps_addr_l;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description - Start address of DDR */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t fpga_ddr_start_addr_h;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - Start address of DDR */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t fpga_ddr_start_addr_l;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description - Start address of cr-space */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t fpga_cr_space_start_addr_h;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description - Start address of cr-space */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t fpga_cr_space_start_addr_l;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description - Size of DDR in a granularity of 1KB */
	/* 0x98.0 - 0x9c.31 */
	 u_int32_t fpga_ddr_size;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description - Size of cr-space in a granularity of 1KB */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t fpga_cr_space_size;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_fpga_access_reg {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Number of bytes to read/write.
Must be aligned to 4 bytes.
Note that the maximum size supported is 64 bytes. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Bits [63:32] of 64-bit address.
Allowed address depending on the FPGA_CAP.access_reg_query_mode 
and FPGA_CAP.access_reg_modify_mode.
 See Table 390, "
FPGA_CAP 
Register Layout
," on page 563
. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t address_h;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Bits [31:0] of 64-bit address.
Allowed address depending on the FPGA_CAP.access_reg_query_mode 
and FPGA_CAP.access_reg_modify_mode.
 See Table 390, "
FPGA_CAP 
Register Layout
," on page 563 */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t address_l;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - For Query operations, specify the read data from FPGA registers space.
For Write operation, specify the data to be written to FPGA registers space. */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t data[1];
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_pmmp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Module number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Override/ignore EEPROM advertisement properties bitmask: 
Bit 0 - Override cable protocols and technology for QSFP
Bit 1 - Override cable protocols and technology for SFP
Bit 2- Ignore Power Class (set high power)
Bit 3- Override Cable Length 
Bit 4- Override Attenuation */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t eeprom_override;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Valid only when
 the protocols and technology is overridden as indicated by 
eeprom_override
See Table 461, "PMMP - QSFP Protocol Bytes Override Layout," on 
page 623 */
	/* 0x8.0 - 0x14.31 */
	 union connectx4lx_pmmp_qsfp_protocol_override_layout_auto qsfp_cable_protocol_technology;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Valid only when
 the protocols and technology is overridden as indicated by 
eeprom_override
See Table 463, "PMMP - SFP Protocol Bytes Override Layout," on 
page 626 */
	/* 0x14.0 - 0x20.31 */
	 union connectx4lx_pmmp_sfp_protocol_override_layout_auto sfp_cable_protocol_technology;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Length of cable assembly, units of 1 m.
Valid only when
 the cable length is overridden as indicated by 
eeprom_override. */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t cable_length;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Valid only when
 the attenuation is overridden as indicated by 
eeprom_override.
Attenuation - total channel attenuation @ 5GHz in db. */
	/* 0x24.0 - 0x24.7 */
	 u_int8_t attenuation_5g;
	/* Description - Valid only when
 the attenuation is overridden as indicated by 
eeprom_override.
Attenuation - total channel attenuation @ 7GHz in db. */
	/* 0x24.8 - 0x24.15 */
	 u_int8_t attenuation_7g;
	/* Description - Valid only when
 the attenuation is overridden as indicated by 
eeprom_override.
Attenuation - total channel attenuation @ 12GHz in db. */
	/* 0x24.16 - 0x24.23 */
	 u_int8_t attenuation_12g;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Valid only when
 the module identifier is overridden as indicated by 
eeprom_override.
0x3
:
 SFP+
/
SFP28
0xD
:
 QSFP+
0x11
:
 QSFP28 */
	/* 0x28.0 - 0x28.7 */
	 u_int8_t module_identifier;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_pcmr_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
PHY/PCS check disable/enable capability */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t pcs_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
FCS check disable/enable capability
 */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t fcs_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
SHORT FRAME check disable/enable capability */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t sht_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
MTU error - check disable/enable capability (data packet"s actual length 
over mtu_frame_size) */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t mtu_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
FRAME TYPE check disable/enable capability (out-of-range Type-Length 
field) */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t type_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
LENGTH MISMATCH check disable/enable capability (Length in Length
Type is does not match actual payload length) */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t len_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
flow-control packet check disable/enable capability */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t fc_cap;
	/* Description - Specifies the check enable/disable capabilities of the local port. A bit set to 
1 for affirmation of supported enable/disable capability: 
Control packet check disable/enable capability */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t cp_cap;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - PHY/PCS error check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t pcs_chk;
	/* Description - FCS check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t fcs_chk;
	/* Description - SHORT FRAME check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.2 - 0x8.2 */
	 u_int8_t sht_chk;
	/* Description - MTU check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.3 - 0x8.3 */
	 u_int8_t mtu_chk;
	/* Description - FRAME TYPE check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.4 - 0x8.4 */
	 u_int8_t type_chk;
	/* Description - LENGTH MISMATCH check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.5 - 0x8.5 */
	 u_int8_t len_chk;
	/* Description - flow-control packet check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.7 - 0x8.7 */
	 u_int8_t fc_chk;
	/* Description - Control packet check
Values:
0: disable check. 
1: perform check
Note: when disabling a check, it will also affects the relevant counters. */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t cp_chk;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_mcion_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Bit 0 - Present ;\Bit1 - RX_LOS ;\Bit2 - TX_FAULT */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t module_status_bits;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_pddr_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port number access type. determines the way 
local_port
 
is inter
preted:
0 - Local port number
1 - IB / label port number
[Internal] 3 - Out of band / PCI */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - page select index:
0 - Operational info page
1 - Troubleshooting info page
[Internal] 2 - Phy info page
[Internal] 3 - Module info page */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t page_select;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - See Table  605, "Operation info page layout," on page  688
See Table  607, "Phy info page layout," on page  693
See Table  611, "Troubleshooting info page layout," on page  704
See Table  609, "Module info page layout," on page  699 */
	/* 0x8.0 - 0x100.31 */
	 union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto page_data;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_mpcnt_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Performance counter group.
0: PCIE performance counters
 */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t grp;
	/* Description - PCI
e
 index number
Reserved when access is from the host */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t pcie_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Clear counters. Setting the 
clr
 bit will reset the counter value for all 
counters in the counter group. This bit can be set for both Set() and 
Get() operation. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t clr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Counter set as described in
Table 657, "
PCI
e
 Performance Counters Data Layout
," on page 746
[Internal] 
Table 661, "
PCIE lanes counters Data Layout
," on 
page 750
[Internal] 
Table 659, "
PCIE timers and states Data Layout
," on 
page 748 */
	/* 0x8.0 - 0x100.31 */
	 union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto counter_set;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_mcia_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Module Status (added in PRM 0.95)
0h - GOOD
1h - NO_EEPROM_MODULE. No response from modules EPROM.
2h - MODULE_NOT_SUPPORTED. Module type not supported by the device. [Internal] we currently supports all module but who knows.
3h - MODULE_NOT_CONNECTED. No module present indica-tion. [Internal] The below codes are available in current FW. I think is  should be removed.
4h - MODULE_TYPE_INVALID               - if the module is not qsfp or sfp - meaning it doesn't has eeprom by definition (no need to  check the bus as NO_EEPROM_MODULE). Module types comes from ini.                  
5h - MODULE_NOT_ACCESSIABLE     - this is future imple-mented but not tested flow. If a module causing the I2C to hang (while we access its module) the firmware reset the I2C and remem-bers not to access this module until it is unplugged. we should fail access commands for this module.
9h - I2C_ERROR. Error occurred while trying to access the mod-ules EPROM using I2C.
10h - MODULE_DISABLED - module is disabled (using Disable Command). */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t status;
	/* Description - Module number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
	/* Description - Cable Info Lock Page bit */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t l;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t device_address;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t page_number;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t i2c_device_address;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t size;
	/* Description - Password capability */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t passwd_cap;
	/* Description - If set to 1 will force the password to be cleared from the module password field at the end of the module access. */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t passwd_clr;
	/* Description - If set to 1 the Password field is valid and is written to the module password field (address 123-126) before accessing the page. */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t passwd_v;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The password that is written to the module password field. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t password;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x40.31 */
	 u_int32_t dword[12];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ppad_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - If 
single_base_mac
 = 0 - base MAC address, mac[7:0] is 
reserved.
If 
single_base_mac
 = 1 - the per port MAC address */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t mac_47_32;
	/* Description - Port number
Reserved when 
single_base_mac
 = 0 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - 0 - base_mac, 
local_port 
should be 0 and mac[7:0] is 
reserved.HW will set incremental 
1 - single_mac - mac of the 
local_port
Reserved for 
SwitchX/-2. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t single_base_mac;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - If 
single_base_mac
 = 0 - base MAC address, mac[7:0] is 
reserved.
If 
single_base_mac
 = 1 - the per port MAC address */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mac_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_pvlc_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Virtual Lanes supported on this port.
0 - Reserved
1: VL0
2: VL0, VL1
4: VL0 - VL3
8: VL0 - VL7
15: VL0 - VL14 */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t vl_hw_cap;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Virtual Lanes enabled by the local admin on this port.
0: No change; valid only on Set()
1: VL0
2: VL0, VL1
4: VL0 - VL3
8: VL0 - VL7
15: VL0 - VL14 */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t vl_admin;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Operational VLs as configured by the SM on this port:
0: No change; valid only on Set()
1: VL0
2: VL0, VL1
4: VL0 - VL3
8: VL0 - VL7
15: VL0 - VL14
Changing 
vl_operational
 in certain PortStates may cause in flow control 
update errors which may initiate Link/PHY retraining.
vl_operational
 value is valid only when link state is UP. */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t vl_operational;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_ppcnt_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Performance counter group.
Group 63 indicates all groups. Only valid on Set() operation with 
clr
 bit set.
0x0: IEEE 802.3 Counters
0x1: RFC 2863 Counters
0x2: RFC 2819 Counters
0x3: RFC 3635 Counters
0x5: Ethernet Extended Counters
0x6: Ethernet Discard Counters (Switches Only)
0x8: Link Level Retransmission Counters
0x10: Per Priority Counters
0x11: Per Traffic Class Counters
0x11: Per Traffic Class Counters
0x12: Physical Layer Counters
0x13: Per Traffic Class Congestion Counters (Switches Only)
0x14: Correct On Demand Counters
0x15: Per Receive Buffer Counters
0x20 InfiniBand PortCounters */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t grp;
	/* Description - Port number access type:
0 - Local port number
1 - IB port number */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number. 
255 indicates all ports on the device, and is only allowed for Set() operation. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - For HCA
:
 must be always 0.
Switch partition ID to associate port with.
Switch partitions are numbered from 0 to 7 inclusively.
Switch partition 254 indicates stacking ports.
Switch partition 255 indicates all switch partitions.
Only valid on Set() operation with local_port=255. */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t swid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Priority for counter set that support per priority. Traffic class for counter set 
the support per traffic class. Otherwise must be 0. */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t prio_tc;
	/* Description - Clear counters. Setting the 
clr
 bit will reset the counter value for all counters 
in the counter group. This bit can be set for both Set() and Get() operation. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t clr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Counter set as described in:
 See Table 244, "
Ethernet IEEE 802.3 Counters Group Data Layout
," on 
page 397
 See Table 246, "
Ethernet RFC 2863 Counter Group Data Layout
," on 
page 400
 See Table 248, "
Ethernet RFC 2819 Coun
t
er Group Data Layout
," on 
page 402
 See Table 250, "
Ethernet RFC 3635 Counter Group Data Layout
," on 
page 405
 See Table 252, "
Ethernet Extended Counter Group Data Layout
," on 
page 408
 See Table 254, "
Ethernet Per Priority Group Data Layout
," on page 409
 See Table 256, "
Ethernet Per Traffic Cla
s
s Group data layout
," on page 411 */
	/* 0x8.0 - 0x100.31 */
	 union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto counter_set;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_ptys_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Protocol Mask. Indicates which of the protocol data is valid
Bit 0: InfiniBand
Bit 1: FC
Bit 2: Ethernet */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t proto_mask;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - When set, use ABA parameters on TX when in force operation (AN-dis
able or parallel detect) */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t force_tx_aba_param;
	/* Description - Auto Negotiation disable capability:
0 - Device does
 not 
support AN disable
1 - Device Supports AN disable */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t an_disable_cap;
	/* Description - Auto Negotiation disable:
0 - Normal operation 
1 - Disable AN.
Note: When Disabling AN, the "
eth_proto_admin
" bit mask must comply 
to single speed
 rate set. 
 */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t an_disable_admin;
	/* Description - THIS BIT MUST BE TIED TO 
1
!
This is old capability bit that address AN_DISABLE capability with only 
one enabled protocol. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t reserved_high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Port data rate in resolution of 100 Mb/s (
data_rate
_oper * 100 Mb/s)
Value 0x0 indicates this field is not supported. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t data_rate_oper;
	/* Description - Auto Negotiation status: 
0 - Status is unavailable
1 - AN completed successfully 
2 - AN performed but failed
3 - AN was not performed, link is up 
4 - AN was not performed, link is down */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t an_status;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - FC port speed/protocols supported (bitmask)
Bit 3 - 8GFC
Bit 2 - 4GFC
Bit 1 - 2GFC
Bit 0 - 1GFC */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t fc_proto_capability;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Ethernet port speed/protocols supported (bitmask)
Bit 31 - 50GBase-KR2
Bit 30 - 50GBase-CR2
Bit 29 - 25GBase-SR
Bit 28 - 25GBase-KR
Bit 27 - 25GBase-CR
[Internal] Bit 26 - 10GBase-T 
[Internal] Bit 25 - 1000Base-T
[Internal] Bit 24 - 100Base-TX
[Internal] Bit 23 - 100GBase LR4/ER4
Bit 22 - 100GBase KR4
Bit 21 - 100GBase SR4
Bit 20 - 100GBase CR4
Bit 19 - 50GBase-KR4
Bit 18 - 50GBase-SR2
Bit 16 - 40GBase LR4/ER4
Bit 15 - 40GBase SR4
Bit 14 - 10GBase ER/LR
Bit 13 - 10GBase SR
Bit 12 - 10GBase CR
[Internal] Bit 8 - 56GBase *R4
Bit 7 - 40GBase KR4
Bit 6 - 40GBase CR4
[internal] Bit 5 - 20GBase-KR2
Bit 4 - 10GBase KR
Bit 3 - 10GBase KX4
Bit 2 - 10GBase-CX4
Bit 1 - 1000Base KX
Bit 0 - SGMII */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t eth_proto_capability;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - InfiniBand port speed supported (bitmask)
ib_link_speed <= ib_proto_capability[7:0]
Bit 0 - SDR
Bit 1 - DDR
Bit 2 - QDR
Bit 3 - FDR10
Bit 4 - FDR
Bit 5 - EDR
[Internal]Bit 6 - HDR
[Internal]Bit 7 - NDR */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t ib_proto_capability;
	/* Description - ib_link_width <= ib_proto_capability
Bit 0 - 1x
Bit 1 - 2x
Bit 2 - 4x
Bit 3 - 8x
Bit 4 - 12x */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t ib_link_width_capability;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - FC port speed/protocols bitmask */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t fc_proto_admin;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Ethernet port speed/protocols bitmask */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t eth_proto_admin;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - InfiniBand port speed bitmask */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t ib_proto_admin;
	/* Description - InfiniBand port link width bitmask */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t ib_link_width_admin;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - FC port speed/protocols bitmask */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t fc_proto_oper;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Ethernet port speed/protocols bitmask */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t eth_proto_oper;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - InfiniBand port speed bitmask */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t ib_proto_oper;
	/* Description - InfiniBand port link width bitmask */
	/* 0x28.16 - 0x28.31 */
	 u_int16_t ib_link_width_oper;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Ethernet port's link partner advertised protocols. Returns the protocols 
that were advertised by the link partner during auto-negotiation. */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t eth_proto_lp_advertise;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_pmlp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - unmap local port
1 - x1 (lane 0 is used)
2 - x2 (lanes 0,1 are used)
4 - x4 (lanes 0,1,2 and 3 are used)
Other - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t width;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - Use different configuration for RX and TX.
If this bit is cleared, the TX value is used for both RX and TX. When set, 
the RX configuration is taken from the separate field. This is to enable 
backward compatible implementation. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rxtx;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Module SerDes for lane <i>
Up to 4 SerDeses in a module can be mapped to a local port. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t lane0_module_mapping;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Module SerDes for lane <i>
Up to 4 SerDeses in a module can be mapped to a local port. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t lane1_module_mapping;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Module SerDes for lane <i>
Up to 4 SerDeses in a module can be mapped to a local port. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t lane2_module_mapping;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Module SerDes for lane <i>
Up to 4 SerDeses in a module can be mapped to a local port. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t lane3_module_mapping;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_register_mfbe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
	/* Description - erase a 64KB bulk */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t bulk_64kb_erase;
	/* Description - erase a 32KB bulk */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t bulk_32kb_erase;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - address in bytes */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t address;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_register_mfba {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Transaction size */
	/* 0x4.0 - 0x4.8 */
	 u_int16_t size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - address in bytes */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t address;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x2c.31 */
	 struct connectx4lx_register_access_data data;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_register_mfpa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flash Select */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t fs;
	/* Description - Parallel */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t p;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - address in bytes */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t boot_address;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - number of flash devices connected */
	/* 0x10.0 - 0x10.3 */
	 u_int8_t flash_num;
	/* Description - supports 64KB bulk erase operation */
	/* 0x10.29 - 0x10.29 */
	 u_int8_t bulk_64kb_erase_en;
	/* Description - supports 32KB bulk erase operation */
	/* 0x10.30 - 0x10.30 */
	 u_int8_t bulk_32kb_erase_en;
	/* Description - reflection of wip bit from flash */
	/* 0x10.31 - 0x10.31 */
	 u_int8_t wip;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Flash JEDEC ID */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t jedec_id;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Flash sectore size */
	/* 0x18.0 - 0x18.9 */
	 u_int16_t sector_size;
	/* Description -  */
	/* 0x18.16 - 0x18.23 */
	 u_int8_t block_allignment;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - capability mask ;bit 0:Parallel flash Support;else:Reserved  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t capability_mask;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_db_threshold_register_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Required upper watermark.
When FIFO/buffer reaches this size- an event will be sent */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t threshold;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Current FIFO/buffer size */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t size;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_pplr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - external loopback enable (default - disabled) */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t exl;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_host_endianness {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0
:
 LITTLE
_
ENDIAN
1
:
 BIG
_
ENDIAN */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t he;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_fp_sl_map {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - If bit [i] of the register is set, SL[i] is a fast path SL */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t fp_sl_indication;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_power_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - minimum power (maximum latency penalty)
0x1-0xfe - reserved
0xff - maximum power (minimum latency penalty) */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t power_settings_level;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_loopback_control {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 - port 1
2 - port 2
255 - both ports
otherwise - reserved */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port;
	/* Description - When set, the HCA will always send packets meant for the same port to wire, 
rather than perform internal loopback */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t no_lb;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_pfcc_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - S
end to higher layers operation:
0 - Pause and PFC are handled by the port (default)
1 - Pause and PFC are handled by the port and are also been send to 
higher layers.
Only valid if 
shl_cap
 = 1. */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t shl_opr;
	/* Description - S
end to higher layers capabilities:
0 - No capability of sending Pause and PFC to higher layers
1 - Device has capability of send Pause and PFC to higher layers
NOTE: This relates to IEEE 802.3 PAUSE and IEEE 802.3 PFC. */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t shl_cap;
	/* Description - Port number access type. determines the way 
local_port
 
is interpreted:
0 - Local port number
1 - IB / label port number
[Internal] 3 - Out of band / PCI
 */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t pnat;
	/* Description - Local port number. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - Indicates if operation of remote admin parameters (
dcxb_operation_
type
 0x2) is supported. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t cap_remote_admin;
	/* Description - Indicates if operation of local admin parameters (
dcxb_operation_type
 
0x1) is supported. */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t cap_local_admin;
	/* Description - The Operation type, valid only on HCAs.
0x0: local operative parameters.
0x1: local admin parameters. Supported only when 
cap_local_ad
min==1
.
0x2: remote admin parameters. Supported only when 
cap_remote_ad
min==1
.
Only 
pfctx
 and 
pfcrx
 are supported on remote device */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t dcbx_operation_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Bit per prio indicating if RX flow control policy should be updated 
based on bit 
pfcrx
. */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t prio_mask_rx;
	/* Description - Bit per prio indicating if TX flow control policy should be updated 
based on bit 
pfctx
. */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t prio_mask_tx;
	/* Description - Pause policy auto negotiation
0: disabled - generate and ignore pause frames based on pptx, pprx
1: enabled - when auto-negotiation is performed, set the pause policy 
based on the auto-negotiation resolution.
Note - The auto-negotiation advertisement is set according to pptx, 
pprx.
Note - When PFC is set on the TX / RX ppan must be set to 0. */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t ppan;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Credit based flow control policy on TX[7:0]. Per TClass bit mask:
0 - never generate flow control credit frames on the specified TClass 
(default)
1 - generate flow control credit frames according to RX buffer state on 
the specified TClass
pfctx
, 
pptx
 and 
cbftx
 must be mutual exclusive (i.e. only one of them 
at most can be set). */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t cbftx;
	/* Description - Valid only on HCAs.
The bit is set if the device has passed the device_stall_critical_water
mark (for global flow control or any priority when using priority flow 
control) and has become stalled. 
When fctx_disabled is set, the device won't send flow control and pri
ority flow control (PFC) packets. */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t fctx_disabled;
	/* Description - Priority based flow control policy on TX[7:0]. Per priority bit mask:
0 - never generate pause frames on the specified priority (default)
1 - generate pause frames according to RX buffer threshold on the 
specified priority
pfctx
, 
pptx
 must be mutually exclusive (for example, only one of them 
at most can be set). */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t pfctx;
	/* Description - Active (operational) pause policy on TX
0 - do not generate pause frames
1 - generate pause frames according to RX buffer threshold */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t aptx;
	/* Description - Admin pause policy on TX (see also 
pfctx
):
0 - never generate pause frames (default)
1 - generate pause frames according to RX buffer threshold */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t pptx;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Credit based flow control policy in RX[7:0]. Per TClass bit mask:
0 - ignore incoming flow control credit frames on the specified TClass 
(default)
1 - respect flow control credit frames according to RX buffer state on 
the specified TClass */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t cbfrx;
	/* Description - Priority based flow control policy on RX[7:0]. Per priority bit mask:
0 - ignore incoming pause frames on the specified priority (default)
1 - respect incoming pause frames on the specified priority */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t pfcrx;
	/* Description - Active (operational) pause policy on RX
0 - ignore received pause frames
1 - respect received pause frames */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t aprx;
	/* Description - Admin pause policy on RX (see also 
pfcrx
):
0 - ignore received pause frames (default)
1 - respect received pause frames */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t pprx;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Valid only on HCAs (When 
rx_activity 
is set).
The maximum period for a single received packet processing, if the 
packet wasnot processed during this time, the device will be declared 
as stalled and will increase the 
device_stall_critical_watermark_cnt 
(PPCNT) 
counter. Value given in mSec, The maximum period is 8 
sec. 
The special value of 0, indicates that the 
device_stall_critical_water
mark
 is inactive.
Range: 0x0050 - 0x1F40 */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t device_stall_critical_watermark;
	/* Description - Valid only on HCAs (When 
rx_activity 
is set).
The maximum period for a single received packet processing, if the 
packet wasn't processed during this time, the device will increase the 
device_stall_minor_watermark_cnt (PPCNT)
. Value given in mSec, 
The maximum period is 8 sec. 
The special value of 0, indicates that the 
device_stall_minor_water
mark
 is inactive.
Range: 0x0050 - 0x1F40 */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t device_stall_minor_watermark;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_access_register_unit_port_capabilities {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - manually added, for reserved equal zero test */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t reserved_1;
	/* Description - local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
	/* Description - manually added, for reserved equal zero test */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t reserved_0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - sets port info capability mask, specifies the supported capabilities of the node. A bit set to 1 for affirmation of supported capability */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t port_capabilities_127_96;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t port_capabilities_95_64;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t port_capabilities_63_32;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t port_capabilities_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_register_unit_perf_counters_global_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - stop counting in all performance counters
0x1 - start counting in all performance counters 
Otherwise - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t cmd;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_access_register_unit_perf_counters_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_access_register_unit_perf_counters_data_line counter[8];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_access_register_unit_perf_counters_cfg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_access_register_unit_perf_counters_cfg_line counter[8];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_register_set_node {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_node_description node_description;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_dcbx_app_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Physical port number.
This field is reserved when HCA_CAP.num_ports ==1. 
 See Table 739, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 801 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port_number;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.5 */
	 u_int8_t num_app_prio;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Application priority entry. */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_application_prio_entry app_prio[1];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dcbx_param_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The maximum size of DCBX application table. */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t max_application_table_size;
	/* Description - Physical port number.
This field is reserved when HCA_CAP.num_ports ==1. 
 See Table 739, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 801 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port_number;
	/* Description - If set, device supports DCBX on standby mode (aux power). */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t dcbx_standby_cap;
	/* Description - If set, DCBX IEEE version is supported. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t dcbx_ieee_cap;
	/* Description - If set, DCBX CEE version is supported. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t dcbx_cee_cap;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Set the DCBX version.
0x0: disabled- host is in charge 
0x1: CEE - supported only when dcbx_cee_cap==1
0x2: IEEE - supported only when dcbx_ieee_cap==1
0x3: CEE_and_IEEE - CEE and IEEE auto select. When using this mode, 
the device uses IEEE mode. If handshake with other party succeed, it will 
continue on using IEEE, otherwise it will fall back to CEE. Supported only 
when dcbx_cee_cap==1 and cbx_ieee_cap==1. */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t version_admin;
	/* Description - 0x0: disabled - host is in charge.
0x1: CEE_enabled
0x2: IEEE_enabled
If the DCBX_PARAM.version_oper is 0x0, all oper and remote fields in 
DCBX_PARAM () are invalid. DCBX_APPLICATION.num_app_prio is 0
DCBX_PARAM.version is 0x0 until a successful handshake with remote 
party. */
	/* 0x4.8 - 0x4.10 */
	 u_int8_t version_oper;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Number of TCs. */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t num_of_tc_admin;
	/* Description - Number of TCs - operational state after negotiation with remote party
. */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t num_of_tc_oper;
	/* Description - Number of traffic classes that may simultaneously support PFC. Can be set 
in the range 0 8 */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t pfc_cap_admin;
	/* Description - Number of traffic classes that may simultaneously support PFC. Can be set 
in the range 0 8 - operational state after negotiation with remote party. */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t pfc_cap_oper;
	/* Description - 0x0: non
_
w
illing
0x1: willing */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t willing_admin;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Remote side's number of TCs. Valid only after negotiation with remote 
party. */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t remote_num_of_tc;
	/* Description - Remote side's number of traffic classes that may simultaneously support 
PFC. Valid only after negotiation with remote party. */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t remote_pfc_cap;
	/* Description - Remote side's willing state. Valid only after negotiation with remote party */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t remote_willing;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Bitmask indicates errors reported.
Bit 0: not enough TC to comply with remote 
Bit 1: not enough pfc to comply with remote 
Bit 2: TSA unsupported */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t error;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_mlcr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Led type (only supported when cap_local_or_uid_only==1.)
0: LOCALP_AND_UID - local port and uid
1: UID 
2: LOCALP - local port */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t led_type;
	/* Description - If set, led_type of type UID and LOCAL Port only are supported. */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t cap_local_or_uid_only;
	/* Description - Local port number
Not supported for CPU port
(only supported only when cap_local_or_uid_only==1.) */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Duration of the beacon to be active, units of seconds
The value of 0x0 will turn off the beacon
The value of 0xffff will set the beacon to infinity */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t beacon_duration;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Remaining duration of the beacon, units of seconds
The value of 0xffff means infinity */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t beacon_remain;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_qhll {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Local port */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - HLL Timeout value
HLL Timeout = 4.096uSec * 2^
hll_time
Values of 20-31 indicate HLL is disabled */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t hll_time;
	/* Description - B
itmask per TC/VL. When a bit is set, the appropriate TC/VL will 
not be subject to HLL timeout. */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t hll_mask;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Stall count. Number of consecutive HLL discarded packets 
required to enter the Stall-State.
Range 1..7
Reserved when 
stall_en
 = 0 */
	/* 0x8.0 - 0x8.2 */
	 u_int8_t stall_cnt;
	/* Description - Stall state enable
0x0 - Stall state disabled
0x1 - Stall state enabled (default) */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t stall_en;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_qtct_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Priority */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t prio;
	/* Description - Physical port number.
This field is reserved when HCA_CAP.num_ports ==1. 
 See Table 739, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 801 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port_number;
	/* Description - Indicates if operation_type==remote_admin_parameters is supported. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t cap_remote_admin;
	/* Description - Indicates if operation_type==local_admin_parameters is supported */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t cap_local_admin;
	/* Description - Operation type.
0x0: local_operative_parameters
0x1: local_admin_parameters - Supported only when cap_local_admin==1
0x2: remote_admin_parameters- Supported only when cap_remote_ad
min==1 */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t operation_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - TClass used for priority=<prio>.
Default values are: tclass[prio=0]=1, tclass[prio=1]=0, tclass[prio=i]=i (for 
i>1). */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t tclass;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_qpdp_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Physical port number.
This field is reserved when HCA_CAP.num_ports ==1. 
 See Table 739, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 801
. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port_number;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Default port priority (default 0) */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t pprio;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_qetcr_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Physical port number.
This field is reserved when HCA_CAP.num_ports ==1. See 
Table 772, 
"
QUERY_HCA_CAP Input Structure Layout
," on page 851 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t port_number;
	/* Description - Indicates if operation_type==remote_admin_parameters is supported. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t cap_remote_admin;
	/* Description - Indicates if operation_type==local_admin_parameters is supported */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t cap_local_admin;
	/* Description - Operation type.
0x0: local operative parameters.
0x1: local admin parameters. Supported only when cap_local_admin==1.
0x2: remote admin parameters. Supported only when cap_remote_ad
min==1.
 */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t operation_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Per-tclass configuration. For details, 
 See Table 378, "
ETS tcN Configu
ration Register Layout
," on page 581
. */
	/* 0x8.0 - 0x48.31 */
	 struct connectx4lx_tc_qos_configuration tc[8];
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - Global configuration. For details, refer to 
Table 380, "
ETS Global 
Configuration Register Layout
"
. */
	/* 0x48.0 - 0x50.31 */
	 u_int64_t global_configuration;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_pcam_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Access Register ID groups
0 - RegID 0x5000 -
 
0x507F
1-255 - Reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t access_reg_group;
	/* Description - Feature list mask index: 
0 - enhanced features 
1-255 - Reserved */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t feature_group;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Supported port's access register bitmaks. Based on 
access_reg_group 
index.
When bit is set , The register is supported in the device. 
When 
access_reg_group == 0
 :
Bit 0 - 0x5000 
Bit 1 - 0x5001 (
PCAP)
Bit 2 - 0x5002 (PMLP)
Bit 3 - 0x5003 (PMTU)
Bit 4 - 0x5004 (PTYS)
.
,
Bit 127-
 
0x507F (PCAM) */
	/* 0x8.0 - 0x18.31 */
	 u_int32_t port_access_reg_cap_mask[4];
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Supported port's enhanced features. Based on 
feature_group
 
index.
When bit is set , The feature is supported in the device: 
Bit 0 - PPCNT counter group: Phy statistical counter group 
Bit 1 - PPCNT counter group: Discard counter group 
Bit 2:255 - Reserved */
	/* 0x28.0 - 0x38.31 */
	 u_int32_t feature_cap_mask[4];
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_mcam_reg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Access Register ID groups 
0 - Fi REG_ID */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t access_reg_group;
	/* Description - Feature list mask index : 
0 - enfeatures */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t feature_group;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Supmanagement's access register bitmaks.
Based on 
access_reg_group 
index.
 
When bit is set , The register is supported in the device. 
Bit 1 - MFCR (0x9001)
Bit 2 - MFSC (0x9002)
BiFSM (0x9003)
Bit 4 - MFSL (0x9004)
Bit 127- MCAP (0x907F) */
	/* 0x8.0 - 0x18.31 */
	 u_int32_t mng_access_reg_cap_mask[4];
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Supported port's enhanced features.
Based on 
feature_group
 
index.
When bit is set , The feature is supported in the device: 
Bit 0 - 
MPCNT counter group: 
PCIE performance counters supported */
	/* 0x28.0 - 0x38.31 */
	 u_int32_t mng_feature_cap_mask[4];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ib_gid {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 u_int32_t dword[4];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_dmfs_encap_meta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t header_type;
	/* Description -  */
	/* 0x4.6 - 0x4.15 */
	 u_int16_t encap_size;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_flow_counter_fw_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - counts how many FTEs count on this counter */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t src_gvmi;
	/* Description -  */
	/* 0x4.24 - 0x4.30 */
	 u_int8_t ft_type;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t ft_type_valid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t mac;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t next_flow_counter;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t prev_flow_counter;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_l2_table_entry_fw_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_mac_address_layout mac;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - ethernet vlan */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t vlan;
	/* Description - when set to 1, vlan field is valid.
when set to 0, vlan field isn't valid - only mac. */
	/* 0x8.12 - 0x8.12 */
	 u_int8_t vlan_valid;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t hw_rx_ix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t hw_sx_ix;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dmfs_fte_meta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t external_dest_vport;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t internal_dest_vport;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t uc_match_exists;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t mc_match_exists;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t src_port_ext_match_exists;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t fte_use_iterator;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - HW iterator for multiple flow destinations */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t dest_iter_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t vst_dealloc_hash_ix;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t vst_dealloc_ste_ix;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dmfs_ft_meta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  0: INVALID
 1: FT_NIC_TRANSMIT
 2: FT_ESW_EGRESS
 3: FT_ESW_INGRESS
 4: FT_ESW_FDB */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t table_type;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t log2_table_size;
	/* Description - location in table chaining hierarchy
level 0x0 is the root table */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t level;
	/* Description - FT is the root FT */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t ft_is_root;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - total num of flows points to this flow table */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t total_ref_count;
	/* Description - valid only for ESW ingress/egress flow table */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t vport_num;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t prev_ft;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t next_ft;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - first group_id in flow table */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t groups_list_head;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - num of groups member in this flow table */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t groups_member_count;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t ft_rx_head_ix;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t ft_sx_head_ix;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t next_table_id;
	/* Description -  */
	/* 0x20.24 - 0x20.27 */
	 u_int8_t table_miss_mode;
	/* Description -  */
	/* 0x20.29 - 0x20.29 */
	 u_int8_t lag_demux;
	/* Description -  */
	/* 0x20.30 - 0x20.30 */
	 u_int8_t decap_en;
	/* Description -  */
	/* 0x20.31 - 0x20.31 */
	 u_int8_t encap_en;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - total number of FGs that were inserted to RX HW tables */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t fgs_in_rx_hw_count;
	/* Description - total number of FGs that were inserted to SX HW tables */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t fgs_in_sx_hw_count;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dmfs_fg_meta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - counting rules member in group */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  0: INVALID
 1: FT_NIC_TRANSMIT
 2: FT_ESW_EGRESS
 3: FT_ESW_INGRESS
 4: FT_ESW_FDB */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t table_type;
	/* Description -  */
	/* 0x4.8 - 0x4.31 */
	 u_int32_t table_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Bitmask representing which of the headers and parameters in match_criteria are used in defining the Flow */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t match_criteria_enable;
	/* Description - group belongs to RX NIC FT, and include vlan match */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t vlan_match_exist;
	/* Description - group exists in the RX HW steering tables (have at least one FTE) */
	/* 0x8.9 - 0x8.9 */
	 u_int8_t in_rx_hw;
	/* Description - group exists in the SX HW steering tables (have at least one FTE) */
	/* 0x8.10 - 0x8.10 */
	 u_int8_t in_sx_hw;
	/* Description - valid only for ESW ingress/egress flow table */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t vport_num;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t start_flow_index;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t end_flow_index;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t prev_group_id;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t next_group_id;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t vst_root_hash_meta_ix;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t rx_root_hash_meta_ix;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t sx_root_hash_meta_ix;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t rx_end_ste_ix;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t sx_end_ste_ix;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - number of FTEs in the RX FG that aren't used in HW */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t unused_ftes_in_rx_count;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - number of FTEs in the SX FG that aren't used in HW */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t unused_ftes_in_sx_count;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_mkey_dump {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ready_4_dump;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_tis {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Defines the desired TX LAG port number. If 0 the device will assign a proper value */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t lag_tx_port_affinity;
	/* Description - If set, the TIS is not subject to LAG TX port remapping */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t strict_lag_tx_port_affinity;
	/* Description -  */
	/* 0x4.12 - 0x4.15 */
	 u_int8_t prio;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t sqn_head;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t transport_domain;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t underlay_qpn;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_tir {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - valid only for direct tir */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t inline_rqn;
	/* Description - 0 - Direct
1 - Indirect */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t disp_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t lro_max_ip_payload_size;
	/* Description -  */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t lro_enable_mask;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t lro_timeout_period_usecs;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - valid only for indirect tir */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t rqt_number;
	/* Description - 0 - HASH_NONE
1 - HASH_INVERTED_XOR8
2 - HASH_TOEPLITZ */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t rx_hash_fn;
	/* Description -  */
	/* 0xc.28 - 0xc.28 */
	 u_int8_t tunneled_offload_en;
	/* Description -  */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t rx_hash_symmetric;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t steering_start_pipe;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - This field sets which outer or the only packets headers fields should be */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_rx_hash_field_select rx_hash_field_selector_outer;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - This field sets which outer or the only packets headers fields should be */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_rx_hash_field_select rx_hash_field_selector_inner;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t transport_domain;
	/* Description -  */
	/* 0x18.24 - 0x18.25 */
	 u_int8_t self_lb_block;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 struct connectx4lx_tir_dmfs dmfs;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_qpc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - shared between fw_qpc_special unions, must move together! 
Transport Service Type:
0x0 - RC
0x1 - UC
0x2 - UD
0x3 - XRC
0x4 - MLX
0x5 - DCI/DCI
0x6 - DCT
0x7 - QP0
0x8 - QP1
0x9 - Raw Ethernet
0xA - Raw IPv6
0xB - Sniffer
0xC - SYNC_UMR
0xD - PTP1588
other: reserved
Note: QPs of types QP0 and QP1 have the same properties as UD QP. There can be at most one for each type per port
QPs of types Raw Ethernet, Raw IPv6, Sniffer and PTP1588 have the same properties as MLX QP. There can be at most one for each type per port
QP of types SYNC_UMR have the same properties as UD QP. There can be at most one such QP per device */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t sw_st;
	/* Description -  */
	/* 0x4.8 - 0x4.10 */
	 u_int8_t sw_rwq_type;
	/* Description -  */
	/* 0x4.11 - 0x4.11 */
	 u_int8_t no_sq;
	/* Description -  */
	/* 0x4.12 - 0x4.13 */
	 u_int8_t sw_rq_type;
	/* Description -  */
	/* 0x4.14 - 0x4.14 */
	 u_int8_t qp_dual_write;
	/* Description -  */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t ack_fence_req;
	/* Description - in nak flow, qp flush will wait till nak2ack slice is done */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t ack_slice_to_fence;
	/* Description -  */
	/* 0x4.24 - 0x4.26 */
	 u_int8_t min_wqe_inline_mode;
	/* Description - If Set, posting multi packet send wqes are allowed on this SQ */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t allow_multi_pkt_send_wqe;
	/* Description - xrq offload is nvme */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t is_connected_to_nvme_xrq;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - original timer value requested by SW */
	/* 0x8.0 - 0x8.4 */
	 u_int8_t sw_timer_granularity;
	/* Description -  */
	/* 0x8.5 - 0x8.9 */
	 u_int8_t current_timer_granularity;
	/* Description -  */
	/* 0x8.10 - 0x8.10 */
	 u_int8_t one_side_flush;
	/* Description - APM - automatic path migration - path validation failed
send EVENT_TYPE_PATH_MIG_FAIL only once per migration cycle */
	/* 0x8.11 - 0x8.11 */
	 u_int8_t apm_path_validation_failed;
	/* Description -  */
	/* 0x8.12 - 0x8.12 */
	 u_int8_t cd_slave_send;
	/* Description -  */
	/* 0x8.13 - 0x8.13 */
	 u_int8_t cd_slave_receive;
	/* Description -  */
	/* 0x8.14 - 0x8.14 */
	 u_int8_t cd_master;
	/* Description -  */
	/* 0x8.15 - 0x8.15 */
	 u_int8_t sqd_on_sigerr;
	/* Description -  */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t sl_diff_new_sl;
	/* Description - original max read atomic */
	/* 0x8.20 - 0x8.22 */
	 u_int8_t fw_max_read_atomic;
	/* Description - sw or fw ownership of the cq */
	/* 0x8.23 - 0x8.23 */
	 u_int8_t hca_sq_owner;
	/* Description - indicate command is waiting. indicate the slot num. */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t cmdif_entry_ix;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 union connectx4lx_fw_qpc_ts_special fw_qpc_ts_special;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_fw_qpc_q responder;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x30.31 */
	 struct connectx4lx_fw_qpc_q requestor;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 union connectx4lx_fw_qpc_special fw_qpc_special;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_srqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t catas_event_generated;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t basic_cyclic_rcv_wqe;
	/* Description -  */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t invalid_user_index;
	/* Description -  */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t end_padding_mode;
	/* Description - bit per reason.
0x0 - reserved
0x1 - SET LIMIT */
	/* 0x4.12 - 0x4.15 */
	 u_int8_t trap_reason;
	/* Description - (fw_trap_reason = SET_LIMIT) -> limit value */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t trap_data;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - valid for memory_rq (non connector_rq) */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t no_lro_qpn;
	/* Description - valid for eth memory_rq only */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t memory_rq_state;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - valid for xrq only */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_fw_xrqc xrq;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_sw_ads {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Index to pkey table
Reserved for RoCE.
For RoCE index 0, which contains the default PKEY: 
0xFFFF, is chosen automatically */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t pkey_index;
	/* Description - When set, packets sent using this QP are marked for free 
adaptive routing. On IB wire, it is marked in LRH and BTH.
For RoCE, it is marked in BTH. Supported only for UD and 
UC transports. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t free_ar;
	/* Description - Force loopback */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t fl;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Remote LID.
Reserved when fl==1.
Reserved for RoCE. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t rlid;
	/* Description - LMC bits of LID 
Reserved for RoCE. */
	/* 0x4.16 - 0x4.22 */
	 u_int8_t mlid;
	/* Description - Use GRH
For InfiniBand, if set, GRH will be placed in the packet 
header, if clear, no GRH.
Reserved for RoCE. */
	/* 0x4.23 - 0x4.23 */
	 u_int8_t grh;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - For IB and RoCE version 1.0: GRH Hop Limit.
For RRoCE: IPv6 hop limit or IPv4 TTL */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t hop_limit;
	/* Description - Maximum static rate control.
0: no_limit - no limit on static rate (100% port speed)
1-6: reserved
7: Gbps_2.5
8: Gbps_10
9: Gbps_30
10: Gbps_5
11: Gbps_20
12: Gbps_40
13: Gbps_60
14: Gbps_80
15: Gbps_120 */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t stat_rate;
	/* Description - Retry Timeout Multiplier. ACK timeout will be multiplied 
by 2^
log_rtm
 every consecutive retry. See 
"
Exponential 
Backoff Timer
" */
	/* 0x8.12 - 0x8.15 */
	 u_int8_t log_rtm;
	/* Description - For InfiniBand: Index to Address Table in the port to get 
source GID address.
For RoCE: index to Address table to get the source GID/IP 
and MAC address, VLAN ID, IP Type (IPV4, IPv6) and 
RoCE type. */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t src_addr_index;
	/* Description - Ack timeout timer for activation of retransmission mecha
nism. If zero - timeout is disabled. timeout is 4.096 uS 
*2^(ack_timeout)/ */
	/* 0x8.27 - 0x8.31 */
	 u_int8_t ack_timeout;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - IPv6 Flow Label */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t flow_label;
	/* Description - For InfiniBand and RoCE v1.0: GRH TClass */
	/* 0xc.20 - 0xc.27 */
	 u_int8_t tclass;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Remote GID/IP address.
For IB port - Valid if the GRH bit is set.
For an Ethernet port for RoCE mode, this field must always 
be valid and contain the remote GID address.
For an Ethernet port for R-RoCE mode, this field contains 
IPv4 or IPv6 depending on the IP type which appears in 
RoCE Address table entry pointed by src_addr_index field: 
for IP type == IPV4 then rgid/rip bits [31:0] specify the 
remote IPv4 address and rgid/rip bits [127:32] are reserved, 
when L3 header type == IPV6 rgid/rip bits [127:0] contains 
an IPv6 address. */
	/* 0x10.24 - 0x20.23 */
	 u_int8_t rgid_rip[16];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - For R-RoCE v2.0 RC/UC QPs: UDP source port.
must belong to the range: [QUERY_HCA_CAP. r_roce_ud
p_src_port_range_min-QUERY_HCA_CAP. r_roce_udp_s
rc_port_range_max]. 
 See Section 743, "
HCA Capabilities 
Layout
," on page 804 */
	/* 0x20.0 - 0x20.15 */
	 u_int16_t udp_sport;
	/* Description - For R-RoCE: IP DSCP
This field is reserved when QP supports only RoCE v1.0. */
	/* 0x20.16 - 0x20.21 */
	 u_int8_t dscp;
	/* Description - For R-RoCE: IP ECN 
This field is reserved when QP supports only RoCE v1.0. */
	/* 0x20.22 - 0x20.23 */
	 u_int8_t ecn;
	/* Description - Force Ethernet user priority for UD/DC RoCE QPs.
When set take Ethernet priority from QP"s Address Path and 
not from send WQE.
Note: When f_eth_prio is enabled but send WQE points to 
RoCE Address Table entry with vlan_valid disabled, priority 
tagged frame is created and Ethernet priority and DEI/CFI 
fields are taken from QP"s Address Path. */
	/* 0x20.24 - 0x20.24 */
	 u_int8_t f_eth_prio;
	/* Description - Force IP ECN only for UD/DC RoCE QPs.
Take IP ECN field from QPC and not from send WQE.
When QP can generate only RoCE v.1 packets this field is 
reserved. */
	/* 0x20.26 - 0x20.26 */
	 u_int8_t f_ecn;
	/* Description - Force IP DSCP for UD/DC QPs.
Take IPv4/IPv6 DSCP field from QPC and not from send 
WQE.
When QP can generate only RoCE v.1 packets this field is 
reserved. */
	/* 0x20.27 - 0x20.27 */
	 u_int8_t f_dscp;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Upper bits of remote MAC address.
Valid only for RoCE QPs. */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t rmac_47_32;
	/* Description - port number */
	/* 0x24.16 - 0x24.23 */
	 u_int8_t port;
	/* Description - InfiniBand: Service Level (SL) */
	/* 0x24.24 - 0x24.27 */
	 u_int8_t sl;
	/* Description - Ethernet Priority (PCP).
Reserved for InfiniBand. */
	/* 0x24.28 - 0x24.30 */
	 u_int8_t eth_prio;
	/* Description - DEI/CFI field.
For UD/DCI QP, DEI/CFI
,
 field is taken from UD Address 
Vector of the send WQE with the following exception:
when f_eth_prio is enabled and send WQE points to RoCE 
Address Table entry with vlan_valid disabled. priority 
tagged frame is created and DEI/CFI is taken from QP"s 
Address Path.
Reserved for InfiniBand and for RoCE UD/DCI QP with 
AP.f_eth_prio disabled. */
	/* 0x24.31 - 0x24.31 */
	 u_int8_t dei_cfi_reserved_from_prm_041;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Lower bits of remote MAC address.
Valid only for RoCE QPs. */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t rmac_31_0;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_gid_mac_l2_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t my_mac_47_32;
	/* Description -  */
	/* 0x0.16 - 0x0.27 */
	 u_int16_t vlan_id;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t sx_insert_vlan;
	/* Description -  */
	/* 0x0.29 - 0x0.31 */
	 u_int8_t rx_allow_vlan;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t my_mac_31_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.2 */
	 u_int8_t roce_type;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_msix_ext_context {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t mask_3_0;
	/* Description -  */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t disable_3_0;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t need;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t timestamp_51_32;
	/* Description -  */
	/* 0x8.20 - 0x8.31 */
	 u_int16_t min_wait;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t timestamp_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_msix_context {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.2 - 0x0.31 */
	 u_int32_t addr_31_2_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t addr_63_32_;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 union connectx4lx_hw_msix_context_data data;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t spec_mask;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_rdb_atomic_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 u_int32_t atomic_data[8];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_hw_mtt2 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t hi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t lo;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_hw_mtt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t pas_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t rd_en;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t wr_en;
	/* Description -  */
	/* 0x4.3 - 0x4.31 */
	 u_int32_t pas_31_3;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_steering_qp_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry3;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry4;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry5;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry6;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry7;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry8;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry9;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry10;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry11;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry12;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry13;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry14;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 struct connectx4lx_steering_qp_entry steering_qp_entry15;
};

/* Description -  Shomron final format */
/* Size in bytes - 64 */
struct connectx4lx_hw_ste {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t byte_mask;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t entry_sub_type;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t entry_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t next_table_base_size_39_32;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t next_lu_type;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t next_table_base_63_48;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t next_table_rank;
	/* Description -  */
	/* 0x8.4 - 0x8.4 */
	 u_int8_t linear_hash_enable;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x8.5 - 0x8.31 */
	 u_int32_t next_table_base_size_31_5;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x40.31 */
	 union connectx4lx_entry_data_union data;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_hw_timer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - time to wait before timeout (see qpc MAS) */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t timer_granularity;
	/* Description - state of timer (see qpc mas) */
	/* 0x0.5 - 0x0.6 */
	 u_int8_t timer_state;
	/* Description - timer is valid */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t timer_valid;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_requestor_in_sq {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_responder_in_sq {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_scheduling_interrupt_requestor {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_scheduling_interrupt_responder {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_doorbell_int {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_fast_path {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_external_db_en {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_valid {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_sq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_swqe_producer_index {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sxdc_uar {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_dct {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_dc_access_key_31_0 dc_access_key_31_0;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_dc_access_key_63_32 dc_access_key_63_32;
	/* Description - except for DCR this is MyQPN in the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_context_number context_number;
	/* Description - IPv4 this holds the TOS */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_tclass tclass;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cq_number cq_number;
	/* Description - Number of hops between subnets a packet can make before being discarded Used by RX for CNP with GRH in connected mode */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_hop_limit hop_limit;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_pkey_table_index pkey_table_index;
	/* Description - in the below description the size relates to the operands size (meaning: size of each operand) 0: disable atomic 1: IB spec (responder extended RDB is N/A) all enum from here support extended atomic in addition 2: only 8B (hermon mode, responder extended RDB is N/A) 3: up to 8B (also 4B, responder extended RDB is N/A) 4: up to 16B (responder extended RDB is N/A) 5: up to 32B (responder extended RDB is N/A) 6: up to 64B (responder extended RDB is 64B) 7: up to 128B (responder extended RDB is 128B) 8: up to 256B (responder extended RDB is 256B) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_extended_atomic extended_atomic;
	/* Description - access ICM with {GVMI, my_gid_index} to get L2 and L3: {ROCE type, MAC, VLAN, IP/GRH} */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_my_gid_mac_index my_gid_mac_index;
	/* Description - Congestion: Inter Packet Delay, a pointer to a table containing the qp rate */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_ipd ipd;
	/* Description - Transport service (0-7: same as packet.BTH.opcode[7:5]) 0-RC 1-UC 2-RD 3-UD 5-XRC (SRC in hermon) 8-ETHoIB (driver is ETHoIB) 9-IPoIB (driver is IPoIB) 11-DCI/DCR 12-DCT 14-ETH (Hermon name: L2, if l2_type&lt;=1 this is ETHoIB encapsulation) 15-IBL2 (Hermon name: MLX, Golan name: L2) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_ts ts;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_srq_number srq_number;
	/* Description - index to the counters table 0-disable */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_counter_index counter_index;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_flow_label flow_label;
	/* Description - 2^this value=max number of atomic/rdma reads Hermon: max_rdma_atomic */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_max_read_atomic max_read_atomic;
	/* Description - TODO: make sure valid bit sits at bit 511 for all contexts */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_qp_valid qp_valid;
	/* Description - LSB of my LID, should be merged with MSB according to LMC */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_my_lid my_lid;
	/* Description - RDMA write coming to this QP will enter the atomic lock mechanism to ensure PCI atomicity */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_atomic_like_write atomic_like_write;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_rnr_timer rnr_timer;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_write_enable write_enable;
	/* Description - 0: disable - data will always be scattered accoding to the scatter entry 1: up to 32B - if payload&lt;=32B, data should be scattered into the CQE (inline) 2: up to 64B - if payload&lt;=64B, data should be scattered into the CQE (inline) Hermon: disable_inline_scatter */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_inline_scatter inline_scatter;
	/* Description - 2^thisValue is the max number of bytes per mesaage */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_max_message_size max_message_size;
	/* Description - TODO: should be valid only on UD */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_ignore_pkey_check ignore_pkey_check;
	/* Description - When set send and invalidate is allowed on this Qp (like AWR bits) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_send_with_invalidate_enable send_with_invalidate_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_read_enable read_enable;
	/* Description - max transfer unit: 0: 256 bytes   1: 512 bytes   2: 1K bytes  3: 2K bytes  4: 4k bytes 5: 8k bytes */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_mtu mtu;
	/* Description - This QP should use the fast_path inside the device */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_fast_path fast_path;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_dc_access_key_log_num_byte dc_access_key_log_num_byte;
	/* Description - TODO: merge with tcu_trap to a 2 bit field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_tcu_drop tcu_drop;
	/* Description - interrupt FW when packet arrives to tcu on this Qp Hermon: tcu_int */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_tcu_trap tcu_trap;
	/* Description - mark packets as eligible for adaptive routing */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_adaptive_routing adaptive_routing;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_port_number port_number;
	/* Description - all connect request will get connection NACK */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_force_cnack force_cnack;
	/* Description - max number of bytes that may encapsulate the packet, in 64B's must be 0 for ts!=ETH, since we don't support it for different TS's */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_max_encapsulation_size max_encapsulation_size;
	/* Description - When RX scatters a send toward memory, it will do cache alignment padding at end of packet: 0-disable 1-padding is allowed only inside the scatter entry 2-if (SE.padding_start=1) padding is allowed even exceeding the scatter entry     else padding is allowed only inside the scatter entry */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cache_alignment_end cache_alignment_end;
	/* Description - This field will be copied into CQE.QPN in DC this field should be taken from DCT, DCR field is invalid */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cqe_qpn cqe_qpn;
	/* Description - allowed bit mask for gid_mac_table.roce_type */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_allow_roce_type allow_roce_type;
	/* Description - bit[1] allow grh bit[0] allow local route */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_allow_grh_type allow_grh_type;
	/* Description - 1: link is MAC 0: link is IB Hermon name: port_mac */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_link_type_mac link_type_mac;
	/* Description - In ROCE this is field is valid only when cntag_enable=1 and will hold the cntag.flowid field in R-ROCE this holds the congestion flowid (does not exist in the packet) TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cntag_flowid cntag_flowid;
	/* Description - holds QoS ServiceLevel (should match the SQ.SL) in link_type_mac=0 holds the LRH.SL */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_sl sl;
	/* Description - link_type_mac=0 (IB): LRH.SL is taken from QP.SL and not from WQE link_type_mac=1 (ETH): replace the packet's vlan prio with QP.vlan_prio field, or add prio tagged for untagged packets */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_force_sl force_sl;
	/* Description - Used for translation and key check (TPT) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_can_use_reserved_lkey can_use_reserved_lkey;
	/* Description - insert cntag to the packet TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cntag_enable cntag_enable;
	/* Description - ROCE over GRH: never force ROCE over IP/ETH: force IP.DSCP with QPC.tclass[7:2] XoIB: force IP.DSCP with QPC.dscp in the internal packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_force_dscp force_dscp;
	/* Description - cqe.TIP field will be set according to: 0: from steering 1: QP.cqe_qpn 3: QPN */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cqe_tip_source cqe_tip_source;
	/* Description - ROCE over GRH (never force) ROCE over IP/ETH: force IP.ECN with QPC.tclass[1:0] XoIB: force IP.ECN with QPC.dscp in the internal packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_force_ecn force_ecn;
	/* Description - when there are no e2e credits: 1: call FW 0: drop the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_e2e_lack_call_fw e2e_lack_call_fw;
	/* Description - {VLAN.prio[3:1], CFI\DEI} */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_vlan_prio vlan_prio;
	/* Description - When set the CVLAN will be sent to CQE, and removed from packet used for Private VLAN implementation */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_dct_cvlan_to_cqe cvlan_to_cqe;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_r_qpc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - e2e credits pysical address, bits[63:2] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_pa_33_2 e2e_pa_33_2;
	/* Description - e2e credits pysical address, bits[63:2] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_pa_63_34 e2e_pa_63_34;
	/* Description - Hermon: srcd */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_xrc_domain xrc_domain;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_mpi_uar mpi_uar;
	/* Description - when equal 0xffffff: next DCR does not exist, end of list */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_next_dcr next_dcr;
	/* Description - 1: dcr is connected 0: dcr is free */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_dcr_connected dcr_connected;
	/* Description - a packet was received on this connection with responder session id */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hand_shake_done hand_shake_done;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_srq_number srq_number;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_dct_number dct_number;
	/* Description - When RX scatters a send toward memory, it will do cache alignment padding at end of packet: 0-disable 1-padding is allowed only inside the scatter entry 2-if (SE.padding_start=1) padding is allowed even exceeding the scatter entry     else padding is allowed only inside the scatter entry */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_cache_alignment_end cache_alignment_end;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_dct_gvmi dct_gvmi;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_cq_number cq_number;
	/* Description - index to the counters table 0-disable */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_counter_index counter_index;
	/* Description - in granularity of 2^rcyclic_stride */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rcyclic_consumer rcyclic_consumer;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rwqe_producer_index rwqe_producer_index;
	/* Description - index to next free wqe rwq_type=SRQ: copy index from SRQ on packet first */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rwqe_consumer_index rwqe_consumer_index;
	/* Description - In ROCE this is field is valid only when cntag_enable=1 and will hold the cntag.flowid field in R-ROCE this holds the congestion flowid (does not exist in the packet) TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_cntag_flowid cntag_flowid;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label lro_ipv6_flow_label;
	/* Description - insert cntag to the packet TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_cntag_enable cntag_enable;
	/* Description - log2 of the minimal header size in DWORDS */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size hds_log2_lookahead_size;
	/* Description - when there are no e2e credits: 1: call FW 0: drop the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_lack_call_fw e2e_lack_call_fw;
	/* Description - in the below description the size relates to the operands size (meaning: size of each operand) 0: disable atomic 1: IB spec (responder extended RDB is N/A) all enum from here support extended atomic in addition 2: only 8B (hermon mode, responder extended RDB is N/A) 3: up to 8B (also 4B, responder extended RDB is N/A) 4: up to 16B (responder extended RDB is N/A) 5: up to 32B (responder extended RDB is N/A) 6: up to 64B (responder extended RDB is 64B) 7: up to 128B (responder extended RDB is 128B) 8: up to 256B (responder extended RDB is 256B) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_extended_atomic extended_atomic;
	/* Description - log2 of the header buffer size in DWORDS hermon name: log2_hdr_buf_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size hds_log2_header_buf_size;
	/* Description - When this bit is set RXT need to read the lro_context TODO: delete this bit on next project, see bug 193459 */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_context_exist lro_context_exist;
	/* Description - Transport service (0-7: same as packet.BTH.opcode[7:5]) 0-RC 1-UC 2-RD 3-UD 5-XRC (SRC in hermon) 8-ETHoIB (driver is ETHoIB) 9-IPoIB (driver is IPoIB) 11-DCI/DCR 12-DCT 14-ETH (Hermon name: L2, if l2_type&lt;=1 this is ETHoIB encapsulation) 15-IBL2 (Hermon name: MLX, Golan name: L2) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_ts ts;
	/* Description - Indicates which MSN was done */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_msn msn;
	/* Description - in granularity of 2^rcyclic_stride */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rcyclic_producer rcyclic_producer;
	/* Description - copy index from SRQ on packet first holds the first stride_index of the current WQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index rwqe_consumer_stride_index;
	/* Description - set on LRO session open: holds the number of strides in the WQE for the current session */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride lro_rwqe_max_stride;
	/* Description - virtual address of write being processed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_write_va_31_0 write_va_31_0;
	/* Description - virtual address of write being processed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_write_va_63_32 write_va_63_32;
	/* Description - expected tcp.sn */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_tcp_sn lro_tcp_sn;
	/* Description - NVGRE -VNI VXLAN - TNI GGRE - GRE KEY */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_tenant_id lro_tenant_id;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_requestor_session_id requestor_session_id;
	/* Description - part of GGRE spec */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_opaque3 lro_opaque3;
	/* Description - l2 tunnel, outer source IP, bits[63:32] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 lro_outer_sip_63_32;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rdb_read_pointer rdb_read_pointer;
	/* Description - E2E Limit on  TCU: exception if descriptor is required and Number_of_E2E_credits=RQ/SRQ.rwqe_limit_event */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rwqe_limit_event rwqe_limit_event;
	/* Description - SQ number TODO: we can remove the "I", and add qualifier: "ts!=DCR", in DC always connect from SL,GVMI context. can we delete this field alltogether? */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_sqn sqn;
	/* Description - Payload mtu in bytes Used in ETHoIB and IPoIB comparing IB payload including insertions, and "TS=ETH with port_type=IB" */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_mtu_byte mtu_byte;
	/* Description - last opcode was: 0-write 1-send */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_last_opcode last_opcode;
	/* Description - Controls handling of packets with correct and incorrect PSN and opcode sequences 0: Unconnected - QPC ePSN and opcode sequence are invalid 1:Connected (good flow) - QPC.ePSN and correct opcode sequence are forwarded; everything else triggers FW 2: Resync xxtate QPC.ePSN and correct opcode sequence will cause HW to move QPC to Connected state; everything else is dropped 3: Closed - everything is dropped in RXT HW writes to this field in RNR-nack flow */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_connection_state connection_state;
	/* Description - 0: disable - data will always be scattered accoding to the scatter entry 1: up to 32B - if payload&lt;=32B, data should be scattered into the CQE (inline) 2: up to 64B - if payload&lt;=64B, data should be scattered into the CQE (inline) Hermon: disable_inline_scatter */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_inline_scatter inline_scatter;
	/* Description - How many TCP payload bytes received in current message 0-not inside a message */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_rx_length_committed lro_rx_length_committed;
	/* Description - On WriteFirst set to the packet.R_key */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_write_rkey write_rkey;
	/* Description - cleared when CQE is sent, increament when packet is dropped due to lack of receive WQE's saturation on 0xff */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_no_wqe_drop_count no_wqe_drop_count;
	/* Description - allowed bit mask for gid_mac_table.roce_type */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_allow_roce_type allow_roce_type;
	/* Description - bit[1] allow grh bit[0] allow local route */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_allow_grh_type allow_grh_type;
	/* Description - bit per IP type: bit[1]-IPv6, bit[0]-IPv4 when the relevant bit (according to packet) is set lro session can be opened */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_enable lro_enable;
	/* Description - How many 256B chuncks received in current message 0-not inside a message hermon name: part was in last_opcode */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rx_length_committed rx_length_committed;
	/* Description - part of GGRE spec */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_opaque1 lro_opaque1;
	/* Description - l2 tunnel, outer source IP, bits[95:64] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 lro_outer_sip_95_64;
	/* Description - part of GGRE spec */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_opaque2 lro_opaque2;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rdb_write_pointer rdb_write_pointer;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_expected_psn expected_psn;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_cvlan lro_cvlan;
	/* Description - max message size in chunks of 256B Shomron name: lro_max_ip_payload_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_max_message_size lro_max_message_size;
	/* Description - 2^this value=max number of atomic/rdma reads Hermon: max_rdma_atomic */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_max_read_atomic max_read_atomic;
	/* Description - number of coalesced segments */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_coalesce_segment lro_coalesce_segment;
	/* Description - set by SX on every packet sent or WQE executed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_sx_heartbeat sx_heartbeat;
	/* Description - 0: ACK 1: RNR_NACK 2: OOS_NACK 3: INV_REQ-NACK 4: RAE_NACK 5: ROE_NACK */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_ack_type ack_type;
	/* Description - TCU requestor should trap when e2e_credits_enabled==&AETH.syndrom.CCCCC TODO: change valid to be RC only */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_credits_enabled e2e_credits_enabled;
	/* Description - in hermon: last_acked_psn (+1 from hermon) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_first_non_acked_psn first_non_acked_psn;
	/* Description - tip id for cqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_cqe_tip lro_cqe_tip;
	/* Description - see rwq_type TODO: merge with rwq_type TODO: delete from responder (And save bits) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rwq_type rwq_type;
	/* Description - Used for translation and key check (TPT) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_can_use_reserved_lkey can_use_reserved_lkey;
	/* Description - This QP should use the fast_path inside the device */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_fast_path fast_path;
	/* Description - 2^ this value is the threshold to check for new E2E credits 0 means e2e prefethch disabled for this qp in rcylic this thrshould is in MTU, otherwise in WQEs */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold e2e_credits_prefetch_threshold;
	/* Description - TODO: make sure valid bit sits at bit 511 for all contexts */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_qp_valid qp_valid;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rnr_timer rnr_timer;
	/* Description - interrupt FW when packet arrives to tcu on this Qp Hermon: tcu_int */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_tcu_trap tcu_trap;
	/* Description - TODO: merge with tcu_trap to a 2 bit field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_tcu_drop tcu_drop;
	/* Description - set by RX on every packet received and accepted */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rx_heartbeat rx_heartbeat;
	/* Description - TODO: should be valid only on UD */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_ignore_pkey_check ignore_pkey_check;
	/* Description - When set no-direct-access is allowed to this QP (i.e. by BTH.QPN). When clear, both direct (i.e. by BTH.QPN) and indirect access (i.e. by RSS remapping, MC remapping etc) is allowed. See issue 34551 TODO: consider deleting this field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_no_direct_access no_direct_access;
	/* Description - e2e fetch is allowed only according to this bit */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_e2e_fetch_enable e2e_fetch_enable;
	/* Description - when this bit is set a post_receive WQE may be executed on this target qp must be set to 0 on DCR and XRC used by RX only as a field condition */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_post_receive_slave_enable post_receive_slave_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_read_enable read_enable;
	/* Description - part of GGRE spec */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_opaque_vld lro_opaque_vld;
	/* Description - When set send and invalidate is allowed on this Qp (like AWR bits) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_send_with_invalidate_enable send_with_invalidate_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hds_lookahead_en hds_lookahead_en;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_write_enable write_enable;
	/* Description - TODO: add condition like hds_lookahead_en */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hds_split_en hds_split_en;
	/* Description - RDMA write coming to this QP will enter the atomic lock mechanism to ensure PCI atomicity */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_atomic_like_write atomic_like_write;
	/* Description - if both lookahead and header split fails: 1: send zero bytes to first segment 0: fill the first segment */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_hds_first_segment_empty hds_first_segment_empty;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_responder_session_id_15_0 responder_session_id_15_0;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_responder_session_id_23_16 responder_session_id_23_16;
	/* Description - when set: multicast loopback packets coming from the same QP will be dropped */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_drop_my_self_multicast drop_my_self_multicast;
	/* Description - 1: GRH is sent to CQE 0: GRH is sent to first 40B of the WQE (or 40B reserved if GRH not present). this is the backward compatiblity mode */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_grh_to_cqe grh_to_cqe;
	/* Description - When set and packet has tunnel header:  will be treated as tunneled */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_tunnel_enable tunnel_enable;
	/* Description - When set the CVLAN will be sent to CQE, and removed from packet used for Private VLAN implementation */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_cvlan_to_cqe cvlan_to_cqe;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_rx_strip_cntag rx_strip_cntag;
	/* Description - current session is l2 tunnel */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_tunnel lro_tunnel;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_timer_granularity lro_timer_granularity;
	/* Description - lro is allowed for TCP over l2 tunnel packet  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_tunnel_enable lro_tunnel_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_cvlan_valid lro_cvlan_valid;
	/* Description - When set: RX strips the outer headers */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable l2_tunnel_decapsulation_enable;
	/* Description - When this bit is set the device will scatter FCS as part of the packets payload */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_fcs_scatter fcs_scatter;
	/* Description - When this bit is set the device will drop packets with bad FCS */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_fcs_check_enable fcs_check_enable;
	/* Description - l2 tunnel, outer source IP IPv6: bits[31:0] IPv4: the entire field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 lro_outer_sip_31_0;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_responder_session_id_23_16 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_responder_session_id_15_0 {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_no_direct_access {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ignore_pkey_check {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_rx_heartbeat {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_tcu_drop {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_tcu_trap {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_qp_valid {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_fast_path {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_can_use_reserved_lkey {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_e2e_credits_enabled {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_sx_heartbeat {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.27 - 0xc.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_max_read_atomic {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.24 - 0xc.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_psn_wraparound {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.18 - 0x10.18 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.17 - 0x10.17 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_dc_full_handshake {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.16 - 0x10.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ldb_prefetch_size {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.14 - 0x10.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_timer_enable {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.13 - 0x10.13 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_frwr_enable {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.12 - 0x10.12 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_wqe_index_check_enable {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.11 - 0x10.11 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_sx_steering_root {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.10 - 0x10.10 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_dc_state {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.8 - 0x10.9 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_limited_qp {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.4 - 0x10.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_umr_enable {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.2 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_allow_grh_type {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_allow_roce_type {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_oldest_non_acked_psn {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_inline_scatter {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.30 - 0x18.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_connection_state {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.28 - 0x18.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ack_req_frequency {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.24 - 0x18.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_mtu_byte {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.29 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ssn {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_grh_tclass {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.31 - 0x1c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_sl {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.30 - 0x1c.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_currently_completing_ds {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x1c.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_requestor_session_id {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_psn_since_ackreq {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.24 - 0x20.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_currently_completing_wqe_index {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_swqe_consumer_index {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_number_outstanding_reads {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.24 - 0x28.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_my_gid_mac_index {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.23 - 0x28.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_sx_gather_commit {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.22 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ts {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.28 - 0x2c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_extended_atomic {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_cntag_enable {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.16 - 0x2c.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_cntag_flowid {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_umr_permission_select {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.30 - 0x30.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_ecn {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.26 - 0x30.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_ecn {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.25 - 0x30.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_dscp {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.24 - 0x30.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_next_to_send_psn {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_counter_index {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.24 - 0x34.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_cq_number {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_dscp {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.16 - 0x38.21 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_packet_count_in_message {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.31 - 0x3c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_packet_allowed {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.30 - 0x3c.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_cvlan {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.29 - 0x3c.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_force_my_mac {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.28 - 0x3c.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_software_parse_enable {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.27 - 0x3c.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_wqe_mandatory_header {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.24 - 0x3c.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_vl15 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.24 - 0x3c.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_deth_sqpn {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_lsn {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_dc_access_key_63_32 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_s_qpc_dc_access_key_31_0 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_common_valid {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_udp_source_port {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.12 - 0x4.27 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_cqe_tip_source {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.10 - 0x4.11 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_dual_write {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_force_loopback {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_rx_migreq {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_sx_migreq {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_max_message_size {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_mtu {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.28 - 0x8.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_link_type_mac {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_rwq_type {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_ipd {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.20 - 0x8.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_flow_label {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_hop_limit {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_wq_signature {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.22 - 0xc.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_log_page_size {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.16 - 0xc.20 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_swqe_buffer_size {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.12 - 0xc.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_force_ipd {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_adaptive_routing {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.31 - 0x10.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_rwqe_stride {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.28 - 0x10.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_rcyclic_size {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.24 - 0x10.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_rwqe_buffer_size {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.24 - 0x10.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_qp {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_max_encapsulation_size {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.30 - 0x14.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_wqe_page_offset {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_cqe_qpn {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_sl {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.28 - 0x18.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_pkey_table_index {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.27 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_grh_bit {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x1c.24 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_force_my_lid {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.23 - 0x1c.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_my_lid {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.16 - 0x1c.22 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_mac_47_32 {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_mac_31_0 {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_lid {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_port_number {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.31 - 0x20.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_vlan_prio {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.24 - 0x20.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_context_number {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_tclass {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.24 - 0x24.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_pd {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_translation_process_index {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.16 - 0x28.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_my_gid_mac_index {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.8 - 0x28.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_lid2 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_qkey {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_qp2 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_gid_127_96 {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_gid_95_64 {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_gid_63_32 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_c_qpc_peer_gid_31_0 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_srq_valid {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwqe_consumer_stride_index {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_log2_wqe_left_lro_allow {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.17 - 0x4.19 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_cqe_rq_source {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_translation_process_index {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_log2_stride_size {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.28 - 0x8.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_two_bytes_shift_en {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_log2_num_of_strides {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_cqe_srqn {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwq_type_srq {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.10 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rcyclic_size {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rcyclic_producer {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rcyclic_consumer {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_srq_fw {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_consumer_index {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_producer_index {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwqe_consumer_index {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_xrc_domain {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.24 - 0x24.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_pd {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwqe_stride {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.28 - 0x28.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwqe_buffer_size {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.24 - 0x28.27 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_cq_number {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_tcu_trap {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.31 - 0x2c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_can_use_reserved_lkey {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.30 - 0x2c.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_tcu_drop {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.29 - 0x2c.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_log_page_size {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_context_number {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rwqe_limit_event {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.16 - 0x30.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_fetch_enable {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.15 - 0x30.15 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_rx_heartbeat {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.14 - 0x30.14 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_wqe_page_offset {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.8 - 0x30.13 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_mtt_pointer_39_32 {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_mtt_pointer_31_0 {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_wq_signature {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.31 - 0x38.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_pa_63_34 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.29 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_srq_e2e_pa_33_2 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_pf_vf_cfg_space {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - pcie sriov capability for pf */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_pf_vf_sriov sriov;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - VPD capability for pf */
	/* 0x8.0 - 0x10.31 */
	 struct connectx4lx_pf_vf_vpd vpd;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.9 */
	 u_int16_t hw_msix_vec0;
	/* Description - General MSIX function mask to all the function's vectors */
	/* 0x10.10 - 0x10.10 */
	 u_int8_t msix_func_mask;
	/* Description - NO_DESCR */
	/* 0x10.11 - 0x10.11 */
	 u_int8_t msix_enable;
	/* Description - pcie bus mastering for the function */
	/* 0x10.12 - 0x10.12 */
	 u_int8_t bus_master_en;
	/* Description - memory space enable
used for Golan only.
for Shomron, use command_register_memory_space */
	/* 0x10.13 - 0x10.13 */
	 u_int8_t memory_space;
	/* Description - valid for pf, rsvd for vf
used for Golan only.
for Shomron, use status_register_serr */
	/* 0x10.15 - 0x10.15 */
	 u_int8_t serr_status;
	/* Description - valid for pf, rsvd for vf
used for Golan only.
for Shomron, use command_register_serr_report_en */
	/* 0x10.16 - 0x10.16 */
	 u_int8_t serr_enable;
	/* Description - NO_DESCR
used for Golan only.
for Shomron, use command_register_perr_report_en */
	/* 0x10.17 - 0x10.17 */
	 u_int8_t perr_enable;
	/* Description - NO_DESCR */
	/* 0x10.18 - 0x10.18 */
	 u_int8_t int_disable;
	/* Description - Function got FLR, need to send event to driver */
	/* 0x10.19 - 0x10.19 */
	 u_int8_t need_to_fire_flr_event;
	/* Description - NO_DESCR */
	/* 0x10.20 - 0x10.20 */
	 u_int8_t in_middle_of_flr;
	/* Description - If set, this function power state is transparent to power management (L1) mechanism */
	/* 0x10.21 - 0x10.21 */
	 u_int8_t hide;
	/* Description - pcie logical Dstate */
	/* 0x10.22 - 0x10.23 */
	 u_int8_t power_state;
	/* Description - NO_DESCR */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t cache_line;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - NO_DESCR */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t interrupt_line;
	/* Description - NO_DESCR */
	/* 0x14.10 - 0x14.10 */
	 u_int8_t exp_rom_en;
	/* Description - NO_DESCR */
	/* 0x14.11 - 0x14.31 */
	 u_int32_t exp_rom_addr_31_11;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.0 - 0x18.0 */
	 u_int8_t device_control_correctable_error_report_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.1 - 0x18.1 */
	 u_int8_t device_control_nonfatal_error_report_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.2 - 0x18.2 */
	 u_int8_t device_control_fatal_error_report_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.3 - 0x18.3 */
	 u_int8_t device_control_ur_error_report_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.4 - 0x18.4 */
	 u_int8_t device_control_enable_relaxed_ordering;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.5 - 0x18.7 */
	 u_int8_t device_control_max_payload_size;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.8 - 0x18.8 */
	 u_int8_t device_control_extended_tag_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.9 - 0x18.9 */
	 u_int8_t device_control_enable_no_snoop;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.10 - 0x18.12 */
	 u_int8_t device_control_max_read_request_size;
	/* Description -  */
	/* 0x18.13 - 0x18.13 */
	 u_int8_t device_status_correctable_error_detected;
	/* Description -  */
	/* 0x18.14 - 0x18.14 */
	 u_int8_t device_status_nonfatal_error_detected;
	/* Description -  */
	/* 0x18.15 - 0x18.15 */
	 u_int8_t device_status_fatal_error_detected;
	/* Description -  */
	/* 0x18.16 - 0x18.16 */
	 u_int8_t device_status_ur_error_detected;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.17 - 0x18.17 */
	 u_int8_t command_register_memory_space;
	/* Description - PF - base. VF - base */
	/* 0x18.18 - 0x18.18 */
	 u_int8_t command_register_bus_master_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.19 - 0x18.19 */
	 u_int8_t command_register_perr_report_en;
	/* Description - PF - base. VF - RsvdP */
	/* 0x18.20 - 0x18.20 */
	 u_int8_t command_register_serr_report_en;
	/* Description - PF - base. VF - 0 */
	/* 0x18.21 - 0x18.21 */
	 u_int8_t command_register_interrupt_disable;
	/* Description - PF - base. VF - 0 */
	/* 0x18.22 - 0x18.22 */
	 u_int8_t status_register_interrupt_status;
	/* Description -  */
	/* 0x18.23 - 0x18.23 */
	 u_int8_t status_register_perr;
	/* Description -  */
	/* 0x18.24 - 0x18.24 */
	 u_int8_t status_register_serr;
	/* Description -  */
	/* 0x18.25 - 0x18.25 */
	 u_int8_t status_register_received_master_abort;
	/* Description -  */
	/* 0x18.26 - 0x18.26 */
	 u_int8_t status_register_received_target_abort;
	/* Description -  */
	/* 0x18.27 - 0x18.27 */
	 u_int8_t status_register_detected_parity_error;
	/* Description -  */
	/* 0x18.28 - 0x18.28 */
	 u_int8_t status_register_signaled_target_abort;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_hw_init_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0-init not started, 1-init in progress, 3 - init done */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t init_state;
	/* Description - lock to prevent parallel init */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t init_lock;
	/* Description - This VF owner PF */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t owner_pf;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cqc_valid {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_log_page_size {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0x0.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa_error {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.22 - 0x0.23 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_small_message_as_solicited {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_time_from_cqe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cqe_coalesce_enable {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_msix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cqe_128b_size {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_last_notified_check_for_arm_en {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_break_by_solicited {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_lookahead_log_size {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.24 - 0x4.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_last_solicited_index {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa0_63_32 {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa0_31_12 {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.12 - 0xc.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cq_trap {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.11 - 0xc.11 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_shrink {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.10 - 0xc.10 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa_mode {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.9 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cqe_heartbeat {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.7 - 0xc.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_db_recovery_enable {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.6 - 0xc.6 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cq_page_offset {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.5 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_last_notified_index {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.8 - 0x10.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 {
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_producer_index {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_min_wait_time {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.20 - 0x18.31 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_eqn {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.19 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_number_of_events_generated {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.30 - 0x1c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_db_heartbeat {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.29 - 0x1c.29 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_log2_size {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x1c.28 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_db_ci {
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cipa_63_32 {
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cipa_31_3 {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.3 - 0x24.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_mtt_pointer_39_37 {
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.2 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_mtt_pointer_36_5 {
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_mtt_pointer_4_0 {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.27 - 0x2c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_overrun_ignore {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.26 - 0x2c.26 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_cq_state {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.24 - 0x2c.25 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_consumer_index {
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa1_63_32 {
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_pa1_31_12 {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.12 - 0x34.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_timestamp_51_40 {
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.11 */
	 u_int16_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_timestamp_39_8 {
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_moderation_timestamp_7_0 {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.24 - 0x3c.31 */
	 u_int8_t val;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_cqc_uar {
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.23 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_calibration_values {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t ffe_tap_offset0;
	/* Description -  */
	/* 0x0.6 - 0x0.16 */
	 u_int16_t mixer_offset0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.10 */
	 u_int16_t slicer_offset;
	/* Description -  */
	/* 0x4.11 - 0x4.16 */
	 u_int8_t ffe_tap_offset1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.9 */
	 u_int16_t mixer_offset1;
};

/* Description -   */
/* Size in bytes - 496 */
struct connectx4lx_lane_const_sd_params_tx_preset {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1-15 - for amp=0
16 - 30 - for amp=1 */
	/* 0x0.0 - 0x1f0.31 */
	 struct connectx4lx_lane_const_sd_params_tx_preset_speed speed[2];
};

/* Description -   */
/* Size in bytes - 640 */
struct connectx4lx_sd_params_rx_aba {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x280.31 */
	 struct connectx4lx_sd_params_rx_set set[32];
};

/* Description -   */
/* Size in bytes - 160 */
struct connectx4lx_shared_const_sd_params_rx_force {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xa0.31 */
	 struct connectx4lx_sd_params_rx_set set[8];
};

/* Description -   */
/* Size in bytes - 192 */
struct connectx4lx_sd_params_tx_vendor_id {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc0.31 */
	 struct connectx4lx_sd_params_tx_active_set set[16];
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_sd_params_tx_active {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_sd_params_tx_active_set speed[4];
};

/* Description -   */
/* Size in bytes - 1024 */
struct connectx4lx_sd_params_tx_aba {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x400.31 */
	 struct connectx4lx_sd_params_tx_aba_speed speed[4];
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_shared_const_sd_params_tx_force {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_sd_params_tx_set set[10];
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_module_reset_data_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t tank_num;
	/* Description -  */
	/* 0x0.4 - 0x0.6 */
	 u_int8_t gpio_num;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_module_select_data_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t tank_num;
	/* Description -  */
	/* 0x0.4 - 0x0.6 */
	 u_int8_t gpio_num;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_module_prsnt_data_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t tank_num;
	/* Description -  */
	/* 0x0.4 - 0x0.6 */
	 u_int8_t gpio_num;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_module2locallane {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_local_num_local_lane_and_serdes lane[4];
};

/* Description -  to be used in core2phy interface */
/* Size in bytes - 4 */
struct connectx4lx_mlnx_enhanced_equal_info_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t mlpn_100kr4_extended_time_sup;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t mlpn_100cr4_extended_time_sup;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t mlpn_40cr4_extended_time_sup;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t mlpn_40kr4_extended_time_sup;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t mlpn_kr_extended_time_sup;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t edr_rx_atten_sup;
	/* Description -  */
	/* 0x0.6 - 0x0.10 */
	 u_int8_t edr_rx_atten;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t fdr_rx_atten_sup;
	/* Description -  */
	/* 0x0.12 - 0x0.16 */
	 u_int8_t fdr_rx_atten;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t qdr_ddr_ts3_rev;
};

/* Description -  mlpn cability (ability)/ admin (request) bits for ScratchPad (not in pages foramt) */
/* Size in bytes - 4 */
struct connectx4lx_mlpn_database_all_protocol_bits_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t fdr_8_10;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t mlx_kr2;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t eth_56gb;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t fdr10;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t speed_reduction;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t width_reduction;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t eth_cbf;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t ib_64b_credits;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t llr_ib_edr;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t llr_ib_fdr;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t llr_ib_fdr10;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t llr_ib_qdr;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t llr_ib_ddr;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t llr_ib_sdr;
	/* Description - llr_en 56GBASE-KR4. ability/request according to node */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t llr_56_kr4;
	/* Description - llr_en 56GBASE-KX4. ability/request according to node */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t llr_56_kx4;
	/* Description - llr_en 40GBASE-KR4. ability/request according to node */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t llr_kr4;
	/* Description - llr_en 40GBASE-CR4 (copper). ability/request according to node */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t llr_cr4;
	/* Description - llr_en 40GBASE-S/LR4(optics). ability/request according to node */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t llr_slr4;
	/* Description - llr_en 10GBASE-KR (XFI). ability/request according to node */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t llr_kr;
	/* Description - llr_en 10GBASE-CR (copper). ability/request according to node */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t llr_cr;
	/* Description - llr_en 10GBASE-S/LR(optics). ability/request according to node */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t llr_slr;
	/* Description - llr_en 10GBASE-X (XAUI). ability/request according to node */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t llr_xaui;
	/* Description - llr_en. ability/request according to node */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t llr_sgmii;
	/* Description - in page0: protocol ability
in page2: protocol default (may set no more than one protocol bit, none - no default) */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t fc_protocol;
	/* Description - in page0: protocol ability
in page2: protocol default (may set no more than one protocol bit, none - no default) */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t eth_protocol;
	/* Description - in page0: protocol ability
in page2: protocol default (may set no more than one protocol bit, none - no default) */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t ib_protocol;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t ib_64_66_spec_recovery;
	/* Description - in page0: protocol ability
in page2: protocol default (may set no more than one protocol bit, none - no default) */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t ib_128b_llr;
	/* Description - in page0: protocol ability
in page2: protocol default (may set no more than one protocol bit, none - no default) */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t ll_llr;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_data_tpt_capabilities {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 when log_max_payload_size is configurable - when ticket #869555 closed pick the node from EAS_st */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t log_max_payload_size_supported;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tpt_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0: AUTO
MATIC
0xC: _4KB */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t log_max_payload_size;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_nv_global_pci_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - True when non_prefetchable_pf_bar field is configurable. */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t non_prefetchable_pf_bar_supported;
	/* Description - When set, t
he log_pf_uar_bar_size field is configurable and the max
_log_pf_uar_bar_size field is valid. */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t pf_bar_size_supported;
	/* Description - When set, t
he log_vf_uar_bar_size field is configurable and the max
_log_vf_uar_bar_size field is valid. */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t vf_bar_size_supported;
	/* Description - Wh
en 
set, 
t
h
e num_pf_msix field is configurable and the max_num_p
f_msix field is valid. */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t num_pf_msix_supported;
	/* Description - When set, t
he num_vf_msix field is configurable and the max
_num_vf_msix field is valid. */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t num_vf_msix_supported;
	/* Description - When set, th
e num_pfs field is configurable and max_num_pfs is valid. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t num_pfs_supported;
	/* Description - When set, the NIC will only respect an NV_GLOBAL_PCI_CONF TLV 
if the total bar size required for all PFs and VFs is lower or equal to the 
number specified in the max_total_bar field below. */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t max_total_bar_valid;
	/* Description - When set, the NIC will only respect NV_GLOBAL_PCI_CONF TLV if 
the total MSIX required for all PFs and VFs is lower or equal to the num
ber specified in the max_total_msix field below. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t max_total_msix_valid;
	/* Description - When set, the NIC will only respect NV_GLOBAL_PCI_CONF TLV if 
its total_vfs parameter is lower than or equal to the value of the max
_vfs_per_pf field below. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t max_vfs_per_pf_valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The maximum number of VFs that can be set in the total_vfs setting (per 
PF)
. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t max_vfs_per_pf;
	/* Description - Maximum number of PFs */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t max_num_pfs;
	/* Description - When set, f
unction per-port setting is configurable */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t fpp_support;
	/* Description - When set, th
e device supports controlling the VF QoS setting. */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t vf_qos_control_support;
	/* Description - When set, SR-IOV support is configurable by the NV_GLOBAL_PCI_
CONF sriov_en bit. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t sriov_support;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Log 2 of the maximum size (in MBs) of a PF"s UAR BAR */
	/* 0x8.0 - 0x8.5 */
	 u_int8_t max_log_pf_uar_bar_size;
	/* Description - Log 2 of the maximum size (in MBs) of a VF"s UAR BAR */
	/* 0x8.6 - 0x8.11 */
	 u_int8_t max_log_vf_uar_bar_size;
	/* Description - Maximum number of MSI-X vectors and EQs per PF. */
	/* 0x8.12 - 0x8.21 */
	 u_int16_t max_num_pf_msix;
	/* Description - Maximum number of MSI-X vectors and EQs per VF. */
	/* 0x8.22 - 0x8.31 */
	 u_int16_t max_num_vf_msix;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Maximum number of MSI-X for the aggregate of all PFs and VFs. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t max_total_msix;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Maximum total of the MMIO space for all PFs and VFs combined, in 
megabytes.
Note: if the number of PF or VF per port is not a power of 2, this param
eter will also not be a power of 2 */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t max_total_bar;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_nv_global_pci_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t toolpf_en;
	/* Description - When set, the PF BAR 'prefetchable' bit is cleared.
Note: PCI switches and operation systems have dedicated quotas for 
non-prefetchable memory hence, you may need to decrease log_p
f_uar_bar_size to enable this feature. */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t non_prefetchable_pf_bar;
	/* Description - When True, non_prefetchable_bar field and allow_large_non_prefetch
able_pf_bar overrides the default value. */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t non_prefetchable_pf_bar_valid;
	/* Description - When set, the pf_bar_size field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t pf_bar_size_valid;
	/* Description - When set, the vf_bar_size field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t vf_bar_size_valid;
	/* Description - When set, the num_pf_msix field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t num_pf_msix_valid;
	/* Description - When set, the num_vf_msix field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t num_vf_msix_valid;
	/* Description - When set, the num_pfs field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t num_pfs_valid;
	/* Description - When set, the fpp field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t fpp_valid;
	/* Description - When set, the full_vf_qos field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t full_vf_qos_valid;
	/* Description - When set, the sriov field is valid. 
When cleared, the device uses the "factory_settings" value. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t sriov_valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The total number of 
Virtual Functions (
VFs
)
 that can be supported, for 
each PF. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t total_vfs;
	/* Description - Total number of PCIe functions (PFs) exposed by the device. The num
ber of PFs must be a multiple of the number of ports */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t num_pfs;
	/* Description - When this bit is cleared, the device exposes a single PCI function for 
both ports. When set, the device exposes one or more PCI functions for 
each port (this is the only mode supported by ConnectX-4 devices). */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t fpp_en;
	/* Description - When set, Virtual Function has the same number of traffic classes as 
physical functions. */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t full_vf_qos;
	/* Description - Enable Single-Root I/O Virtualization (SR-IOV) */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t sriov_en;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Log 2 of the size of a PF"s UAR BAR in MBs. */
	/* 0x8.0 - 0x8.5 */
	 u_int8_t log_pf_uar_bar_size;
	/* Description - Log 2 of the size of a VF"s UAR BAR in MBs. */
	/* 0x8.6 - 0x8.11 */
	 u_int8_t log_vf_uar_bar_size;
	/* Description - Number of MSI-X vectors and EQs per PF. */
	/* 0x8.12 - 0x8.21 */
	 u_int16_t num_pf_msix;
	/* Description - Number of MSI-X vectors and EQs per VF. */
	/* 0x8.22 - 0x8.31 */
	 u_int16_t num_vf_msix;
};

/* Description -  PCI express link capabilities register2 */
/* Size in bytes - 4 */
struct connectx4lx_link_caps2 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t supported_link_speed_vector;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t cross_link_supported;
};

/* Description -  PCI express device capabilities register2 */
/* Size in bytes - 4 */
struct connectx4lx_device_caps2 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t completion_timeout_ranges_supported;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t completion_timeout_disable_supported;
	/* Description -  */
	/* 0x0.5 - 0x0.7 */
	 u_int8_t ari_forwarding_supported;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t _10bit_tag_completer_supported;
	/* Description -  */
	/* 0x0.18 - 0x0.19 */
	 u_int8_t obff_supported;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t extended_fmt_field_supported;
};

/* Description -  PCI express link capabilities register */
/* Size in bytes - 4 */
struct connectx4lx_link_caps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t max_link_speed;
	/* Description -  */
	/* 0x0.4 - 0x0.9 */
	 u_int8_t max_link_width;
	/* Description -  */
	/* 0x0.10 - 0x0.11 */
	 u_int8_t aspm_support;
	/* Description -  */
	/* 0x0.12 - 0x0.14 */
	 u_int8_t l0s_exit_latency;
	/* Description -  */
	/* 0x0.15 - 0x0.17 */
	 u_int8_t l1_exit_latency;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t clock_power_management;
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t surprise_down_error_reporting_cap;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t link_active_reporting_cap;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t link_bw_notification_cap;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t aspm_optionality_compliance;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t port_number;
};

/* Description -  PCI express device capabilities register */
/* Size in bytes - 4 */
struct connectx4lx_device_caps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t max_payload_size_supported;
	/* Description -  */
	/* 0x0.3 - 0x0.4 */
	 u_int8_t phantom_funcs;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t extended_tag_field_sup;
	/* Description -  */
	/* 0x0.6 - 0x0.8 */
	 u_int8_t l0s_acceptable_latency;
	/* Description -  */
	/* 0x0.9 - 0x0.11 */
	 u_int8_t l1_acceptable_latency;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t role_based_error_reporting;
	/* Description -  */
	/* 0x0.18 - 0x0.25 */
	 u_int8_t captured_slot_power_limit_value;
	/* Description -  */
	/* 0x0.26 - 0x0.27 */
	 u_int8_t captured_slot_power_limit_scale;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t function_level_reset_capability;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_external_port_pf_array {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port owner (PF array, pf_ix = (host_ix)*max_num_pfs_per_host_ini_value + func_num) */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_pf_array_default_ones port_owner;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Allow read counters (PF array, pf_ix = (host_ix)*max_num_pfs_per_host_ini_value + func_num) */
	/* 0x8.0 - 0x10.31 */
	 struct connectx4lx_pf_array_default_ones allow_rd_counters;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Renegotiate only on config change (PF array, pf_ix = (host_ix)*max_num_pfs_per_host_ini_value + func_num) */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_pf_array_default_ones reneg_on_change;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_nv_config_host_port_main {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_nv_wol_conf wol;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_data_curr_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - indicates who was the last writer id to write/invalidate tlv */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t current_cfg_method;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_config_flex_nic {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - user image
0x1 - factory default
other - reserved - remove when #844406 closed - pick the node from EAS_st */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t fpga_image_bank;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_config_host_2_bmc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - No traffic is looped-back in the device 
 0x1 - Enable traffic from host 2 local BMC - remove when ticket #843912 closed and pick node from EAS_st */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t host_2_bmc_traffic_enable;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_tweaks {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Enable packet pacing */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t packet_pacing;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_nv_sw_offload_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Configure which algorithm should be used by the NIC in order 
to decide when to activate CQE compression based on PCIe bus 
condition.Note that the driver can enable compression on a per 
CQE basis
0x0: BALANCED
0x1: AGGRESSIVE */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t cqe_compression;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t one_qp_per_recovery;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Log2 of Large Receive Offload (LRO) timeout #0, in microsec
onds. Driver can select one of the 4 configured LRO timeouts on 
a per Qp basis in run-time (lro_timeout_period_usecs field of the 
TIR context) */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t lro_log_timeout0;
	/* Description - Log2 of Large Receive Offload (LRO) timeout #1, in microsec
onds. Driver can select one of the 4 configured LRO timeouts on 
a per Qp basis in run-time (lro_timeout_period_usecs field of the 
TIR context) */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t lro_log_timeout1;
	/* Description - Log2 of Large Receive Offload (LRO) timeout #2, in microsec
onds. Driver can select one of the 4 configured LRO timeouts on 
a per Qp basis in run-time (lro_timeout_period_usecs field of the 
TIR context) */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t lro_log_timeout2;
	/* Description - Log2 of Large Receive Offload (LRO) timeout #3, in microsec
onds. Driver can select one of the 4 configured LRO timeouts on 
a per Qp basis in run-time (lro_timeout_period_usecs field of the 
TIR context) */
	/* 0x4.12 - 0x4.15 */
	 u_int8_t lro_log_timeout3;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_roce_1_5_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The next protocol value set in the IPv4/IPv6 packets for RoCE 
v1.5. The default is 0xFE. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t roce_over_ip_next_protocol;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_mpfs_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Defines the forwarding behavior in MPFS for MACs which are dupli
cated in more than one PF.
0x0: LAST_C
FG
 - last PF which added the MAC will receive the traf
fic.
0x1: LOAD_BALANCE - MPFS will load-balance ipv4 traffic for 
packets with destination MAC addresses that belong to more than one 
PF between all PFs that have this MAC */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t duplicated_mac_action_mode;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_nv_qos_ets_tc_conf {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x48.31 */
	 struct connectx4lx_nv_ets_tcN_config_reg tc_configuration[8];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_qos_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Maximum number of VLs supported by the HBA.
0x1: _1_VL - VL0 only
0x2: _2_VLs - VL0, VL1
0x3: _4_VLs - VL0..VL3
0x4: _8_VLs - VL0..VL7
0x5: _15_VLs -- VL0..VL14 (VL15 is always present for 
MADs) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t max_num_of_vl;
	/* Description - Maximum number of traffic classes supported by the NIC, where 
0 => 8 T
C */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t max_num_of_tc;
	/* Description - Maximum number of priority flow control
supported_from_version: 1 */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t max_num_pfc;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_nv_qos_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Number of Infiniband Virtual Lanes for this port,
 
(s
see vl_admin 
in PVLC Register)
0x1: _1_VL - VL0 only
0x2: _2_VLs - VL0, VL1
0x3: _4_VLs - VL0..VL3
0x4: _8_VLs - VL0..VL7
0x5: _15_VLs --VL0, VL14 (VL15 is always present for MADs) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t num_of_vl;
	/* Description - Number of traffic classes, when DCB-X is enabled, this is the 
maximum number of TC that can negotiated with the remote 
peer. (see num_of_tc_admin in DCBX_PARAM Register)
0x0: _8_TCs
0x1: _1_TC
0x2: _2_TCs
0x3: _3_TCs
0x4: _4_TCs
0x5: _5_TCs
0x6: _6_TCs
0x7: _7_TCs */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t num_of_tc;
	/* Description - Number of IEEE priorities that may simultaneously support flow 
control. 
 (see pfc_cap_admin DCBX_PARAM Register) */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t num_pfc;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Control pause frame transmission and reception (processing) per 
an IEEE priority
(See prio_pfctx and prio_pfcrx in the PFCC
 r
egister
0x0: DISABLED
0x1: RX_ONLY
0x2: TX_ONLY
0x3: RX_TX */
	/* 0x4.28 - 0x8.27 */
	 u_int8_t priority_pfcc_pfc[8];
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The TC used for a given IEEE priority (see tclass in the QTCT 
register) */
	/* 0x8.28 - 0xc.27 */
	 u_int8_t priority_tc[8];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_lldp_nb_dcbx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Enable DCBX in IEEE mode */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ieee_dcbx_en;
	/* Description - Enable DCBX in CEE mode */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t cee_dcbx_en;
	/* Description - Allow the NIC to accept DCBX configuration from the remote 
peer. */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t dcbx_willing;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_nv_lldp_nb_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Interval for sending LLDP NB PDUs in seconds */
	/* 0x0.0 - 0x0.11 */
	 u_int16_t lldp_msg_tx_interval;
	/* Description - Enable DCBX */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t lldp_nb_dcbx;
	/* Description - Enable the internal LLDP client, and define which TLV it will 
process.
0x0: OFF - Not listen for incoming LLDP BPDU (incoming 
LLDP frames will be routed to the host)
0x1: MANDATORY - Listen for incoming LLDP frames, store 
only the mandatory LLDP BPDUs (1..3)
0x2: ALL - Receive and store all incoming LLDP BPDUs */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t lldp_nb_rx_mode;
	/* Description - Select which LLDP TLV will be generated by the NIC
0x0: OFF - NIC internal LLDP client will not send LLDP frames 
0x1: MANDATORY - Transmit only mandatory LLDP BPDU 
(ChassisID, PortID & TTL)
0x2:
 
ALL - Transmit optional LLDP BPDU if configured */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t lldp_nb_tx_mode;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The size in bytes of that the lldp client must reserve for incoming 
TLVs */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t lldp_nb_rx_buffer_size;
	/* Description - The size in bytes of that the lldp client must reserve for transmit
ted TLVs. The buffer size must be big enough to hold all the 
mandatory TLVs (chassisID, PortID & TTL) as well as all the 
optional TLVs that the client need to send. */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t lldp_nb_tx_buffer_size;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_nv_lldp_nb_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - DCB-X supported
supported_from_version:1 */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t lldp_nb_dcbx_en;
	/* Description - 0x0: NA - Reception and storing of LLDP frames is not sup
ported (incoming frames will be forwarded to the host)
0x1: MANDATORY - The client can only store received the 
mandatory LLDP-TLVs 
0x2: ALL - The client can receive and store incoming LLDP 
TLVs */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t lldp_nb_rx_cap;
	/* Description - 0x0: NA - LLDP transmission not supported 
0x1: MANDATORY - The LLDP client only support sending of 
the mandatory LLDP NB TLVs (ChassisID, PortID & TTL)
0x2: ALL - The LLDP client support sending mandatory and 
optional TLVs 
3: reserved */
	/* 0x0.30 - 0x0.31 */
	 u_int8_t lldp_nb_tx_cap;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The maximum supported buffer size for incoming  LLDP TLVs */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t max_lldp_nb_rx_buffer_size;
	/* Description - The maximum supported buffer size for outgoing LLDP TLVs */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t max_lldp_nb_tx_buffer_size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The maximum number of optional LLDP TLVs that are sup
ported by the firmware. The firmware is searching of LLDP NB 
TLV to send from type 0x110 to type (0x110 + this field)
Default: 16 */
	/* 0x8.0 - 0x8.6 */
	 u_int8_t max_num_of_tx_optional_lldp_tlv;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_keep_link_up {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - When set, the NIC keeps the link up as long as the server is not in 
standby mode (Ethernet only). */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t keep_eth_link_up;
	/* Description - When set, the NIC keeps the link up as long as the server is not in 
standby mode (InfiniBand only). */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t keep_ib_link_up;
	/* Description - When set, the NIC keeps the link up as long as the server is not in 
standby mode and a driver is not initialized. */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t keep_link_up_on_boot;
	/* Description - When set, the NIC keeps the link up from power-up until the server 
is turned on, and when the server is in standby mode. */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t keep_link_up_on_standby;
	/* Description - When set, the NIC does not clear the ppcnt counters value when the first real os driver lunch init_hca, this bit is mainly for debugging purpose . */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t disable_clear_port_stat_on_loading;
};

/* Description -   */
/* Size in bytes - 68 */
struct connectx4lx_nv_roce_cc_ecn {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - When receiving an CNP, the target rate should be updated if the 
transmission rate was increased due to the timer, and not only 
due to the byte counter */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t clamp_tgt_rate_after_time_inc;
	/* Description - If set, whenever a CNP is processed, the target rate is updated to 
be the current rate. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t clamp_tgt_rate;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Time between rate increases if no CNPs are received. Given in 
u-seconds. */
	/* 0x4.0 - 0x4.16 */
	 u_int32_t rpg_time_reset;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Transmitted data between rate increases if no CNPs are received. 
Given in Bytes (0=DISABLED) */
	/* 0x8.0 - 0x8.14 */
	 u_int16_t rpg_byte_reset;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The number of times rpByteStage or rpTimeStage can count 
before the RP rate control state machine advances states. */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t rpg_threshold;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The maximum rate, in Mbits per second, at which an RP can 
transmit. Once this limit is reached, the RP rate limited is 
released and the flow is not rate limited any more (0=Full Port 
Speed). */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rpg_max_rate;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The rate, in Mbits per second, used to increase rpTargetRate in 
the RPR_ACTIVE_INCREASE. */
	/* 0x14.0 - 0x14.16 */
	 u_int32_t rpg_ai_rate;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The rate, in Mbits per second, used to increase rpTargetRate in 
the RPR_HYPER_INCREASE state */
	/* 0x18.0 - 0x18.16 */
	 u_int32_t rpg_hai_rate;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - I
f a CNP is received, the flow rate is reduced at the beginning of 
the next rate_reduce_monitor_period interval to (1-Alpha/
Gd)*CurrentRate. rpg_gd is given as log2(Gd), where Gd may 
only be powers of 2. */
	/* 0x1c.0 - 0x1c.3 */
	 u_int8_t rpg_gd;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The minimum factor by which the current transmit rate can be 
changed when processing a CNP. Value is given as a percentage 
(1-100). */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t rpg_min_dec_fac;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - The minimum value, in Mbits per second, for rate to limit. */
	/* 0x24.0 - 0x24.16 */
	 u_int32_t rpg_min_rate;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - The rate that is set for the flow when a rate limiter is allocated to 
it upon first CNP received, in Mbps (=Full Port Speed) */
	/* 0x28.0 - 0x28.16 */
	 u_int32_t rate_to_set_on_first_cnp;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Used to update the congestion estimator (alpha) once every 
dce_tcp_rtt microseconds, according to the equation:
Alpha = (cnp_received * dceTcpG) + (1 - dceTcpG) * alpha .
dceTcpG is divided by 2^10.
cnp_received is set to one if a CNP was received for this flow 
during period since the previous update and the current update */
	/* 0x2c.0 - 0x2c.9 */
	 u_int16_t dce_tcp_g;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - The time between updates of the alpha value, in microseconds. */
	/* 0x30.0 - 0x30.16 */
	 u_int32_t dce_tcp_rtt;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - The minimum time between 2 consecutive rate reductions for a 
single flow. Rate reduction will occur only if a CNP is received 
during the relevant time interval. */
	/* 0x34.0 - 0x34.16 */
	 u_int32_t rate_reduce_monitor_period;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - The initial value of alpha to use when receiving the first CNP for 
a flow. Expressed in a fixed point fraction of 2^10
. */
	/* 0x38.0 - 0x38.9 */
	 u_int16_t initial_alpha_value;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Minimum time between sending CNPs from the port, in micro
seconds. */
	/* 0x3c.0 - 0x3c.16 */
	 u_int32_t min_time_between_cnps;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - The 802.1p priority value of the generated CNP for this port */
	/* 0x40.0 - 0x40.2 */
	 u_int8_t cnp_802p_prio;
	/* Description - The DiffServ Code Point of the generated CNP for this port. */
	/* 0x40.8 - 0x40.13 */
	 u_int8_t cnp_dscp;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_roce_cc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Each bit in this mask indicates if the RoCE should be enabled on 
the n-th IEEE priority. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t roce_cc_enable_pri;
	/* Description - Select RDMA over Converged Ethernet (RoCE) algorithm
0x0: ECN
0x1: QCN */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t roce_cc_algorithm;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pll_prj_ini_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - number of varactors connected to analog */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t analog_varac;
	/* Description - 0x0-div mode
 0x1-FFF mode
 0x2-Open loop */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t lock_mode;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_itoc_param {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.21 */
	 u_int32_t size;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t addr;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_subroutines_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_subroutines_db_name by_name;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_subroutines_db_index by_index;
};

/* Description -   */
/* Size in bytes - 216 */
struct connectx4lx_sm_admin_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - IB spec/ Legacy mode
1 - Internal ports (Backplane)
2 - Passive copper short: atten < than medium_range_copper_atten_th && link_length <= short_range_copper_link_length_th
3 - Passive copper medium: medium_range_copper_atten_th <= atten < long_range_copper_atten_th && link_length <= medium_range_copper_link_length_th
4 - Passive copper long
5 - Active short reach
6 - Active long reach (over retransmission range 20m+)
7 - Disable FEC
8 - Default FEC */
	/* 0x0.0 - 0xd8.31 */
	 struct connectx4lx_phy_profile_ini_db phy_profile[9];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_err_correction_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Standard LL RS-FEC - RS(271,257)
Bit 4 - Mellanox Strong RS-FEC - RS(277,257)
Bit 5 - Mellanox LL RS-FEC - RS(163,155)
Bit 6 - Mellanox COD
 */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t mlx_fec_mode;
	/* Description - Bit 0 - LLR
Bit 1 - PLR
 */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t retransmission_mode;
	/* Description - Bit 0 - No FEC
Bit 1 - Reserved
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Reserved */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t eth_fec_mode_100g;
	/* Description - Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Standard RS-FEC - RS(528,514)
Bit 3 - Reserved */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t eth_fec_mode_25g_50g;
	/* Description - Bit 0 - No FEC
Bit 1 - Firecode FEC
Bit 2 - Reserved
Bit 3 - Reserved */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t eth_fec_mode_10g_40g;
	/* Description - Bit 0 - No FEC
Bit 1 - Firecode FEC */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t eth_fec_mode_56g;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_eth_speeds_supported {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t Speed1Gb;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t Speed10Gb;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t Speed20Gb;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t Speed25Gb;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t Speed40Gb;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t Speed50Gb;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t Speed56Gb;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t Speed100Gb;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_dword_val {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_port_cap_mask1_fields {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t is_sm;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t is_notice_sup;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t is_trap_sup;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t is_optional_ipd_sup;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t is_automatic_migration_sup;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t is_sl_mapping_sup;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t is_mkey_nvram;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t is_pkey_nvram;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t is_led_info_sup;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t is_sm_disabled;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t is_system_image_guid_sup;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t is_pkey_switch_external_port_trap_sup;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t is_cable_info_supported;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t is_extended_speed_sup;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t is_capability_mask2_supported;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t is_communication_management_sup;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t is_snmp_tunneling_sup;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t is_reinit_sup;
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t is_device_management_sup;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t is_vendor_class_sup;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t is_dr_notice_sup;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t is_capability_mask_notice_sup;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t is_boot_management_sup;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t is_link_round_trip_latency_sup;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t is_client_reregistration_sup;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t is_other_local_changes_notice_supported;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t is_link_speed_width_pairs_table_supported;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t is_vendor_specific_mads_table_supported;
	/* Description -  */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t is_multicast_pkey_trap_suppression_supported;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t is_multicast_fdb_top_supported;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t is_hierarchy_info_supported;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_dcr_odp_event_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t dcrn;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_flow_counter_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flow counter handle */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t flow_counter_id;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_dest_format_struct {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - When destination_type == VPORT - destination is vport number. Only 
bits[15:0] are valid, bits[23:16] are reserved.
When destination_type == FLOW_TABLE - destination is Flow Table Id.
When destination_type == TIR - destination is TIR.
When destination_type==QP - destination QP Number */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t destination_id;
	/* Description - Defines the destination type. Valid only when action [FWD_DEST] is set
0x
0: VPORT
0x
1: FLOW_TABLE
0x
2: TIR
0x3: QP */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t destination_type;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_rxt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t psn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t srq_number;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t reserved0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t reserved1;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t bth_opcode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t requestor;
	/* Description -  */
	/* 0xc.25 - 0xc.25 */
	 u_int8_t bth_se;
	/* Description -  */
	/* 0xc.26 - 0xc.26 */
	 u_int8_t bth_valid;
	/* Description -  */
	/* 0xc.27 - 0xc.27 */
	 u_int8_t reserved2;
	/* Description -  */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t rq_type;
	/* Description -  */
	/* 0xc.30 - 0xc.31 */
	 u_int8_t reserved3;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_sxw {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t consumer_index;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t reserved0;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t wqe_opcode;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.16 */
	 u_int8_t requestor;
	/* Description -  */
	/* 0x8.17 - 0x8.17 */
	 u_int8_t reserved1;
	/* Description -  */
	/* 0x8.18 - 0x8.18 */
	 u_int8_t reserved2;
	/* Description -  */
	/* 0x8.19 - 0x8.19 */
	 u_int8_t reserved3;
	/* Description -  */
	/* 0x8.20 - 0x8.20 */
	 u_int8_t reserved4;
	/* Description -  */
	/* 0x8.21 - 0x8.21 */
	 u_int8_t reserved5;
	/* Description -  */
	/* 0x8.22 - 0x8.22 */
	 u_int8_t reserved6;
	/* Description -  */
	/* 0x8.23 - 0x8.23 */
	 u_int8_t reserved7;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t opcode_mod;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t qp_ts;
	/* Description -  */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t reserved8;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_tpt {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t unitid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t reserved;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t mkey;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_tpt_memop {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t mkey_change_mask_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mkey_change_mask_31_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t reserved;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t mkey;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_rxc {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t producer_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t reserved0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t cqn_eqn;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t reserved1;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_rxw_fte {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t wqe_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t reserved0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - qp number or srq number (depends on rq_type) */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t context_number;
	/* Description -  */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t requestor;
	/* Description -  */
	/* 0xc.25 - 0xc.27 */
	 u_int8_t reserved1;
	/* Description -  */
	/* 0xc.28 - 0xc.28 */
	 u_int8_t srq_en;
	/* Description -  */
	/* 0xc.29 - 0xc.31 */
	 u_int8_t reserved2;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_error_flow_trigger_tag_rxw_ldb {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t wqe_index;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t wqe_opcode;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t opcode_mod;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t qp_ts;
	/* Description -  */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t reserved;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_odp_hca_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t odp_rc;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t odp_uc;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t odp_ud;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t odp_xrc;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t odp_dc;
};

/* Description -   */
/* Size in bytes - 32 */
union connectx4lx_cmdif_ctx_special {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create c;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_modify_tir tir;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_modify_tis tis;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_qp_commands qp;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create_rq rq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create_srq srq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create_xrq xrq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_rqt rqt;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create_eq eq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_create_cq c_cq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_modify_cq m_cq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_mkey mkey;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_arm_rq arm_rq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_special_modify_rmp modify_rmp;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_sniffer sniffer;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_mcg mcg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_psv psv;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_create_mtt mtt;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_dmfs_fte dmfs_fte;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_dmfs_fg dmfs_fg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_dmfs_ft dmfs_ft;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_l2_table l2_table;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_modify_rq modify_rq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_modify_sq modify_sq;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_create_lag lag;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_fpga_access_reg fpga_access_reg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_cmdif_ctx_fpga_cap fpga_cap;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_flush_type {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_flush_type_bits bits;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_flush_type_bitmask bitmask;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_general_notification_delay_drop_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The User Index of the RQ that cause the timeout */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t rq_user_index_delay_drop;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_pps_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Indicating the pin where PPS event was generated */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t pin;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - MSB of 
t
he device time when it was triggered from the exter
nal GPIO pin. 
In_time for ptp_in, and out_time for ptp_out.
Time is in units of device clock. Device clock frequency can 
be fetched from HCA_CAP.device_frequency */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t time_stamp_h;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - MSB of 
t
he device time when it was triggered from the exter
nal GPIO pin. 
In_time for ptp_in, and out_time for ptp_out.
Time is in units of device clock. Device clock frequency can 
be fetched from HCA_CAP.device_frequency */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t time_stamp_l;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_fpga_qp_error_event {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0x1: retry_counter_expired
0x2: RNR_expired */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t syndrome;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - FPGA QP Number */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t fpga_qpn;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_fpga_error_event {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0x1: corrupted_ddr
0x2: flash_timeout
0x3: internal_link_error
0x4: watchdog_failure
0x5: I2C_failure
0x6: Image_changed */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t syndrome;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_nic_vport_change_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Which function requested to claim or reclaim pages
0 - my hca.
others - function_id of specific vhca. used by vhca_group_man
ager(HCA_CAP.vhca_group_manager ==1). */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vport_num;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_pages_req_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Which function requested to claim or reclaim pages
0 - my hca.
others - function_id of specific vhca. used by vhca_group_man
ager(HCA_CAP.vhca_group_manager ==1). */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t function_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Number of missing / unneeded pages (signed number, msb indicate sign). 
This is just a recommendation for the driver. the actual number of pages 
that the driver deliver to the device is as set in the MANAGE_PAGES 
command. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t num_pages;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_cmd_inter_comp_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bits in this vector are set for commands completed and not yet 
reported by event */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t command_completion_vector;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_stall_vl_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - VL number */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t vl;
	/* Description - port number */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t port_num;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_db_bf_congestion_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - N/A
1 - Mild congestion
...
7 - Severe congestion */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t congestion_level;
	/* Description - 0 - Doorbell congestion
1 - BlueFlame congestion */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t event_subtype;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_temp_warning_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit vector indicating which of the sensor reading is above thresh;old.;Address 00h bit31 is sensor_warning[127];Address 0Ch bit0 is sensor_warning[0] */
	/* 0x0.0 - 0x10.31 */
	 u_int32_t sensor_warning[4];
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_dcbx_change_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Event subtype.
0x1: ERROR_STATE - DCBX has reached an error state. The 
error is reported in the error field. The error enumeration is 
according to its definition in error field in the DCBX_PARAM 
register. 
0x2: REMOTE_CONFIG_CHANGE - Change in remote 
party config. New parameters reported by PFCC, QTCT, 
QETCR and DCBX_PARAM registers for remote config 
change.
0x3: LOCAL_OPER_CANGE - Change in local party opera
tional state. New parameters reported by PFCC, QTCT, 
QETCR and DCBX_PARAM registers for local operational 
change 
0x4: REMOTE_CONFIG_APPLICATION_PRIORI
TY_CHANGE - Change in DCBX_APPLICATION register. 
No event data is attached. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t event_sub_type;
	/* Description - Indicates the error cause the event.
valid only when event_sub_type==ERROR_STATE. */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t error;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_port_module_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Module Status.
0x1: 
P
lugged
0x2:
 
U
nplugged
0x3: 
M
odule plugged with Error
-
 Details in errors reported in 
error_type field. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t module_status;
	/* Description - Module Number.
SW can use PMLP register to know port number to module 
number mapping. */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Module error type. Valid when module_status==0x3
0x0: Power Budget Exceeded
0x1: Long Range for non MLNX cable/module
0x2: Bus stuck(I2C or data shorted)
0x3: No EEPROM/retry timeout
0x4: Enforce part number list
0x5: Unknown identifier
0x6: High Temperature
0x7: Cable is shorted */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t error_type;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_gpio_event {
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - If any bit is set to '1', then a rising/falling event has occurred 
on the corresponding GPIO pin. */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t gpio_event_hi;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - If any bit is set to '1', then a rising/falling event has occurred 
on the corresponding GPIO pin. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t gpio_event_lo;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_port_state_change_event {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Port number */
	/* 0x8.28 - 0x8.31 */
	 u_int8_t port_num;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_dropped_packet_logged {
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_cq_error {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - CQ number event is reported for */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t cqn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0x1: CQ_overrun
0x2: CQ_access_violation_error */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t syndrome;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_rdma_page_fault_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The number of bytes already sent/received in this WQE before the fault. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bytes_committed;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The R-key used for the RDMA transaction which caused the fault. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t r_key;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The length of the packet received/constructed for transmission when the 
fault occurred. Measured in bytes.
This can be used on RDMA write operations, where we do not always 
know the rdma_op_len. The software may attempt to prefetch memory 
based on the event attributes, but must make sure it can map the pages 
needed for packet_len bytes. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t packet_len;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - The length of the RDMA operation, in bytes. If the HW cannot reliably 
report the length, it will put 0 in this field, and the driver should perform 
prefetching based on access pattern */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rdma_op_len;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The VA used for the beginning of the RDMA operation, upper 32-bits. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rdma_va_hi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The VA used for the beginning of the RDMA operation, lower 32-bits. */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t rdma_va_lo;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The QP on which the fault occurred */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t qpn;
	/* Description - If set, the fault happened on the requestor (initiator) side of the QP.
Not set - responder side of the QP */
	/* 0x18.24 - 0x18.24 */
	 u_int8_t requestor;
	/* Description - If set, the operation attempted was writing memory. 
Not set - reading from memory */
	/* 0x18.25 - 0x18.25 */
	 u_int8_t write_read_;
	/* Description - 1 - RDMA associated page fault.
0 - WQE associated page fault */
	/* 0x18.26 - 0x18.26 */
	 u_int8_t rdma;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_wqe_associated_page_fault_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The number of bytes already sent/received in this WQE before the fault. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bytes_committed;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - The WQE index (from beginning of the relevant queue, in WQEBB 
units) where the fault occurred */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t wqe_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Length of memory access operation that experienced a page fault.
For page faults on send operations in the responder side we need to know 
how much of the WQE's memory we must fetch successfully. We may 
try to fetch more of the WQE's memory, beyond the needs of the current 
packet, but a failure to do that will not cause a QP error. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t len;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The QP
 number on which the fault occurred */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t qpn;
	/* Description - If set, the fault happened on the requestor (initiator) side of the QP.
Not set - responder side of the QP */
	/* 0x18.24 - 0x18.24 */
	 u_int8_t requestor;
	/* Description - If set, the operation attempted was writing memory. 
Not set - reading from memory */
	/* 0x18.25 - 0x18.25 */
	 u_int8_t write_read;
	/* Description - 1 - RDMA associated page fault
0 - WQE associated page fault */
	/* 0x18.26 - 0x18.26 */
	 u_int8_t rdma;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_qp_events {
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Queue type
0: QP
1: RQ
2: SQ */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t type;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Indicates 
QPN, 
SQN or RQN depending on type field. */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t qpn_rqn_sqn;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_dct_events {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t dctn;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_comp_event {
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t cqn;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_sw_eqe_flat_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 u_int32_t data[7];
};

/* Description -  each response contain a place holder for ph oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_ph_oem_resp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x60.31 */
	 struct connectx4lx_get_oem_ph_host_network_parameters_response get_host_network_parameters;
};

/* Description -  each response contain a place holder for lled oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_lled_oem_resp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x68.31 */
	 struct connectx4lx_lled_get_interface_info_resp get_interface_info;
	/* Description -  */
	/* 0x0.0 - 0x38.31 */
	 union connectx4lx_lled_get_interface_sensor_resp get_interface_sensor;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_get_lldp_resp get_lldp;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_lled_get_inventory_resp get_inventory;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_lled_get_teaming_info_resp get_teaming_info;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_lled_get_temperature_resp get_temperature;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_lled_get_os_driver_version_resp get_os_driver_version;
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_lled_get_rdma_stat_resp get_rdma_stat;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_lled_get_sup_ver_resp get_sup_ver;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_set_address_resp set_address;
	/* Description - get_address resp layout is the same as set_address cmd */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_lled_set_address_cmd get_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_pt_control_cmd_resp get_pt_control;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_get_iscsi_boot_init_config_resp get_iscsi_boot_init_config;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_lled_set_iscsi_boot_init_config_resp set_iscsi_boot_init_config;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp get_iscsi_boot_tgt_config;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp set_iscsi_boot_tgt_config;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_lled_get_part_info_resp get_part_info;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_lled_get_ext_cap_resp get_ext_cap;
};

/* Description -  each response contain a place holder for mlnx oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_mlnx_oem_resp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_mlnx_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_set_mc_affinity_resp set_mc_affinity;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_get_allocated_management_address_resp get_allocated_management_address;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_get_pf_mac_address_resp get_pf_mac_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_reset_nic reset_nic;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_mlnx_oem_resp_get_temperature get_temperature;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mlnx_oem_resp_get_set_addresses get_addresses;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mlnx_oem_resp_get_set_addresses set_addresses;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_get_port_led_control_resp get_port_led_control;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_set_port_led_control_resp set_port_led_control;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_get_addresses_groups_count_resp get_addresses_groups_count;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_set_pf_mac_address_resp set_pf_mac_address;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_get_flex_filter_mask_length_resp get_flex_filter_mask_length;
	/* Description -  */
	/* 0x0.0 - 0x88.31 */
	 struct connectx4lx_get_flex_filter_data_resp get_flex_filter_data;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_temperature_control_data get_temperature_control;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_temperature_control_data set_temperature_control;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mellanox_aen_control get_mellanox_aen_control;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mellanox_aen_control set_mellanox_aen_control;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_get_pt_stat {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t pt_tx_packets_received_hi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t pt_tx_packets_received_lo;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t pt_tx_packets_dropped;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t pt_tx_channel_state_error;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t pt_tx_packet_undersized_error;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t pt_tx_packet_oversized_error;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t pt_rx_packets_received;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t pt_rx_packets_dropped;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t pt_rx_channel_state_error;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t pt_rx_packet_undersized_error;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t pt_rx_packet_oversized_error;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_get_control_stat {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t ncsi_commands_received;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t ncsi_control_packets_dropped;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ncsi_command_type_error;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ncsi_command_checksum_error;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t ncsi_receive_packets;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t ncsi_transmit_packets;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t aens_sent;
};

/* Description -   */
/* Size in bytes - 200 */
struct connectx4lx_get_port_stat {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t counters_cleared_from_last_read_hi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t counters_cleared_from_last_read_lo;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t total_bytes_received_hi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t total_bytes_received_lo;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t total_bytes_transmitted_hi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t total_bytes_transmitted_lo;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t total_unicast_packets_received_hi;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t total_unicast_packets_received_lo;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t total_multicast_packets_received_hi;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t total_multicast_packets_received_lo;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t total_broadcast_packets_received_hi;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t total_broadcast_packets_received_lo;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t total_unicast_packets_transmitted_hi;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t total_unicast_packets_transmitted_lo;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t total_multicast_packets_transmitted_hi;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t total_multicast_packets_transmitted_lo;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t total_broadcast_packets_transmitted_hi;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t total_broadcast_packets_transmitted_lo;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t fcs_receive_errors;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t alignment_errors;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t false_carrier_detections;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t runt_packets_received;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t jabber_packets_received;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t pause_xon_frames_received;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t pause_xoff_frames_received;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t pause_xon_frames_transmitted;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t pause_xoff_frames_transmitted;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t single_collision_transmit_frames;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t multiple_collision_transmit_frames;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description -  */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t late_collision_frames;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t excessive_collision_frames;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description -  */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t control_frames_received;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t byte_frames_received_64;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t byte_frames_received_65_127;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description -  */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t byte_frames_received_128_255;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description -  */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t byte_frames_received_256_511;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description -  */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t byte_frames_received_512_1023;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t byte_frames_received_1024_1522;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description -  */
	/* 0x98.0 - 0x9c.31 */
	 u_int32_t byte_frames_received_1523_9022;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description -  */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t byte_frames_transmitted_64;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description -  */
	/* 0xa0.0 - 0xa4.31 */
	 u_int32_t byte_frames_transmitted_65_127;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description -  */
	/* 0xa4.0 - 0xa8.31 */
	 u_int32_t byte_frames_transmitted_128_255;
/*---------------- DWORD[42] (Offset 0xa8) ----------------*/
	/* Description -  */
	/* 0xa8.0 - 0xac.31 */
	 u_int32_t byte_frames_transmitted_256_511;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description -  */
	/* 0xac.0 - 0xb0.31 */
	 u_int32_t byte_frames_transmitted_512_1023;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description -  */
	/* 0xb0.0 - 0xb4.31 */
	 u_int32_t byte_frames_transmitted_1024_1522;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description -  */
	/* 0xb4.0 - 0xb8.31 */
	 u_int32_t byte_frames_transmitted_1523_9022;
/*---------------- DWORD[46] (Offset 0xb8) ----------------*/
	/* Description -  */
	/* 0xb8.0 - 0xbc.31 */
	 u_int32_t valid_bytes_received_hi;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description -  */
	/* 0xbc.0 - 0xc0.31 */
	 u_int32_t valid_bytes_received_lo;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0xc4.31 */
	 u_int32_t error_runt_packets_received;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc8.31 */
	 u_int32_t error_jabber_packets_received;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_get_capabilities {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_capability_flags capability_flags;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_broadcast_filter_settings broadcast_filter_settings;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_multicast_filter_settings multicast_filter_settings;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t buffering_capability_field;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_aen_control_support_field aen_control_support_field;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t unicast_filter_count_field;
	/* Description -  */
	/* 0x14.8 - 0x14.15 */
	 u_int8_t multicast_filter_count_field;
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t mixed_filter_count_field;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t vlan_filter_count_field;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.7 */
	 u_int8_t channel_count;
	/* Description -  */
	/* 0x18.8 - 0x18.8 */
	 u_int8_t vlan_only;
	/* Description -  */
	/* 0x18.9 - 0x18.9 */
	 u_int8_t vlan_and_non_vlan;
	/* Description -  */
	/* 0x18.10 - 0x18.10 */
	 u_int8_t any_vlan_and_non_vlan;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_get_version_id {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t alpha1;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t update;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t minor;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t major;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t alpha2;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t fw_name_str2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t fw_name_str1;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t fw_name_str0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t fw_version;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t pci_vid;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t pci_did;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t pci_svid;
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t pci_ssid;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t manufacturer_id;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_get_params_response {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t mac_address_flags;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t mac_address_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t vlan_tag_flags;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t vlan_tag_count;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_link_settings link_settings;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_broadcast_filter_settings broadcast_filter_settings;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_configuration_flags conf_flags;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t flow_control_enable;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t vlan_mode;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t aen_control;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - as array of words */
	/* 0x1c.16 - 0x6c.15 */
	 u_int16_t macs_and_vlan_tags[40];
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_get_link_status_response {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_link_status_field link_status_field;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t other_indications;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t oem_link_status;
};

/* Description -  each command contain a place holder for ph oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_ph_oem_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_get_oem_ph_host_network_parameters_request get_host_network_parameters;
};

/* Description -  each command contain a place holder for lled oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_lled_oem_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_lled_get_os_driver_version_cmd get_os_driver_version;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_get_rdma_stat_cmd get_rdma_stat;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_lled_set_address_cmd set_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_get_address_cmd get_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_pt_control_cmd_resp set_pt_control;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lled_pt_control_cmd_resp get_pt_control;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_lled_get_teaming_info_cmd get_teaming_info;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_lled_get_iscsi_boot_init_config_cmd get_iscsi_boot_init_config;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_set_iscsi_boot_init_config_cmd set_iscsi_boot_init_config;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd get_iscsi_boot_tgt_config;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd set_iscsi_boot_tgt_config;
};

/* Description -  each command contain a place holder for mlnx oem cmd hdr */
/* Size in bytes - 256 */
union connectx4lx_mlnx_oem_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_mlnx_oem_hdr hdr;
	/* Description -  */
	/* 0x0.0 - 0x3c.31 */
	 struct connectx4lx_set_mc_affinity set_mc_affinity;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_get_allocated_management_address get_allocated_management_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_get_pf_mac_address get_pf_mac_address;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_reset_nic reset_nic;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_mlnx_oem_cmd_get_temperature get_temperature;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_mlnx_oem_cmd_get_addresses get_addresses;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_mlnx_oem_cmd_set_addresses set_addresses;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_get_port_led_control get_port_led_control;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_set_port_led_control set_port_led_control;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_set_pf_mac_address set_pf_mac_address;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_get_flex_filter_mask_length get_flex_filter_mask_length;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_get_flex_filter_data get_flex_filter_data;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_temperature_control_data get_temperature_control;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_temperature_control_data set_temperature_control;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_get_mellanox_aen_control get_mellanox_aen_control;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_mellanox_aen_control set_mellanox_aen_control;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_set_ncsi_flow_control {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t flow_control_enable;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_disable_channel {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Allow Link Down */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ald;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_aen_enable {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t aen_mc_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t link_status_change_aen_control;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t configuration_required_aen_control;
	/* Description -  */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t host_nc_driver_status_change_aen_control;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t oem_specific_aen_control;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_set_link_cmd_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_link_settings link_settings;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_enable_vlan_cmd_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t mode;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_set_vlan_cmd_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vlan;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t enable;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t filter_selector;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_set_mac_cmd_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t mac_31_16;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t mac_47_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t enable;
	/* Description -  */
	/* 0x4.5 - 0x4.7 */
	 u_int8_t addr_type;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t addr_num;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t mac_15_0;
};

/* Description -   */
/* Size in bytes - 268 */
struct connectx4lx_generic_flash_reg_access_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 union connectx4lx_reg_access_reg_tlv_data reg_data;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - reg access is shared with smp mads that are limited to 0x40B */
	/* 0x2c.0 - 0x10c.31 */
	 u_int32_t more_data[56];
};

/* Description -   */
/* Size in bytes - 264 */
union connectx4lx_access_register_data_layout {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_mcam_reg mcam_reg;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_pcam_reg pcam_reg;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_qetcr_reg qetcr;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_qpdp_reg qpdp;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_qtct_reg qtct;
	/* Description - Table 363 - QHLL - QoS Head of Queue Lifetime Limit Register Layout */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_qhll qhll;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_mlcr mlcr;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dcbx_param_reg dcbx;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_dcbx_app_reg dcbx_app;
	/* Description - register_set_node */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_register_set_node register_set_node;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_access_register_unit_perf_counters_cfg perf_counters_cfg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_access_register_unit_perf_counters_data perf_counters_data;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_unit_perf_counters_global_ctrl perf_counters_global_ctrl;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_access_register_unit_port_capabilities port_capabilities_reg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_pfcc_reg port_flow_control_cfg_reg;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_loopback_control loopback_control_reg;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_power_settings power_settings_reg;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_fp_sl_map fp_sl_map_reg;
	/* Description - register_host_endianness layout */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_host_endianness register_host_endianness;
	/* Description - register_pplr */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_register_pplr register_pplr;
	/* Description - misc_counters */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_register_misc_counters misc_counters;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_db_threshold_register_layout db_threshold;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_register_mfpa flash_mfpa;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_register_mfba flash_mfba;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_register_mfbe flash_mfbe;
	/* Description - Table 236 - PAOS - Ports Administrative and Operational Status Register Layout */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_paos_reg access_register_paos;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pmtu_reg access_register_pmtu;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_pmlp_reg access_register_pmlp;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_ptys_reg access_register_ptys;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_ppcnt_reg access_register_ppcnt;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pvlc_reg access_register_pvlc;
	/* Description - Table 307 - [Internal] PPAMP - Port Phy opAMP data Register Layout */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_pamp_reg access_register_pamp;
	/* Description - Table 315 - PTAS - Phy Tuning Algorithm Settings Register Layout */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_ptas_reg access_register_ptas;
	/* Description - Table 313 - SLRG - Serdes Lane Receive Grade Register Layout */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_slrg_reg access_register_slrg;
	/* Description - Serdes Lane Receive Parameters */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_slrp_reg access_register_slrp;
	/* Description - Table 311 - [Internal] SLTP - Serdes Lane Transmit Parameters Register Layout */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_sltp_reg access_register_sltp;
	/* Description - Table 291 - PPLR - Port Physical Loopback Register Layout */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_pplr_reg access_register_pplr;
	/* Description - Table 297 - PLPC - Phy Link Profiles Control Register Layout */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_plpc_reg access_register_plpc;
	/* Description - Table 299 - PPLM - Port Phy Link Mode Register Layout */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_pplm_reg access_register_pplm;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ppad_reg access_register_ppad;
	/* Description - mcia - misc cable info access */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_mcia_reg access_register_mcia;
	/* Description - Table 438 - pcie info register */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_mpein_reg access_register_mpein;
	/* Description - Table 440 */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_mpcnt_reg access_register_mpcnt;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_pddr_reg access_register_pddr;
	/* Description - Table 440 */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_mcion_reg access_register_mcion;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_pptt_reg access_register_pptt;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_pprt_reg access_register_pprt;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ppaos_reg access_register_ppaos;
	/* Description - Table 406 - PCMR - Ports Check Mask Register Layout */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_pcmr_reg access_register_pcmr;
	/* Description - Port Module Memory Map Properties Register */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_pmmp_reg access_register_pmmp;
	/* Description - Port Module Control Register */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_pmcr_reg access_register_pmcr;
	/* Description - Table 344 - FPGA_ACCESS_REG_SPACE Register Layout */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_fpga_access_reg fpga_access_reg;
	/* Description - Table 338 - FPGA_CAP Register Layout */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_fpga_cap fpga_cap;
	/* Description - Table 342 - FPGA_CTRL Register Layout */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_fpga_ctrl fpga_ctrl;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_mtpps_reg access_register_mtpps;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_mtppse_reg access_register_mtppse;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pmaos_reg access_register_pmaos;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_scheduling_context {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Type of Scheduling Element
0x0: TSAR
0x1: VPORT
0x2: VPORT_TC
0x3: PARA_VPORT_TC
other values are reserved */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t element_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Specific attributes according to the 
element_type
.
TSAR - 
 See Table 1465, "
TSAR Element Attributes Format
," on 
page 1082
VPORT - 
 See Table 1467, "
VPORT Element Attributes Format
," on 
page 1082
VPORT_TC - 
 See Table 1469, "
VPORT_TC Element Attributes 
Format
," on page 1083
PARA_VPORT_TC - 
 See Table 1471, "
PARA_VPORT_TC Ele
ment Attributes Format
," on page 1083 */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t element_attributes;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Identifier of the Scheduling element to which the created Scheduling 
element will be connected. This field is reserved for the root TSAR. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t parent_element_id;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - The relative BW share allocated for this element. This field has no 
units. The BW is shared between all elements connected to the same 
parent element, relatively to their 
bw_share
.
Value 0x0 indicates a device default Weight. This field is reserved 
for the root TSAR */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t bw_share;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - The maximal transmission rate allowed for the element, averaged 
over time. 
Value is given in units of 1 Mbit/sec.
Value 0x0 indicates the rate is unlimited. */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t max_average_bw;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fw_ipoib_meta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t q_key;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t pkey_index;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_q_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t duplicate_request;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rnr_nack_retry_err;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t packet_seq_err;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t implied_nack_seq_err;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t local_ack_timeout_err;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t resp_rnr_nak;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t req_rnr_retries_exceeded;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_fw_transport_domain {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sq_list_size;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_vqos_arb_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 arbiter is allowed to distribute tokens */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t allowed;
	/* Description - ID of the lower level arbiter */
	/* 0x0.1 - 0x0.11 */
	 u_int16_t father_id;
	/* Description - arbiter's weight for consuming tokens */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t weight;
	/* Description - Sum of childrens weights */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t sum_of_weights;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - arbiters amount of tokens */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t token_count;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - cweight for rate limiter */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t cweight;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - ctoken count */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ctoken_count;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - indication for being the first sq to need tokens from father */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t i_am_first;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dc_control_packet_desc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t dlid;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t slid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t source_qp;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t valid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t dest_qp;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t psn;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t pkey;
	/* Description -  */
	/* 0x10.16 - 0x10.19 */
	 u_int8_t sl;
	/* Description -  */
	/* 0x10.20 - 0x10.20 */
	 u_int8_t port_id;
	/* Description -  */
	/* 0x10.21 - 0x10.21 */
	 u_int8_t has_grh;
	/* Description -  */
	/* 0x10.22 - 0x10.22 */
	 u_int8_t force_loopback;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t dct_gvmi;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.7 */
	 u_int8_t tclass;
	/* Description -  */
	/* 0x18.8 - 0x18.15 */
	 u_int8_t hop_limit;
	/* Description -  */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t flow_label;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x30.31 */
	 struct connectx4lx_ib_gid dgid;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 struct connectx4lx_ib_gid sgid;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_dmfs_resources {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dmfs_fg_meta fg_meta;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dmfs_ft_meta ft_meta;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dmfs_fte_meta fte_meta;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_l2_table_entry_fw_ctx l2_table_entry_fw_ctx;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_flow_counter_fw_ctx flow_counter_fw_ctx;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_dmfs_encap_meta encap_meta;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_list_element {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.24 */
	 u_int32_t next;
	/* Description -  */
	/* 0x0.25 - 0x0.30 */
	 u_int8_t list_ix;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t in_list;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.24 */
	 u_int32_t prev;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_fw_rqt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t rqt_max_size;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t rqt_actual_size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t lro_max_ip_payload_size;
	/* Description -  */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t lro_enable_mask;
	/* Description -  */
	/* 0x8.12 - 0x8.12 */
	 u_int8_t tunneled_offload_en;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t lro_timeout_period_usecs;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.1 */
	 u_int8_t rss_qpn_size;
	/* Description -  */
	/* 0xc.2 - 0xc.25 */
	 u_int32_t rss_indirection_table_base_qpn;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rqt_hw_data_ix;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t rqt_fw_data_ix;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fw_cqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x0 = Ok
0x1 = Error: CQ Overrun
0x2 = Error: Access Violation */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t cq_status;
	/* Description -  */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t trap_reason;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t in_cq_overrun_list;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t in_eq_overrun_list;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_psv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t pd;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t fw_marked_sigerr;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fw_mkc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.30 */
	 u_int32_t state;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t sync_umr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_mkey_dump mkey_dump;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t next_num_of_sigerr;
	/* Description -  */
	/* 0xc.1 - 0xc.1 */
	 u_int8_t pg_access;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_fw_cre {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_srqc fw_srqc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_qpc fw_qpc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_tir fw_tir;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_tis fw_tis;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_basic_res_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_fw_alt_path {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - ads layout */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_sw_ads alt;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_fw_eqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Note: ref_counter must be in offset 0x0 ! */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_ref_count fw_ref_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x0 = Ok
0x2 = Error: Access Violation */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t eq_status;
	/* Description -  */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t trap_reason;
	/* Description -  */
	/* 0x4.16 - 0x4.20 */
	 u_int8_t log_page_size;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t needs_eq_probe;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t in_eq_overrun_list;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_gvmi_counter {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t octets_63_56;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t octets_55_24;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t packets_39_32;
	/* Description -  */
	/* 0x8.8 - 0x8.31 */
	 u_int32_t octets_23_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t packets_31_0;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_qp_counter {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - RX only */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t write_req;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - RX only */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t read_req;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - RX only */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t out_of_sequence;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - RX only */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t out_of_buffer_drop;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - RX only */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t dc_connect_ack;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - RX only */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t dc_connect;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - RX only */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t config_opcode_counter;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - RX only */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t atomic_req;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_gid_mac_table_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NO_DESCR */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t gid_prefix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - NO_DESCR */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t guid;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - NO_DESCR */
	/* 0x10.0 - 0x1c.31 */
	 struct connectx4lx_gid_mac_l2_entry l2_address;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_msix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - pci spec msix vector */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_hw_msix_context msix_context;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - msix extended context */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_hw_msix_ext_context msix_ext_context;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_rdb {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t opcode;
	/* Description - TODO: need to align this field to 32. */
	/* 0x0.8 - 0x0.31 */
	 u_int32_t psn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t r_key;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t address_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t address_31_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t byte_count;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.7 - 0x14.7 */
	 u_int8_t can_use_reserved_lkey;
	/* Description - TODO: need to align this field to 32. */
	/* 0x14.8 - 0x14.31 */
	 u_int32_t pd;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - new name for fw_marked_as_read */
	/* 0x1c.0 - 0x1c.0 */
	 u_int8_t allow_excessiveness;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_hw_rdb_atomic_data atomic_data;
};

/* Description -   */
/* Size in bytes - 8 */
union connectx4lx_icm_mtt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_hw_mtt hw;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_hw_mtt2 as_dw;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_steering_entry_icmc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_ste hw_ste;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_steering_qp_list steering_qp_list;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_hw_pkey {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NO_DESCR */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t pkey;
};

/* Description -  the timer is 8 bit, this is an adapter to node to unions */
/* Size in bytes - 4 */
struct connectx4lx_hw_timer_32 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 struct connectx4lx_hw_timer hw_timer;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_hw_sq_qp_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  QPN QP number */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t qpi;
	/* Description -  DCR if this bit is set, the QP came from DCR DB */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t global_gvmi;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_hw_pipa {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Producer Index Physical Address */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t pa_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - if 0, there will not br recovery on this QPn */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t recovery_en;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t always_zero;
	/* Description -  Producer Index Physical Address */
	/* 0x4.2 - 0x4.31 */
	 u_int32_t pa_31_2;
};

/* Description -   */
/* Size in bytes - 8 */
union connectx4lx_hw_sxdc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_uar uar;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_swqe_producer_index swqe_producer_index;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_sq sq;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_valid valid;
	/* Description - only when set external DB are accepted by the device, when cleared they are silently dropped */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_external_db_en external_db_en;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_fast_path fast_path;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_doorbell_int doorbell_int;
	/* Description - QP should not be scheduled when popping from the SQ but go the FW state */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_scheduling_interrupt_responder scheduling_interrupt_responder;
	/* Description - QP should not be scheduled when popping from the SQ but go the FW state Golan name: schedualing_interrupt */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_scheduling_interrupt_requestor scheduling_interrupt_requestor;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_responder_in_sq responder_in_sq;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_sxdc_requestor_in_sq requestor_in_sq;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_klm_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - NO_DESCR */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t length;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - NO_DESCR */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t key;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - NO_DESCR */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t va;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_sq_tokens {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  number of tokens to transfer in case the SQ has WareHouse QPs */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t ware_house_burst_size_23_8;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  Number of bytes for transmission by SXW for a QP popped from this SQ responder queue */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t responder_burst_size;
	/* Description -  number of tokens to transfer in case the SQ has WareHouse QPs */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t ware_house_burst_size_7_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  Number of bytes for transmission by SXW for a QP popped from this SQ requestor queue */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t requestor_burst_size;
	/* Description -  */
	/* 0x8.24 - 0x8.28 */
	 u_int8_t log2qp_rate_limiter_time;
	/* Description -  */
	/* 0x8.29 - 0x8.31 */
	 u_int8_t reserved0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  Number of bytes to add to GvmiTokenCount from GVMI tokens pool */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t gvmi_vl_weight;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t reserved1;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  Number of bytes allocated to the SQ from the GVMI tokens pool */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t gvmi_vl_token_count;
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t reserved2;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  Maximum value of GvmiVlTokenCount */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t gvmi_vl_saturation;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t reserved3;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  Number of bytes to add to SwitchTokenCount during reset event of SQ-to-SL virtual switch arbiter */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t dwrr_weight;
	/* Description -  */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t reserved4;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  Number of Tokens that the SQ has to Transfer to the SXW from the DWRR token Count */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t dwrr_token_count;
	/* Description -  */
	/* 0x1c.24 - 0x1c.27 */
	 u_int8_t vl;
	/* Description -  */
	/* 0x1c.28 - 0x1c.30 */
	 u_int8_t vlg;
	/* Description -  */
	/* 0x1c.31 - 0x1c.31 */
	 u_int8_t port;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_gvmi_tokens {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t reserved4;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t reserved5;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  Maximum value in *_token_count = (2 ^ *_weight_saturation - 1); must be  <= 23 to allow negative tokens */
	/* 0x8.0 - 0x8.4 */
	 u_int8_t port1_avg_saturation;
	/* Description -  VL group that will get tokens in next distribution cycle; updated during token reset cycle */
	/* 0x8.5 - 0x8.7 */
	 u_int8_t port1_high_vlg_req_token;
	/* Description -  port1_avg_time Log2 of the number of token distribution cycles to wait before adding tokens to average bandwidth bucket */
	/* 0x8.8 - 0x8.12 */
	 u_int8_t port1_log2avg_time;
	/* Description -  Maximum bucket bandwidth = weight_mantissa * 2^weight_exp, in bytes */
	/* 0x8.13 - 0x8.15 */
	 u_int8_t port1_max_weight_exp;
	/* Description -  port1_max_time Log2 of the number of token distribution cycles to wait before adding tokens to maximum bandwidth bucket */
	/* 0x8.16 - 0x8.20 */
	 u_int8_t port1_log2max_time;
	/* Description -  port0_has_tokens During token distribution cycle (from GVMI to SQ), indicates if maximum bandwidth bucket had tokens at the beginning of the cycle */
	/* 0x8.21 - 0x8.21 */
	 u_int8_t port0_has_token;
	/* Description -  VL group that will get tokens in next distribution cycle; updated during token reset cycle */
	/* 0x8.22 - 0x8.22 */
	 u_int8_t port0_vlg_req_vld;
	/* Description -  During token distribution cycle (from GVMI to SQ), indicates if maximum bandwidth bucket had tokens at the beginning of the cycle */
	/* 0x8.23 - 0x8.23 */
	 u_int8_t port1_has_token;
	/* Description -  Maximum value in *_token_count = (2 ^ *_weight_saturation - 1); must be  <= 23 to allow negative tokens */
	/* 0x8.24 - 0x8.28 */
	 u_int8_t port1_max_saturation;
	/* Description -  VL group that will get tokens in next distribution cycle; updated during token reset cycle */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t port1_vlg_req_vld;
	/* Description -  */
	/* 0x8.30 - 0x8.31 */
	 u_int8_t reserved6;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  Maximum value in *_token_count = (2 ^ *_weight_saturation - 1); must be  <= 23 to allow negative tokens */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t port0_avg_saturation;
	/* Description -  Maximum bucket bandwidth = weight_mantissa * 2^weight_exp, in bytes */
	/* 0xc.5 - 0xc.7 */
	 u_int8_t port0_avg_weight_exp;
	/* Description -  port0_avg_time Log2 of the number of token distribution cycles to wait before adding tokens to average bandwidth bucket */
	/* 0xc.8 - 0xc.12 */
	 u_int8_t port0_log2avg_time;
	/* Description -  VL group that will get tokens in next distribution cycle; updated during token reset cycle */
	/* 0xc.13 - 0xc.15 */
	 u_int8_t port0_high_vlg_req_token;
	/* Description -  port0_max_time Log2 of the number of token distribution cycles to wait before adding tokens to maximum bandwidth bucket */
	/* 0xc.16 - 0xc.20 */
	 u_int8_t port0_log2max_time;
	/* Description -  Maximum bucket bandwidth = weight_mantissa * 2^weight_exp, in bytes */
	/* 0xc.21 - 0xc.23 */
	 u_int8_t port0_max_weight_exp;
	/* Description -  Maximum value in *_token_count = (2 ^ *_weight_saturation - 1); must be  <= 23 to allow negative tokens */
	/* 0xc.24 - 0xc.28 */
	 u_int8_t port0_max_saturation;
	/* Description -  Average bucket bandwidth = weight_mantissa * 2^weight_exp, in bytes */
	/* 0xc.29 - 0xc.31 */
	 u_int8_t port1_avg_weight_exp;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  Maximum bandwidth bucket token count */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t port1_max_token_count;
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t port1_max_weight_mantissa;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  Average bandwidth bucket token count */
	/* 0x14.0 - 0x14.23 */
	 u_int32_t port1_avg_token_count;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t port1_avg_weight_mantissa;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  Maximum bandwidth bucket token count */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t port0_max_token_count;
	/* Description -  */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t port0_max_weight_mantissa;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  Average bandwidth bucket token count */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t port0_avg_token_count;
	/* Description -  */
	/* 0x1c.24 - 0x1c.31 */
	 u_int8_t port0_avg_weight_mantissa;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hw_sq_pointers {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  weight of requestor for dwrr between requstor and responder */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t weight_requestor;
	/* Description - NO_DESCR */
	/* 0x0.10 - 0x0.15 */
	 u_int8_t sq_offset_11_6;
	/* Description -  weight of responder for dwrr between requstor and responder */
	/* 0x0.16 - 0x0.25 */
	 u_int16_t weight_responder;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t reserved0;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t qp_rate_limiter_en;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t qp_rate_limiter_scheduling_count_15_12;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  Guest Virtual Machine ID */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description -  requestor_responder_dwrr_token number of corrent tokens for corrent LastGntRequestor */
	/* 0x4.16 - 0x4.25 */
	 u_int16_t token;
	/* Description - NO_DESCR */
	/* 0x4.26 - 0x4.31 */
	 u_int8_t sq_offset_5_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  ware_house_counter_responder Number of responder QPs unscheduled back into the SQ due to lack of VL credits */
	/* 0x8.0 - 0x8.24 */
	 u_int32_t ware_house_counter_responder;
	/* Description -  */
	/* 0x8.25 - 0x8.27 */
	 u_int8_t reserved1;
	/* Description -  */
	/* 0x8.28 - 0x8.31 */
	 u_int8_t qp_rate_limiter_scheduling_count_11_8;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  ware_house_counter_requestor Number of requestor QPs unscheduled back into the SQ due to lack of VL credits */
	/* 0xc.0 - 0xc.24 */
	 u_int32_t ware_house_counter_requestor;
	/* Description -  */
	/* 0xc.25 - 0xc.27 */
	 u_int8_t reserved2;
	/* Description -  */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t qp_rate_limiter_scheduling_count_7_4;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  responder_push_pointer responder push pointer at the SQ */
	/* 0x10.0 - 0x10.24 */
	 u_int32_t push_pointer_responder;
	/* Description -  */
	/* 0x10.25 - 0x10.27 */
	 u_int8_t reserved3;
	/* Description -  */
	/* 0x10.28 - 0x10.31 */
	 u_int8_t qp_rate_limiter_scheduling_count_3_0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  requestor_push_pointer requestor push pointer at the SQ */
	/* 0x14.0 - 0x14.24 */
	 u_int32_t push_pointer_requestor;
	/* Description -  */
	/* 0x14.25 - 0x14.25 */
	 u_int8_t port;
	/* Description -  scheduling_interrupt if set QPs at this SQ will not be sched to the SXW, but will move to FW state at the scheduling slices */
	/* 0x14.26 - 0x14.26 */
	 u_int8_t scheduling_interrupt;
	/* Description -  */
	/* 0x14.27 - 0x14.27 */
	 u_int8_t reserved4;
	/* Description -  Virtual lane */
	/* 0x14.28 - 0x14.31 */
	 u_int8_t vl;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  responder_pop_pointer responder pop pointer at the SQ */
	/* 0x18.0 - 0x18.24 */
	 u_int32_t pop_pointer_responder;
	/* Description -  last grant ID (requestor/responder) for DWRR at the SQ */
	/* 0x18.25 - 0x18.25 */
	 u_int8_t last_gnt_requestor;
	/* Description -  Log2 size of responder schedule queue, opened in ICM for QP list */
	/* 0x18.26 - 0x18.31 */
	 u_int8_t log2_max_num_of_qp_responder;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  requestor_pop_pointer requestor pop pointer at the SQ */
	/* 0x1c.0 - 0x1c.24 */
	 u_int32_t pop_pointer_requestor;
	/* Description -  scheduling_interrupt if set QPs at this SQ will not be sched to the SXW, but will move to FW state at the scheduling slices */
	/* 0x1c.25 - 0x1c.25 */
	 u_int8_t db_interrupt;
	/* Description -  Log2 size of requestor schedule queue, opened in ICM for QP list */
	/* 0x1c.26 - 0x1c.31 */
	 u_int8_t log2_max_num_of_qp_requestor;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_hw_trasta {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t va_offset_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t va_offset_31_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t klm_index;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t invalidation_counter;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t valid;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_port_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - LID mask control for this GVMI port */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t lmc;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t reserved0_1bit;
	/* Description -  */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t host_id;
	/* Description -  */
	/* 0x0.6 - 0x0.24 */
	 u_int32_t reserved0_19bit;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t cache_line_size;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t host_endianess_responder;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t host_endianess_requestor;
	/* Description - Handling of MADs:
0 = all QP0/1 goes to SW
1 = all QP0/1 goes to FW
2 = go to FW based on MAD filter result */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t mad_filter;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - GVMI port LID */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t lid;
	/* Description -  */
	/* 0x4.16 - 0x4.27 */
	 u_int16_t default_cvlan_id;
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t default_cvlan_cfi;
	/* Description -  */
	/* 0x4.29 - 0x4.31 */
	 u_int8_t default_cvlan_pcp;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t rx_strip_cvlan;
	/* Description -  */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t rx_strip_svlan;
	/* Description -  */
	/* 0x8.2 - 0x8.2 */
	 u_int8_t rx_strip_port_extender;
	/* Description -  */
	/* 0x8.3 - 0x8.3 */
	 u_int8_t rx_gre_opaque_en;
	/* Description -  */
	/* 0x8.4 - 0x8.4 */
	 u_int8_t rx_tni_to_cqe;
	/* Description -  */
	/* 0x8.5 - 0x8.31 */
	 u_int32_t reserved1_27bit;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t sx_allow_untagged;
	/* Description -  */
	/* 0xc.1 - 0xc.1 */
	 u_int8_t sx_allow_prio_tagged;
	/* Description -  */
	/* 0xc.2 - 0xc.2 */
	 u_int8_t sx_allow_tagged;
	/* Description -  */
	/* 0xc.3 - 0xc.4 */
	 u_int8_t sx_cvlan_tagging_mode;
	/* Description -  */
	/* 0xc.5 - 0xc.7 */
	 u_int8_t sx_tag_prio_overwrite;
	/* Description -  */
	/* 0xc.8 - 0xc.9 */
	 u_int8_t sx_tag_data_size;
	/* Description -  */
	/* 0xc.10 - 0xc.10 */
	 u_int8_t sx_lso_inc_outer_ipid;
	/* Description -  */
	/* 0xc.11 - 0xc.11 */
	 u_int8_t sx_drop;
	/* Description -  */
	/* 0xc.12 - 0xc.12 */
	 u_int8_t sx_sl_diff_check_en;
	/* Description -  */
	/* 0xc.13 - 0xc.13 */
	 u_int8_t sx_sl2vl_diff_check_en;
	/* Description -  */
	/* 0xc.14 - 0xc.14 */
	 u_int8_t sx_allow_other_tagged;
	/* Description -  */
	/* 0xc.15 - 0xc.15 */
	 u_int8_t sx_rroce_udp_sport_calc_en;
	/* Description -  */
	/* 0xc.16 - 0xc.16 */
	 u_int8_t sx_encap_ecn_copy_en;
	/* Description -  */
	/* 0xc.17 - 0xc.31 */
	 u_int16_t reserved4_15bit;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.2 */
	 u_int8_t sx_prio_regen_pcp0;
	/* Description -  */
	/* 0x10.3 - 0x10.5 */
	 u_int8_t sx_prio_regen_pcp1;
	/* Description -  */
	/* 0x10.6 - 0x10.8 */
	 u_int8_t sx_prio_regen_pcp2;
	/* Description -  */
	/* 0x10.9 - 0x10.11 */
	 u_int8_t sx_prio_regen_pcp3;
	/* Description -  */
	/* 0x10.12 - 0x10.14 */
	 u_int8_t sx_prio_regen_pcp4;
	/* Description -  */
	/* 0x10.15 - 0x10.17 */
	 u_int8_t sx_prio_regen_pcp5;
	/* Description -  */
	/* 0x10.18 - 0x10.20 */
	 u_int8_t sx_prio_regen_pcp6;
	/* Description -  */
	/* 0x10.21 - 0x10.23 */
	 u_int8_t sx_prio_regen_pcp7;
	/* Description -  */
	/* 0x10.24 - 0x10.24 */
	 u_int8_t sx_prio_regen_cfi_0;
	/* Description -  */
	/* 0x10.25 - 0x10.25 */
	 u_int8_t sx_prio_regen_cfi_1;
	/* Description -  */
	/* 0x10.26 - 0x10.31 */
	 u_int8_t reserved3_6bit;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t sx_tag_data_95_64;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t sx_tag_data_63_32;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t sx_tag_data_31_0;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - NO_DESCR */
	/* 0x20.16 - 0x40.15 */
	 u_int16_t dc_rsl2sq_map[16];
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_qpc_r_dct {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_r_qpc qpc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_dct dct;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_s_qpc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_dc_access_key_31_0 dc_access_key_31_0;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_dc_access_key_63_32 dc_access_key_63_32;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_lsn lsn;
	/* Description - SX should put this field in DETH.SQPN field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_deth_sqpn deth_sqpn;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_vl15 vl15;
	/* Description - Defines the headers that must exist in the "ethernet" segment of the wqe, if the madatory header does not exist in the the wqe, packet will be dropped If parser reach a terminate header it means "everything exist" 0: none 1: L2 2: IP 3: TCP/UDP 5: inner L2 6: inner IP 7: inner TCP/UDP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_wqe_mandatory_header wqe_mandatory_header;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_software_parse_enable software_parse_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_my_mac force_my_mac;
	/* Description - when set and WQE.cvlan differ from my_gid.cvlan drop the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_cvlan force_cvlan;
	/* Description - SX WQE opcode that cause packet creation are allowed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_packet_allowed packet_allowed;
	/* Description - Hermon name: ethertype_enforce_mode */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable sx_ethertype_check_enable;
	/* Description - number of packets since msg start for LSO IPv4.ID calculation in hermon was part of SSN */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_packet_count_in_message packet_count_in_message;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_dscp dscp;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_cq_number cq_number;
	/* Description - index to the counters table 0-disable */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_counter_index counter_index;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_next_to_send_psn next_to_send_psn;
	/* Description - ROCE over GRH: never force ROCE over IP/ETH: force IP.DSCP with QPC.tclass[7:2] XoIB: force IP.DSCP with QPC.dscp in the internal packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_dscp force_dscp;
	/* Description - ROCE over GRH (never force) ROCE over IP/ETH: force IP.ECN with QPC.tclass[1:0] XoIB: force IP.ECN with QPC.dscp in the internal packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_ecn force_ecn;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ecn ecn;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_umr_permission_select umr_permission_select;
	/* Description - In ROCE this is field is valid only when cntag_enable=1 and will hold the cntag.flowid field in R-ROCE this holds the congestion flowid (does not exist in the packet) TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_cntag_flowid cntag_flowid;
	/* Description - insert cntag to the packet TODO: this is invalid for ETHOIB (must be set to 0), delete on next project */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_cntag_enable cntag_enable;
	/* Description - in the below description the size relates to the operands size (meaning: size of each operand) 0: disable atomic 1: IB spec (responder extended RDB is N/A) all enum from here support extended atomic in addition 2: only 8B (hermon mode, responder extended RDB is N/A) 3: up to 8B (also 4B, responder extended RDB is N/A) 4: up to 16B (responder extended RDB is N/A) 5: up to 32B (responder extended RDB is N/A) 6: up to 64B (responder extended RDB is 64B) 7: up to 128B (responder extended RDB is 128B) 8: up to 256B (responder extended RDB is 256B) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_extended_atomic extended_atomic;
	/* Description - Transport service (0-7: same as packet.BTH.opcode[7:5]) 0-RC 1-UC 2-RD 3-UD 5-XRC (SRC in hermon) 8-ETHoIB (driver is ETHoIB) 9-IPoIB (driver is IPoIB) 11-DCI/DCR 12-DCT 14-ETH (Hermon name: L2, if l2_type&lt;=1 this is ETHoIB encapsulation) 15-IBL2 (Hermon name: MLX, Golan name: L2) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ts ts;
	/* Description - How many bytes were sent from current WQE IB: in chuncks of 256B LSO (UD/L2): byte granularty */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_sx_gather_commit sx_gather_commit;
	/* Description - When set: gid index is taken from qpc.my_gid FW must also set grh_bit=1 Golan name: force_my_gid_index */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_my_gid_mac_index force_my_gid_mac_index;
	/* Description - Counts number of outstanding reads and atomic */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_number_outstanding_reads number_outstanding_reads;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_swqe_consumer_index swqe_consumer_index;
	/* Description - index updated when poping from ldb (ldb_index) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_currently_completing_wqe_index currently_completing_wqe_index;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing first_psn_of_message_currently_completing;
	/* Description - ACKREQ_PSN (PSN of last packet sent with ACKREQ=1, virtual field for timer decision) = QP.next_to_send_psn - 1 - QP.PSN_since_ACKREQ */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_psn_since_ackreq psn_since_ackreq;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_requestor_session_id requestor_session_id;
	/* Description - value 0 means that we are not in the middle of a read response read middle: if DS is too big rx slice should skip the REQSL machine */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_currently_completing_ds currently_completing_ds;
	/* Description - link_type_mac=0 (IB): LRH.SL is taken from QP.SL and not from WQE link_type_mac=1 (ETH): replace the packet's vlan prio with QP.vlan_prio field, or add prio tagged for untagged packets */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_sl force_sl;
	/* Description - in IB native force GRH.TCLASS with QPC.tclass */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_force_grh_tclass force_grh_tclass;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ssn ssn;
	/* Description - Payload mtu in bytes Used in ETHoIB and IPoIB comparing IB payload including insertions, and "TS=ETH with port_type=IB" */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_mtu_byte mtu_byte;
	/* Description -  2^value is the frequency at which we send ackreq.valid. values are 0-8 giving ackreq bit per 1-256 packets */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ack_req_frequency ack_req_frequency;
	/* Description - Controls handling of packets with correct and incorrect PSN and opcode sequences 0: Unconnected - QPC ePSN and opcode sequence are invalid 1:Connected (good flow) - QPC.ePSN and correct opcode sequence are forwarded; everything else triggers FW 2: Resync xxtate QPC.ePSN and correct opcode sequence will cause HW to move QPC to Connected state; everything else is dropped 3: Closed - everything is dropped in RXT HW writes to this field in RNR-nack flow */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_connection_state connection_state;
	/* Description - 0: disable - data will always be scattered accoding to the scatter entry 1: up to 32B - if payload&lt;=32B, data should be scattered into the CQE (inline) 2: up to 64B - if payload&lt;=64B, data should be scattered into the CQE (inline) Hermon: disable_inline_scatter */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_inline_scatter inline_scatter;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_oldest_non_acked_psn oldest_non_acked_psn;
	/* Description - allowed bit mask for gid_mac_table.roce_type */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_allow_roce_type allow_roce_type;
	/* Description - bit[1] allow grh bit[0] allow local route */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_allow_grh_type allow_grh_type;
	/* Description - This is part of an adaptive algorithm for optimisation SX WQ fetch 0-6 limit the number of fetched WQBB (64B) to 2^N 7-don't limit */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit sx_wq_fetch_limit;
	/* Description - Hermon name: bind_enable */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_umr_enable umr_enable;
	/* Description - 0-no limit 1-outstanding reads 2-fence 3-strong ordering 4-only FW can exit from the limited state 5-outstanding psn 6-dc wait for connect 7-e2e credit (limited state) 8-DC disconnect work done (wait for all acks before sending disconnect) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_limited_qp limited_qp;
	/* Description - 0: not connected 1: connect packet sent 2: connect was acked */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_dc_state dc_state;
	/* Description - When QP.enhanced_steering or GVMI.enhanced_steering do source steering first (and only than destination steering) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_sx_steering_root sx_steering_root;
	/* Description - When this bit is set HW will compare WQE.wqe_index field with CI. In case of mismatch a WQE error will occur, and FW will close the QP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_wqe_index_check_enable wqe_index_check_enable;
	/* Description - enable fast register WQE Hermon name: frwr_en */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_frwr_enable frwr_enable;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_timer_enable timer_enable;
	/* Description - LDB prefetch size per PSN: 0: 64B 1: 128B 2: 192B 3: unlimited */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ldb_prefetch_size ldb_prefetch_size;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_dc_full_handshake dc_full_handshake;
	/* Description - set by SX when executing a non wire WQE cleared by RX when LDB is empty used by LDB for performance optimisation */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe uncompleted_non_wire_wqe;
	/* Description - set when PSN wraparound, cleared on connect. on connect if this bit is set the dci_session_id will be increamented */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_psn_wraparound psn_wraparound;
	/* Description - 2^this value=max number of atomic/rdma reads Hermon: max_rdma_atomic */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_max_read_atomic max_read_atomic;
	/* Description - set by SX on every packet sent or WQE executed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_sx_heartbeat sx_heartbeat;
	/* Description - TCU requestor should trap when e2e_credits_enabled==&AETH.syndrom.CCCCC TODO: change valid to be RC only */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_e2e_credits_enabled e2e_credits_enabled;
	/* Description - Used for translation and key check (TPT) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_can_use_reserved_lkey can_use_reserved_lkey;
	/* Description - This QP should use the fast_path inside the device */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_fast_path fast_path;
	/* Description - TODO: make sure valid bit sits at bit 511 for all contexts */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_qp_valid qp_valid;
	/* Description - interrupt FW when packet arrives to tcu on this Qp Hermon: tcu_int */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_tcu_trap tcu_trap;
	/* Description - TODO: merge with tcu_trap to a 2 bit field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_tcu_drop tcu_drop;
	/* Description - set by RX on every packet received and accepted */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_rx_heartbeat rx_heartbeat;
	/* Description - TODO: should be valid only on UD */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_ignore_pkey_check ignore_pkey_check;
	/* Description - When set no-direct-access is allowed to this QP (i.e. by BTH.QPN). When clear, both direct (i.e. by BTH.QPN) and indirect access (i.e. by RSS remapping, MC remapping etc) is allowed. See issue 34551 TODO: consider deleting this field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_no_direct_access no_direct_access;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_responder_session_id_15_0 responder_session_id_15_0;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_s_qpc_responder_session_id_23_16 responder_session_id_23_16;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_c_qpc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This holds either the GRH.DGID, IPv4.DIP (in bits 31:0), IPv6.DIP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_gid_31_0 peer_gid_31_0;
	/* Description - This holds either the GRH.DGID, IPv4.DIP (in bits 31:0), IPv6.DIP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_gid_63_32 peer_gid_63_32;
	/* Description - This holds either the GRH.DGID, IPv4.DIP (in bits 31:0), IPv6.DIP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_gid_95_64 peer_gid_95_64;
	/* Description - This holds either the GRH.DGID, IPv4.DIP (in bits 31:0), IPv6.DIP */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_gid_127_96 peer_gid_127_96;
	/* Description - this hold the 2'nd peer_qp for dual write */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_qp2 peer_qp2;
	/* Description - sx: used when WQE.Qkey[31]=1 */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_qkey qkey;
	/* Description - this hold the 2'nd peer_lid for dual write */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_lid2 peer_lid2;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 mtt_pointer_31_0;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 mtt_pointer_39_32;
	/* Description - access ICM with {GVMI, my_gid_index} to get L2 and L3: {ROCE type, MAC, VLAN, IP/GRH} */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_my_gid_mac_index my_gid_mac_index;
	/* Description - When translation VA to MA (effective to real) this is the process_index of the translation tables */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_translation_process_index translation_process_index;
	/* Description - protection domain */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_pd pd;
	/* Description - IPv4 this holds the TOS */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_tclass tclass;
	/* Description - except for DCR this is MyQPN in the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_context_number context_number;
	/* Description - {VLAN.prio[3:1], CFI\DEI} */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_vlan_prio vlan_prio;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_port_number port_number;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_lid peer_lid;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_mac_31_0 peer_mac_31_0;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_mac_47_32 peer_mac_47_32;
	/* Description - LSB of my LID, should be merged with MSB according to LMC */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_my_lid my_lid;
	/* Description - When this bit is set the my_lid LSB's (accoring to LMC) will be taken from QP and not from WQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_force_my_lid force_my_lid;
	/* Description - 0: local route 1: global route */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_grh_bit grh_bit;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_pkey_table_index pkey_table_index;
	/* Description - holds QoS ServiceLevel (should match the SQ.SL) in link_type_mac=0 holds the LRH.SL */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_sl sl;
	/* Description - This field will be copied into CQE.QPN in DC this field should be taken from DCT, DCR field is invalid */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_cqe_qpn cqe_qpn;
	/* Description - If rwq_type==0 then      swqe_address=(2^log_page_size)*wqe_page_offset*64 + masked_wqe_index*64 else      rwqe_address=(2^log_page_size)*wqe_page_offset*64 + masked_wqe_index*64     swqe_address=(2^log_page_size)*wqe_page_offset*64 + 2^(rwqe_buffer_size+rwqe_stride)*16  + masked_wqe_index*64 */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_wqe_page_offset wqe_page_offset;
	/* Description - max number of bytes that may encapsulate the packet, in 64B's must be 0 for ts!=ETH, since we don't support it for different TS's */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_max_encapsulation_size max_encapsulation_size;
	/* Description - Dest Qp in connection */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_peer_qp peer_qp;
	/* Description - number of WQEs in the WQ: 2 in power of */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_rwqe_buffer_size rwqe_buffer_size;
	/* Description - WQ size: 2^rcyclic_size bytes */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_rcyclic_size rcyclic_size;
	/* Description - WQE size: (2^this field)*16B value 7 means that there is no RWQ. TODO: fix in next project use rwq_type=NONE instead */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_rwqe_stride rwqe_stride;
	/* Description - mark packets as eligible for adaptive routing */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_adaptive_routing adaptive_routing;
	/* Description - when this bit is set, IPD is taken from QP instead of WQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_force_ipd force_ipd;
	/* Description - WQ size = 64B*2^value */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_swqe_buffer_size swqe_buffer_size;
	/* Description - page_size = 4096*2^log_page_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_log_page_size log_page_size;
	/* Description - each WQE in the r&s WQ are signature protected */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_wq_signature wq_signature;
	/* Description - Number of hops between subnets a packet can make before being discarded Used by RX for CNP with GRH in connected mode */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_hop_limit hop_limit;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_flow_label flow_label;
	/* Description - Congestion: Inter Packet Delay, a pointer to a table containing the qp rate */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_ipd ipd;
	/* Description - see rwq_type TODO: merge with rwq_type TODO: delete from responder (And save bits) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_rwq_type rwq_type;
	/* Description - 1: link is MAC 0: link is IB Hermon name: port_mac */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_link_type_mac link_type_mac;
	/* Description - max transfer unit: 0: 256 bytes   1: 512 bytes   2: 1K bytes  3: 2K bytes  4: 4k bytes 5: 8k bytes */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_mtu mtu;
	/* Description - 2^thisValue is the max number of bytes per mesaage */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_max_message_size max_message_size;
	/* Description - sx will put this field in the migreq field Hermon: path_migration_fsm[1] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_sx_migreq sx_migreq;
	/* Description - tcu check will jump if pkt.migreq differ from this bit Hermon: mig_req */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_rx_migreq rx_migreq;
	/* Description - all packets go only to loopback */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_force_loopback force_loopback;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_dual_write dual_write;
	/* Description - cqe.TIP field will be set according to: 0: from steering 1: QP.cqe_qpn 3: QPN */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_cqe_tip_source cqe_tip_source;
	/* Description - in ROCE over UDP (v2.0) this will field will be taken to UDP.source_port. In UD/DCI should be taken from AV In DCT connect should be taken from packet old name: bental_roce_entropy */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_udp_source_port udp_source_port;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_c_qpc_common_valid common_valid;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_c_srq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - e2e credits pysical address, bits[63:2] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_pa_33_2 e2e_pa_33_2;
	/* Description - e2e credits pysical address, bits[63:2] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_pa_63_34 e2e_pa_63_34;
	/* Description - each WQE in the r&s WQ are signature protected */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_wq_signature wq_signature;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_mtt_pointer_31_0 mtt_pointer_31_0;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_mtt_pointer_39_32 mtt_pointer_39_32;
	/* Description - If rwq_type==0 then      swqe_address=(2^log_page_size)*wqe_page_offset*64 + masked_wqe_index*64 else      rwqe_address=(2^log_page_size)*wqe_page_offset*64 + masked_wqe_index*64     swqe_address=(2^log_page_size)*wqe_page_offset*64 + 2^(rwqe_buffer_size+rwqe_stride)*16  + masked_wqe_index*64 */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_wqe_page_offset wqe_page_offset;
	/* Description - set by RX on every packet received and accepted */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rx_heartbeat rx_heartbeat;
	/* Description - e2e fetch is allowed only according to this bit */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_fetch_enable e2e_fetch_enable;
	/* Description - E2E Limit on  TCU: exception if descriptor is required and Number_of_E2E_credits=RQ/SRQ.rwqe_limit_event */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwqe_limit_event rwqe_limit_event;
	/* Description - except for DCR this is MyQPN in the packet */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_context_number context_number;
	/* Description - page_size = 4096*2^log_page_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_log_page_size log_page_size;
	/* Description - TODO: merge with tcu_trap to a 2 bit field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_tcu_drop tcu_drop;
	/* Description - Used for translation and key check (TPT) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_can_use_reserved_lkey can_use_reserved_lkey;
	/* Description - interrupt FW when packet arrives to tcu on this Qp Hermon: tcu_int */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_tcu_trap tcu_trap;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_cq_number cq_number;
	/* Description - number of WQEs in the WQ: 2 in power of */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwqe_buffer_size rwqe_buffer_size;
	/* Description - WQE size: (2^this field)*16B value 7 means that there is no RWQ. TODO: fix in next project use rwq_type=NONE instead */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwqe_stride rwqe_stride;
	/* Description - protection domain */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_pd pd;
	/* Description - 2^ this value is the threshold to check for new E2E credits 0 means e2e prefethch disabled for this qp in rcylic this thrshould is in MTU, otherwise in WQEs */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold e2e_credits_prefetch_threshold;
	/* Description - Hermon: srcd */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_xrc_domain xrc_domain;
	/* Description - index to next free wqe rwq_type=SRQ: copy index from SRQ on packet first */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwqe_consumer_index rwqe_consumer_index;
	/* Description - written by e2e credit machine */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_producer_index e2e_producer_index;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_e2e_consumer_index e2e_consumer_index;
	/* Description - FW bits, these are the only reserved bits that are not overriden by HW in ICM */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_srq_fw srq_fw;
	/* Description - in granularity of 2^rcyclic_stride */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rcyclic_consumer rcyclic_consumer;
	/* Description - in granularity of 2^rcyclic_stride */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rcyclic_producer rcyclic_producer;
	/* Description - WQ size: 2^rcyclic_size bytes */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rcyclic_size rcyclic_size;
	/* Description - Work Queue Type 0: None 1: REGULAR WQ 2: attached to SRQ 3: Receive Cyclic Buffer 4. link list 5. REGULAR with 16B header per WQE 6. Strided WQE  normal QP support: 0-3 SRQ support: 1 (not in Golan), 4-6 */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwq_type_srq rwq_type;
	/* Description - This field will be copied into CQE.SRQN */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_cqe_srqn cqe_srqn;
	/* Description - number of strides in each WQE: 512*2^this */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_log2_num_of_strides log2_num_of_strides;
	/* Description - send 2 bytes of 0's before each message */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_two_bytes_shift_en two_bytes_shift_en;
	/* Description - stride size = (2^this_field)*64B */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_log2_stride_size log2_stride_size;
	/* Description - When translation VA to MA (effective to real) this is the process_index of the translation tables */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_translation_process_index translation_process_index;
	/* Description - CQE.rq field will be set according to: 0: QP.cqe_qpn 1: SRQ.cqe_srqn */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_cqe_rq_source cqe_rq_source;
	/* Description - When there are equal or more than 2^this WQE's LRO open is allowed */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_log2_wqe_left_lro_allow log2_wqe_left_lro_allow;
	/* Description - copy index from SRQ on packet first holds the first stride_index of the current WQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_rwqe_consumer_stride_index rwqe_consumer_stride_index;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_srq_srq_valid srq_valid;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_toc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  number that should be added to EQ number when giving an EQ DoorBell to RXC */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t eqn_offset;
	/* Description -  number that should be added to MSIx Vector Number when giving an MSIx Read/Write operation to RXC */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t msix_offset;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0-idle, 1-in progress, 2-do not used, 3-returning pages */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t flr_state;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - NO_DESCR */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t cmdq_phy_addr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_hw_init_info init_info;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - pci_configuration_per_pf_vf */
	/* 0x14.0 - 0x30.31 */
	 struct connectx4lx_pf_vf_cfg_space pci_cfg_space;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.7 */
	 u_int8_t sw_cmd_eq;
	/* Description - cmdif_checksum */
	/* 0x30.8 - 0x30.9 */
	 u_int8_t csum;
	/* Description -  */
	/* 0x30.10 - 0x30.10 */
	 u_int8_t ext_mod;
	/* Description -  */
	/* 0x30.11 - 0x30.11 */
	 u_int8_t teardown_event;
	/* Description -  */
	/* 0x30.12 - 0x30.12 */
	 u_int8_t pre_icm_driver_refused;
	/* Description - Reported in function initialization segment: 1 - device still in initializing state.0 - device is ready to receive commands. There is also global bit - static_config_not_done */
	/* 0x30.13 - 0x30.13 */
	 u_int8_t initializing;
	/* Description -  */
	/* 0x30.24 - 0x30.31 */
	 u_int8_t issi;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - state for init gvmix function  - pre init hca */
	/* 0x34.0 - 0x34.7 */
	 u_int8_t hca_state;
	/* Description - 0 - disabled, 1 - full driver , 2 - simple nic - internal FW copy */
	/* 0x34.8 - 0x34.9 */
	 u_int8_t nic_interface_type;
	/* Description - 0 - disabled, 1 - full driver , 2 - simple nic - value of SW visible field */
	/* 0x34.10 - 0x34.11 */
	 u_int8_t nic_interface_type_sw;
	/* Description - If set FLR was triggered by internal flr and not pci related */
	/* 0x34.12 - 0x34.12 */
	 u_int8_t non_pci_flr;
	/* Description - If set PCI error was triggered */
	/* 0x34.13 - 0x34.13 */
	 u_int8_t icmc_error_px;
	/* Description - GALIL ONLY : per gvmi bit for enabling/disabling doorbell recovery */
	/* 0x34.14 - 0x34.14 */
	 u_int8_t doorbell_recovery_en;
	/* Description - global nodnic (simple nic interface) index */
	/* 0x34.16 - 0x34.18 */
	 u_int8_t nodnic_idx;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - NO_DESCR */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t doorbell_record;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Used in CAPI for ICM pages */
	/* 0x3c.0 - 0x3c.15 */
	 u_int16_t capi_direct_pasid;
	/* Description - Used in CAPI for command mailbox */
	/* 0x3c.16 - 0x3c.31 */
	 u_int16_t capi_pasid;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_hw_mkc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - check that the mkey version fit to cr_space version. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t version;
	/* Description - this bits allows pci reads to bypass pci writes on this mkey */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t free_ordered;
	/* Description - If set issue PCIe cycle with relaxed ordering attribute (allows write after write bypassing) for writes */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t relaxed_ordering_read;
	/* Description - 0x0: PA - (VA=PA, no translation needed) 0x1: MTT - (PA is needed) 0x2: KLMs (Indirect access) 0x3:KSM's (indirect access with equal len taken from entity_size) */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t access_mode;
	/* Description - If set, local read is enabled why is this check not part of the EAS? It's part of the IB Spec */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t lr;
	/* Description - If set, local write is enabled */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t lw;
	/* Description - If set, remote read is enabled */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t rr;
	/* Description - If set, remote write is enabled */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t rw;
	/* Description - If set, atomic operation is enabled */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t a;
	/* Description - If set, this Mkey context support UMR operations */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t umr_en;
	/* Description - If set, the corresponding bit in the transaltion response will be set
EAS: responder will have one read request toward the PCIe (per QP) */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t small_fence_on_rdma_read_response;
	/* Description - If cleared, no PCI access will be performed on the target address.
RDMA write will be druped drooped.
RDMA read will give zeroes.
need to open on QUERY_DUMP_FILL_MKEY
 */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t goto_pci;
	/* Description - If set issue PCIe cycle with relaxed ordering attribute (allows write after write bypassing) for writes */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t relaxed_ordering_write;
	/* Description - If set, issue PCIe cycle with (no Snoop) attribute and this cycle will not be snooped in CPU cache */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t no_snoop;
	/* Description -  */
	/* 0x0.20 - 0x0.21 */
	 u_int8_t tlp_processing_hints;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t tlp_processing_hints_en;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t indirection_opcode_valid;
	/* Description - this bits allows pci reads to bypass pci writes on this mkey */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t free;
	/* Description - determines if theKLMs 3 MSBs are the klm type , type enumeration:0 - old mode, 1 - zero base, 2 - parent base */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Variant part of MKey specified by this MKey context */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t mem_key;
	/* Description - QP number this MW is attached to. (no QPN attached if QPN = 0xFFFFFF) */
	/* 0x4.8 - 0x4.31 */
	 u_int32_t qpn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - an input to the XSL block for translating EA-  >RA */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t process_index;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Protection Domain. (no Protection Domain if PD = 0xFFFFFF) */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t pd;
	/* Description - Enable remote invalidation */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t en_rinval;
	/* Description - shomron descr: (LSB of expected number of sigerr_cqes) , golan descr: If set, MKEY is armed to produce sigerr cqe. */
	/* 0xc.26 - 0xc.26 */
	 u_int8_t num_of_sigerr;
	/* Description - can improve permormance of klm */
	/* 0xc.28 - 0xc.28 */
	 u_int8_t trast_a_en;
	/* Description - can improve permormance of bsf */
	/* 0xc.29 - 0xc.29 */
	 u_int8_t trast_b_en;
	/* Description - If set, this MKey specifies BSF (signature context) */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t bsf_enabled;
	/* Description - to determine that len is 2^64 */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t length_64;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  Start Address - Virtual Address where this region/window starts */
	/* 0x10.0 - 0x18.31 */
	 u_int64_t start_address;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  Region/Window Length [bytes] */
	/* 0x18.0 - 0x20.31 */
	 u_int64_t length;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t bsf_octoword_count;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.14 */
	 u_int16_t bsf_first_index_46_32;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.4 - 0x28.31 */
	 u_int32_t bsf_first_index_31_4;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.14 */
	 u_int16_t mtt_first_index_46_32;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.3 - 0x30.31 */
	 u_int32_t mtt_first_index_31_3;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - number of MTTs/KLMs octowords (16B) that are mapped to this region */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t mtt_octoword_count;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - page size = 2^(entity_size) */
	/* 0x38.0 - 0x38.5 */
	 u_int8_t entity_size;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.15 */
	 u_int16_t generation_counter;
	/* Description -  */
	/* 0x3c.16 - 0x3c.26 */
	 u_int16_t tlp_processing_hints_tag;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_c_eqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_uar uar;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_7_0 moderation_timestamp_7_0;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_39_8 moderation_timestamp_39_8;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_51_40 moderation_timestamp_51_40;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa1_31_12 pa1_31_12;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa1_63_32 pa1_63_32;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_consumer_index consumer_index;
	/* Description - 0-Fired 1-Armed Solicited 2-Armed 3-Always Armed Hermon name: state */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_state cq_state;
	/* Description - When set: ci is ignored, and never read (block,lookahead) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_overrun_ignore overrun_ignore;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_4_0 mtt_pointer_4_0;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_36_5 mtt_pointer_36_5;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_39_37 mtt_pointer_39_37;
	/* Description - bits[63:3] of the physical address of the ci */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cipa_31_3 cipa_31_3;
	/* Description - bits[63:3] of the physical address of the ci */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cipa_63_32 cipa_63_32;
	/* Description - doorbell ci - in the case of cq_state different from Fired, this field indicates what should be pi for firing the event. Updated by the doorbell handler */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_ci db_ci;
	/* Description - amount of CQE in CQ is 2^los2_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_log2_size log2_size;
	/* Description - set to 1 on every received DB */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_heartbeat db_heartbeat;
	/* Description - used for db.db_sn check */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_number_of_events_generated number_of_events_generated;
	/* Description - CQC: eqn+eq_offset EQC with MSIX number+offset EQC with interrupt: 0-INT_A, 1-INT_B, 2-INT_C, 3-INT_D, 4-INT_YU */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_eqn eqn_msix;
	/* Description - minimum wait time between eqe: 0 means moderation is disabled on this CQ */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_min_wait_time moderation_min_wait_time;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_producer_index producer_index;
	/* Description - minimum # of cqes to generate eqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 moderation_cnt_limit_7_0;
	/* Description - minimum # of cqes to generate eqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 moderation_cnt_limit_15_8;
	/* Description - last index for which an event was created */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_notified_index last_notified_index;
	/* Description - CQ start address is: cq_page_offset &lt;&lt; (crspace+6) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_page_offset cq_page_offset;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_recovery_enable db_recovery_enable;
	/* Description - set to 1 on every CQE creation */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_heartbeat cqe_heartbeat;
	/* Description - 0: no pa fetch 1: single pa (bring next pa when last CQE of page is written) 2: dual pa prefetch */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa_mode pa_mode;
	/* Description - All CQEs are written to the same address (required for CQE coalescing) In PA mode must be set to 0 (no pa fetch) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_shrink shrink;
	/* Description - when this bit is set, FW should be called */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_trap cq_trap;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa0_31_12 pa0_31_12;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa0_63_32 pa0_63_32;
	/* Description - index of the last CQE with SE bit set */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_solicited_index last_solicited_index;
	/* Description - When pi - ci = 2^lookahead_size ci is read from memory Golan name: lookahead_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_lookahead_log_size lookahead_log_size;
	/* Description - 0: solicited cqe has no effect on moderation 1: break moderation for solicited cqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_break_by_solicited moderation_break_by_solicited;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_notified_check_for_arm_en last_notified_check_for_arm_en;
	/* Description - CQE size: 0-64B, 1-128B */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_128b_size cqe_128b_size;
	/* Description - 1: send interupt to MSIX 0:send interupt to int pin */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_msix msix;
	/* Description - This bit defines the "cqe coalese" content: 0: rss hash result 1: checksum field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix cqe_coalesce_checksum_msix;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_coalesce_enable cqe_coalesce_enable;
	/* Description - moderation time will be measured (before EQE is generated) from: 0: last EQE (golan mode) 1: last CQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_time_from_cqe moderation_time_from_cqe;
	/* Description - when set small message cqe will act as IB solicited event marked message */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_small_message_as_solicited small_message_as_solicited;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa_error pa_error;
	/* Description - page_size = 4096*2^log_page_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_log_page_size log_page_size;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue poll_cq_cqe_with_error_generated_on_this_queue;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state poll_cq_queue_in_error_state;
	/* Description - when this bit is cleared IRISC should be called */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqc_valid cqc_valid;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_c_cqc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_uar uar;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_7_0 moderation_timestamp_7_0;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_39_8 moderation_timestamp_39_8;
	/* Description - updated when eqe is generated from a global timer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_timestamp_51_40 moderation_timestamp_51_40;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa1_31_12 pa1_31_12;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa1_63_32 pa1_63_32;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_consumer_index consumer_index;
	/* Description - 0-Fired 1-Armed Solicited 2-Armed 3-Always Armed Hermon name: state */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_state cq_state;
	/* Description - When set: ci is ignored, and never read (block,lookahead) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_overrun_ignore overrun_ignore;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_4_0 mtt_pointer_4_0;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_36_5 mtt_pointer_36_5;
	/* Description - Used in TPT for wqe translation TODO: condition on RQ_TYPE, also for other fields that control the receive buffer */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_mtt_pointer_39_37 mtt_pointer_39_37;
	/* Description - bits[63:3] of the physical address of the ci */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cipa_31_3 cipa_31_3;
	/* Description - bits[63:3] of the physical address of the ci */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cipa_63_32 cipa_63_32;
	/* Description - doorbell ci - in the case of cq_state different from Fired, this field indicates what should be pi for firing the event. Updated by the doorbell handler */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_ci db_ci;
	/* Description - amount of CQE in CQ is 2^los2_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_log2_size log2_size;
	/* Description - set to 1 on every received DB */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_heartbeat db_heartbeat;
	/* Description - used for db.db_sn check */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_number_of_events_generated number_of_events_generated;
	/* Description - CQC: eqn+eq_offset EQC with MSIX number+offset EQC with interrupt: 0-INT_A, 1-INT_B, 2-INT_C, 3-INT_D, 4-INT_YU */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_eqn eqn_msix;
	/* Description - minimum wait time between eqe: 0 means moderation is disabled on this CQ */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_min_wait_time moderation_min_wait_time;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_producer_index producer_index;
	/* Description - minimum # of cqes to generate eqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 moderation_cnt_limit_7_0;
	/* Description - minimum # of cqes to generate eqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 moderation_cnt_limit_15_8;
	/* Description - last index for which an event was created */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_notified_index last_notified_index;
	/* Description - CQ start address is: cq_page_offset &lt;&lt; (crspace+6) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_page_offset cq_page_offset;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_db_recovery_enable db_recovery_enable;
	/* Description - set to 1 on every CQE creation */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_heartbeat cqe_heartbeat;
	/* Description - 0: no pa fetch 1: single pa (bring next pa when last CQE of page is written) 2: dual pa prefetch */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa_mode pa_mode;
	/* Description - All CQEs are written to the same address (required for CQE coalescing) In PA mode must be set to 0 (no pa fetch) */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_shrink shrink;
	/* Description - when this bit is set, FW should be called */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cq_trap cq_trap;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa0_31_12 pa0_31_12;
	/* Description - MSB of physical address translation, 12lsb are VA[11:0] */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa0_63_32 pa0_63_32;
	/* Description - index of the last CQE with SE bit set */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_solicited_index last_solicited_index;
	/* Description - When pi - ci = 2^lookahead_size ci is read from memory Golan name: lookahead_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_lookahead_log_size lookahead_log_size;
	/* Description - 0: solicited cqe has no effect on moderation 1: break moderation for solicited cqe */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_break_by_solicited moderation_break_by_solicited;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_last_notified_check_for_arm_en last_notified_check_for_arm_en;
	/* Description - CQE size: 0-64B, 1-128B */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_128b_size cqe_128b_size;
	/* Description - 1: send interupt to MSIX 0:send interupt to int pin */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_msix msix;
	/* Description - This bit defines the "cqe coalese" content: 0: rss hash result 1: checksum field */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix cqe_coalesce_checksum_msix;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqe_coalesce_enable cqe_coalesce_enable;
	/* Description - moderation time will be measured (before EQE is generated) from: 0: last EQE (golan mode) 1: last CQE */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_moderation_time_from_cqe moderation_time_from_cqe;
	/* Description - when set small message cqe will act as IB solicited event marked message */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_small_message_as_solicited small_message_as_solicited;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_pa_error pa_error;
	/* Description - page_size = 4096*2^log_page_size */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_log_page_size log_page_size;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue poll_cq_cqe_with_error_generated_on_this_queue;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state poll_cq_queue_in_error_state;
	/* Description - when this bit is cleared IRISC should be called */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_cqc_cqc_valid cqc_valid;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_lane_const_frame_lock {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_sd_params_rx_set ffe_taps;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x20.31 */
	 struct connectx4lx_calibration_values calibration;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t valid;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_lane_const_calib_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Parameter - 
Which feedback will be used in mixer clibration
0x0 = slicer feedback
0x1 = mixer feedback */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t mixer_calib_feedback;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Param-mixer offset index */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t mixer_offset_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Param
distractive = 0x1
non distractive = 0x0 */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t dis_non_dis_index;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Param-delta from positive edge */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t delta_from_edges_neg;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Param-delta from negative edge */
	/* 0x10.0 - 0x10.19 */
	 u_int32_t delta_from_edges_pos;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Param
0x0 = debug mode doesn't clear the relevant mixer_offsetX and ffe_tap_offsetX, when X is the offset that the mixer clibration doesn't run on.
0x1 = regular flow, clears relevant mixer_offsetX and ffe_tap_offsetX
 */
	/* 0x14.0 - 0x14.19 */
	 u_int32_t clear_mixer_vals;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Param-Perform mixer clibration as part of the analog calibration */
	/* 0x18.0 - 0x18.19 */
	 u_int32_t perform_mixer_calib;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Param-Perform slicer clibration as part of the analog calibration */
	/* 0x1c.0 - 0x1c.19 */
	 u_int32_t perform_slicer_calib;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Param-Stabilization time, this time will be calculated: (2^(this value))*(64 nsec)
default is 16384 nsec */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t stab_time;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Param-Measure time, this time will be calculated: (this value)*(64 nsec)
default is 128 nsec */
	/* 0x24.0 - 0x24.19 */
	 u_int32_t measure_time;
};

/* Description -   */
/* Size in bytes - 496 */
struct connectx4lx_lane_const_sd_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - FDR
 1- EDR
 */
	/* 0x0.0 - 0x1f0.31 */
	 struct connectx4lx_lane_const_sd_params_tx_preset tx_preset;
};

/* Description -   */
/* Size in bytes - 800 */
struct connectx4lx_shared_const_sd_params_rx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - SDR
1 - DDR
2 - SGMII
3 - XAUI
4- DME
5 - XFI10
6 - XFI25
7 - reserved
 */
	/* 0x0.0 - 0xa0.31 */
	 struct connectx4lx_shared_const_sd_params_rx_force force;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description - ABA for 100GE */
	/* 0xa0.0 - 0x320.31 */
	 struct connectx4lx_sd_params_rx_aba aba;
};

/* Description -   */
/* Size in bytes - 1344 */
struct connectx4lx_shared_const_sd_params_tx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - SDR
1 - DDR and QDR REV0
2 - SGMII
3 - XFI 10G
4 - XFI 25G
5 - CL73 DME
6 - KR initialize 10G/40G
7 - KR preset 10G/40G
8 - KR initialize 100G
9 - KR preset 100G */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_shared_const_sd_params_tx_force force;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - 0 - QDR, FDR10
1 - FDR
2 - EDR
3 - RESERVED */
	/* 0x50.0 - 0x450.31 */
	 struct connectx4lx_sd_params_tx_aba aba;
/*---------------- DWORD[276] (Offset 0x450) ----------------*/
	/* Description - 0 - QDR
1 - FDR non eq
2 - EDR
3 - reserved */
	/* 0x450.0 - 0x480.31 */
	 struct connectx4lx_sd_params_tx_active active;
/*---------------- DWORD[288] (Offset 0x480) ----------------*/
	/* Description -  */
	/* 0x480.0 - 0x540.31 */
	 struct connectx4lx_sd_params_tx_vendor_id vendor_id;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_pcie_subroutines_db_index {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_subroutine pcie_subroutine[8];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_pcie_subroutines_db_name {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_subroutine subroutine_pcie_nd_eye_scan;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_subroutine subroutine_pcie_height_measure;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_subroutine subroutine_pcie_config_rx_set_to_serdes;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_subroutine subroutine_pcie_copy_curr_set_to_best_set;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_subroutine subroutine_pcie_configure_curr_tapX_from_serdes;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_subroutine subroutine_pcie_process_rx_set;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_subroutine subroutine_pcie_search_best_set_per_start_point;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 struct connectx4lx_subroutine subroutine_pcie_height_measure_gen4;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_eqlz_tx_adaptation {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - TX adaptation mode:
0 - old mode. we will request the same parametrs that we receive at the begining of ph2
1 - we will ask the configured parametrs below
2 - same as 1 but after eye opener the FW will restore the received tx conf */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t mode;
	/* Description - if set, the FW will ask preset. otherwize it will ask coeffs */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t use_preset;
	/* Description -  */
	/* 0x0.8 - 0x0.13 */
	 u_int8_t postcursor;
	/* Description -  */
	/* 0x0.14 - 0x0.19 */
	 u_int8_t cursor;
	/* Description -  */
	/* 0x0.20 - 0x0.25 */
	 u_int8_t precursor;
	/* Description -  */
	/* 0x0.26 - 0x0.29 */
	 u_int8_t preset;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_ffe_tap_set_9_taps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t ffe_tap0;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t ffe_tap1;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t ffe_tap2;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t ffe_tap3;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t ffe_tap4;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t ffe_tap5;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t ffe_tap6;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t ffe_tap7;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t ffe_tap8;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_tx_sets_shomron {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t ob_tap0;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t ob_tap1;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t ob_tap2;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_pn_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t pn;
};

/* Description -   */
/* Size in bytes - 0 */
struct connectx4lx_bit_type_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t bit_type;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_gpio_group_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 2 bit per gpio 
00 - input
01 - ful drive
10 - open drain 0 hi-Z
11 - open drain 1 hi-Z */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t mode;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t def_val;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t pull_up;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t pull_en;
	/* Description - 2 bit per gpio 
00 - gpio is controled by FW
01 - gpio is controled by HW (option 1)
10 - gpio is controled by HW (option 2)
11 - gpio is controled by HW (option 3) */
	/* 0x0.5 - 0x0.6 */
	 u_int8_t functional_enable;
	/* Description - enables configuring the field in init flow */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t gpio_config_en;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_gpio_function {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Map function to GPIO num, 0x00 - GPIO_PORT_LEDS_OFFSET, 0x3ff - function not present.  */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t mapping;
	/* Description - function polarity 0-normal, 1-reverse. Normal polarity means 0 = non active, 1 = active. */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t reverse_polarity;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pca_mapping_database {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 struct connectx4lx_module_prsnt_data_db prsnt;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 struct connectx4lx_module_select_data_db modsel;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 struct connectx4lx_module_reset_data_db reset;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_module2local {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_module2locallane tx;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_module2locallane rx;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_led_mapping {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - offset of this port logic led in the led chain (value are 135-0) */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t logic_offset;
	/* Description - offset of this port phy led in the led chain (value are 135-0) */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t phy_offset;
};

/* Description -  to be used in core2phy interface (not in page format) */
/* Size in bytes - 4 */
struct connectx4lx_mlpn_enhanced_database_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - mlpn bits */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_mlnx_enhanced_equal_info_ini as_bits;
};

/* Description -  mlpn cability (ability)/ admin (request) bits for ScratchPad (not in pages foramt) */
/* Size in bytes - 4 */
struct connectx4lx_mlpn_database_all_protocol_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - mlpn bits */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_mlpn_database_all_protocol_bits_ini as_bits;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 u_int32_t logic_to_serdes[8];
};

/* Description -   */
/* Size in bytes - 92 */
struct connectx4lx_ib_an_hw_main_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t preset_tx_mask_internal_fdr;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t preset_tx_mask_external_fdr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t preset_tx_mask_internal_edr;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t preset_tx_mask_external_edr;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_tlv_data_vpi_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t network_link_type_ib;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t network_link_type_eth;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t default_link_type_ib;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t default_link_type_eth;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_config_kdnet_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - indicates if KDNET is ebnabled - remove when ticket #869451 closed and pick node from EAS_st */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t kdnet_en;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_nv_config_tpt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tpt_conf settings;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_nv_tlv_data_tpt_capabilities capabilities;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_nv_config_pci {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_nv_global_pci_conf settings;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x20.31 */
	 struct connectx4lx_nv_global_pci_cap capabilities;
};

/* Description -  ini AER Capability */
/* Size in bytes - 4 */
struct connectx4lx_aer_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ecrc_check_cap;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t ecrc_generation_cap;
};

/* Description -  ini MSI-X Capability */
/* Size in bytes - 8 */
struct connectx4lx_msix_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Vector table BAR number */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t Table_BIR;
	/* Description - Vector table offset in the BAR */
	/* 0x0.3 - 0x0.31 */
	 u_int32_t Table_Offset;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Pending bit array BAR number */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t PBA_BIR;
	/* Description - PBA offset in the BAR */
	/* 0x4.3 - 0x4.31 */
	 u_int32_t PBA_Offset;
};

/* Description -  ini PCIe Capability */
/* Size in bytes - 24 */
struct connectx4lx_pciex_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_device_caps device_caps;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_link_caps link_caps;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_device_caps2 device_caps2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_link_caps2 link_caps2;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.1 */
	 u_int8_t link_ctl_aspm_control;
	/* Description -  */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t link_ctl_enable_clock_power_management;
	/* Description -  */
	/* 0x10.3 - 0x10.3 */
	 u_int8_t link_stat2_current_de_emphasis_level;
};

/* Description -  ini SR-IOV Capability */
/* Size in bytes - 8 */
struct connectx4lx_sriov_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vf_device_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Supported Page Sizes. By default support all page size up to 4MB */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t supported_page_sizes;
};

/* Description -  ini PCIe Configuration Space Header */
/* Size in bytes - 16 */
struct connectx4lx_pci_cfg_hdr_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - pcie vendor id for type0 header */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vendor_id;
	/* Description - pcie device id for type0 header */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t device_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - class code */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t class_code;
	/* Description - revision id */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t rev_id;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t sub_vendor_id;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t subsystem_id;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_block_behavior_fields {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - [MCC/MCDA flow] disable MFPA, MFBA and MFBE reg access cmds */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t disable_mfpa_mfba_mfbe;
	/* Description - [MCC/MCDA flow] write access to flash GW is disabled */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t disable_cr_space_flash_gw;
	/* Description - [MCC/MCDA flow] the fw_block_behavior fields overwrite the defaults value */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t en;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_block_behavior_dw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dw;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_nv_config_host_func_main {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_external_port_pf_array external_port;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_nv_config_host_main {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_nv_config_host_port_main port[2];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_nv_config_global_main {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_roce_1_5_conf roce_1_5_next_prot;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_nv_sw_offload_conf sw_offload_conf;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_nv_tlv_tweaks tweaks;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_nv_config_host_2_bmc host_2_bmc;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_nv_config_flex_nic flex_nic;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_nv_tlv_data_curr_config current_configurator;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_port_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_roce_cc roce_cc_ctrl;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x4c.31 */
	 struct connectx4lx_nv_roce_cc_ecn roce_ecn;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 struct connectx4lx_nv_keep_link_up keep_link_up;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x6c.31 */
	 struct connectx4lx_nv_lldp_nb_cap lldp_nb_cap;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x78.31 */
	 struct connectx4lx_nv_lldp_nb_conf lldp_nb_param;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 struct connectx4lx_nv_lldp_nb_dcbx dcbx_nb;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x90.31 */
	 struct connectx4lx_nv_qos_conf qos_conf;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description -  */
	/* 0x90.0 - 0x94.31 */
	 struct connectx4lx_nv_qos_cap qos_cap;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0xdc.31 */
	 struct connectx4lx_nv_qos_ets_tc_conf qos_ets_tc_conf;
/*---------------- DWORD[55] (Offset 0xdc) ----------------*/
	/* Description -  */
	/* 0xdc.0 - 0xe0.31 */
	 struct connectx4lx_nv_mpfs_conf mpfs_conf;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ini_fff_mode_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Vmid threshold for step size decision */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vmid_threshold;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - normal lower bound step size */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t step_size_lo_bnd_norm;
	/* Description - normal higher bound step size */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t step_size_hi_bnd_norm;
	/* Description - fine lower bound step size */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t step_size_lo_bnd_fine;
	/* Description - fine higher bound step size */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t step_size_hi_bnd_fine;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_centerpll_prj_ini_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pll_prj_ini_db pll[4];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_power_management_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Overrides the power_mode_value for the dynamic pll feature.
0 - don't override.
1 - override, disable feature.
3 - override, enable feature. */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t dynamic_pll_management;
	/* Description - Overrides the power_mode_value for the dynamic clkrep feature.
0 - don't override.
1 - override, disable feature.
    3 - override, enable feature. */
	/* 0x0.2 - 0x0.3 */
	 u_int8_t dynamic_clkrep_management;
	/* Description - Overrides the power_mode_value for the dynamic port feature.
0 - don't override.
1 - override, disable feature.
    3 - override, enable feature. */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t dynamic_port_management;
	/* Description - Power modes:
 0 - Business As Usual
 1 - No Performance Impact
 2 - Auto performance impact
 3 - Force */
	/* 0x0.6 - 0x0.7 */
	 u_int8_t power_mode_value;
	/* Description - enable the power governor HW feature. */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t power_governor_enable;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t switch_managed;
	/* Description - set delay for serdes_down_delay. 2^(value+1)=ticks */
	/* 0x0.10 - 0x0.13 */
	 u_int8_t serdes_down_delay;
	/* Description - set delay for serdes_up_delay. 2^(value+1)=ticks */
	/* 0x0.14 - 0x0.17 */
	 u_int8_t serdes_up_delay;
	/* Description - set delay for clock_down_delay. 2^(value+1)=ticks */
	/* 0x0.18 - 0x0.21 */
	 u_int8_t clock_down_delay;
	/* Description - set delay for clock_up_delay. 2^(value+1)=ticks */
	/* 0x0.22 - 0x0.25 */
	 u_int8_t clock_up_delay;
	/* Description - set delay for memory_down_delay. 2^(value+1)=ticks */
	/* 0x0.26 - 0x0.29 */
	 u_int8_t memory_down_delay;
	/* Description - enable power_validation flow */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t enable_power_validation;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - second input buffer max open lanes */
	/* 0x4.0 - 0x4.8 */
	 u_int16_t lanes_counter_threshold;
	/* Description - usec delay between each lane input buffer powerup / powerdown */
	/* 0x4.9 - 0x4.16 */
	 u_int8_t in_buff_lane_pwr_delay_usec;
	/* Description - msec timer between each input buffer powerup retry. use only 125 or 250 */
	/* 0x4.17 - 0x4.24 */
	 u_int8_t in_buff_power_timer;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_tx_tuning_2_vars {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t tx_tuning_pre_jump;
	/* Description -  */
	/* 0x0.3 - 0x0.5 */
	 u_int8_t tx_tuning_post_jump;
	/* Description -  */
	/* 0x0.6 - 0x0.11 */
	 u_int8_t polarity_margin;
	/* Description -  */
	/* 0x0.12 - 0x0.21 */
	 u_int16_t tx_norm;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_tx_tuning_vars {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - The max value that grade is going down that determaine that we passed max grade */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t lower_threshold_percent;
	/* Description - Max grade tollerance from max grade set to determaine that alogorithm is done (nose threshold) */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t noise_threshold_percent;
	/* Description -  */
	/* 0x0.16 - 0x0.18 */
	 u_int8_t tx_tuning_up_step;
	/* Description -  */
	/* 0x0.19 - 0x0.21 */
	 u_int8_t tx_tuning_down_step;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_error_correction_thresholds {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - if analog grade < this threshold no FEC is needed */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t analog_grade_no_fec;
	/* Description - if analog grade < this threshold FC FEC is needed */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t analog_grade_fc_fec;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - if analog grade < this threshold RS FEC is needed */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t analog_grade_rs_fec;
	/* Description - if analog grade on backplane ports lower than this threshold speed degradation is needed */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t analog_grade_backplane;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - if ber sample < this threshold no FEC is needed */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t ber_sample_zero;
	/* Description - if ber sample < this threshold standard RS FEC is needed, no PLR */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t ber_sample_sd_fec;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - if ber sample < this threshold standard RS FEC is needed, with PLR */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t ber_sample_sd_fec_plr;
	/* Description - if ber sample < this threshold Mellanox strong RS FEC is needed, no PLR */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t ber_sample_st_fec;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - if ber sample < this threshold Mellanox strong RS FEC is needed, with PLR */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t ber_sample_st_fec_plr;
	/* Description - if ber sample < this threshold low latency RS FEC is needed, no PLR */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t ber_sample_sd_ll_fec;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - if ber sample < this threshold standard low latency RS FEC is needed, with PLR */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t ber_sample_sd_ll_fec_plr;
	/* Description - if ber sample < this threshold Mellanox low latency RS FEC is needed, no PLR */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t ber_sample_mlx_ll_fec;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - if ber sample < this threshold Mellanox low latency RS FEC is needed, with PLR */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t ber_sample_mlx_ll_fec_plr;
	/* Description - if ber sample < this threshold LLR is needed */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t ber_sample_llr;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - if atten smaller than this value, use short copper profile */
	/* 0x1c.0 - 0x1c.5 */
	 u_int8_t medium_range_copper_atten_th;
	/* Description - if atten smaller than this value and bigger than medium th,
use medium copper profile, if bigger than this th use long copper profile */
	/* 0x1c.6 - 0x1c.11 */
	 u_int8_t long_range_copper_atten_th;
	/* Description - if link_length smaller than this value no fec is supported */
	/* 0x1c.12 - 0x1c.15 */
	 u_int8_t short_range_copper_link_length_th;
	/* Description - if link_length smaller than this value no fec is supported */
	/* 0x1c.16 - 0x1c.19 */
	 u_int8_t medium_range_copper_link_length_th;
	/* Description - if link_length smaller than this value no fec is supported */
	/* 0x1c.20 - 0x1c.26 */
	 u_int8_t short_range_active_link_length_th;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - the lowest grade of bath accepted by the kr-startup */
	/* 0x20.0 - 0x20.11 */
	 u_int16_t frame_lock_min_grade;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - if analog grade < this threshold COD is needed */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t analog_grade_cod;
	/* Description - if ber sample < this threshold COD is needed */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t ber_sample_cod;
};

/* Description -   */
/* Size in bytes - 280 */
struct connectx4lx_phy_uc_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_subroutines_db subroutines;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x100.11 */
	 u_int16_t total_num_of_commands;
	/* Description -  */
	/* 0x100.12 - 0x100.23 */
	 u_int16_t commands_start_line_in_db;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description -  */
	/* 0x104.0 - 0x10c.31 */
	 struct connectx4lx_itoc_param part_type_phy_uc_commands;
/*---------------- DWORD[67] (Offset 0x10c) ----------------*/
	/* Description -  */
	/* 0x10c.0 - 0x114.31 */
	 struct connectx4lx_itoc_param part_type_phy_uc_data;
/*---------------- DWORD[69] (Offset 0x114) ----------------*/
	/* Description - MEASURE_METHOD_BATH=0, MEASURE_METHOD_ONES=1, MEASURE_METHOD_IET=2, MEASURE_METHOD_XOR= 3 */
	/* 0x114.0 - 0x114.1 */
	 u_int8_t eth_measure_method;
};

/* Description -   */
/* Size in bytes - 220 */
struct connectx4lx_err_correction_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_err_correction_cap cap;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xdc.31 */
	 struct connectx4lx_sm_admin_ini sm_admin;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_phy_temp_cfg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - bit_per_port */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t mloop_en;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_phy_lcl_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - mlpn1, 1 - mlx_phy_en, relevant only if 'mlpn_enable' = 1 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t mlpn_mode;
	/* Description - 0 - mlpn disabled, 1 - mlpn enabled due to mlpn_mode field */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t mlpn_enable;
	/* Description - if set then when using active cable the sd type used will be vendor id */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t force_vendor_id;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t ll_llr_req;
	/* Description - When set, port will skip negotiation and start sending IDLEs. */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t force_mode;
	/* Description - for extended kr startup time. */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t extended_time_sup;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t FC_ability;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t FC_request;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t RS_ability;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t RS_request;
	/* Description - if set then the fec request in non mlpn flow will be as defined by spec according to cable */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t non_mlpn_fec_request_is_spec;
	/* Description - if set then the fec request in mlpn flow will be as defined by spec according to cable */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t mlpn_fec_request_is_spec;
	/* Description -  stop sending consortium next pages */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t disable_consortium;
	/* Description - consortium version:
0 - version 1.6 
1 - version 1.5.1
 */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t consortium_version;
	/* Description - when set, only 50GBaseKR4 is supported and only in force mode */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t speed_50g_kr4_en;
	/* Description - when set, 9 start points are enabled */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t extra_start_points_ib_en;
	/* Description -  */
	/* 0x0.16 - 0x0.22 */
	 u_int8_t local_attenuation;
	/* Description - Attnt type:
0 - The trace attenuation (does not include the cable / backplane)
1 - The entire channel attenuation
 */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t attnt;
	/* Description - when set  work as IEEE spec, when reset we work as cisco spec */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t base1000x_SGMII_;
	/* Description - if  = 0 then disable parallel detection in cl37 */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t eth_1g_legacy_support;
	/* Description - Bit 0 - Phy remote loopback ,Bit 1 - Phy local loopback ,Bit 2 - External local loopback */
	/* 0x0.26 - 0x0.28 */
	 u_int8_t lb_cap;
	/* Description - dont advertise IEEE 25G in base page */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t disable_IEEE_25G;
	/* Description - dont advertise IEEE_S 25G in base page */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t disable_IEEE_25G_S;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.5 */
	 u_int8_t c_zero_steps;
	/* Description -  */
	/* 0x4.6 - 0x4.11 */
	 u_int8_t c_min1_steps;
	/* Description -  */
	/* 0x4.12 - 0x4.17 */
	 u_int8_t c_pls1_steps;
	/* Description - 0 - DEC, 1 - INC */
	/* 0x4.18 - 0x4.18 */
	 u_int8_t c_zero_inc_dec_;
	/* Description - 0 - DEC, 1 - INC */
	/* 0x4.19 - 0x4.19 */
	 u_int8_t c_min1_inc_dec_;
	/* Description - 0 - DEC, 1 - INC */
	/* 0x4.20 - 0x4.20 */
	 u_int8_t c_pls1_inc_dec_;
	/* Description - 0 - preset, 1 - init */
	/* 0x4.21 - 0x4.21 */
	 u_int8_t init_preset_;
	/* Description - 0 - ABA
 1 - tx_tuning_algorithm_1 */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t mlx_phy_tx_tuning_algorithm;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 struct connectx4lx_eth_speeds_supported eth_speeds_supported;
	/* Description - 0 - No override, 1 - No FEC , 2- RESERVED , 3- RS FEC */
	/* 0x8.8 - 0x8.9 */
	 u_int8_t fec_override_admin_100g;
	/* Description - 0 - No override, 1 - No FEC , 2- FC FEC   , 3- RS FEC */
	/* 0x8.10 - 0x8.11 */
	 u_int8_t fec_override_admin_25g_50g;
	/* Description - 0 - No override, 1 - No FEC , 2- FC FEC   , 3- RESERVED */
	/* 0x8.12 - 0x8.13 */
	 u_int8_t fec_override_admin_10g_40g;
	/* Description - 0 - No override, 1 - No FEC , 2- FC FEC   , 3- RESERVED */
	/* 0x8.14 - 0x8.15 */
	 u_int8_t fec_override_admin_56g;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pldm_supported_features {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t num_sensor_uint16_sensor_id;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t platform_event_message;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t unified_temp_reporting;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t firmware_update;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pldm_sensor_rec_handle_en {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rh_terminus_pdr;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t rh_health_pdr;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t rh_port_0_link_pdr;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t rh_port_1_link_pdr;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t rh_primary_temp_pdr;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t rh_port_0_temp_pdr;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t rh_port_1_temp_pdr;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t rh_port_0_link_speed_pdr;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t rh_port_1_link_speed_pdr;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t rh_ambient_temp_pdr;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_oem_enable {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - enable per group masking. If clear the value of next bits is ignored */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t mask_en;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t always_en;
	/* Description - set if passthrough supported */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t pt_only_en;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t iscsi_en;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t wol_en;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_pca9536_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - def_val of gpio that on the expander */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t def_val;
	/* Description - configure input-1/output-0 gpio */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t config;
	/* Description - gpio_polarity */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t polarity;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pca9555_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - def_val of gpio that on the expander */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t def_val;
	/* Description - configure input-1/output-0 gpio */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t config;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_port_cap_mask1 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_port_cap_mask1_fields fields;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_dword_val dword;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_status2pattern {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t ber_none;
	/* Description -  */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t ber_link_down;
	/* Description -  */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t ber_link_up;
	/* Description -  */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t ber_low_rate;
	/* Description -  */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t ber_high_rate;
	/* Description -  */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t ber_i2c_error;
	/* Description -  */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t traffic_link_down;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t traffic_link_up_no_traffic;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t traffic_low_rate;
	/* Description -  */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t traffic_medium_rate;
	/* Description -  */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t traffic_high_rate;
	/* Description -  */
	/* 0x4.12 - 0x4.15 */
	 u_int8_t status_led_over_temperture;
	/* Description -  */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t status_led_over_current;
	/* Description -  */
	/* 0x4.20 - 0x4.23 */
	 u_int8_t status_led_healty;
	/* Description -  */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t fans_healthy;
	/* Description -  */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t fans_not_present;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t fans_speed_not_in_range;
	/* Description -  */
	/* 0x8.4 - 0x8.7 */
	 u_int8_t ps1_healthy;
	/* Description -  */
	/* 0x8.8 - 0x8.11 */
	 u_int8_t ps1_not_present;
	/* Description -  */
	/* 0x8.12 - 0x8.15 */
	 u_int8_t ps1_error;
	/* Description -  */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t ps2_healthy;
	/* Description -  */
	/* 0x8.20 - 0x8.23 */
	 u_int8_t ps2_not_present;
	/* Description -  */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t ps2_error;
	/* Description -  */
	/* 0x8.28 - 0x8.31 */
	 u_int8_t uid_boot_series;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t uid_manual;
	/* Description -  */
	/* 0xc.4 - 0xc.7 */
	 u_int8_t bad_led_ber;
	/* Description -  */
	/* 0xc.8 - 0xc.11 */
	 u_int8_t bad_led_i2c_error;
	/* Description -  */
	/* 0xc.12 - 0xc.15 */
	 u_int8_t ber_beacon;
	/* Description -  */
	/* 0xc.16 - 0xc.19 */
	 u_int8_t traffic_beacon;
	/* Description -  */
	/* 0xc.20 - 0xc.23 */
	 u_int8_t pci_gen_1;
	/* Description -  */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t pci_gen_2;
	/* Description -  */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t traffic_max_rate;
};

/* Description -   */
/* Size in bytes - 0 */
struct connectx4lx_pattern_length_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t data;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_pattern_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_reset_version {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Reset considered only if valid is set */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t valid;
	/* Description - If Major matches. Match means seamless reset. Greater means reset supported. Less then upgrade not supported */
	/* 0x0.4 - 0x0.15 */
	 u_int16_t minor;
	/* Description - Match means upgrade supported, mismatch implies reset not supported */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t major;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dcr_odp_events {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dcr_odp_event_entry event_entry[16];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_disable_mask_value {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This value correspond to the bits in disable_mask_bits that influence any_disable_bit_set f       unction. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t value;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_disable_mask_bits {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 - port is disabled due to module absence / cage power off */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t module_not_present;
	/* Description - 1 - port is disabled due to paos command */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t paos;
	/* Description - 1 - port is disabled due to IB PortInfo MAD */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t mad;
	/* Description - 1 - port is disabled by ini setting, this port will never be used in this system */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t non_mlnx_long_range_cable;
	/* Description - 1 - port is disabled due to verification command */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t verification;
	/* Description - 1 - port is disabled due to ekey command */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t ekey;
	/* Description - 1 - port is disabled when cable requires high power but INI doesn't allow it */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t high_power_not_allowed;
	/* Description - 1 - port is disabled when cable identifier is unknown */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t unknown_identifier;
	/* Description - 1 - port is disabled due to admin_up_once is active */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t paos_up_once_active;
	/* Description - 1 - port is disabled due to stamping mismatch */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t stamping_failure;
	/* Description - 1 - port is disabled due to calibration not done */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t calibration;
	/* Description - 1 - port is disabled due to force link down */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t force_link_down;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_mctp_oem_message_header {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - major element, feature set of device enumerator */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t object_type;
	/* Description - set for requests andd cleared for responses */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t req;
	/* Description -  */
	/* 0x0.8 - 0x0.23 */
	 u_int16_t pci_vid;
	/* Description - Present only in the first packet of a message (som=1).

0x00 - MCTP control
0x02 - NC-SI control
0x03 - Ethernet (N/A) */
	/* 0x0.24 - 0x0.30 */
	 u_int8_t msg_type;
	/* Description - Integrity check: present only in the first packet of a message (som=1).
msg_type 0x00 (MCTP control)            the value is 0 (no integrity check)
msg_type 0x02 (NC-SI control over MCTP) the value is 0
msg_type 0x03 (Ethernet over MCTP)      the value is 1 */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t ic;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - only for responses and acks */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t completion_code;
	/* Description - size in bytes following hdr, and up to 2K. Does not include header size, but does include completion code and 32b crc value */
	/* 0x4.8 - 0x4.18 */
	 u_int16_t payload_size;
	/* Description - 0-get, 1-put, 2-post, 3-delete */
	/* 0x4.20 - 0x4.21 */
	 u_int8_t cmd_method;
	/* Description -  */
	/* 0x4.22 - 0x4.23 */
	 u_int8_t hdr_ver;
	/* Description - index to an instance of the object field */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t instance;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_mctp_vnd_pci_debug_words {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t words[64];
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_tlv_words {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - write - input, read -output. Data including headers */
	/* 0x0.0 - 0x80.31 */
	 u_int32_t tlv[32];
};

/* Description -   */
/* Size in bytes - 60 */
struct connectx4lx_dcbx_cee_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t oui_23_8;
	/* Description -  */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t tlv_length;
	/* Description -  */
	/* 0x0.25 - 0x0.31 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.8 */
	 u_int16_t ctrl_subtlv_length;
	/* Description -  */
	/* 0x4.9 - 0x4.15 */
	 u_int8_t ctrl_subtlv_type;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t subtype;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t oui_7_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t ctrl_seq_no_31_16;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t ctrl_max_version;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t ctrl_op_version;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t ctrl_ack_no_31_16;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t ctrl_seq_no_15_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.8 */
	 u_int16_t pg_subtlv_length;
	/* Description -  */
	/* 0x10.9 - 0x10.15 */
	 u_int8_t pg_subtlv_type;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t ctrl_ack_no_15_0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t pg_op_subtype;
	/* Description -  */
	/* 0x14.13 - 0x14.13 */
	 u_int8_t pg_error;
	/* Description -  */
	/* 0x14.14 - 0x14.14 */
	 u_int8_t pg_willing;
	/* Description -  */
	/* 0x14.15 - 0x14.15 */
	 u_int8_t pg_enable;
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t pg_max_version;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t pg_op_version;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t pg_pg_to_prio;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t pg_pg_bw_allocation_63_32;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t pg_pg_bw_allocation_31_0;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.7 */
	 u_int8_t pfc_op_version;
	/* Description -  */
	/* 0x24.8 - 0x24.16 */
	 u_int16_t pfc_subtlv_length;
	/* Description -  */
	/* 0x24.17 - 0x24.23 */
	 u_int8_t pfc_subtlv_type;
	/* Description -  */
	/* 0x24.24 - 0x24.31 */
	 u_int8_t pg_max_num_of_tcs;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.7 */
	 u_int8_t pfc_pfc_en_table;
	/* Description -  */
	/* 0x28.8 - 0x28.15 */
	 u_int8_t pfc_op_subtype;
	/* Description -  */
	/* 0x28.21 - 0x28.21 */
	 u_int8_t pfc_error;
	/* Description -  */
	/* 0x28.22 - 0x28.22 */
	 u_int8_t pfc_willing;
	/* Description -  */
	/* 0x28.23 - 0x28.23 */
	 u_int8_t pfc_enable;
	/* Description -  */
	/* 0x28.24 - 0x28.31 */
	 u_int8_t pfc_max_version;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.7 */
	 u_int8_t app_op_version;
	/* Description -  */
	/* 0x2c.8 - 0x2c.16 */
	 u_int16_t app_subtlv_length;
	/* Description -  */
	/* 0x2c.17 - 0x2c.23 */
	 u_int8_t app_subtlv_type;
	/* Description -  */
	/* 0x2c.24 - 0x2c.31 */
	 u_int8_t pfc_max_tcs_with_pfc;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.7 */
	 u_int8_t app_protocol_15_8;
	/* Description -  */
	/* 0x30.8 - 0x30.15 */
	 u_int8_t app_op_subtype;
	/* Description -  */
	/* 0x30.21 - 0x30.21 */
	 u_int8_t app_error;
	/* Description -  */
	/* 0x30.22 - 0x30.22 */
	 u_int8_t app_willing;
	/* Description -  */
	/* 0x30.23 - 0x30.23 */
	 u_int8_t app_enable;
	/* Description -  */
	/* 0x30.24 - 0x30.31 */
	 u_int8_t app_max_version;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.15 */
	 u_int16_t app_lower_oui;
	/* Description -  */
	/* 0x34.16 - 0x34.17 */
	 u_int8_t app_sel_field;
	/* Description -  */
	/* 0x34.18 - 0x34.23 */
	 u_int8_t app_upper_oui;
	/* Description -  */
	/* 0x34.24 - 0x34.31 */
	 u_int8_t app_protocol_7_0;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.24 - 0x38.31 */
	 u_int8_t app_user_prio_map;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_dcbx_app {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t oui_0;
	/* Description -  */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t tlv_length;
	/* Description -  */
	/* 0x0.25 - 0x0.31 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t protocol_1;
	/* Description -  */
	/* 0x4.10 - 0x4.12 */
	 u_int8_t sel_field;
	/* Description -  */
	/* 0x4.13 - 0x4.15 */
	 u_int8_t priority;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t subtype;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t oui_1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t protocol_2;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_dcbx_pfc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t oui_0;
	/* Description -  */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t tlv_length;
	/* Description -  */
	/* 0x0.25 - 0x0.31 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t pfc_en;
	/* Description -  */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t num_of_tc_supp_pfc;
	/* Description -  */
	/* 0x4.14 - 0x4.14 */
	 u_int8_t mac_sec;
	/* Description -  */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t willing;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t subtype;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t oui_1;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_dcbx_ets_reco {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t oui_0;
	/* Description -  */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t tlv_length;
	/* Description -  */
	/* 0x0.25 - 0x0.31 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t prio_table_31_24;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t subtype;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t oui_1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t tc_bw_63_56;
	/* Description -  */
	/* 0x8.8 - 0x8.31 */
	 u_int32_t prio_table_23_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t tc_bw_55_24;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t tsa_per_tc_63_56;
	/* Description -  */
	/* 0x10.8 - 0x10.31 */
	 u_int32_t tc_bw_23_0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t tsa_per_tc_55_24;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.8 - 0x18.31 */
	 u_int32_t tsa_per_tc_23_0;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_dcbx_ets_conf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t oui_0;
	/* Description -  */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t tlv_length;
	/* Description -  */
	/* 0x0.25 - 0x0.31 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t prio_table_31_24;
	/* Description -  */
	/* 0x4.8 - 0x4.10 */
	 u_int8_t num_of_tc;
	/* Description -  */
	/* 0x4.14 - 0x4.14 */
	 u_int8_t cbs;
	/* Description -  */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t willing;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t subtype;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t oui_1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t tc_bw_63_56;
	/* Description -  */
	/* 0x8.8 - 0x8.31 */
	 u_int32_t prio_table_23_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t tc_bw_55_24;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t tsa_per_tc_63_56;
	/* Description -  */
	/* 0x10.8 - 0x10.31 */
	 u_int32_t tc_bw_23_0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t tsa_per_tc_55_24;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.8 - 0x18.31 */
	 u_int32_t tsa_per_tc_23_0;
};

/* Description -  uint64 subnode can't be a field of a union */
/* Size in bytes - 8 */
struct connectx4lx_uint64_wa_678118 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t as_u64;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lldp_tlv_extended_type_dwords {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t high;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t low;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_lldp_tlv_extended_type_fields {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t oui_sub;
	/* Description -  */
	/* 0x0.24 - 0x0.30 */
	 u_int8_t tlv_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - only 3 lsb bytes */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t oui;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_dmfs_ft_type_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - the root flow table id */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t root_ft;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t ft_exist;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t level0_ft_exist;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t is_ft_root_set;
};

/* Description -   */
/* Size in bytes - 68 */
struct connectx4lx_ocbb_fields_from_vpd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0x28.23 */
	 u_int8_t product_name[40];
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.24 - 0x34.23 */
	 u_int8_t part_number[12];
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.24 - 0x40.23 */
	 u_int8_t serial_number[12];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.8 - 0x40.15 */
	 u_int8_t serial_number_size;
	/* Description -  */
	/* 0x40.16 - 0x40.23 */
	 u_int8_t part_number_size;
	/* Description -  */
	/* 0x40.24 - 0x40.31 */
	 u_int8_t product_name_size;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_fw_banner {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 u_int32_t fw_banner_str[3];
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_sfp_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 for modules  (link length supported)  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t cable_length;
	/* Description - LSB - Passive cable 
MSB - Active cable */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t cable_tech;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t passive;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t active;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t nbr_25;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t speed_10gbase_sr;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t speed_10gbase_lr;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t sgmii;
	/* Description - reserve if passive =1; if set a2h is supported without change address sequence */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t support_a2h_without_change_sequence;
	/* Description - com_code_bit */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t sfp_25gbase_active_fec;
	/* Description - com_code_bit */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t sfp_25gbase_active_nofec;
	/* Description - com_code_bit */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t sfp_25gbase_sr;
	/* Description - com_code_bit */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t sfp_25gbase_cr_ca_s;
	/* Description - com_code_bit */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t sfp_25gbase_cr_ca_n;
	/* Description - com_code_bit */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t sfp_25gbase_cr_ca_l;
	/* Description - if set- application_select_implemented */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t application_select_implemented;
	/* Description - module_cap byte 36 */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t module_cap;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - if set- attenuation bit in QSFP st are valid */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t sfp_attenuation_valid;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t sfp_rate_select_implemented;
	/* Description -  */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t sfp_soft_rate_select_implemented;
	/* Description -  */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t sfp_soft_rate_select_implemented_sff_8431;
	/* Description -  0-rs0, 1- rs1 */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t sfp_soft_state;
	/* Description - 0- everything plugged, 1- external link unplugged  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t rx_los_value;
	/* Description - com_code_bit */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t sfp_25gbase_lr;
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t sfp_nominal_rate_below_15g;
	/* Description - soft_rs0 byte, bit 3 is rs0 */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t soft_rs0_byte;
	/* Description - soft_rs1 byte  bit 3 is rs1 */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t soft_rs1_byte;
	/* Description - rx_los enable read from i/o */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t sfp_rx_los_io_en;
	/* Description - tx_fault enable read from memory map */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t sfp_tx_fault_soft_en;
	/* Description - tx_fault enable read from i/o */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t sfp_tx_fault_io_en;
	/* Description - rx_los enable read from memory map */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t sfp_rx_los_soft_en;
	/* Description - no capability to change rs0 and rs1 with differenet values */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t rs0_rs1_shorted_together;
	/* Description - capability to configure rs1 */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t sfp_rs_phy_cap;
	/* Description - default value (after or between module and GPIO) for rs0 */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t rs0_default;
	/* Description - default value (after or between module and GPIO) for rs1 */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t rs1_default;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - current value (after or between module and GPIO) for rs0 */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t rs0_value;
	/* Description - current value (after or between module and GPIO) for rs1 */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t rs1_value;
	/* Description -  */
	/* 0x8.2 - 0x8.2 */
	 u_int8_t nbr_10;
	/* Description -  */
	/* 0x8.3 - 0x8.3 */
	 u_int8_t sfp_no_comp;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t rx_output_emp;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t tx_input_eq;
	/* Description -  */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t ethernet_compliance_codes;
	/* Description -  */
	/* 0x8.28 - 0x8.28 */
	 u_int8_t cdr_prsnt;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t base_t_module;
	/* Description -  */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t base_t_init_done;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_qsfp_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t flat_memory;
	/* Description - 0 for modules  (link length supported)  */
	/* 0x0.1 - 0x0.8 */
	 u_int8_t cable_length;
	/* Description - (device tech) */
	/* 0x0.9 - 0x0.12 */
	 u_int8_t transmitter_tech;
	/* Description -  */
	/* 0x0.13 - 0x0.20 */
	 u_int8_t ib_speed;
	/* Description - MSB- Tx, LSB- Rx */
	/* 0x0.21 - 0x0.22 */
	 u_int8_t cdr_prsnt;
	/* Description -  */
	/* 0x0.23 - 0x0.30 */
	 u_int8_t page_cap_type;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t passive;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t cable_led_supported;
	/* Description -  */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t fw_revision;
	/* Description - (VendorID)
(optic fdr set index) */
	/* 0x4.5 - 0x4.12 */
	 u_int8_t vendor_id;
	/* Description - revision compliance */
	/* 0x4.13 - 0x4.20 */
	 u_int8_t memory_map_version;
	/* Description -  */
	/* 0x4.21 - 0x4.28 */
	 u_int8_t extended_spec_com_codes;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t extended_spec_com_codes_valid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t atten_5g;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t atten_7g;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t atten_12g;
	/* Description - port RX output de-emphasis capability */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t rx_output_emp_capability;
	/* Description - port RX amplitude capability */
	/* 0x8.25 - 0x8.25 */
	 u_int8_t rx_output_amp_capability;
	/* Description - input equalization capability */
	/* 0x8.26 - 0x8.26 */
	 u_int8_t tx_input_eq_capability;
	/* Description - TX CDR control capability */
	/* 0x8.27 - 0x8.27 */
	 u_int8_t tx_input_cdr_ctrl_capability;
	/* Description - RX CDR control capability */
	/* 0x8.28 - 0x8.28 */
	 u_int8_t rx_output_cdr_ctrl_capability;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - port RX output de-emphasis */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t rx_output_emp;
	/* Description - port RX amplitude */
	/* 0xc.4 - 0xc.5 */
	 u_int8_t rx_output_amp;
	/* Description - lane input equalization */
	/* 0xc.6 - 0xc.9 */
	 u_int8_t tx_input_eq_3;
	/* Description - lane input equalization */
	/* 0xc.10 - 0xc.13 */
	 u_int8_t tx_input_eq_2;
	/* Description - lane input equalization */
	/* 0xc.14 - 0xc.17 */
	 u_int8_t tx_input_eq_1;
	/* Description - lane input equalization */
	/* 0xc.18 - 0xc.21 */
	 u_int8_t tx_input_eq_0;
	/* Description -  */
	/* 0xc.22 - 0xc.22 */
	 u_int8_t rx_output_cdr_ctrl_0;
	/* Description -  */
	/* 0xc.23 - 0xc.23 */
	 u_int8_t rx_output_cdr_ctrl_1;
	/* Description -  */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t rx_output_cdr_ctrl_2;
	/* Description -  */
	/* 0xc.25 - 0xc.25 */
	 u_int8_t rx_output_cdr_ctrl_3;
	/* Description -  */
	/* 0xc.26 - 0xc.26 */
	 u_int8_t tx_input_cdr_ctrl_0;
	/* Description -  */
	/* 0xc.27 - 0xc.27 */
	 u_int8_t tx_input_cdr_ctrl_1;
	/* Description -  */
	/* 0xc.28 - 0xc.28 */
	 u_int8_t tx_input_cdr_ctrl_2;
	/* Description -  */
	/* 0xc.29 - 0xc.29 */
	 u_int8_t tx_input_cdr_ctrl_3;
	/* Description - default value of the RX CDR ctrl, assumption that all 4 lanes have the same default value */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t default_rx_output_cdr_ctrl_0;
	/* Description - default value of the TX CDR ctrl, assumption that all 4 lanes have the same default value */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t default_tx_input_cdr_ctrl_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t mellanox_tuning_capability;
	/* Description -  */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t tx_input_pre_correction;
	/* Description -  */
	/* 0x10.16 - 0x10.23 */
	 u_int8_t tx_input_main_correction;
	/* Description -  */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t tx_input_post_correction;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.3 */
	 u_int8_t tx_input_eq_correction;
	/* Description -  */
	/* 0x14.4 - 0x14.7 */
	 u_int8_t rx_output_emp_correction;
	/* Description -  */
	/* 0x14.8 - 0x14.15 */
	 u_int8_t mellanox_tuning_checksum;
	/* Description -  */
	/* 0x14.16 - 0x14.16 */
	 u_int8_t extended_valid;
	/* Description -  */
	/* 0x14.17 - 0x14.17 */
	 u_int8_t speed_100gbase_cr4;
	/* Description -  */
	/* 0x14.18 - 0x14.18 */
	 u_int8_t speed_100gbase_sr4;
	/* Description -  */
	/* 0x14.19 - 0x14.19 */
	 u_int8_t speed_100gbase_lr4;
	/* Description -  */
	/* 0x14.20 - 0x14.20 */
	 u_int8_t speed_100g_active;
	/* Description -  */
	/* 0x14.21 - 0x14.21 */
	 u_int8_t speed_40gbase_cr4;
	/* Description -  */
	/* 0x14.22 - 0x14.22 */
	 u_int8_t speed_40gbase_sr4;
	/* Description -  */
	/* 0x14.23 - 0x14.23 */
	 u_int8_t speed_40gbase_lr4;
	/* Description -  */
	/* 0x14.24 - 0x14.24 */
	 u_int8_t speed_40g_active;
	/* Description -  */
	/* 0x14.25 - 0x14.25 */
	 u_int8_t speed_10gbase_sr;
	/* Description -  */
	/* 0x14.26 - 0x14.26 */
	 u_int8_t speed_10gbase_lr;
	/* Description -  */
	/* 0x14.27 - 0x14.27 */
	 u_int8_t speed_ib_fdr;
	/* Description -  */
	/* 0x14.28 - 0x14.28 */
	 u_int8_t speed_1g_x;
	/* Description -  */
	/* 0x14.29 - 0x14.29 */
	 u_int8_t speed_100gbase_cwdm4_fec;
	/* Description -  */
	/* 0x14.30 - 0x14.30 */
	 u_int8_t speed_100gbase_cwdm4_nofec;
	/* Description -  */
	/* 0x14.31 - 0x14.31 */
	 u_int8_t speed_100g_active_nofec;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.0 */
	 u_int8_t speed_25gbase_cr_ca_s;
	/* Description -  */
	/* 0x18.1 - 0x18.1 */
	 u_int8_t speed_25gbase_cr_ca_n;
	/* Description -  */
	/* 0x18.2 - 0x18.2 */
	 u_int8_t qsfp_far_1_lanes;
	/* Description -  */
	/* 0x18.3 - 0x18.3 */
	 u_int8_t qsfp_far_2_lanes;
	/* Description -  */
	/* 0x18.4 - 0x18.4 */
	 u_int8_t qsfp_near_1_lanes;
	/* Description -  */
	/* 0x18.5 - 0x18.5 */
	 u_int8_t qsfp_near_2_lanes;
	/* Description -  */
	/* 0x18.6 - 0x18.6 */
	 u_int8_t qsfp_effective_1_lane;
	/* Description -  */
	/* 0x18.7 - 0x18.7 */
	 u_int8_t qsfp_effective_2_lane;
	/* Description -  */
	/* 0x18.8 - 0x18.8 */
	 u_int8_t qsfp_effective_4_lane;
	/* Description -  */
	/* 0x18.9 - 0x18.9 */
	 u_int8_t qsfb_nbr_20;
	/* Description -  */
	/* 0x18.10 - 0x18.10 */
	 u_int8_t qsfb_nbr_50;
	/* Description -  */
	/* 0x18.11 - 0x18.11 */
	 u_int8_t qsfp_lc_connector;
	/* Description -  */
	/* 0x18.12 - 0x18.12 */
	 u_int8_t qsfp_bidi_40;
	/* Description -  */
	/* 0x18.13 - 0x18.13 */
	 u_int8_t aoc_no_fec_report_override;
	/* Description -  */
	/* 0x18.14 - 0x18.14 */
	 u_int8_t qsfp_not_compliance_code;
	/* Description -  */
	/* 0x18.15 - 0x18.15 */
	 u_int8_t qsfp_csco_cable;
	/* Description -  */
	/* 0x18.16 - 0x18.16 */
	 u_int8_t qsfp_csco_passive_cable;
	/* Description -  */
	/* 0x18.17 - 0x18.17 */
	 u_int8_t qsfp_csco_active_cable;
	/* Description -  */
	/* 0x18.18 - 0x18.18 */
	 u_int8_t qsfp_csco_10g_active_cable;
	/* Description -  */
	/* 0x18.19 - 0x18.19 */
	 u_int8_t qsfp_csco_sr_module_cable;
	/* Description -  */
	/* 0x18.20 - 0x18.20 */
	 u_int8_t qsfp_csco_lr_er_module_cable;
	/* Description -  */
	/* 0x18.21 - 0x18.21 */
	 u_int8_t qsfp_csco_bidi_module_cable;
	/* Description -  */
	/* 0x18.22 - 0x18.22 */
	 u_int8_t qsfp_csco_bidi_rx_module_cable;
	/* Description -  */
	/* 0x18.23 - 0x18.23 */
	 u_int8_t qsfp_nominal_rate_below_15g;
	/* Description -  */
	/* 0x18.24 - 0x18.24 */
	 u_int8_t qsfp_fdr_cable;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t cable_version;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.7 */
	 u_int8_t cable_breakout;
	/* Description -  */
	/* 0x20.8 - 0x20.15 */
	 u_int8_t ethernet_compliance_code;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_general_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  eeprom_present = 1 -> the module has eeprom. data can be read from the module.
eeprom_present = 0 -> the module witout eeprom. */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t eeprom_prsnt;
	/* Description - 1 - module is present  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t prsnt;
	/* Description - QSFP - 0xC, QSFP+ - 0xD, QSFP28 - 0x11
SFP - 0x3
 */
	/* 0x0.2 - 0x0.9 */
	 u_int8_t identifier;
	/* Description - 1 - this module connector has mellanox OUI 
0 - this module connector has other vendor OUI */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t mlnx_connector;
	/* Description - This field identifies if the module is long-range type */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t long_range_cable;
	/* Description - Equal to 1 if cable supports high power but it is not allowed due to INI configuration */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t high_power_not_allowed;
	/* Description - 1W =0, 1.5W=1, 2W=2, 2.5W=3, 3.5W=4 */
	/* 0x0.13 - 0x0.15 */
	 u_int8_t cable_power_level_supported;
	/* Description - For QSFP contains addr 93, and for SFP addr 118 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t power_write_byte;
	/* Description - dont_access = 1 -> this module got the i2c bus stuck. the module machines won't access
this module until the connector will be plugged out (causing clear to this bit) */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t dont_access;
	/* Description - if = 1 -> this module got the i2c bus stuck and recovery flow was activated. */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t recovery_flow_was_activated;
	/* Description - cp pn list locking */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t activate_cp_cable_locking;
	/* Description - bad_cable = 1 -> this module got over current, and we need to close it, untill tha cable will be plugged out. */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t bad_cable;
	/* Description - unused =0, 4W=5, 4.5W=6, 5W=7 */
	/* 0x0.28 - 0x0.30 */
	 u_int8_t cable_power_level_supported_high;
	/* Description - When GPIO shows module is plugged out this bit will be turned on until plugging out is complete. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t gpio_not_prsnt;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - last page selected for this module */
	/* 0x4.0 - 0x4.8 */
	 u_int16_t module_selected_page;
	/* Description - is module separated from the cabel */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t module_separated;
	/* Description - bidi */
	/* 0x4.10 - 0x4.10 */
	 u_int8_t no_mlpn_module;
	/* Description - disconnected by configuration (pmaos disconnect) */
	/* 0x4.11 - 0x4.11 */
	 u_int8_t disconnected_by_conf;
	/* Description - disconnected by power management (PCI slot power limit) */
	/* 0x4.12 - 0x4.12 */
	 u_int8_t disconnected_by_power_mng;
	/* Description - nominal laser wavelength in nm */
	/* 0x4.13 - 0x4.28 */
	 u_int16_t wavelength;
	/* Description - flag that recovery is according phy2module (to not raise dont access) */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t phy2module_recovery;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_resource_type_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t type;
	/* Description - resource is locked in icmc */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t locked;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_index_and_length {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - first open resource index */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - number of open resources following (including the first one) */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t length;
};

/* Description -   */
/* Size in bytes - 8 */
union connectx4lx_flow_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_dest_format_struct dest;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_flow_counter_list cntr;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_flow_table_entry_match_set_lyr_2_4 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Source MAC address of incoming packet. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t smac_47_16;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Incoming packet Ethertype - this is the Ethertype following the last VLAN 
tag of the packet. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t ethertype;
	/* Description - Source MAC address of incoming packet. */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t smac_15_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Destination MAC address of incoming packet. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t dmac_47_16;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - VLAN ID of first VLAN tag in the incoming packet. Valid only when 
cvlan_tag==1 or svlan_tag==1. */
	/* 0xc.0 - 0xc.11 */
	 u_int16_t first_vid;
	/* Description - CFI bit of first VLAN tag in the incoming packet. Valid only when 
cvlan_tag==1 or svlan_tag==1. */
	/* 0xc.12 - 0xc.12 */
	 u_int8_t first_cfi;
	/* Description - Priority of first VLAN tag in the incoming packet. Valid only when 
cvlan_tag==1 or svlan_tag==1. */
	/* 0xc.13 - 0xc.15 */
	 u_int8_t first_prio;
	/* Description - Destination MAC address of incoming packet. */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t dmac_15_0;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - TCP flags. 
Bit 0: FIN
Bit 1: SYN
Bit 2: RST
Bit 3: PSH
Bit 4: ACK
Bit 5: URG
Bit 6: ECE
Bit 7: CWR
Bit 8: NS */
	/* 0x10.0 - 0x10.8 */
	 u_int16_t tcp_flags;
	/* Description -  */
	/* 0x10.9 - 0x10.12 */
	 u_int8_t ip_version;
	/* Description - Packet is an IP fragment. */
	/* 0x10.13 - 0x10.13 */
	 u_int8_t frag;
	/* Description - The first vlan in the packet is s-vlan (0x8a88). cvlan_tag and svlan_tag 
cannot be set together. */
	/* 0x10.14 - 0x10.14 */
	 u_int8_t svlan_tag;
	/* Description - The first vlan in the packet is c-vlan (0x8100). cvlan_tag and svlan_tag 
cannot be set together */
	/* 0x10.15 - 0x10.15 */
	 u_int8_t cvlan_tag;
	/* Description - Explicit Congestion Notification derived from Traffic Class/TOS field of 
IPv6/v4 */
	/* 0x10.16 - 0x10.17 */
	 u_int8_t ip_ecn;
	/* Description - Differentiated Services Code Point derived from Traffic Class/TOS field 
of IPv6/v4 */
	/* 0x10.18 - 0x10.23 */
	 u_int8_t ip_dscp;
	/* Description - IP protocol. */
	/* 0x10.24 - 0x10.31 */
	 u_int8_t ip_protocol;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - TCP destination port. 
tcp and udp sport/dport are mutually exclusive. */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t tcp_dport;
	/* Description - TCP source port.
tcp and udp sport/dport are mutually exclusive. */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t tcp_sport;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - UDP destination port.
tcp and udp sport/dport are mutually exclusive. */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t udp_dport;
	/* Description - UDP source port.
tcp and udp sport/dport are mutually exclusive. */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t udp_sport;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - IPv6 source address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t src_ip_127_96;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - IPv6 source address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t src_ip_95_64;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - IPv6 source address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t src_ip_63_32;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - IPv6 source address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t src_ip_31_0;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - IPv6 destination address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t dst_ip_127_96;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - IPv6 destination address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t dst_ip_95_64;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - IPv6 destination address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t dst_ip_63_32;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - IPv6 destination address of incoming packets ;For IPv4 address use bits 31:0 (rest of the bits are reserved);This field should be qualified by an appropriate ;ether;t;ype */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t dst_ip_31_0;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_flow_table_entry_match_set_misc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Source SQN */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t source_sqn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Source port.
0xffff determines wire port. */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t source_port;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - VLAN ID of first VLAN tag the inner header of the incoming packet. Valid 
only when inner_second_cvlan_tag ==1 or inner_second_svlan_tag ==1. */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t inner_second_vid;
	/* Description - CFI bit of first VLAN tag in the inner header of the incoming packet. Valid 
only when inner_second_cvlan_tag ==1 or inner_second_svlan_tag ==1. */
	/* 0x8.12 - 0x8.12 */
	 u_int8_t inner_second_cfi;
	/* Description - Priority of second VLAN tag in the inner header of the incoming packet. 
Valid only when inner_second_cvlan_tag ==1 or inner_second_svlan_tag 
==1. */
	/* 0x8.13 - 0x8.15 */
	 u_int8_t inner_second_prio;
	/* Description - VLAN ID of first VLAN tag the outer header of the incoming packet. Valid 
only when outer_second_cvlan_tag ==1 or outer_second_svlan_tag ==1. */
	/* 0x8.16 - 0x8.27 */
	 u_int16_t outer_second_vid;
	/* Description - CFI bit of first VLAN tag in the outer header of the incoming packet. Valid 
only when outer_second_cvlan_tag ==1 or outer_second_svlan_tag ==1. */
	/* 0x8.28 - 0x8.28 */
	 u_int8_t outer_second_cfi;
	/* Description - Priority of second VLAN tag in the outer header of the incoming packet. 
Valid only when outer_second_cvlan_tag ==1 or outer_second_svlan_tag 
==1. */
	/* 0x8.29 - 0x8.31 */
	 u_int8_t outer_second_prio;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - GRE Protocol (outer). */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t gre_protocol;
	/* Description - The second vlan in the inner header of the packet is s-vlan (0x8a88). 
inner_second_cvlan_tag and inner_second_svlan_tag cannot be set together. */
	/* 0xc.28 - 0xc.28 */
	 u_int8_t inner_second_svlan_tag;
	/* Description - The second vlan in the outer header of the packet is s-vlan (0x8a88). out
er_second_cvlan_tag and outer_second_svlan_tag cannot be set together. */
	/* 0xc.29 - 0xc.29 */
	 u_int8_t outer_second_svlan_tag;
	/* Description - The second vlan in the inner header of the packet is c-vlan (0x8100). 
inner_second_cvlan_tag and inner_second_svlan_tag cannot be set together. */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t inner_second_cvlan_tag;
	/* Description - The second vlan in the outer header of the packet is c-vlan (0x8100). out
er_second_cvlan_tag and outer_second_svlan_tag cannot be set together. */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t outer_second_cvlan_tag;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - GRE Key [7:0] (outer). */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t gre_key_l;
	/* Description - GRE Key[31:8] (outer). */
	/* 0x10.8 - 0x10.31 */
	 u_int32_t gre_key_h;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - VXLAN VNI (outer). */
	/* 0x14.8 - 0x14.31 */
	 u_int32_t vxlan_vni;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - GENEVE OAM field (outer) */
	/* 0x18.0 - 0x18.0 */
	 u_int8_t geneve_oam;
	/* Description - GENEVE VNI field (outer) */
	/* 0x18.8 - 0x18.31 */
	 u_int32_t geneve_vni;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Flow label of incoming IPv6 packet (outer). */
	/* 0x1c.0 - 0x1c.19 */
	 u_int32_t outer_ipv6_flow_label;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Flow label of incoming IPv6 packet (inner). */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t inner_ipv6_flow_label;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - GENEVE protocol type (outer) */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t geneve_protocol_type;
	/* Description - GENEVE protocol type (outer) */
	/* 0x24.16 - 0x24.21 */
	 u_int8_t geneve_opt_len;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Destination QP in BTH header. */
	/* 0x28.0 - 0x28.23 */
	 u_int32_t bth_dst_qp;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_qsfp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t link_length;
	/* Description -  */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t transmitter_tech;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t extended_identifier;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t ib_speed_mask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t attenuation_5g;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t attenuation_7g;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t attenuation_12g;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t optic_set_index;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_sfp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t fiber_channel_speed;
	/* Description -  */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t ib_10GE_com_codes;
	/* Description -  */
	/* 0x0.15 - 0x0.22 */
	 u_int8_t eth_com_codes;
	/* Description -  */
	/* 0x0.23 - 0x0.31 */
	 u_int16_t tech;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t link_length_supported;
	/* Description - if set- attenuation bit in QSFP st are valid */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t sfp_attenuation_valid;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_grade_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t grade;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t ber;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t phase_grade;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.9 */
	 u_int16_t phase_center;
	/* Description -  */
	/* 0xc.10 - 0xc.19 */
	 u_int16_t bath_sigma;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.19 */
	 u_int32_t bath_grade;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.19 */
	 u_int32_t bath_dz;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.19 */
	 u_int32_t voltage_eo_grade;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.9 */
	 u_int16_t start_point_index;
	/* Description - 0- no shift
1- main taps 0,2
2- main taps 0,1 */
	/* 0x1c.10 - 0x1c.19 */
	 u_int16_t start_point_shifted;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_as_dw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t val;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_eth_protocols_as_bits {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t Speed1000BaseCX;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t Speed1000BaseKX;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t Speed10GBaseCX4;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t Speed10GBaseKX4;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t Speed10GBaseKR;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t Speed20GBaseR2;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t Speed40GBaseCR4;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t Speed40GBaseKR4;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t Speed56GBaseR4;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t Speed10GBaseCR;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t Speed10GBaseSR;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t Speed10GBaseLR;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t Speed40GBaseSR4;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t Speed40GBaseLR4;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t Speed50GBaseSR2;
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t Speed50GBaseKR4;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t Speed100GBaseCR4;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t Speed100GBaseSR4;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t Speed100GBaseKR4;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t Speed100GBaseLR4;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t Speed100BaseTX;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t Speed1000BaseT;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t Speed10GBaseT;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t Speed25GBaseCR;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t Speed25GBaseKR;
	/* Description -  */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t Speed25GBaseSR;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t Speed50GBaseCR2;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t Speed50GBaseKR2;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_ver_data_one_qp_per_recovery {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rw_;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t input;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t output;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_ver_data_max_atomic {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - minimum value of 5, max value is 8. Set 0 to return to original value */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t log_max_atomic_size;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_error_flow_trigger_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_rxw_ldb rxw_ldb;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_rxw_fte rxw_fte;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_rxc rxc;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_tpt_memop tpt_memop;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_tpt tpt;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_sxw sxw;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_error_flow_trigger_tag_rxt rxt;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_fw_vport_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  0-port is down, 1-port is up, 2-follow */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t esw_state;
	/* Description -  ETH: 0-port is down, 1-port is up, IB: 1-down, 2- initalize, 3- arm, 4- active */
	/* 0x0.2 - 0x0.4 */
	 u_int8_t nic_state;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t connected_2_steering;
	/* Description - bit mask: PORT_MAD_EVENT_NUM_PKEY =  0
PORT_MAD_EVENT_NUM_LID =  1
PORT_MAD_EVENT_NUM_CLIENT_REREG = 2
PORT_MAD_EVENT_NUM_GUID = 3
 PORT_MAD_EVENT_NUM_PORT_STATE = 4
PORT_MAD_EVENT_NUM_ERROR_CABLE_M0 = 5
PORT_MAD_EVENT_NUM_ERROR_CABLE_M1 = 6
 */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t event_mask;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_vf_pages_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int64_t pages[8];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icm_page_manager {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - pointer to first free page. Head of page linked list */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t page_list;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Number of free pages (without the pre-allocated pages) available to GVMI */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t free_count;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Number of used pages of GVMI */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t used_count;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Number of free pages + pre-allocated unused pages */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t page_list_length;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - If set, means page manager is used by another flow */
	/* 0x14.0 - 0x14.0 */
	 u_int8_t lock;
	/* Description - Event was triggered and response is still pending */
	/* 0x14.1 - 0x14.1 */
	 u_int8_t event_pending;
	/* Description - Received a command from driver refusing to give pages. Return fail instead of wait for alloc pages request */
	/* 0x14.2 - 0x14.2 */
	 u_int8_t driver_refused;
	/* Description -  0-init state, 1-default state, 2-teardown state */
	/* 0x14.3 - 0x14.4 */
	 u_int8_t state;
	/* Description -  */
	/* 0x14.5 - 0x14.5 */
	 u_int8_t valid;
	/* Description -  */
	/* 0x14.16 - 0x14.23 */
	 u_int8_t num_vf_pages;
	/* Description -  */
	/* 0x14.24 - 0x14.31 */
	 u_int8_t vf_page_ix;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - process address space id - CAPI/ATS */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t page_owner_pasid;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_hca_params {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t partition_cap;
	/* Description -  */
	/* 0x8.24 - 0x8.28 */
	 u_int8_t log_max_qp;
	/* Description -  */
	/* 0x8.29 - 0x8.29 */
	 u_int8_t phy_port_owner;
	/* Description -  */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t eswitch_owner;
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t dct;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.13 */
	 u_int8_t log_max_ra_res_qp;
	/* Description -  */
	/* 0xc.24 - 0xc.29 */
	 u_int8_t log_max_ra_req_qp;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t num_ports;
	/* Description - If set, 128 byte Cache line size is supported.0 means only 64 byte cache line is supported */
	/* 0x10.31 - 0x10.31 */
	 u_int8_t cache_line_128byte;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - log2_uar_page_sz in 4kbyte chunks. 4-64 kbyte supported */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t log_uar_page_sz;
	/* Description - sw format = log_gid_table_size-3: 0: 8 gid entries, 1: 16 gid entries, 2: 32 gid entries, 3: 64 gid entries, 4: 128 gid entries, other: reserved */
	/* 0x14.16 - 0x14.21 */
	 u_int8_t log_gid_table_size;
	/* Description -  */
	/* 0x14.22 - 0x14.22 */
	 u_int8_t uar_4k;
	/* Description - snapshot named_qp capability */
	/* 0x14.23 - 0x14.23 */
	 u_int8_t named_qp;
	/* Description - snapshot named_mkey capability */
	/* 0x14.24 - 0x14.24 */
	 u_int8_t named_mkey;
	/* Description - 0:BE,  1: according to HOST_ENDIENESS for 8B only */
	/* 0x14.28 - 0x14.29 */
	 u_int8_t atomic_req_8b_endianess_mode;
	/* Description -  */
	/* 0x14.30 - 0x14.30 */
	 u_int8_t init_hca_disable_linkup;
	/* Description - 0:BE   1:LE */
	/* 0x14.31 - 0x14.31 */
	 u_int8_t host_endianess;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_odp_hca_params odp_caps;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dummy_addresses_one_cache_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int64_t ix[8];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_cmdif_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t done_missions;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.24 */
	 u_int32_t res_num;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t cmd_valid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t opcode;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t op_mod;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t allocated_pages;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t needed_pages;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 union connectx4lx_flush_type flush_type;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - valid only when flush_type qp_flush is set */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t flush_qpn;
	/* Description - valid only when flush_type qp_flush is set */
	/* 0x18.24 - 0x18.31 */
	 u_int8_t flush_synd;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t nim_start_offset;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 union connectx4lx_cmdif_ctx_special s;
};

/* Description -   */
/* Size in bytes - 28 */
union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_sw_eqe_flat_data flat_data;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_comp_event comp_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_dct_events dct_events;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_qp_events qp_events;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_wqe_associated_page_fault_event wqe_associated_page_fault_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_rdma_page_fault_event rdma_page_fault_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_cq_error cq_error;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_dropped_packet_logged dropped_packet_logged;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_port_state_change_event port_state_change_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_gpio_event gpio_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_port_module_event port_module_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_dcbx_change_event dcbx_change_event;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_temp_warning_event temp_warning_event;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_db_bf_congestion_event db_bf_congestion_event;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_stall_vl_event stall_vl_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_cmd_inter_comp_event cmd_inter_comp_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_pages_req_event pages_req_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_nic_vport_change_event nic_vport_change_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_fpga_error_event fpga_error_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_fpga_qp_error_event fpga_qp_error_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_pps_event pps_event;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_general_notification_delay_drop_event general_notification_delay_drop_event;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_ncsi_response_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_get_link_status_response get_link_status;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_get_params_response get_params;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_get_version_id get_version_id;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_get_capabilities get_capabilities;
	/* Description -  */
	/* 0x0.0 - 0xc8.31 */
	 struct connectx4lx_get_port_stat get_port_stat;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_get_control_stat get_control_stat;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_get_pt_stat get_pt_stat;
	/* Description - each response contain a place holder for mlnx oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_mlnx_oem_resp mlnx_oem;
	/* Description - each response contain a place holder for lled oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_lled_oem_resp lled_oem;
	/* Description - each response contain a place holder for ph oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_ph_oem_resp ph_oem;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ncsi_hdr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t iid;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t hdr_rev;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t mc_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.11 */
	 u_int16_t pyld_len;
	/* Description -  */
	/* 0x4.16 - 0x4.20 */
	 u_int8_t intrnl_ch_id;
	/* Description -  */
	/* 0x4.21 - 0x4.23 */
	 u_int8_t pkg_id;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t command;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_ncsi_cmd_payload {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_set_mac_cmd_payload set_mac;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_set_vlan_cmd_payload set_vlan;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_enable_vlan_cmd_payload enable_vlan;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_broadcast_filter_settings en_broadcast_filter;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_multicast_filter_settings en_global_multicast_filter;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_set_link_cmd_payload set_link;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_aen_enable aen_enable;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_disable_channel disable_channel;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_set_ncsi_flow_control set_ncsi_flow_control;
	/* Description - each command contain a place holder for mlnx oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_mlnx_oem_cmd mlnx_oem;
	/* Description - each command contain a place holder for lled oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_lled_oem_cmd lled_oem;
	/* Description - each command contain a place holder for ph oem cmd hdr */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_ph_oem_cmd ph_oem;
};

/* Description -   */
/* Size in bytes - 272 */
union connectx4lx_icmd_generic_reg_access_reg_tlv_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x108.31 */
	 union connectx4lx_access_register_data_layout cmdif_access_register;
	/* Description -  */
	/* 0x0.0 - 0x10c.31 */
	 struct connectx4lx_generic_flash_reg_access_data flash_reg_access;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_reg_access_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.26 */
	 u_int16_t len;
	/* Description - enum {
    EMAD_TLV_TYPE_END   = 0x0,
    EMAD_TLV_TYPE_OPER  = 0x1,
    EMAD_TLV_TYPE_RD    = 0x2,
    EMAD_TLV_TYPE_REG   = 0x3,
    EMAD_TLV_TYPE_UDATA = 0x4,
};
 */
	/* 0x0.27 - 0x0.31 */
	 u_int8_t type;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_IB_TID {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t High;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t Low;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_kdnet_ctrl_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bus-Device-Function (BDF) of the PF that was/will be created for KDNET use.
This field is reserved when 
status
 field is DISABLED or ERROR. */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t kdnet_bdf;
	/* Description - Current status of the KDNET PF:
0x0: DISABLED
0x1: ENABLED
0x2: DISABLE_PENDING- the KDNET PF will be disabled after the next server boot
0x3: ENABLE_PENDING - the KDNET PF will be disabled after the next server boot.
0x4: BUSY - KDNET is enabled on other port
0xF: ERROR
other values are reserved */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t status;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_kdnet_ctrl_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Command operation:
0x0: DISABLE 
0x1: ENABLE 
0x2: QUERY 
other values are reserved */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t operation;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_itrace_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - threashhold of logging to print from:
0 - LOG_DEBUG
1 - LOG_INFO
2 - LOG_WARNING
3 - LOG_ERROR */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t log_level;
	/* Description - added delay (usec) to prevent log event lost */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t log_delay;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_output_inline_standart {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - check the io function before changing this field.
overrun while status and syndrom is writen */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t auto_1;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t status;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t syndrome;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t ix;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t auto_2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t auto_3;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_input_inline_standart {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - manually added, for reserved equal zero test */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t reserved_0;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t opcode;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t opcode_mod;
	/* Description - manually added, for reserved equal zero test */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t reserved_1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t ix;
	/* Description - manually added, for reserved equal zero test */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t reserved_2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - manually added, for reserved equal zero test */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t reserved_3;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_g_rse_decoders_as_dwords {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t dword[64];
};

/* Description -  // Created At Wed Apr  1 16:30:32 IDT 2015, By the following script (revision 1.48): /verification/utils/decoder2adb.tcl -f /verification/dotan/14_1r1/linux/rbv.cache/out//rxs_rxt_desc_decoder.v -o rxs_rxt_desc_decoder -adbfile ../adabe/dotan//hw_decoders_st.adb */
/* Size in bytes - 64 */
struct connectx4lx_rxs_rxt_desc_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.13 */
	 u_int16_t scatter_offset_3;
	/* Description -  */
	/* 0x0.16 - 0x0.29 */
	 u_int16_t scatter_offset_4;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.13 */
	 u_int16_t scatter_offset_1;
	/* Description -  */
	/* 0x4.16 - 0x4.29 */
	 u_int16_t scatter_offset_2;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.13 */
	 u_int16_t scatter_end_offset_4;
	/* Description -  */
	/* 0x8.16 - 0x8.29 */
	 u_int16_t scatter_offset_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.13 */
	 u_int16_t scatter_end_offset_2;
	/* Description -  */
	/* 0xc.16 - 0xc.29 */
	 u_int16_t scatter_end_offset_3;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.13 */
	 u_int16_t scatter_end_offset_0;
	/* Description -  */
	/* 0x10.16 - 0x10.29 */
	 u_int16_t scatter_end_offset_1;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x14.16 - 0x14.29 */
	 u_int16_t packet_len;
	/* Description -  */
	/* 0x14.30 - 0x14.30 */
	 u_int8_t use_dcr_gvmi_for_rdb;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x18.24 - 0x18.26 */
	 u_int8_t packet_type;
	/* Description -  */
	/* 0x18.27 - 0x18.27 */
	 u_int8_t free_line;
	/* Description -  */
	/* 0x18.28 - 0x18.28 */
	 u_int8_t header_capture;
	/* Description -  */
	/* 0x18.29 - 0x18.29 */
	 u_int8_t host_is_little_endian;
	/* Description -  */
	/* 0x18.30 - 0x18.30 */
	 u_int8_t mask_px_icmc_tpt_vld;
	/* Description -  */
	/* 0x18.31 - 0x18.31 */
	 u_int8_t need_invalidation;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.23 */
	 u_int32_t psn;
	/* Description -  */
	/* 0x1c.24 - 0x1c.27 */
	 u_int8_t extended_rdb_size;
	/* Description -  */
	/* 0x1c.28 - 0x1c.30 */
	 u_int8_t max_rdma_atomic;
	/* Description -  */
	/* 0x1c.31 - 0x1c.31 */
	 u_int8_t can_use_reserved_lkey;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t pd;
	/* Description -  */
	/* 0x20.24 - 0x20.31 */
	 u_int8_t rdb_write_pointer;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t rkey;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t dma_length;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t va_63_32;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t va_31_0;
};

/* Description -  // Created At Wed Apr  1 16:30:32 IDT 2015, By the following script (revision 1.48): /verification/utils/decoder2adb.tcl -f /verification/dotan/14_1r1/linux/rbv.cache/out//rxt_context_fetch_qp_desc_decoder.v -o rxt_context_fetch_qp_desc_decoder -adbfile ../adabe/dotan//hw_decoders_st.adb */
/* Size in bytes - 16 */
struct connectx4lx_rxt_context_fetch_qp_desc_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t qpc_ts_3_3;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t port_number;
	/* Description - TODO: need to align this field to 32.  */
	/* 0x0.2 - 0x0.25 */
	 u_int32_t qp_number;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t lro_context_exist;
	/* Description -  */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t lro_enable_any;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.0 - 0x4.12 */
	 u_int16_t srq_number_23_11;
	/* Description - TODO: need to align this field to 16.  */
	/* 0x4.13 - 0x4.28 */
	 u_int16_t gvmi;
	/* Description - TODO: need to align this field to 4. This Field was broken due to 32-bit miss-alignement  */
	/* 0x4.29 - 0x4.31 */
	 u_int8_t qpc_ts_2_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.11 */
	 u_int16_t pkey_index;
	/* Description - TODO: need to align this field to 8.  */
	/* 0x8.12 - 0x8.19 */
	 u_int8_t my_gid_mac_index;
	/* Description -  */
	/* 0x8.20 - 0x8.20 */
	 u_int8_t srq_vld;
	/* Description - TODO: need to align this field to 32. This Field was broken due to 32-bit miss-alignement  */
	/* 0x8.21 - 0x8.31 */
	 u_int16_t srq_number_10_0;
};

/* Description -  // Created At Wed Apr  1 16:30:32 IDT 2015, By the following script (revision 1.48): /verification/utils/decoder2adb.tcl -f /verification/dotan/14_1r1/linux/rbv.cache/out//rxt_checks_steering_results_decoder.v -o rxt_checks_steering_results_decoder -adbfile ../adabe/dotan//hw_decoders_st.adb */
/* Size in bytes - 32 */
struct connectx4lx_rxt_checks_steering_results_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t outbound_buffer1_lossy_action_needed_wred;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t outbound_buffer2_lossless_action_needed_full;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t outbound_buffer2_lossless_action_needed_wred;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t outbound_buffer2_lossy_action_needed_full;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t outbound_buffer2_lossy_action_needed_wred;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t outbound_buffer3_lossless_action_needed_full;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t outbound_buffer3_lossless_action_needed_wred;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t outbound_buffer3_lossy_action_needed_full;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t outbound_buffer3_lossy_action_needed_wred;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t packet_decapsulated;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t qpn_direct_access;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t tunnel_enable;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t tip_id;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t rss_hash_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rss_hash_result;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.8 */
	 u_int16_t xqpn_40_32;
	/* Description -  */
	/* 0xc.9 - 0xc.9 */
	 u_int8_t outbound_buffer0_lossless_action_needed_full;
	/* Description -  */
	/* 0xc.10 - 0xc.10 */
	 u_int8_t outbound_buffer0_lossless_action_needed_wred;
	/* Description -  */
	/* 0xc.11 - 0xc.11 */
	 u_int8_t outbound_buffer0_lossy_action_needed_full;
	/* Description -  */
	/* 0xc.12 - 0xc.12 */
	 u_int8_t outbound_buffer0_lossy_action_needed_wred;
	/* Description -  */
	/* 0xc.13 - 0xc.13 */
	 u_int8_t outbound_buffer1_lossless_action_needed_full;
	/* Description -  */
	/* 0xc.14 - 0xc.14 */
	 u_int8_t outbound_buffer1_lossless_action_needed_wred;
	/* Description -  */
	/* 0xc.15 - 0xc.15 */
	 u_int8_t outbound_buffer1_lossy_action_needed_full;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t counter_trigger;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t xqpn_31_0;
};

/* Description -  // Created At Wed Apr  1 16:30:32 IDT 2015, By the following script (revision 1.48): /verification/utils/decoder2adb.tcl -f /verification/dotan/14_1r1/linux/rbv.cache/out//rxt_steering_context_decoder.v -o rxt_steering_context_decoder -adbfile ../adabe/dotan//hw_decoders_st.adb */
/* Size in bytes - 64 */
struct connectx4lx_rxt_steering_context_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t level2_stored_gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t level1_stored_gvmi;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t level2_iteration_counter;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t level0_stored_gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t level1_iteration_counter;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0xc.0 - 0xc.1 */
	 u_int8_t level2_stored_index_33_32;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t level0_iteration_counter;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t level2_stored_index_31_0;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x14.0 - 0x14.1 */
	 u_int8_t level1_stored_index_33_32;
	/* Description -  */
	/* 0x14.2 - 0x14.2 */
	 u_int8_t level0_tunnel_enable;
	/* Description -  */
	/* 0x14.3 - 0x14.3 */
	 u_int8_t level1_last_iteration;
	/* Description -  */
	/* 0x14.4 - 0x14.4 */
	 u_int8_t level1_packet_decapsulated;
	/* Description -  */
	/* 0x14.5 - 0x14.5 */
	 u_int8_t level1_stored_rank;
	/* Description -  */
	/* 0x14.6 - 0x14.6 */
	 u_int8_t level1_stored_type_steering;
	/* Description -  */
	/* 0x14.7 - 0x14.7 */
	 u_int8_t level1_tunnel_enable;
	/* Description -  */
	/* 0x14.8 - 0x14.8 */
	 u_int8_t level2_last_iteration;
	/* Description -  */
	/* 0x14.9 - 0x14.9 */
	 u_int8_t level2_packet_decapsulated;
	/* Description -  */
	/* 0x14.10 - 0x14.10 */
	 u_int8_t level2_stored_rank;
	/* Description -  */
	/* 0x14.11 - 0x14.11 */
	 u_int8_t level2_stored_type_steering;
	/* Description -  */
	/* 0x14.12 - 0x14.12 */
	 u_int8_t level2_tunnel_enable;
	/* Description -  */
	/* 0x14.13 - 0x14.13 */
	 u_int8_t level3_packet_decapsulated;
	/* Description -  */
	/* 0x14.14 - 0x14.14 */
	 u_int8_t level3_tunnel_enable;
	/* Description -  */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t counter_index;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t level1_stored_index_31_0;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x1c.0 - 0x1c.1 */
	 u_int8_t level0_stored_index_33_32;
	/* Description -  */
	/* 0x1c.2 - 0x1c.3 */
	 u_int8_t iteration_level;
	/* Description -  */
	/* 0x1c.4 - 0x1c.4 */
	 u_int8_t level0_last_iteration;
	/* Description -  */
	/* 0x1c.5 - 0x1c.5 */
	 u_int8_t level0_packet_decapsulated;
	/* Description -  */
	/* 0x1c.6 - 0x1c.6 */
	 u_int8_t level0_stored_rank;
	/* Description -  */
	/* 0x1c.7 - 0x1c.7 */
	 u_int8_t level0_stored_type_steering;
	/* Description - TODO: need to align this field to 32.  */
	/* 0x1c.8 - 0x1c.31 */
	 u_int32_t tip_id;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - This Field was broken due to 32-bit miss-alignement  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t level0_stored_index_31_0;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_rxt_checks_packet_descriptor_decoder {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -   */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t mad_send2host;
	/* Description -   */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t port_type_ethernet;
	/* Description -   */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t outer_cqe_l2_ok;
	/* Description -   */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t inner_cqe_l2_ok;
	/* Description -   */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t outer_cqe_ip_ok;
	/* Description -   */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t inner_cqe_ip_ok;
	/* Description -   */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t outer_cqe_l4_ok;
	/* Description -   */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t inner_cqe_l4_ok;
	/* Description -   */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t lro_outer_ok;
	/* Description -   */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t lro_inner_ok;
	/* Description -   */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t hds_l3_outer_ok;
	/* Description -   */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t hds_l4_outer_ok;
	/* Description -   */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t hds_l3_inner_ok;
	/* Description -   */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t hds_l4_inner_ok;
	/* Description -   */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t l2_tunneling_ok;
	/* Description -   */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t l3_tunneling_ok;
	/* Description -   */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t first_tcp_has_no_options_or_time_stamp;
	/* Description -   */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t second_tcp_has_no_options_or_time_stamp;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -   */
	/* 0x4.0 - 0x4.13 */
	 u_int16_t packet_end_offset;
	/* Description -   */
	/* 0x4.16 - 0x4.21 */
	 u_int8_t mad_qp1_class;
	/* Description -   */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t mad_baseversion_error;
	/* Description -   */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t fcs_ok;
	/* Description -   */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t icrc_ok;
	/* Description -   */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t first_ipv4_checksum_ok;
	/* Description -   */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t second_ipv4_checksum_ok;
	/* Description -   */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t first_tcp_udp_checksum_ok;
	/* Description -   */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t second_tcp_udp_checksum_ok;
	/* Description -   */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t mad_classversion_error;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -   */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t first_ip_payload_checksum;
	/* Description -   */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t second_ip_payload_checksum;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -   */
	/* 0xc.0 - 0xc.6 */
	 u_int8_t llu2rxt_desc_4;
	/* Description -   */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t lro_checksum_payload_only;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -   */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t llu2rxt_desc_3;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -   */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t llu2rxt_desc_2;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -   */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t llu2rxt_desc_1;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -   */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t llu2rxt_desc_0;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_ctx_as_dwords {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t dwords[16];
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_fw_resource_context {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_fw_eqc fw_eqc;
	/* Description - ads layout */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_fw_alt_path fw_alt_path;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_basic_res_ctx fw_basic;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_fw_cre fw_cre;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_fw_mkc fw_mkc;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_psv fw_psv;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_fw_cqc fw_cqc;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_fw_rqt fw_rqt;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_list_element list_element;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_dmfs_resources dmfs_resources;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dc_control_packet_desc dc_control_packet_desc;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_vqos_arb_ctx vqos_arb_ctx;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_fw_transport_domain fw_transport_domain;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_q_counters fw_q_counters;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_fw_ipoib_meta fw_ipoib_meta;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_scheduling_context sched_element_ctx;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_hw_hca_contexts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_c_cqc hw_c_cqc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_c_eqc hw_c_eqc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_mkc mkc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_toc toc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_c_srq hw_c_srq;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_dct dct;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_c_qpc c_qpc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_s_qpc s_qpc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_qpc_r_dct r_qpc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_port_info port_info;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_hw_trasta trasta;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hw_sq_pointers sq_pointers;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hw_gvmi_tokens gvmi_tokens;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hw_sq_tokens sq_tokens;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_hw_klm_entry klm_entry;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 union connectx4lx_hw_sxdc sxdc;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_hw_pipa pipa;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_hw_sq_qp_list sq_qp_list;
	/* Description - the timer is 8 bit, here its just a wrapper */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_hw_timer_32 timer;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_hw_pkey pkey;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_ste hw_ste;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_steering_entry_icmc steering_entry_icmc;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 union connectx4lx_icm_mtt mtt;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_rdb rdb;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hw_msix msix;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_gid_mac_table_entry gid_mac_table_entry;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hw_qp_counter qp_counter;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_hw_gvmi_counter hw_gvmi_counter;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_bath_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t dz;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t dv;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t sigma;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t bath_center;
};

/* Description -   */
/* Size in bytes - 60 */
struct connectx4lx_local_best_rx_set {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_sd_params_rx_set ffe_taps;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x20.31 */
	 struct connectx4lx_calibration_values calibration;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t grade;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.19 */
	 u_int32_t phase_grade;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.19 */
	 u_int32_t phase_center;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.19 */
	 u_int32_t bath_grade;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.19 */
	 u_int32_t bath_dz;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.19 */
	 u_int32_t bath_sigma;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.19 */
	 u_int32_t voltage_eo_grade;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_field_boundary {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t field_boundary;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_add_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t add_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_compare_mask_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t compare_mask_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_swap_mask_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t swap_mask_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_compare_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t compare_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_swap_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t swap_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_component_authentication_configuration {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0-NULL, 1-SHA256Digest, 3-2048 bit RSA */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t auth_type;
	/* Description - used for authenticating Factory Re-COnfiguration Responses */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t frc_en;
	/* Description - used for signing NVCONFIG at MLNX level */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t mlnx_nvconfig_en;
	/* Description - used for authenticating NVCONFIG at OEM level */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t vendor_nvconfig_en;
	/* Description - used for authenticating CS tokens at OEM level */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t cs_token_en;
	/* Description - Used for authenticating firmware, DBG_FW, DBG Tokens */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t fw_en;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_data_pointer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Offset of entire list area from start of NV data area. Every unit is 64 bytes */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t offset_in_64_bytes;
	/* Description - Size of entire list area. Every unit is 64 bytes. */
	/* 0x0.16 - 0x0.25 */
	 u_int16_t size_in_64_bytes;
};

/* Description -   */
/* Size in bytes - 800 */
struct connectx4lx_pll_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t pll_const0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t pll_const1;
};

/* Description -   */
/* Size in bytes - 704 */
struct connectx4lx_lane_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x1f0.31 */
	 struct connectx4lx_lane_const_sd_params serdes_params;
/*---------------- DWORD[124] (Offset 0x1f0) ----------------*/
	/* Description -  */
	/* 0x1f0.0 - 0x218.31 */
	 struct connectx4lx_lane_const_calib_params calib_params;
/*---------------- DWORD[134] (Offset 0x218) ----------------*/
	/* Description -  */
	/* 0x218.0 - 0x23c.31 */
	 struct connectx4lx_lane_const_frame_lock frame_lock_set;
/*---------------- DWORD[143] (Offset 0x23c) ----------------*/
	/* Description - 0 or 1 */
	/* 0x23c.0 - 0x23c.19 */
	 u_int32_t clp;
/*---------------- DWORD[144] (Offset 0x240) ----------------*/
	/* Description -  */
	/* 0x240.0 - 0x240.19 */
	 u_int32_t speed_is_edr;
/*---------------- DWORD[145] (Offset 0x244) ----------------*/
	/* Description - 0-bath, 1-ones_ratio, 2-iet, 3-xor */
	/* 0x244.0 - 0x244.19 */
	 u_int32_t global_measure_method;
/*---------------- DWORD[146] (Offset 0x248) ----------------*/
	/* Description - 5 bit mask. bit per start point */
	/* 0x248.0 - 0x248.19 */
	 u_int32_t start_points_mask;
/*---------------- DWORD[147] (Offset 0x24c) ----------------*/
	/* Description -  */
	/* 0x24c.0 - 0x24c.19 */
	 u_int32_t grade_bath_iterations_num;
/*---------------- DWORD[148] (Offset 0x250) ----------------*/
	/* Description - 1 - modify radius only when central point has the highest grade, 0 - modify radius each search cycle */
	/* 0x250.0 - 0x250.19 */
	 u_int32_t space_modify_radius_only_if_no_improve;
/*---------------- DWORD[149] (Offset 0x254) ----------------*/
	/* Description - mask for ffe taps to enable in serdes */
	/* 0x254.0 - 0x254.19 */
	 u_int32_t ffe_tap_en_mask;
/*---------------- DWORD[150] (Offset 0x258) ----------------*/
	/* Description -  */
	/* 0x258.0 - 0x258.19 */
	 u_int32_t space_first_search_radius;
/*---------------- DWORD[151] (Offset 0x25c) ----------------*/
	/* Description -  */
	/* 0x25c.0 - 0x25c.19 */
	 u_int32_t space_last_search_radius;
/*---------------- DWORD[152] (Offset 0x260) ----------------*/
	/* Description -  */
	/* 0x260.0 - 0x260.19 */
	 u_int32_t grade_threshold;
/*---------------- DWORD[153] (Offset 0x264) ----------------*/
	/* Description - bit_mask, stuck phy_uc each: 0 - measure, 1 - bath_iteration, 2 - set process */
	/* 0x264.0 - 0x264.19 */
	 u_int32_t debug_mode;
/*---------------- DWORD[154] (Offset 0x268) ----------------*/
	/* Description -  */
	/* 0x268.0 - 0x268.19 */
	 u_int32_t measure_bits;
/*---------------- DWORD[155] (Offset 0x26c) ----------------*/
	/* Description -  */
	/* 0x26c.0 - 0x26c.19 */
	 u_int32_t high_threshold;
/*---------------- DWORD[156] (Offset 0x270) ----------------*/
	/* Description -  */
	/* 0x270.0 - 0x270.19 */
	 u_int32_t mid_threshold;
/*---------------- DWORD[157] (Offset 0x274) ----------------*/
	/* Description -  */
	/* 0x274.0 - 0x274.19 */
	 u_int32_t low_threshold;
/*---------------- DWORD[158] (Offset 0x278) ----------------*/
	/* Description -  */
	/* 0x278.0 - 0x278.19 */
	 u_int32_t ones_ratio_half_measured_bits;
/*---------------- DWORD[159] (Offset 0x27c) ----------------*/
	/* Description -  */
	/* 0x27c.0 - 0x27c.19 */
	 u_int32_t best_rx_set_bath_iterations_num;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x280.19 */
	 u_int32_t best_rx_set_phase_en;
/*---------------- DWORD[161] (Offset 0x284) ----------------*/
	/* Description - determined according to speed and FEC */
	/* 0x284.0 - 0x284.19 */
	 u_int32_t phase_eo_errors_opcode;
/*---------------- DWORD[162] (Offset 0x288) ----------------*/
	/* Description -  */
	/* 0x288.0 - 0x288.19 */
	 u_int32_t debug_port_last_line;
/*---------------- DWORD[163] (Offset 0x28c) ----------------*/
	/* Description -  */
	/* 0x28c.0 - 0x28c.19 */
	 u_int32_t cable_is_copper;
/*---------------- DWORD[164] (Offset 0x290) ----------------*/
	/* Description - when set, last rx best ffe taps are used as extra start point */
	/* 0x290.0 - 0x290.19 */
	 u_int32_t use_last_best_as_start_point;
/*---------------- DWORD[165] (Offset 0x294) ----------------*/
	/* Description - 0: bath_grade = (bath_dz_factor * dz / (sigma + 1)) + sigma  . 
1: eye_opener_grade = SerDes_ffe_tap_offset1 * dz * eye_opener_dz_factor + sigma */
	/* 0x294.0 - 0x294.19 */
	 u_int32_t grade_method;
/*---------------- DWORD[166] (Offset 0x298) ----------------*/
	/* Description - 0- no shift
1- main taps 0,2
2- main taps 0,1 */
	/* 0x298.0 - 0x298.19 */
	 u_int32_t ffe_tap_shift_mode;
/*---------------- DWORD[167] (Offset 0x29c) ----------------*/
	/* Description -  */
	/* 0x29c.0 - 0x29c.19 */
	 u_int32_t speed_is_fdr;
/*---------------- DWORD[168] (Offset 0x2a0) ----------------*/
	/* Description -  */
	/* 0x2a0.0 - 0x2a0.19 */
	 u_int32_t link_maintenance;
/*---------------- DWORD[169] (Offset 0x2a4) ----------------*/
	/* Description -  */
	/* 0x2a4.0 - 0x2a4.19 */
	 u_int32_t lm_voltage_centering_needed;
/*---------------- DWORD[170] (Offset 0x2a8) ----------------*/
	/* Description -  */
	/* 0x2a8.0 - 0x2a8.19 */
	 u_int32_t link_maintenance_first_set_open_bath;
};

/* Description -   */
/* Size in bytes - 2160 */
struct connectx4lx_port_shared_const_sd_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x540.31 */
	 struct connectx4lx_shared_const_sd_params_tx tx;
/*---------------- DWORD[336] (Offset 0x540) ----------------*/
	/* Description -  */
	/* 0x540.0 - 0x860.31 */
	 struct connectx4lx_shared_const_sd_params_rx rx;
/*---------------- DWORD[536] (Offset 0x860) ----------------*/
	/* Description -  */
	/* 0x860.0 - 0x860.19 */
	 u_int32_t ffe_tap_offset1_default_val;
};

/* Description -   */
/* Size in bytes - 32 */
union connectx4lx_pcie_subroutines_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_pcie_subroutines_db_name by_name;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_pcie_subroutines_db_index by_index;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_jump_addresses {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t plastic;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_eqlz_ph3_array_force_single_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - if set, the coeefs field in the ph3 array will be replced with the taps values below */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
	/* Description - if set, all array will be field with the below taps values */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t all_arr_bypass_enable;
	/* Description -  */
	/* 0x0.8 - 0x0.13 */
	 u_int8_t c_p_1;
	/* Description -  */
	/* 0x0.16 - 0x0.21 */
	 u_int8_t c_m_1;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.6 */
	 u_int8_t ob_tap0;
	/* Description -  */
	/* 0x4.8 - 0x4.14 */
	 u_int8_t ob_tap1;
	/* Description -  */
	/* 0x4.16 - 0x4.22 */
	 u_int8_t ob_tap2;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_capi_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Log base 2 of capi P1 bar  size in MB */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t log2_p1_bar_bytes;
	/* Description - Log base 2 of capi P2 bar  size in MB */
	/* 0x0.6 - 0x0.11 */
	 u_int8_t log2_p2_bar_bytes;
	/* Description - Log base 2 of capi capi bar  size in MB */
	/* 0x0.12 - 0x0.17 */
	 u_int8_t log2_capi_bar_megabytes;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t cap_en;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t debug_mode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_gen4_spec_0_5 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t eieos_gen4_as_gen3;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t status_skp_en;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_eqlz_ctrl_gen4 {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - this is the base RX set for gen4 rx tuning algorithm */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
	/* Description - this is the base RX set for gen4 rx tuning algorithm */
	/* 0x0.1 - 0x0.3 */
	 u_int8_t rx_set_index;
	/* Description - select which input buffers we will use during rx tuning */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t ib;
	/* Description -  */
	/* 0x0.6 - 0x0.14 */
	 u_int16_t taps_working_mask;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t start_radius_log;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t grading_type_height_width_;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t mixer_offset_ib_select;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_eqlz_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t num_of_rx_set;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t disable_ph2_rx_adaptation;
	/* Description -  */
	/* 0x0.16 - 0x0.20 */
	 u_int8_t ph2_eq_num_of_iter_maj_vote;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_eqlz_tx_adaptation eqlz_tx_adaptation;
};

/* Description -   */
/* Size in bytes - 84 */
struct connectx4lx_pcie_rx_sets {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x54.31 */
	 struct connectx4lx_ffe_tap_set_9_taps set[7];
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_pcie_tx_sets {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_tx_sets_shomron set[5];
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_power_configuration {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - configures serdes_down_delay value. use for thermal shut down */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t power_delay;
	/* Description - enable the power governor HW feature. */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t power_governor_enable;
	/* Description - enable height eye opening measurment. */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t pcie_eqlz_height_en;
	/* Description - log of number of opened input buffer1 at the same time, for pcie height measurements
 0 - 1 lane at a time
 1 - 2 lanes at a time
 2 - 4 lanes at a time
 3 - 8 lanes at a time
 4 - 16 lanes at a time. */
	/* 0x0.6 - 0x0.9 */
	 u_int8_t log_num_opened_ib1;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_enforce_pn_list_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1- need to check cable for checkpoint */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x30.15 */
	 struct connectx4lx_pn_st part_number[22];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_power_supply_monitoring {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - is power Supply monitoring replaceable */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t field_replaceable;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_i2c_devices_smbus_slv_ix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - MNG CPLD which supports HW reset */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t mng_cpld;
	/* Description - CPLD which supports disconnect debug mode */
	/* 0x0.6 - 0x0.11 */
	 u_int8_t disconnect_mode_cpld;
	/* Description -  */
	/* 0x0.12 - 0x0.17 */
	 u_int8_t mng_psu1;
	/* Description -  */
	/* 0x0.18 - 0x0.23 */
	 u_int8_t mng_psu2;
	/* Description -  */
	/* 0x0.24 - 0x0.29 */
	 u_int8_t ismic;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_jtag_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - JTAG Master enabled */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t jtag_en;
	/* Description - TRST is used */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t trst_supported;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t tdi_st_mul;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t tdi_st_div;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t tck_high_mul;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t tck_high_div;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_yu_shift_register_init {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 2^delay_time i1 cycles will pass between enable# deselect and first cycle */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t delay_time;
	/* Description -  */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t relax_time;
	/* Description - 2^clock_freq i1 cycles are the duty cycle of the led clock */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t clock_freq;
	/* Description -  */
	/* 0x0.16 - 0x0.25 */
	 u_int16_t chain_size;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.30 - 0xc.29 */
	 struct connectx4lx_bit_type_st bit_type[32];
};

/* Description -   */
/* Size in bytes - 160 */
struct connectx4lx_gpio_conf_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0xa0.23 */
	 struct connectx4lx_gpio_group_config gpios[160];
};

/* Description -   */
/* Size in bytes - 200 */
struct connectx4lx_gpio_functions {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0xc8.15 */
	 struct connectx4lx_gpio_function gpio_func[100];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_i2c_device_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - I2C slave address */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t slave_addr;
	/* Description - Father device index. Father device can be:
- I2C switch or CPLD
- Root master gw in Switch or HCA */
	/* 0x0.8 - 0x0.13 */
	 u_int8_t fidx;
	/* Description - Father port number - the number of the I2C port in the father switch,if father is IS4 device must be 0 */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t fport;
	/* Description - Master gw index the device is connected to (directly or via switches) */
	/* 0x0.20 - 0x0.22 */
	 u_int8_t gw_idx;
	/* Description - 
 
     */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t type;
	/* Description - Apply PEC on read/write from/to the device */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t pec_en;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_module_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 struct connectx4lx_led_mapping led;
	/* Description - 0 - internal backplnae
1 - QSFP
2 - SFP

7 - empty module

TBD:
internal_1x
internal_2x
internal_4x */
	/* 0x0.16 - 0x0.18 */
	 u_int8_t type;
	/* Description -  */
	/* 0x0.19 - 0x0.25 */
	 u_int8_t label_port;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t ib_long_haul_cap;
	/* Description -  */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t smbus_slv_indx;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 1W =0, 1.5W=1, 2W=2, 2.5W=3, 3.5W=4 */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t module_power_level_supported;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - module2local database */
	/* 0xc.0 - 0x2c.31 */
	 struct connectx4lx_module2local m2l;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 struct connectx4lx_pca_mapping_database pca_mapping;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.7 */
	 u_int8_t atten_5g;
	/* Description -  */
	/* 0x30.8 - 0x30.15 */
	 u_int8_t atten_7g;
	/* Description -  */
	/* 0x30.16 - 0x30.23 */
	 u_int8_t atten_12g;
};

/* Description -   */
/* Size in bytes - 1 */
struct connectx4lx_diode_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t mode;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t disable;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_iopx_power {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ref_clk_right_left_;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_iopl_power {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ref_clk_right_left_;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t dynamic_pll_manage_en;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t dynamic_serdes_manage_en;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_port_mlpn_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - mlpn ability bits */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_mlpn_database_all_protocol_ini mlpn_supported;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - mlpn request bits */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_mlpn_database_all_protocol_ini mlpn_request;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - mlpn mlnx_enhanced_equalization_info bits */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_mlpn_enhanced_database_ini mlpn_enhanced_database;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_pll_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t pll_fctrl_th;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t enable_phy_varactor_calibration;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 u_int32_t pll_fctrl_var[4];
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x24.31 */
	 u_int32_t pll_fctrl_val[4];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_logic_serdes_mapping_node_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini tx;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini rx;
};

/* Description -   */
/* Size in bytes - 384 */
struct connectx4lx_phy_hw_main_config_ip {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x5c.31 */
	 struct connectx4lx_ib_an_hw_main_ini ib_an_hw_main;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_nv_config_boot_port_settings {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_nv_tlv_data_vpi_settings vpi;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_nv_config_boot_global {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_nv_config_pci pci;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x28.31 */
	 struct connectx4lx_nv_config_tpt tpt;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 struct connectx4lx_nv_config_kdnet_data kdnet_data;
};

/* Description -   */
/* Size in bytes - 60 */
struct connectx4lx_pci_cfg_space_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Configuration Space Header ini fields */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_pci_cfg_hdr_ini cfg_hdr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - SR-IOV Capability ini fields */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_sriov_ini sriov;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - PCIe Capability ini fields */
	/* 0x18.0 - 0x30.31 */
	 struct connectx4lx_pciex_ini pciex;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - MSIX Capability ini fields */
	/* 0x30.0 - 0x38.31 */
	 struct connectx4lx_msix_ini msix;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - AER Capability ini fields */
	/* 0x38.0 - 0x3c.31 */
	 struct connectx4lx_aer_ini aer;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_logger_init_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.14 */
	 u_int16_t cfg_request_mask;
	/* Description -  */
	/* 0x0.15 - 0x0.24 */
	 u_int16_t splix_mask;
	/* Description -  */
	/* 0x0.25 - 0x0.30 */
	 u_int8_t writes_amount;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_mh_host_mapping {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - hix to customer host number */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t hix_0;
	/* Description - hix to customer host number */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t hix_1;
	/* Description - hix to customer host number */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t hix_2;
	/* Description - hix to customer host number */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t hix_3;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_fw_block_behavior {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - dword for the extra capabilities */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_block_behavior_dw dw;
	/* Description - fields description for the extra capabilities */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_fw_block_behavior_fields fields;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_nv_config_main_fw_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_port_settings port[2];
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description -  */
	/* 0x200.0 - 0x240.31 */
	 struct connectx4lx_nv_config_global_main global;
/*---------------- DWORD[144] (Offset 0x240) ----------------*/
	/* Description -  */
	/* 0x240.0 - 0x280.31 */
	 struct connectx4lx_nv_config_host_main host[4];
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description - tlvs with class host_func */
	/* 0x280.0 - 0x298.31 */
	 struct connectx4lx_nv_config_host_func_main host_func_pf_order;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_serdes_fw_main_config_ip {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - the opamp calib will work once every 2^register / cr_opamp_calib_div */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t opamp_calib_time;
	/* Description - divider for the opamp_calib_timer */
	/* 0x0.5 - 0x0.8 */
	 u_int8_t opamp_calib_div;
	/* Description - Enable Opamp calibration */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t opamp_calib_en;
	/* Description - Opamp Open Loop Stabilization time */
	/* 0x0.10 - 0x0.15 */
	 u_int8_t opamp_open_loop_stab_time;
	/* Description - Opamp to Master Stabilization time */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t opamp2master_stab_time;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Opamp Shadow to Master Stabilization time */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t opamp_shadow2master_stab_time;
	/* Description - Opamp Closed Loop Stabilization time */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t opamp_closed_loop_stab_time;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - configurable delta between clk00 and clkeo. Default value for Shomron and Dotan only */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t clk00_clkeo_calibration_delta;
	/* Description - break opamp flow to work each time on different set of ports */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t opamp_calib_long_flow;
	/* Description - enable rx defect DFT code */
	/* 0x8.9 - 0x8.9 */
	 u_int8_t serdes_rx_defect_en;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - FastFlipFlop mode database */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_ini_fff_mode_db fff_mode;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_serdes_fw_main_config_prj {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_centerpll_prj_ini_db centerpll[2];
};

/* Description -   */
/* Size in bytes - 384 */
struct connectx4lx_phy_fw_main_config_ip {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x118.31 */
	 struct connectx4lx_phy_uc_config phy_uc_config;
/*---------------- DWORD[70] (Offset 0x118) ----------------*/
	/* Description - Heartbeat Requested */
	/* 0x118.0 - 0x118.0 */
	 u_int8_t ts3_hbr;
	/* Description - Test pattern:
0-PRBS23
1-PRBS11 */
	/* 0x118.1 - 0x118.1 */
	 u_int8_t ts3_tp;
	/* Description - support FDR bubbles opcode rev2 */
	/* 0x118.2 - 0x118.2 */
	 u_int8_t fdr_bubbles_rev2_support;
	/* Description -  */
	/* 0x118.3 - 0x118.9 */
	 u_int8_t retry_counter_threshold;
	/* Description -  */
	/* 0x118.10 - 0x118.10 */
	 u_int8_t dont_allow_rx_cdr;
	/* Description -  */
	/* 0x118.11 - 0x118.11 */
	 u_int8_t dont_allow_tx_cdr;
	/* Description -  */
	/* 0x118.12 - 0x118.15 */
	 u_int8_t rx_logic_reset_timer;
	/* Description - enabling doing RX tuning for KR frame lock */
	/* 0x118.16 - 0x118.16 */
	 u_int8_t kr_frame_lock_tuning_en;
	/* Description - enabling doing RX tuning over idles after kr startup with 3rd party */
	/* 0x118.17 - 0x118.17 */
	 u_int8_t extra_tune_en;
	/* Description - enabling doing RX tuning for parallel detect */
	/* 0x118.18 - 0x118.18 */
	 u_int8_t parallel_detect_tuning_en;
	/* Description -  */
	/* 0x118.19 - 0x118.19 */
	 u_int8_t force_atten0_backplane_port;
	/* Description - 2^num of consecutive error free fec blocks in SLOW state before moving to TRANSITION */
	/* 0x118.20 - 0x118.24 */
	 u_int8_t cod_slow2transition_timeout;
	/* Description - 2^num of consecutive error free fec blocks in TRANSITION state before moving to FAST */
	/* 0x118.25 - 0x118.29 */
	 u_int8_t cod_transition2fast_timeout;
	/* Description - bubbles support. this bit is going to MLPN1 */
	/* 0x118.30 - 0x118.30 */
	 u_int8_t bubbles_support;
	/* Description - if set, in EDR, when LLR agreed PLR will be set and when LL RS FEC agreed, do MLX strongest RS FEC instead */
	/* 0x118.31 - 0x118.31 */
	 u_int8_t strong_mlx_rs_fec;
/*---------------- DWORD[71] (Offset 0x11c) ----------------*/
	/* Description - dme_bit_width that will be used in PD */
	/* 0x11c.0 - 0x11c.1 */
	 u_int8_t const_dme_bit_width;
	/* Description - when set, EDR PLL will be configured to 25G (not 25.78125G) */
	/* 0x11c.2 - 0x11c.2 */
	 u_int8_t pll_12_5_en;
	/* Description -  */
	/* 0x11c.4 - 0x11c.4 */
	 u_int8_t kr_ignore_tx_change_requests;
	/* Description - if set, the ETH AN FSM will enable/disable module's CDR according to speed enabled/active */
	/* 0x11c.5 - 0x11c.5 */
	 u_int8_t eth_an_cdr_control_en;
	/* Description - if set, the ETH AN FSM will not check the nonce_match */
	/* 0x11c.6 - 0x11c.6 */
	 u_int8_t disable_nonce_check;
	/* Description - units are lane fifo lines. cut pkts longer than this val. 0x0 - disable  */
	/* 0x11c.7 - 0x11c.14 */
	 u_int8_t cod_rewind_limit;
	/* Description - Correct on Demand */
	/* 0x11c.15 - 0x11c.15 */
	 u_int8_t cod_enable;
	/* Description - MCB FW application supported */
	/* 0x11c.16 - 0x11c.31 */
	 u_int16_t mcb_opcode_supported_mask;
/*---------------- DWORD[72] (Offset 0x120) ----------------*/
	/* Description - this number is divided by 10,000.
exact number is 0.110904 */
	/* 0x120.0 - 0x120.15 */
	 u_int16_t eo_ticks_to_mv_coefficient;
	/* Description - sets the extended time to linkup request */
	/* 0x120.16 - 0x120.22 */
	 u_int8_t mlpn_extended_time;
	/* Description - if set kr will start from initialize and change requests will be ignored */
	/* 0x120.24 - 0x120.24 */
	 u_int8_t kr_ignore_preset_initialize_request;
	/* Description - if set kr will decline all requests to move tx coefficient and respond with max/min */
	/* 0x120.25 - 0x120.25 */
	 u_int8_t kr_ignore_tx_moving_request;
	/* Description - this is the value in seconds of the link fail inhibit timer in parallel detect */
	/* 0x120.26 - 0x120.31 */
	 u_int8_t parallel_detect_inhibit_timer_sec;
/*---------------- DWORD[73] (Offset 0x124) ----------------*/
	/* Description -  */
	/* 0x124.0 - 0x14c.31 */
	 struct connectx4lx_error_correction_thresholds error_correction_thresholds;
/*---------------- DWORD[83] (Offset 0x14c) ----------------*/
	/* Description -  */
	/* 0x14c.0 - 0x150.31 */
	 struct connectx4lx_tx_tuning_vars tx_tuning_1_vars;
/*---------------- DWORD[84] (Offset 0x150) ----------------*/
	/* Description -  */
	/* 0x150.0 - 0x158.31 */
	 struct connectx4lx_tx_tuning_2_vars tx_tuning_2_vars;
/*---------------- DWORD[86] (Offset 0x158) ----------------*/
	/* Description -  */
	/* 0x158.0 - 0x160.31 */
	 struct connectx4lx_power_management_ini power_mode;
/*---------------- DWORD[88] (Offset 0x160) ----------------*/
	/* Description - mask of com codes RS FEC request for MLPN:
bit 0 - unspecified codes
bit 1 - 100/25 AOC bad BER
bit 2 - 100/25 SR
bit 3 - 100 LR
bit 4 - 100 ER
bit 6 - 100 CWDM4 FEC
bit 7 - 100 PSM4
bit 8 - 100/25 ACC bad BER
bit 9 - 100 CWDM4 no FEC
bit 11 - 100/25 CR
bit 12 - 25 CR_S
bit 13 - 25 CR_N
bit 23 - 100 CLR4
bit 24 - 100/25 AOC good BER
bit 25 - 100/25 ACC good BER */
	/* 0x160.0 - 0x164.31 */
	 u_int32_t mlpn_eth_com_codes_fec_rs;
/*---------------- DWORD[89] (Offset 0x164) ----------------*/
	/* Description - mask of com codes FC FEC request for MLPN:
bit 0 - unspecified codes
bit 1 - 100/25 AOC bad BER
bit 2 - 100/25 SR
bit 3 - 100 LR
bit 4 - 100 ER
bit 6 - 100 CWDM4 FEC
bit 7 - 100 PSM4
bit 8 - 100/25 ACC bad BER
bit 9 - 100 CWDM4 no FEC
bit 11 - 100/25 CR
bit 12 - 25 CR_S
bit 13 - 25 CR_N
bit 23 - 100 CLR4
bit 24 - 100/25 AOC good BER
bit 25 - 100/25 ACC good BER */
	/* 0x164.0 - 0x168.31 */
	 u_int32_t mlpn_eth_com_codes_fec_fc;
/*---------------- DWORD[90] (Offset 0x168) ----------------*/
	/* Description - enable FEC on long optic in FDR/FDR10 */
	/* 0x168.0 - 0x168.0 */
	 u_int8_t enable_fec_on_long_optic;
	/* Description - enable FEC on FDR link if optic cable is longer then this length */
	/* 0x168.1 - 0x168.8 */
	 u_int8_t fec_min_cable_length;
	/* Description - disable LLR on long optic in FDR/FDR10 */
	/* 0x168.9 - 0x168.9 */
	 u_int8_t disable_llr_on_long_optic;
	/* Description - LLR will be disabled in FDR/FDR10 on optic cables longer than this length */
	/* 0x168.10 - 0x168.17 */
	 u_int8_t llr_max_cable_length;
	/* Description - sets mlpn_extended_time to a specific value. 0 disables it. value * 250 = time (msec) */
	/* 0x168.18 - 0x168.24 */
	 u_int8_t conf_mlpn_extended_time;
	/* Description - when set, phase eye opener is done in POST_LOCK_TUNE when valid */
	/* 0x168.25 - 0x168.25 */
	 u_int8_t phase_centering_en;
	/* Description - when set, mix90phase will remain at 32 */
	/* 0x168.26 - 0x168.26 */
	 u_int8_t open_phase_eye_only;
	/* Description - 2 ^ num = minimal phase length to allow phase centering */
	/* 0x168.28 - 0x168.30 */
	 u_int8_t min_valid_phase_grade;
	/* Description -  */
	/* 0x168.31 - 0x168.31 */
	 u_int8_t use_optic_starting_points_in_bp;
/*---------------- DWORD[92] (Offset 0x170) ----------------*/
	/* Description -  */
	/* 0x170.17 - 0x170.22 */
	 u_int8_t max_polarity;
	/* Description - Using last chosen RX set as an additional start point */
	/* 0x170.23 - 0x170.23 */
	 u_int8_t use_last_rx_set_in_rx_adap;
	/* Description - enables Link Maintenance feature */
	/* 0x170.24 - 0x170.24 */
	 u_int8_t link_maintenance_en;
	/* Description - interval between link maintenance activations in minutes/10. (value=20 is 2 minutes) */
	/* 0x170.25 - 0x170.29 */
	 u_int8_t link_maintenance_time_interval;
	/* Description -  */
	/* 0x170.30 - 0x170.30 */
	 u_int8_t validity_test_enable;
	/* Description -  */
	/* 0x170.31 - 0x170.31 */
	 u_int8_t similarity_test_enable;
/*---------------- DWORD[93] (Offset 0x174) ----------------*/
	/* Description -  */
	/* 0x174.0 - 0x174.0 */
	 u_int8_t lm_similarity_test_enable;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_phy_fw_main_config_shomron {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_phy_lcl_ini lcl[2];
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_phy_temp_cfg phy_temp_cfg;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0xfc.31 */
	 struct connectx4lx_err_correction_ini err_correction;
/*---------------- DWORD[63] (Offset 0xfc) ----------------*/
	/* Description - num of lanes (serdes) used by this port.
0 - 1X
1 - 2X
2 - 4X
 */
	/* 0xfc.0 - 0xfc.1 */
	 u_int8_t port0_width;
	/* Description - num of lanes (serdes) used by this port.
0 - 1X
1 - 2X
2 - 4X
 */
	/* 0xfc.2 - 0xfc.3 */
	 u_int8_t port1_width;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_pldm_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - to enable or disable pldm sensor reporting */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_pldm_sensor_rec_handle_en pldm_sensor_rec_handle_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - to enable or disable pldm features */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_pldm_supported_features pldm_supported_features;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - to enable or disable pldm features */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t pldm_temp_hysteresis;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_wol_cap_host_port {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - bit0 - host0 port0, bit1 - host1 port 0, ..., bit 4 - host0 port 1, bit5 - host1 port1 */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t magic_packet;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_mctp_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - nic_slave_address */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t nic_slave_addr;
	/* Description - nic_eid */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t nic_eid;
	/* Description - for verification pci setup sender side, prevents FW from popping VDMs */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t ver_over_pci;
	/* Description - pci_enable_link_mask */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t pci_enable;
	/* Description - smbus_enable_gw_mask */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t smbus_enable;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_ibm_thermal_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t thermal_threshold_tcontrol;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t thermal_threshold_tcontrol_low;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t thermal_threshold_twarning;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t thermal_threshold_twarning_low;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t thermal_threshold_tcritical;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t thermal_threshold_tcritical_low;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_ocsd_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t internal_caution_threshold;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t extrenal_caution_threshold;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t internal_max_cont_threshold;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t external_max_cont_threshold;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_ncsi_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t num_channels_per_pkg;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t debug_mode_no_mgmt_link;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t single_mgmt_port_portid;
	/* Description -  */
	/* 0x0.4 - 0x0.6 */
	 u_int8_t num_of_bmc;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t rmii_en;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t supported_pkg_id;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t keep_link_up_for_mng;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t keep_pt_over_rmii;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t disable_mng_pt;
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t send_ncsi_ctrl_pkt_to_port0_for_debug;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t lled_flex_addr_cap;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_oem_enable oem_enable;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_fw_vport0_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t partition_cap;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t log_guid_cap;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_apollo_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0x20.23 */
	 u_int8_t atten_12g[32];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_extended_port_info_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t link_speed_supported;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t link_speed_enabled;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t llr_64_byte_cell_size;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t llr_128_byte_cell_size;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t link_up_after_boot;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_ovonel_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t thermal_threshold_Tcritical;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t thermal_threshold_Tcritical_low;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t thermal_threshold_Twarning;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t thermal_threshold_Twarning_low;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t vpd_smbus_slv_indx;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t thermal_threshold_Tcontrol_low;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t thermal_threshold_Tcontrol;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_expander_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_pca9555_config pca9555;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t pca9555_exist;
	/* Description -  */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t pca9536_exist;
	/* Description -  */
	/* 0x4.2 - 0x4.5 */
	 u_int8_t smbus_slv_indx;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 struct connectx4lx_pca9536_config pca9536;
};

/* Description -   */
/* Size in bytes - 28 */
struct connectx4lx_ib_port_info_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Additional supported capabilities of this port. Valid only if IsCapabilityMask2Supported bit is set in CapabilityMask. A bit set to 1 indicates affirmation of supported capability. 0: IsSetNodeDescriptionSupportede 1: IsPortInfoExtendedSupported 2-15: Reserved */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t cap_mask2;
	/* Description - Diagnostic code, as described in 14.2.5.6.1 Interpretation of DiagCode on page 889. */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t diag_code;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Optional; shall be 0 if not implemented (PortInfo:CapabilityMask.IsLinkRoundTripLatency-Supported = 0). This value represents a measurement of the round-trip latency of the link attached to this port. It is an unsigned 24-bit integer counting 4 nsec. intervals. This value might not be accurate to better than +/- 4 nsec. A value of 0 is valid when implemented, and indicates a latency of up to 4 nsec. LinkRoundTripLatency is reset to 0xFFFFFF whenever this port transitions to PortState = Down. Each time a link heartbeat reply (ACK) is received on this port when PortState is not Down, this value is set to the minimum of (a) the prior value of this attribute; and (b) the time elapsed since the corresponding heartbeat (SND) was sent. Note that while the value of this component will never increase, it may change over time due to varying queueing delays associated with traffic load. Note that this component is always 0 for Enhanced SP 0. See InfiniBand Architecture Volume 2, Link/Phy Interface chapter. */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t link_roundtrip_lat;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Optional; shall be 0 if not implemented (PortInfo:CapabilityMask.IsLinkRoundTripLatency-Supported = 0). This value provides a vendordependent indication of the maximum number of credits available per VL on the Port. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t max_credit_hint;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 union connectx4lx_port_cap_mask1 cap_mask;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t link_width_sup;
	/* Description - Enabled link width, indicated as follows: 0: No State Change valid only on Set(); 1: 1x 2: 4x; 3: 1x or 4x; 4: 8x; 5: 1x or 8x; 6: 4x or 8x; 7: 1x or 4x or 8x; 8: 12x; 9: 1x or 12x; 10: 4x or 12x; 11: 1x or 4x or 12x; 12: 8x or 12x; 13: 1x or 8x or 12x; 14: 4x or 8x or 12x; 15: 1x or 4x or 8x or 12x; 16 - 254: Reserved; 255: Set to LinkWidthSupported value; response; contains actual LinkWidthSupported.;Changes to this component do not take effect immediately. See InfiniBand Architecture Specification Volume 2, Link/Phy Interface chapter. */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t link_width_ena;
	/* Description - Enabled link speed, indicated as follows: 0: No State Change; valid only on Set(); 1: 2.5 Gbps (also when SMSupportsExtended-Speeds is set to 0 on set, disable any extended speeds); 3: 2.5 or 5.0 Gbps (also when SMSupportsExtendedSpeeds is set to 0 on set, disable any extended speeds); 5: 2.5 or 10.0 Gbps (or higher when SMSupportsExtendedSpeeds is set to 0 in request/response AM); 7: 2.5 or 5.0 or 10.0 Gbps (or higher when SMSupportsExtendedSpeeds is set to 0 in request/response AM); 2, 4, 6, 8-14 Reserved; 15: Set to LinkSpeedSupported value; response contains actual LinkSpeedSupported. In addition to the LinkSpeedSupported value, when SMSupportsExtendedSpeeds is set to 0 in request/response AM, response contains QDR indication if an extended speed is enabled.; Note: See 14.3.14 SMSupportsExtendedLink-Speeds on page 932 for more information on SMSupportsExtendedSpeeds.; Changes to this component do not take effect immediately. See InfiniBand Architecture Specification Volume 2, Link/Phy Interface chapter. */
	/* 0x10.16 - 0x10.19 */
	 u_int8_t link_speed_ena;
	/* Description - 0: No state change; valid only on Set(); 1: Sleep; 2: Polling; 3 - 15: Reserved; See InfiniBand Architecture Specification Volume 2, Link/Phy Interface chapter. */
	/* 0x10.20 - 0x10.23 */
	 u_int8_t down_def_state;
	/* Description - Supported link speed, indicated as follows: 1: 2.5 Gbps; 3: 2.5 or 5.0 Gbps; 5: 2.5 or 10.0 Gbps (or higher when SMSupportsExtendedSpeeds is set to 0 in request/response AM); 7: 2.5 or 5.0 or 10.0 Gbps (or higher when SMSupportsExtendedSpeeds is set to 0 in request/response AM); 0, 2, 4, 6, 8-15: Reserved; Note: See 14.3.14 SMSupportsExtendedLink-Speeds on page 932 for more information on SMSupportsExtendedSpeeds. */
	/* 0x10.24 - 0x10.27 */
	 u_int8_t link_speed_sup;
	/* Description - Optional; shall be 0 if not implemented. Type of initialization requested by this port before SM moves it to Active or Armed state. See 14.4.4 Node Reinitialization on page 947.;/  bit 0: NoLoad. 0 = Port is requesting that its attributes be initialized (see 14.4.3 Initialization Actions on page 943). 1 = Port is requesting that no data be loaded into its attributes at all, asserting that the last-loaded data still exists and is valid.;/  bit 1: PreserveContent. 0 = Port makes no request regarding content of the data that is loaded into its attributes. 1 = Port is requesting that all such data, if loaded, be set to the most recent content loaded by the SM.;/ bit 2: PreservePresence. 0 = Port is requesting that all settable SA attributes referencing this port (see Table 209 Subnet Administration Attribute / Method Map on page 968) be removed prior to activating this port and Report()s of in/out of service (trap numbers 64/65) be sent. 1 = Port is requesting that all such data be preserved, and Report()s of in/out of service (trap numbers 64/65) not be sent for this port.;/ bit 3: DoNotResuscitate. 0 = bits 0, 1, and 2 of this field are valid; initialization of this port should begin based on their values. 1 = bits 0, 1, and 2 are not valid; port is requesting that reinitialization of this port, and any Report()s of in/out of service (trap numbers 64/65) be delayed until this bit is set to 0. */
	/* 0x10.28 - 0x10.31 */
	 u_int8_t init_type;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - VL/Weight pairs supported on this port in the VLArbitration table for high priority. Shall be 1 to 64 if more than one data VL is supported on this port, 0 otherwise. See 7.6.9 VL Arbitration and Prioritization on page 200. */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t vl_arb_high_cap;
	/* Description - Limit of High Priority component of VL Arbitration Table, as defined in 7.6.9 VL Arbitration and Prioritization on page 200. */
	/* 0x14.8 - 0x14.15 */
	 u_int8_t vl_high_limit;
	/* Description - VL/Weight pairs supported on this port in the VLArbitration table for high priority. Shall be 1 to 64 if more than one data VL is supported on this port, 0 otherwise. See 7.6.9 VL Arbitration and Prioritization on page 200. */
	/* 0x14.20 - 0x14.27 */
	 u_int8_t vl_arb_low_cap;
	/* Description - Virtual Lanes operational on this port, indicated as follows: 0: No change; valid only on Set();/ 1: VL0;/ 2: VL0, VL1;/ 3: VL0 - VL3;/ 4: VL0 - VL7;/ 5: VL0 - VL14;/ 6 - 15: reserved;/ Changing OperationalVLs in certain PortStates may cause flow control update errors which may initiate Link/Phy retraining. */
	/* 0x14.28 - 0x14.31 */
	 u_int8_t operational_vl;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Virtual Lanes operational on this port, indicated as follows: 0: No change; valid only on Set();/ 1: VL0;/ 2: VL0, VL1;/ 3: VL0 - VL3;/ 4: VL0 - VL7;/ 5: VL0 - VL14;/ 6 - 15: reserved;/ Changing OperationalVLs in certain PortStates may cause flow control update errors which may initiate Link/Phy retraining. */
	/* 0x18.0 - 0x18.3 */
	 u_int8_t neighbor_mtu;
	/* Description - Maximum MTU supported by this port.;/ 1: 256 ;/ 2: 512;/ 3: 1024;/ 4: 2048;/ 5: 4096;/ 0, 6 - 15: reserved */
	/* 0x18.4 - 0x18.7 */
	 u_int8_t mtu_cap;
	/* Description - Multicast PKey Trap Suppression Enable */
	/* 0x18.8 - 0x18.9 */
	 u_int8_t mc_pkey_trap_suppress_en;
	/* Description - Number of GUID entries supported in the GUIDInfo attribute for this port. */
	/* 0x18.10 - 0x18.17 */
	 u_int8_t guid_cap;
	/* Description - Specifies the expected maximum time between the port reception of a SMP and the transmission of the associated response. The duration of time is calculated based on (4.096 usec * 2^RespTimeValue). */
	/* 0x18.18 - 0x18.22 */
	 u_int8_t resp_time_value;
	/* Description - 0: No State Change; valid only on Set(); 1: 14.0625 Gbps (FDR); 2: 25.78125 Gbps (EDR); 3: 14.0625 Gbps (FDR) or 25.78125 Gbps (EDR); 4-29: Reserved; 30: Disable extended link speeds/Extended link speeds disabled; 31: Set to LinkSpeedExtSupported value; response contains actual LinkSpeedExtSupported; */
	/* 0x18.23 - 0x18.27 */
	 u_int8_t link_speed_ext_ena;
	/* Description - 0: Reserved; 1: 14.0625 Gbps (FDR); 2: 25.78125 Gbps (EDR); 3: 14.0625 Gbps (FDR) or 25.78125 Gbps (EDR); 4-15: Reserved */
	/* 0x18.28 - 0x18.31 */
	 u_int8_t link_speed_ext_sup;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_node_info_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t node_type;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t class_version;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t base_version;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t system_image_guid_hi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t system_image_guid_lo;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t node_guid_hi;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t node_guid_lo;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t port_guid_hi;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t port_guid_lo;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t device_id;
	/* Description -  */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t partition_cap;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t revision;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x24.23 */
	 u_int32_t vendor_id;
	/* Description -  */
	/* 0x24.24 - 0x24.31 */
	 u_int8_t local_port_num;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_port_leds_offsets {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t phy;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t logic;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_leds_patterns {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 16 bits describes the led pattern, 1 for on, 0 for off. */
	/* 0x0.16 - 0x20.15 */
	 struct connectx4lx_pattern_data pattern[16];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - describes the period length in bits of the pattern in this index */
	/* 0x20.28 - 0x28.27 */
	 struct connectx4lx_pattern_length_data pattern_length[16];
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - table of leds statuses and the index of the desired pattern for each logical state  */
	/* 0x28.0 - 0x48.31 */
	 struct connectx4lx_status2pattern status2pattern;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_uid_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Number of allocated UIDs in this entry */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t num_allocated;
	/* Description - Step size by which to derive the UIDs for this entry
See struct description */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t step;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - For MACs, the upper 16 bits in the 'hi' dword are reserved */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t uid;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_module_version {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t branch;
	/* Description -  */
	/* 0x0.8 - 0x0.19 */
	 u_int16_t minor;
	/* Description -  */
	/* 0x0.20 - 0x0.31 */
	 u_int16_t major;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_reset_level_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_reset_version ver;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t ini_sig;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 2^0-full ISFU, 2^1-management+link up ISFU 2^2-only PCIe ISFU 2^3-PCI disable/enable, 2^7-power_up */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t reset_type;
	/* Description -  */
	/* 0x8.8 - 0x8.8 */
	 u_int8_t ini_sig_v;
	/* Description -  */
	/* 0x8.9 - 0x8.9 */
	 u_int8_t ini_sig_ignore;
};

/* Description -   */
/* Size in bytes - 732 */
struct connectx4lx_sysport_packet_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x2dc.31 */
	 u_int32_t data[183];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_sysport_packet_properties {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t portid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t vl;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t prio;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t func_loopback;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t force_loopback;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t sx_sniffer;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t packet_is_roce;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_rw_gvmi_fw_ctx_sub_structs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dcr_odp_events dcr_odp_event;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_disable_mask {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - disable the port - bit for each reason */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_disable_mask_bits bits;
	/* Description - disable the port - total value of the mask */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_disable_mask_value value;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_drivers_mask_arr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0-63 per pf */
	/* 0x0.0 - 0x8.31 */
	 u_int32_t mask[2];
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_icmd_mctp_vnd_pci_debug_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_mctp_vnd_pci_debug_words words;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_mctp_oem_message_header header;
};

/* Description -   */
/* Size in bytes - 128 */
union connectx4lx_tlv_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_dcbx_ets_conf ets_conf;
	/* Description -  */
	/* 0x0.0 - 0x1c.31 */
	 struct connectx4lx_dcbx_ets_reco ets_reco;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_dcbx_pfc pfc_conf;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_dcbx_app app_prio;
	/* Description -  */
	/* 0x0.0 - 0x3c.31 */
	 struct connectx4lx_dcbx_cee_tlv dcbx_cee_tlv;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_tlv_words tlv_words;
};

/* Description -   */
/* Size in bytes - 8 */
union connectx4lx_lldp_tlv_extended_type {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lldp_tlv_extended_type_fields fields;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_lldp_tlv_extended_type_dwords dwords;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_uint64_wa_678118 qword;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_vport_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - IB + ROCE */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t port_guid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - IB + ROCE */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t node_guid;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_mac_address_layout permanent_address;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t cap_mask;
	/* Description -  */
	/* 0x18.16 - 0x18.27 */
	 u_int16_t allowed_uc_list_size;
	/* Description -  */
	/* 0x18.28 - 0x18.28 */
	 u_int8_t force_roce_disable_shadow;
	/* Description - disable RoCE per function */
	/* 0x18.29 - 0x18.29 */
	 u_int8_t force_roce_disable;
	/* Description - vport ctx was changed but event wasn't armed */
	/* 0x18.30 - 0x18.30 */
	 u_int8_t esw_ctx_dirty;
	/* Description -  */
	/* 0x18.31 - 0x18.31 */
	 u_int8_t roce_en;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t p_key_violations;
	/* Description - IB + ROCE */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t q_key_violations;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.11 */
	 u_int16_t allowed_mc_list_size;
	/* Description -  */
	/* 0x20.12 - 0x20.12 */
	 u_int8_t event_on_uc_address_change;
	/* Description -  */
	/* 0x20.13 - 0x20.13 */
	 u_int8_t event_on_mc_address_change;
	/* Description -  */
	/* 0x20.14 - 0x20.14 */
	 u_int8_t event_on_vlan_change;
	/* Description -  */
	/* 0x20.15 - 0x20.15 */
	 u_int8_t event_on_promisc_change;
	/* Description -  */
	/* 0x20.16 - 0x20.27 */
	 u_int16_t allowed_vlan_list_size;
	/* Description -  */
	/* 0x20.28 - 0x20.28 */
	 u_int8_t arm_change_event;
	/* Description -  */
	/* 0x20.29 - 0x20.29 */
	 u_int8_t promisc_all;
	/* Description -  */
	/* 0x20.30 - 0x20.30 */
	 u_int8_t promisc_mc;
	/* Description -  */
	/* 0x20.31 - 0x20.31 */
	 u_int8_t promisc_uc;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.22 - 0x24.22 */
	 u_int8_t disable_mc_local_lb;
	/* Description -  */
	/* 0x24.23 - 0x24.23 */
	 u_int8_t disable_uc_local_lb;
	/* Description -  */
	/* 0x24.24 - 0x24.26 */
	 u_int8_t min_wqe_inline_mode;
	/* Description - the offset in FW ICM context */
	/* 0x24.27 - 0x24.27 */
	 u_int8_t uc_list_offset_selector;
	/* Description - the offset in FW ICM context */
	/* 0x24.28 - 0x24.28 */
	 u_int8_t mc_list_offset_selector;
	/* Description - the offset in FW ICM context */
	/* 0x24.29 - 0x24.29 */
	 u_int8_t vlan_list_offset_selector;
	/* Description - was mtu ever written by vnic */
	/* 0x24.30 - 0x24.30 */
	 u_int8_t mtu_vld;
	/* Description -  */
	/* 0x24.31 - 0x24.31 */
	 u_int8_t event_on_mtu_change;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t mtu;
	/* Description - flow_counter_id of the vport flow counters link list head */
	/* 0x28.16 - 0x28.31 */
	 u_int16_t flow_counter_head;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 struct connectx4lx_dmfs_ft_type_info esw_egress_info;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 struct connectx4lx_dmfs_ft_type_info esw_ingress_info;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - this field defines dcbx and other event types */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t extension_event_mask;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_vport_shadow {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - IB + ROCE */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t port_guid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - IB + ROCE */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t node_guid;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_mac_address_layout permanent_address;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_ocbb_pci_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t pci_vendor_id;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t pci_device_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t pci_subsys_vendor_id;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t pci_subsys_device_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t num_of_pcie_func_per_port;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t pci_bus_number;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t pci_class;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t pci_bus_rx_utilization;
	/* Description -  */
	/* 0x10.8 - 0x10.15 */
	 u_int8_t pci_bus_tx_utilization;
	/* Description -  */
	/* 0x10.16 - 0x10.23 */
	 u_int8_t pci_function_num;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t pci_errors_cap_id;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t pci_errors_uncor_stat;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t pci_errors_uncor_mask;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t pci_errors_corr_stat;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t pci_errors_corr_mask;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t pci_errors_cap_and_ctrl;
};

/* Description -   */
/* Size in bytes - 512 */
struct connectx4lx_ocbb_fields {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_fw_banner fw_banner_str;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t hca_cap_num_ports;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t sriov_en;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t max_num_vmq_per_port;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t max_num_vmq_per_pf;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t lowest_port_recv;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.24 - 0x28.23 */
	 u_int8_t lldp_rx_get_chassis_id_tlv[12];
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.24 - 0x30.23 */
	 u_int8_t lldp_rx_get_port_id_tlv[8];
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.24 - 0x38.23 */
	 u_int8_t core_utilization[4];
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.24 - 0x44.23 */
	 u_int8_t device_bios_version[12];
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.24 - 0x50.23 */
	 u_int8_t device_hw_version[12];
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x50.7 */
	 u_int8_t port_type;
	/* Description -  */
	/* 0x50.8 - 0x50.15 */
	 u_int8_t flow_control_indicator;
	/* Description -  */
	/* 0x50.16 - 0x50.23 */
	 u_int8_t flex_ten_mode_en;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t port_speed;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x58.7 */
	 u_int8_t port_phy_link_status;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t max_speed_supported;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x60.7 */
	 u_int8_t function_type;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x64.15 */
	 u_int16_t mtu_size;
	/* Description -  */
	/* 0x64.16 - 0x64.31 */
	 u_int16_t feature_flags;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x68.15 */
	 u_int16_t max_offload_size;
	/* Description -  */
	/* 0x68.16 - 0x68.31 */
	 u_int16_t lso_min_seg_count;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x6c.7 */
	 u_int8_t promiscuous_mode;
	/* Description -  */
	/* 0x6c.16 - 0x6c.31 */
	 u_int16_t tx_descr_size;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x70.15 */
	 u_int16_t rx_descr_size;
	/* Description -  */
	/* 0x70.24 - 0x70.31 */
	 u_int8_t iov_offload;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description -  */
	/* 0x74.0 - 0x74.15 */
	 u_int16_t num_of_netq;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t pcp_prio_map_table;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description -  */
	/* 0x7c.0 - 0x7c.7 */
	 u_int8_t max_num_pci_vfs_per_pfs;
	/* Description -  */
	/* 0x7c.8 - 0x7c.15 */
	 u_int8_t os_driver_state;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0xc4.31 */
	 struct connectx4lx_ocbb_fields_from_vpd vpd_data;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc4.7 */
	 u_int8_t device_power_reset_state;
	/* Description -  */
	/* 0xc4.16 - 0xc4.31 */
	 u_int16_t max_num_of_vfs;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x104.31 */
	 u_int32_t rx_discards;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description -  */
	/* 0x104.0 - 0x108.31 */
	 u_int32_t rx_errors;
/*---------------- DWORD[66] (Offset 0x108) ----------------*/
	/* Description -  */
	/* 0x108.0 - 0x10c.31 */
	 u_int32_t tx_errors;
/*---------------- DWORD[67] (Offset 0x10c) ----------------*/
	/* Description -  */
	/* 0x10c.0 - 0x110.31 */
	 u_int32_t tx_discards;
/*---------------- DWORD[68] (Offset 0x110) ----------------*/
	/* Description -  */
	/* 0x110.0 - 0x118.31 */
	 u_int64_t rx_frames_received;
/*---------------- DWORD[70] (Offset 0x118) ----------------*/
	/* Description -  */
	/* 0x118.0 - 0x120.31 */
	 u_int64_t rx_bytes_received;
/*---------------- DWORD[72] (Offset 0x120) ----------------*/
	/* Description -  */
	/* 0x120.0 - 0x128.31 */
	 u_int64_t tx_frames_sent;
/*---------------- DWORD[74] (Offset 0x128) ----------------*/
	/* Description -  */
	/* 0x128.0 - 0x130.31 */
	 u_int64_t tx_bytes_sent;
/*---------------- DWORD[76] (Offset 0x130) ----------------*/
	/* Description -  */
	/* 0x130.0 - 0x138.31 */
	 u_int64_t pfc_frames_sent;
/*---------------- DWORD[78] (Offset 0x138) ----------------*/
	/* Description -  */
	/* 0x138.0 - 0x140.31 */
	 u_int64_t pfc_frames_received;
/*---------------- DWORD[80] (Offset 0x140) ----------------*/
	/* Description -  */
	/* 0x140.0 - 0x148.31 */
	 u_int64_t prog_max_addr_1;
/*---------------- DWORD[82] (Offset 0x148) ----------------*/
	/* Description -  */
	/* 0x148.0 - 0x150.31 */
	 u_int64_t prog_max_addr_2;
/*---------------- DWORD[84] (Offset 0x150) ----------------*/
	/* Description -  */
	/* 0x150.0 - 0x150.15 */
	 u_int16_t max_mtu;
	/* Description -  */
	/* 0x150.16 - 0x150.31 */
	 u_int16_t max_num_of_pci_func_per_port;
};

/* Description -   */
/* Size in bytes - 56 */
struct connectx4lx_module_db_pre_define_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_general_st misc;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x2c.31 */
	 struct connectx4lx_qsfp_st qsfp;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x38.31 */
	 struct connectx4lx_sfp_st sfp;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_fw_driver_version {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t data[16];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_iterator_result {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.17 */
	 u_int8_t port_0_1;
	/* Description -  */
	/* 0x0.18 - 0x0.21 */
	 u_int8_t vl;
	/* Description -  */
	/* 0x0.22 - 0x0.25 */
	 u_int8_t sl;
	/* Description -  */
	/* 0x0.26 - 0x0.29 */
	 u_int8_t pp;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t req_res_;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t is_fw_sq;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t sqn;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_general_fault_injector_pair {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - in config: must be bigger then 1 */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t freq;
	/* Description - the error will be duration of times in sequence */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t duration;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_dmfs_gvmi_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_dmfs_ft_type_info rx_nic_info;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_dmfs_ft_type_info sx_nic_info;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_dmfs_ft_type_info esw_fdb_info;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_dmfs_ft_type_info rx_sniffer_info;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_dmfs_ft_type_info sx_sniffer_info;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_dmfs_ft_type_info rx_rdma_info;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - ref_count of vports with sx sniffer enable */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t sx_sniffer_pf_ref_count;
	/* Description - counter of pf active vfs */
	/* 0x18.16 - 0x18.27 */
	 u_int16_t active_vfs_counter;
	/* Description - gvmi has started init flow for steering purposes */
	/* 0x18.28 - 0x18.28 */
	 u_int8_t is_gvmi_init_hca_set;
	/* Description - enabled by LAG matser gvmi, via CREATE_VPORT_LAG command */
	/* 0x18.29 - 0x18.29 */
	 u_int8_t vport_lag_enable;
	/* Description - vport works on VST mode */
	/* 0x18.30 - 0x18.30 */
	 u_int8_t cvlan_stripping_enable;
	/* Description -  */
	/* 0x18.31 - 0x18.31 */
	 u_int8_t gvmi_sx_sniffer_enable;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - ETH: number of mac only addresses connected to that pf
IB : number of IBL3 addresses connected to that pf */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t mpfs_cache_pf_mac_guid_counter;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - num of mac+vlan addresses on that pf */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t mpfs_cache_pf_mac_vlan_counter;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t ft_link_list_head;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - number of Flow Counter that were attached to the gvmi NIC FT */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t nic_flow_counters_cntr;
	/* Description -  */
	/* 0x28.16 - 0x28.23 */
	 u_int8_t load_balance_mac_ref_count;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - ref_count of tables with encap_en set */
	/* 0x2c.0 - 0x2c.7 */
	 u_int8_t encap_en_ref_count;
	/* Description - number of enhanced ipoib QPs opened for that gvmi */
	/* 0x2c.8 - 0x2c.31 */
	 u_int32_t ipoib_enhanced_qps_counter;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_dmfs_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - is mpfs cache enable (fast mode) */
	/* 0x0.1 - 0x0.2 */
	 u_int8_t mpfs_cache_enable[2];
	/* Description - sx steering will do always loopback - patch for Utopx - DO NOT MOVE!!! */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t steering_loopback_mode;
	/* Description - mpfs cache chicken bit (if set, cache isn't active) */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t mpfs_cache_chicken;
	/* Description - number of bmc loopback entries of that port */
	/* 0x0.24 - 0x0.7 */
	 u_int8_t bmc_member_count[2];
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - number of port gvmis that has sx_sniffer  */
	/* 0x4.16 - 0x8.15 */
	 u_int16_t sx_sniffer_ref_counter[2];
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - ETH: number of L2 mac only addresses connected to that port
IB : number of IBL3 addresses connected to that port */
	/* 0x8.0 - 0x10.31 */
	 u_int32_t mpfs_cache_mac_guid_addrs_counter[2];
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - number of L2 mac+vlan addresses connected to that port */
	/* 0x10.0 - 0x18.31 */
	 u_int32_t mpfs_cache_mac_vlan_addrs_counter[2];
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_get_ste_resources_list_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t resources_count;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x100.31 */
	 struct connectx4lx_resource_type_entry resource_type[63];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ste_resources_list_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_get_ste_open_resources_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - there are more open resources, please query again with the next start index */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t more;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - number of valid entries in open resources table */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t output_size;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x208.31 */
	 struct connectx4lx_index_and_length opened_resource[32];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ste_open_resources_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t icm_resource_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t start_index;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_get_fte_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t action;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t group_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t flow_tag;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t destination_list_size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.23 */
	 u_int32_t flow_counter_list_size;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_flow_table_entry_match_set_lyr_2_4 outer_headers;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0xc0.31 */
	 struct connectx4lx_flow_table_entry_match_set_misc misc_parameters;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0x100.31 */
	 struct connectx4lx_flow_table_entry_match_set_lyr_2_4 inner_headers;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x300.31 */
	 union connectx4lx_flow_list destination[64];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fte_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t flow_index;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t requested_fte_partition;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fte_list_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t valid;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t last;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t first;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t flow_index;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fte_list_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
	/* Description - 0: Request the first FTE and ignore flow_index
1: Request the next FTE following the one pointed by flow_index */
	/* 0x0.29 - 0x0.31 */
	 u_int8_t info;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t flow_index;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_get_fg_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t start_flow_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t end_flow_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t match_criteria_enable;
	/* Description -  */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t valid;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_flow_table_entry_match_set_lyr_2_4 outer_headers;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0xc0.31 */
	 struct connectx4lx_flow_table_entry_match_set_misc misc_parameters;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0x100.31 */
	 struct connectx4lx_flow_table_entry_match_set_lyr_2_4 inner_headers;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fg_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t group_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fg_list_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t valid;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t last;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t first;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t group_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_fg_list_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
	/* Description - 0: Request the first FG and ignore group_ID
1: Request the next FG following the one pointed by Group_ID */
	/* 0x0.29 - 0x0.31 */
	 u_int8_t info;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t group_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ft_info_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t log_size;
	/* Description -  */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t level;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t table_type;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t valid;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t table_miss_id;
	/* Description -  */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t table_miss_mode;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t encap_en;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t decap_en;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t lag_master_next_table_id;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ft_info_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ft_list_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
	/* Description -  */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t valid;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t last;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t first;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_ft_list_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t table_id;
	/* Description - 0: Request the first FT and ignore Table_ID
1: Request  the next FT following the one pointed by Table_ID */
	/* 0x0.29 - 0x0.31 */
	 u_int8_t info;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_led_control_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t port_led_pair_bank[16];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pll_varactor_config_value {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - perform the algorithm for this PLL */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t perform_algo;
	/* Description - which last step to perform
0x0-don't perform
0x1-compare
0x2-fine tune */
	/* 0x0.1 - 0x0.2 */
	 u_int8_t last_step;
	/* Description - how many varactors connected to fctrl */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t f_ctrl_num_of_varac;
	/* Description - fctrl compare value used in the algorithm */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t f_ctrl_compare_value;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_phy_uc_array_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t low;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t hi;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pll_status {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Measurement of fctrl in ticks Shell be set to 0 if not implemented */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t f_ctrl_measure;
	/* Description - Number of varactors connected to the analog by algorithm configuration */
	/* 0x0.10 - 0x0.15 */
	 u_int8_t analog_algo_num_var;
	/* Description - fctrl value of the varactor algorithm */
	/* 0x0.16 - 0x0.25 */
	 u_int16_t algo_f_ctrl;
	/* Description - PLL Lock status causes */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t lock_status;
	/* Description - PLL lock after the varactor calibration flow (locked by f_ctrl_measure)
0 - Locked; 1 - Unlocked. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t lock_cal;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Number of varactors connected to the configurable voltage */
	/* 0x4.0 - 0x4.5 */
	 u_int8_t mid_var;
	/* Description - Number of varactors connected to the low voltage */
	/* 0x4.8 - 0x4.13 */
	 u_int8_t low_var;
	/* Description - Number of varactors connected to the high voltage */
	/* 0x4.16 - 0x4.21 */
	 u_int8_t high_var;
	/* Description - Number of varactors connected to the analog */
	/* 0x4.24 - 0x4.29 */
	 u_int8_t analog_var;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_module_params {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - internal backplnae
1 - QSFP
2 - SFP

7 - empty module

TBD:
internal_1x
internal_2x
internal_4x */
	/* 0x0.0 - 0x0.2 */
	 u_int8_t type;
	/* Description -  */
	/* 0x0.3 - 0x0.10 */
	 u_int8_t identifier;
	/* Description - If set the module supports up to 40G */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t support_up_to_40g;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_sfp sfp;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x14.31 */
	 struct connectx4lx_qsfp qsfp;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_best_rx_set {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_sd_params_rx_set ffe_taps;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x20.31 */
	 struct connectx4lx_calibration_values calibration;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_grade_params grade;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_temperature_fields_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t module_current_temperature;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t module_high_alarm_temperature;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t module_high_warning_temperature;
	/* Description -  */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t support_temperature_monitoring;
	/* Description -  */
	/* 0x4.17 - 0x4.17 */
	 u_int8_t support_temperature_monitoring_pldm;
	/* Description -  */
	/* 0x4.18 - 0x4.18 */
	 u_int8_t support_temperature_monitoring_cnt;
	/* Description - sfp-0-not support,1-external calibrate,2-internal calibrate,3-not support */
	/* 0x4.19 - 0x4.20 */
	 u_int8_t support_temprature_calibrate;
	/* Description - Enable for measuring the max temperature */
	/* 0x4.21 - 0x4.21 */
	 u_int8_t mte;
	/* Description - Temprerature event enable 0-non generate event; 1-generate event; 2-generate single event */
	/* 0x4.22 - 0x4.23 */
	 u_int8_t tee;
	/* Description - debug bit to protect spike */
	/* 0x4.24 - 0x4.26 */
	 u_int8_t high_alarm_temperature_cnt;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t temp_hook_enable;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - sfp-calibrate bit */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t t_slope;
	/* Description - sfp-calibrate bit */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t t_offset;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Indicates for the max temprature that have been on the module */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t module_max_temperature;
	/* Description - save_last_temp_for_hot_algorithm */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t thermal_algorithm_prev_temp;
	/* Description - counter for stable module temperature */
	/* 0xc.24 - 0xc.25 */
	 u_int8_t thermal_algorithm_counter;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t module_low_alarm_temperature;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_admin_fields_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Module administrative state (the desired state of the module)
0000 - initializing
0001 - Enabled
0010 - Disabled by configuration
0011 - Enabled once - if the module is active and then unplugged, the
operational status should go to disabled and can only be enabled up
upon explicit enable command
1110 - Disconnect Cable. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t prsnt_admin_status;
	/* Description - Event Generation on operational state change:
00 - Do not generate event
01 - Generate Event
10 - Generate Single Event
See 5.16.7 PMAOS - Ports Module Administrative and Operational Status Register */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t pmpe_e;
	/* Description - Enable/Disable EDR cable stamping;0 - Enable;1 - Disable */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t edr_cable_stamping_disable;
	/* Description - Enable/Disable EDR20 cable stamping;0 - Enable;1 - Disable */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t edr20_cable_stamping_disable;
	/* Description - Enable/Disable FDR10 cable stamping;0 - Enable;1 - Disable */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t fdr10_cable_stamping_disable;
	/* Description - Enable/Disable IB NBL cable stamping;0 - Enable;1 - Disable */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t ib_nbl_cable_stamping_disable;
	/* Description - Enable/Disable ETH 100/50/25G QSFP cable stamping;0 - Enable;1 - Disable */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t eth_100g_cable_stamping_disable;
	/* Description - Enable/Disable ETH 25G SFP cable stamping;0 - Enable;1 - Disable */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t eth25g_sfp_cable_stamping_disable;
	/* Description - Enable/Disable ETH MLX PHY speeds cable stamping;0 - Enable;1 - Disable */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t eth_mlx_phy_speeds_cable_stamping_disable;
	/* Description - Enable/Disable ETH NBL cable stamping;0 - Enable;1 - Disable */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t eth_nbl_cable_stamping_disable;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t lr4_40g_long_range_stamping_disable;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t lr4_100g_long_range_stamping_disable;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t compliance_codes_cable_stamping_disable;
	/* Description - 1- BMC forced link down */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t bmc_forced_link_down;
	/* Description - for testing only */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t disable_reset_during_recovery;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_com_codes_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_eth_protocols_as_bits as_bits;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_as_dw as_dw;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_fpga_flex_nic_ctrl_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 u_int32_t words[32];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_steering_table_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - base index of table */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t base_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t default_ste_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t entry_count;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t descendant_count;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - table lookup type */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t ste_lu_type;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t log2_table_size;
	/* Description -  */
	/* 0xc.16 - 0xc.19 */
	 u_int8_t log2_entry_size;
	/* Description - if 1 - hash_table was sent to garbage collector */
	/* 0xc.23 - 0xc.23 */
	 u_int8_t sent_to_gc;
	/* Description -  */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t pipe;
	/* Description - 0 - NO_RESIZE
1 - RESIZE_CLEANUP
2 - AWAITING_RESIZE
3 - IN_PROGRESS
4 - RESIZE_POINTLESS */
	/* 0xc.25 - 0xc.27 */
	 u_int8_t resize_state;
	/* Description - while searching ste in table:
0 - do match only on data + mask
1 - do match only on data
2 - do full match on whole ste */
	/* 0xc.28 - 0xc.29 */
	 u_int8_t match_mode;
	/* Description - which mask is taking to hash calc:
0 - byte_mask
1 - bit_mask */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t mask_mode;
	/* Description -  */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t sx_rx_;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 union connectx4lx_hw_ste_tag bit_mask;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - id of the flow table corresponding to the hash table */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t table_id;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - id of the flow group corresponding to the hash table */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t group_id;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Number of buckets containing valid entries */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t bucket_count;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - valid only when resize_in_progress == 1. index of the destination hash meta in resize process */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t new_hash_meta_ix;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - valid only when resize_in_progress == 1. index of next bucket in hash table that will be copied to resize_table_icm_addr */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t next_bucket_to_copy;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.15 */
	 u_int16_t needed_pages;
	/* Description -  */
	/* 0x34.16 - 0x34.31 */
	 u_int16_t allocated_pages;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_dcr_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t next_dcri;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t valid;
	/* Description -  */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t connected;
	/* Description -  */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t trapped;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_icmd_ver_data_cmd_specific {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - command allowed only when no driver is loaded */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_ver_data_max_atomic max_atomic;
	/* Description - command allowed only when no driver is loaded */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_ver_data_one_qp_per_recovery one_qp_per_recovery;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_pcie_ver_frequency {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - .yu.bootrecord.core_f */
	/* 0x0.0 - 0x0.6 */
	 u_int8_t core_f;
	/* Description - .scratchpad.kernel.shared_kernel.core_clocks_per_usec */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t core_clocks_per_usec;
	/* Description - .yu.bootrecord.core_r */
	/* 0x0.8 - 0x0.12 */
	 u_int8_t core_r;
	/* Description - .px.pxdp.pxp.cx3_count_in_core_clocks */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t cx3_count_in_core_clocks;
	/* Description - .scratchpad.kernel.shared_kernel.usecs_in_high_tick */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t usecs_in_high_tick;
	/* Description - .scratchpad.ini.hw_main_config.gpios.functions.vdd_mod.mapping */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t vdd_mod_mapping;
	/* Description - .yu.bootrecord.flash_div */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t flash_div;
	/* Description - .yu.bootrecord.core_od */
	/* 0x0.20 - 0x0.21 */
	 u_int8_t core_od;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_pcie_ver_cables {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.identifier */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t identifier;
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.qsfp.extended_identifier */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t extended_identifier;
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.qsfp.device_tech */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t device_tech;
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.qsfp.attenuation_5g */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t attenuation_5g;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - .scratchpad.peripherals.module_mng.module_database[NUM].vendor_oui */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t vendor_oui;
	/* Description - .scratchpad.peripherals.module_mng.module_database[NUM].m_fsm_state */
	/* 0x4.24 - 0x4.29 */
	 u_int8_t m_fsm_state;
	/* Description - .scratchpad.peripherals.module_mng.module_database[NUM].mlnx_cable */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t mlnx_cable;
	/* Description - .scratchpad.peripherals.module_mng.module_database[NUM].eeprom_present */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t eeprom_present;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.sfp.link_length_supported */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t link_length_supported;
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.sfp.eth_com_codes */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t eth_com_codes;
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.sfp.tech */
	/* 0x8.16 - 0x8.24 */
	 u_int16_t tech;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - .scratchpad.phy_manager.port[NUM].port_cfg.module_params.sfp.ib_10ge_com_codes */
	/* 0xc.0 - 0xc.6 */
	 u_int8_t ib_10ge_com_codes;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_pcie_ver_device {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - .yu.boot.devid.devid */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t devid;
	/* Description - .yu.boot.devid.revid */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t revid;
	/* Description - .yu.boot.reset.strap_eprom_present */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t strap_eprom_present;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_error_flow_trigger_union {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - number of times to attempt to match and trigger error flow. set by test, decremented by HW when matched. a value of 0xf means always trigger when match (no HW decrement) */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t counter;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - FW only
configured by test
FW replaces special FW syndrome with this value */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t check_id;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - data for error flow trigger comparison */
	/* 0x20.0 - 0x30.31 */
	 union connectx4lx_error_flow_trigger_tag data;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - mask for error flow trigger comparison */
	/* 0x30.0 - 0x40.31 */
	 union connectx4lx_error_flow_trigger_tag mask;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_code_coverage_control {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Window start address [Byte] is code address */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t window;
	/* Description - Read only: size in bytes of collection window. */
	/* 0x0.24 - 0x0.28 */
	 u_int8_t log_window_size;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Bitmask of irisc to collect 1-Iron, 0-7 plastic */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t irisc_bitmask;
	/* Description - Shomron only. back pressure on congestion */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t bp;
	/* Description - Shomron only. If set collect all IPs, if cleared only branches */
	/* 0x4.25 - 0x4.25 */
	 u_int8_t all_ips;
	/* Description - Shomron only. Use 0 for legacy mode, non 0 for future modes */
	/* 0x4.26 - 0x4.27 */
	 u_int8_t trace_mode;
	/* Description - If set tracer will be enabled. For ini, use boot field for boot collection */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t enable;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_vport_real_state {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.28 - 0x80.27 */
	 u_int8_t real_state[256];
};

/* Description -   */
/* Size in bytes - 512 */
struct connectx4lx_fw_esw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x200.15 */
	 struct connectx4lx_fw_vport_ctx vport_ctx[256];
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_gvmix_sub_structs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_cmdif_ctx cmdif_ctx;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_dummy_addresses_one_cache_line dummy_addresses;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_hca_params hca_params;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icm_page_manager icm_page_manager;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_vf_pages_list vf_pages_list;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_sw_eqe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Event Sub Type.
Defined for events which have sub types, zero elsewhere. */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t event_sub_type;
	/* Description - Event Type */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t event_type;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Delivers auxiliary data to handle the event.
 See Table 142, "
Event_data Field - Completion Event Layout
," on 
page 335
 See Table 144, "
Event_data Field - DCT Events Layout
," on page 335
 See Table 146, "
Event_data Field - 
QP/
SQ/RQ Events Layout
," on 
page 336
 See Table 149, "
Event_data Field - WQE Associated Page Fault Event 
Layout
," on page 337
 See Table 151, "
Event_data Field - RDMA Page Fault Event Layout
," 
on page 338
 See Table 153, "
Event_data Field - Completion Queue Error Event Lay
out
," on page 339
 See Table 155, "
Event_data Field - DROPPED_PACKET_LOGGED 
Event Layout
," on page 340
 See Table 157, "
Event_data Field - Port State Change Event Layout
," on 
page 341
 See Table 160, "
Event_data Field - GPIO Event Layout
," on page 342
 See Table 162, "
Event_data Field - Port Module Event Layout
," on 
page 342
 See Table 164, "
Event_data Field - DCBX Change Event Layout
," on 
page 343
 See Table 168, "
Temperature Warning Event Layout
," on page 345
 See Table 170, "
Event_data Field - Doorbell / Blueflame Congestion 
Event Layout
," on page 346
 See Table 173, "
Event_data Field - Stall VL Event Field Descriptions
," 
on page 347
 See Table 174, "
Event_data Field - Command interface Completion 
Event Layout
," on page 347
 See Table 176, "
Pages Request Event Layout
," on page 347
 See Table 178, "
Nic Vport Change Event Layout
," on page 348
 See Table 180, "
Event_data Field - FPGA Error Event Layout
," on 
page 348
 See Table 182, "
Event_data Field - FPGA QP Error Event Layout
," on 
page 349 */
	/* 0x20.0 - 0x3c.31 */
	 union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto event_data;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Owner of the entry */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t owner;
	/* Description - Byte-wise XOR of EQE - signature protection (see 
 See Section 16.2.4, 
"
Completion and Event Queue Elements (CQEs and EQEs)
," on 
page 474
). EQE is valid if byte-wise XOR of entire EQE (including 
sig
nature
 field) and the EQE index is 0xff. */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t signature;
};

/* Description -   */
/* Size in bytes - 276 */
struct connectx4lx_ncsi_response {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ncsi_hdr hdr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t reason_code;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t response_code;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x114.31 */
	 union connectx4lx_ncsi_response_payload payload;
};

/* Description -   */
/* Size in bytes - 272 */
struct connectx4lx_ncsi_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ncsi_hdr hdr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x110.31 */
	 union connectx4lx_ncsi_cmd_payload payload;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_lock_tag {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t resource_id;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t resource_type;
};

/* Description -   */
/* Size in bytes - 276 */
struct connectx4lx_icmd_generic_reg_access_reg_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_reg_access_tlv hdr;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x114.31 */
	 union connectx4lx_icmd_generic_reg_access_reg_tlv_data reg_tlv_data;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_reg_access_oper_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Code indicating status of operation */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t Status;
	/* Description - Direct route - must be set on direct route packets. DR TLV must follow. */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t dr;
	/* Description -  */
	/* 0x0.16 - 0x0.26 */
	 u_int16_t len;
	/* Description -  */
	/* 0x0.27 - 0x0.31 */
	 u_int8_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Class of operation */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t class_;
	/* Description - Method to perform Based on Management Class */
	/* 0x4.8 - 0x4.14 */
	 u_int8_t Method;
	/* Description - Response
0 Request */
	/* 0x4.15 - 0x4.15 */
	 u_int8_t r;
	/* Description - Defines objects being operated by a management class (Page 658) */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t register_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 struct connectx4lx_IB_TID TID;
};

/* Description -   */
/* Size in bytes - 4 */
union connectx4lx_icmd_kdnet_ctrl_io {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_kdnet_ctrl_in ctrl_in;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_kdnet_ctrl_out ctrl_out;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_query_cap_general {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - When set, device supports FW components updated through ICMD interface. 
See 
"Firmware Components Update" on page 428
 */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t fw_ctrl_update_icmd;
	/* Description - When set, the 
"
ICMD_KDNET_CTRL - Control KDNET PF
"
 com
mand is supported. */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t kdnet_ctrl;
	/* Description - When set, multi-host synchronization through the device is supported. 
 See 
Section 25.4.3, "
ICMD_MH_SYNC - Multi-Host Synchronization
," on 
page 772
. */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t mh_sync;
	/* Description - If set, ICMD_ACCESS_REGISTER supports every register. (in the past it sup
ported some of them). */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t allow_icmd_access_reg_on_all_registers;
	/* Description - When set, ICMD_QUERY_FW_INFO returns the 
psid
 field. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t fw_info_psid;
	/* Description - When set, ICMD_ACCESS_REGISTER supports the following registers:
NVDA
NVDI
NVIA
NVQC */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t nv_access;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - If set, wake on phy activity is supported. */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t wol_p;
	/* Description - If set, wake on unicast packet is supported. */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t wol_u;
	/* Description - If set, wake on multicast packet is supported. */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t wol_m;
	/* Description - If set, wake on broadcast packet is supported. */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t wol_b;
	/* Description - If set, wake on ARP is supported. */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t wol_a;
	/* Description - If set, wake on magic packet is supported. */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t wol_g;
	/* Description - If set, wake on secured magic packet is supported. */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t wol_s;
	/* Description - If set, reset on magic packet is supported. */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t rol_g;
	/* Description - If set, reset on secured magic packet is supp
o
rted. */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t rol_s;
	/* Description - If set, FPGA device is supported by the device. See TBD */
	/* 0x4.10 - 0x4.10 */
	 u_int8_t fpga;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_query_cap_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Group of capabilities.
0x0 - General capability
other values are reserved. */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t capability_group;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_cable_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t address;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t page_number;
	/* Description - slave adddr */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t device_address;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t size;
	/* Description - If set to 1 will force the password to be cleared from the module password field at the end of the module access. */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t passwd_clr;
	/* Description - If set to 1 the Password field is valid and is written to the module password field (address 123-126) before accessing the page. */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t passwd_v;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The password that is written to the module password field. */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t password;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x40.31 */
	 u_int32_t dword[12];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_grepper_dwords {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t dwords[16];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_itrace {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - bit numbers:
0=DEBUG_INIT
1=INIT
2=ICM
3=ICM_FREE_LIST
4=LOG_MOD_HOST_MNG
5=CMD_IF
6=PHY_IB
7=PHY_RX_ADAP
8=PHY_EYE_OPN
9=PHY_GENERAL
10=PHY_MANAGER
11=PWR
12=FLR
13=ICM_ACCESS
14=MAD
15=RXT_CHECKS
16=I2C
17=TRANSPORT
18=FW_LL
19=RX_ERRORS
20=CMDIF_DRIVER
21=PROFILING
22=MANAGEMENT
23=FLASH
24=STEERING
25=IFARM
26=ICMD
27=PCI
28=DC_CLEANUP
29=PHY_ETH
30=VIRT */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t unit_mask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_itrace_ctrl ctrl;
};

/* Description -   */
/* Size in bytes - 2 */
struct connectx4lx_cc_table_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - this is the shift value used when calculating the injection rate delay */
	/* 0x0.0 - 0x0.13 */
	 u_int16_t cct_multiplier;
	/* Description - this is the multiplier used when calculating the injection rate delay */
	/* 0x0.14 - 0x0.15 */
	 u_int8_t cct_shift;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_ca_congestion_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - when the CCTI is equal to this value, an event is logged in the CA's cycyclic event log */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t trigger_threshold;
	/* Description - the number to be added to the table index (CCTI) on the receipt of a BECN */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t ccti_increase;
	/* Description - when the timer expires it will be reset to its specified value, and 1 will be decremented from the CCTI */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t ccti_timer;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - the minimum value permitted for the CCTI. This is used to impose a minimum injection rate delay on the SL */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t ccti_min;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_congestion_log_event_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - local QP that reached CN threshold. Set to zero if port threshold reached */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t service_type;
	/* Description - SL associated with local QP */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t sl;
	/* Description - remote QP that is connect to local QP. set to zero for datagram QPs */
	/* 0x0.8 - 0x0.31 */
	 u_int32_t local_qpn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - local QP that reached CN threshold. Set to zero if port threshold reached */
	/* 0x4.8 - 0x4.31 */
	 u_int32_t remote_qpn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - LID of remote port that is connet to local QP. Set to zero for datagram service */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t remote_lid;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - timestamp when threshold reached */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t timestamp;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_special_qps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t qp0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t qp1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t raw;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ipv6;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t reserved;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t ptp1588;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t sync_umr;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t cnak;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_cmdif_hdr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t reserved0;
	/* Description - cmd type = 0x7 */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - input command length in bytes */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t input_length;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t ibox_pointer;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - just the standart, The first 128 bits of the command input */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_input_inline_standart input_inline;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The first 128 bits of the command output */
	/* 0x20.0 - 0x30.31 */
	 struct connectx4lx_output_inline_standart output_inline;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x38.31 */
	 u_int64_t obox_pointer;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - output command length in bytes */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t output_length;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - SW should set to 1 when posting the command. HW will change to zero to move ownership bit to SW. */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t ownership;
	/* Description -     NO_ERRORS          = 0x0,
    SIGNATURE_ERROR    = 0x1,
    TOKEN_ERROR        = 0x2,
    BAD_BLOCK_NUMBER   = 0x3,
    BAD_OUTPUT_POINTER = 0x4,   // pointer not align to mailbox size
    BAD_INPUT_POINTER  = 0x5,   // pointer not align to mailbox size
    INTERNAL_ERROR     = 0x6,
    INPUT_LEN_ERROR    = 0x7,   // input  length less than 0x8.
    OUTPUT_LEN_ERROR   = 0x8,   // output length less than 0x8.
    RESERVE_NOT_ZERO   = 0x9,
    BAD_CMD_TYPE       = 0x10,
 */
	/* 0x3c.1 - 0x3c.7 */
	 u_int8_t status;
	/* Description -  */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t reserved1;
	/* Description - SW should set to 1 when posting the command. HW will change to zero to move ownership bit to SW. */
	/* 0x3c.16 - 0x3c.23 */
	 u_int8_t signature;
	/* Description - SW should set to 1 when posting the command. HW will change to zero to move ownership bit to SW. */
	/* 0x3c.24 - 0x3c.31 */
	 u_int8_t token;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_header_capture_checks {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t word[16];
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_header_capture_headers {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 u_int32_t word[32];
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_g_rse_hw_decoders {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_rxt_checks_packet_descriptor_decoder rxt_checks_packet_descriptor_decoder;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_rxt_steering_context_decoder rxt_steering_context_decoder;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_rxt_checks_steering_results_decoder rxt_checks_steering_results_decoder;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_rxt_context_fetch_qp_desc_decoder rxt_context_fetch_qp_desc_decoder;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_rxs_rxt_desc_decoder rxs_rxt_desc_decoder;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_g_rse_decoders_as_dwords raw_dwords;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_FW_VERSION {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t MAJOR;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t SUBMINOR;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t MINOR;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t Hour;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t Minutes;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t Seconds;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t Day;
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t Month;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t Year;
};

/* Description -   */
/* Size in bytes - 64 */
union connectx4lx_golan_hw_fw_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_hca_contexts hw_ctx;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_fw_resource_context fw_ctx;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_ctx_as_dwords as_dwords;
};

/* Description -   */
/* Size in bytes - 144 */
struct connectx4lx_best_rx_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x90.31 */
	 struct connectx4lx_bath_debug bath[9];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_data_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t data;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_start_point_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x3c.31 */
	 struct connectx4lx_local_best_rx_set local_best_rx_set;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.19 */
	 u_int32_t curr_search_radius;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_lane_search_vars {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
0x0 = MIX90PHASE
0x1 = MIX90PHASE_FDR
0x2 = INBUF0_MIXER_OFFSET0
0x3 = INBUF0_MIXER_OFFSET1
0x4 = INBUF1_MIXER_OFFSET0
0x5 = INBUF1_MIXER_OFFSET1
0x6 = INBUF0_SLICER_OFFSET
0x7 = INBUF1_SLICER_OFFSET
0x8 = INBUF0_FFE_TAP_OFFSET0
0x9 = INBUF0_FFE_TAP_OFFSET1
0xa = INBUF1_FFE_TAP_OFFSET0
0xb = INBUF1_FFE_TAP_OFFSET1 */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t search_opcode;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
selected error to count 
0 -disparity_or_pcie_error 
1 -kr_prbs_err 
2 -pib_error 
3 -sh_error 
4 -lane_64_66_err_blk 
5 -bip_error 
6 -prbs_error 
7 -rx_all_ones 
8 -rx_all_zeros 
9 -rx_mixed_zeros_and_ones 
10-firecode_correctable 
11-firecode_uncorrectable 
12-rs_symbol_error 
13-serdes_error 
14-op_calib_open_loop_response_top 
15-op_calib_open_loop_response_bot 
16-op_calib_open_loop_response_mid 
17-op_calib_open_loop_response_nbl_pfc 
18-op_calib_open_loop_response_nbl_nfc 
19-nbl_pll_ck_meas
20-nbl_ref_clk_sync 
21-op_calib_open_loop_response_pll_pfc_up 
22-op_calib_open_loop_response_pll_pfc_down 
23-op_calib_open_loop_response_pll_nfc 
24-pll_ck_meas
25-ext_oscilator_ck 
26-kr_count_prbs_error
27-serdes_spare */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t search_error_opcode;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
How many errors are the limit to stop the search (according to search_error_indication parameter) */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t search_error_count_limit;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
Starting value of the search */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t search_start_point;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
Step size of the search 
In binary search should be the range to cover from the start point in both directions. 
Example: to search from 10 to 73 it should be 32 (start point=42) 

In linear search this is the step advance of the search. 
Example: step size of 3 (start point = 10 and direction=positive) search will be: 10,13,16... */
	/* 0x10.0 - 0x10.19 */
	 u_int32_t search_step_size;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
in which direction should the search advance 
0x0 - positive 
0x1 - negative 
not in use in the binary search */
	/* 0x14.0 - 0x14.19 */
	 u_int32_t search_direction;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
Minimum limit of search value */
	/* 0x18.0 - 0x18.19 */
	 u_int32_t search_limit_min;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
Maximum limit of search value */
	/* 0x1c.0 - 0x1c.19 */
	 u_int32_t search_limit_max;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
0x0 - stop on first error 
0x1 - stop on first good */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t search_error_indication;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Parameter - this value should be updated by the caller. 
0x0 - no recovery 
0x1 - perform search recovery */
	/* 0x24.0 - 0x24.19 */
	 u_int32_t search_recovery;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Parameter to read/write_serdes subroutines - value to be written or read from serdes crspace */
	/* 0x28.0 - 0x28.19 */
	 u_int32_t search_rw_serdes_value;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - Variable - current search value */
	/* 0x2c.0 - 0x2c.19 */
	 u_int32_t search_cur_idx;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - Variable - used as a flag in the loops. */
	/* 0x30.0 - 0x30.19 */
	 u_int32_t search_loop_flag;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description - Variable - saves original value of crspace (serdes) for recovery */
	/* 0x34.0 - 0x34.19 */
	 u_int32_t search_recovery_value;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - Variable - search result (search output) */
	/* 0x38.0 - 0x38.19 */
	 u_int32_t search_result;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - Variable - temp search variable */
	/* 0x3c.0 - 0x3c.19 */
	 u_int32_t search_temp_var4;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - Variable - temp search variable */
	/* 0x40.0 - 0x40.19 */
	 u_int32_t search_temp_var3;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - Variable - temp search variable */
	/* 0x44.0 - 0x44.19 */
	 u_int32_t search_temp_var2;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - Variable - temp search variable */
	/* 0x48.0 - 0x48.19 */
	 u_int32_t search_temp_var1;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - Variable - temp search variable */
	/* 0x4c.0 - 0x4c.19 */
	 u_int32_t search_temp_var0;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_opamp_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.5 */
	 u_int8_t opamp_calib_range;
	/* Description -  */
	/* 0x0.6 - 0x0.10 */
	 u_int8_t opamp_calib_step;
	/* Description -  */
	/* 0x0.11 - 0x0.16 */
	 u_int8_t opamp_calib_status;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_wqe_extended_atomic_fetch_add_128byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_add_data add_data[32];
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x100.31 */
	 struct connectx4lx_field_boundary field_boundary[32];
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_wqe_extended_atomic_fetch_add_64byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_add_data add_data[16];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_field_boundary field_boundary[16];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_wqe_extended_atomic_fetch_add_32byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_add_data add_data[8];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_field_boundary field_boundary[8];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_wqe_extended_atomic_fetch_add_16byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_add_data add_data[4];
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_field_boundary field_boundary[4];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_extended_atomic_fetch_add_8byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_add_data add_data[2];
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 struct connectx4lx_field_boundary field_boundary[2];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_extended_atomic_fetch_add_4byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t add_data;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t field_boundary;
};

/* Description -   */
/* Size in bytes - 512 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_swap_data swap_data[32];
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x100.31 */
	 struct connectx4lx_compare_data compare_data[32];
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x180.31 */
	 struct connectx4lx_swap_mask_data swap_mask_data[32];
/*---------------- DWORD[96] (Offset 0x180) ----------------*/
	/* Description -  */
	/* 0x180.0 - 0x200.31 */
	 struct connectx4lx_compare_mask_data compare_mask_data[32];
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_swap_data swap_data[16];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_compare_data compare_data[16];
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0xc0.31 */
	 struct connectx4lx_swap_mask_data swap_mask_data[16];
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0x100.31 */
	 struct connectx4lx_compare_mask_data compare_mask_data[16];
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_swap_data swap_data[8];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_compare_data compare_data[8];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x60.31 */
	 struct connectx4lx_swap_mask_data swap_mask_data[8];
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x80.31 */
	 struct connectx4lx_compare_mask_data compare_mask_data[8];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_swap_data swap_data[4];
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_compare_data compare_data[4];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x30.31 */
	 struct connectx4lx_swap_mask_data swap_mask_data[4];
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 struct connectx4lx_compare_mask_data compare_mask_data[4];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_swap_data swap_data[2];
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 struct connectx4lx_compare_data compare_data[2];
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_swap_mask_data swap_mask_data[2];
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x20.31 */
	 struct connectx4lx_compare_mask_data compare_mask_data[2];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t swap_data;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t compare_data;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t swap_mask_data;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t compare_mask_data;
};

/* Description -   */
/* Size in bytes - 288 */
struct connectx4lx_file_public_keys {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - configuration bits to enable authentication for each component */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_component_authentication_configuration component_authentication_configuration;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - public key exponent, FW should use an exponent of 65537 */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t keypair_exp;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - UUID of this key created by server when it generates a keypair */
	/* 0x10.0 - 0x20.31 */
	 u_int32_t keypair_uuid[4];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - 2048 bit public-key */
	/* 0x20.0 - 0x120.31 */
	 u_int32_t key[64];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_nv_config_header {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - if 0x4d544346, this nv_data partition is valid */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t signature;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t version_minor;
	/* Description -  */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t version_major;
	/* Description - non volatile counter incremented when fw didn't find valid configuration header and need to erase the nv partition */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t num_of_init_cfg_hdr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - non volatile counter incremented on each sector erase */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t num_of_swaps;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - 0=hw_calibration, 1=fast_list, 2=slow_list */
	/* 0xc.0 - 0x24.31 */
	 struct connectx4lx_nv_data_pointer list_pointers[6];
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - crc16 of header area */
	/* 0x3c.0 - 0x3c.15 */
	 u_int16_t crc16;
};

/* Description -   */
/* Size in bytes - 10752 */
struct connectx4lx_cluster_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10e0.31 */
	 struct connectx4lx_port_shared_const_sd_params port[2];
/*---------------- DWORD[1080] (Offset 0x10e0) ----------------*/
	/* Description -  */
	/* 0x10e0.0 - 0x26e0.31 */
	 struct connectx4lx_lane_consts lane[8];
/*---------------- DWORD[2488] (Offset 0x26e0) ----------------*/
	/* Description -  */
	/* 0x26e0.0 - 0x2a00.31 */
	 struct connectx4lx_pll_consts pll;
};

/* Description -   */
/* Size in bytes - 640 */
struct connectx4lx_shared_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - (2^stab_time)*64 nsec */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t stabilization_time_rx_set;
	/* Description - (2^stab_time)*64 nsec */
	/* 0x0.10 - 0x0.19 */
	 u_int16_t cdr_stabilization_time;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t adaptive_tap_offset_iterations_num;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - mask for ffe taps to enable in serdesFlow-parallel detect eth for 10g speed per lane */
	/* 0x8.0 - 0x8.9 */
	 u_int16_t ffe_tap_en_mask_eth_pd_10g;
	/* Description - mask for ffe taps to enable in serdes. for parallel space flow for 10g speed per lane */
	/* 0x8.10 - 0x8.19 */
	 u_int16_t ffe_tap_en_mask_reduced_space_10g;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - minimum xor bath grade of a set, to run xor voltage eo */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t similarity_min_grade;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - mask for ffe taps to enable in serdes. for serial space flow for 10g speed per lane */
	/* 0x10.0 - 0x10.19 */
	 u_int32_t ffe_tap_en_mask_s_space_10g;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.19 */
	 u_int32_t bracketing_mixer_offset_jump_size;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.9 */
	 u_int16_t bracketing_tap_offset_jump_size;
	/* Description -  */
	/* 0x18.10 - 0x18.19 */
	 u_int16_t bracketing_tap_offset_init_val;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - 4 msec */
	/* 0x1c.0 - 0x1c.19 */
	 u_int32_t voltage_eo_measure_time;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.19 */
	 u_int32_t voltage_eo_err_th;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - (2^stab_time)*64 nsec */
	/* 0x24.0 - 0x24.9 */
	 u_int16_t short_stab_time;
	/* Description - (2^stab_time)*64 nsec */
	/* 0x24.10 - 0x24.19 */
	 u_int16_t long_stab_time;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.19 */
	 u_int32_t static_calibration_ffe_tap_offset0;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x2c.19 */
	 u_int32_t static_calibration_mixer_offset0;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x30.19 */
	 u_int32_t static_calibration_mixer_offset1;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.19 */
	 u_int32_t static_calibration_slicer_offset;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.9 */
	 u_int16_t static_calibration_mix90phase_edr;
	/* Description -  */
	/* 0x38.10 - 0x38.19 */
	 u_int16_t static_calibration_mix90phase_not_edr;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - 4 mili-sec */
	/* 0x3c.0 - 0x3c.19 */
	 u_int32_t phase_eo_long_measure_time;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - 256 micro-sec */
	/* 0x40.0 - 0x40.19 */
	 u_int32_t phase_eo_short_measure_time;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - 0 - static, 1 - digital, 2 - analog */
	/* 0x44.0 - 0x44.19 */
	 u_int32_t calibration_mode;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - 1 - adaptive tap flow, 0 - set default value */
	/* 0x48.0 - 0x48.19 */
	 u_int32_t adaptive_tap_offset_en;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x4c.19 */
	 u_int32_t bath_mixer_offset1_jump_size;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - Used also in one's ratio IB QDR. 0.08*bath_measure_bits. Value for Pelican, Shomron overrided */
	/* 0x50.0 - 0x50.19 */
	 u_int32_t bath_high_threshold;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x54.9 */
	 u_int16_t bath_mid_threshold;
	/* Description -  */
	/* 0x54.10 - 0x54.19 */
	 u_int16_t bath_low_threshold;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x58.19 */
	 u_int32_t bath_dz_factor;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - Used also in one's ratio IB QDR. Value for Pelican - multiples of 80 bits. Overrided in Shomron */
	/* 0x5c.0 - 0x5c.19 */
	 u_int32_t bath_measure_bits;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description - (2^stab_time)*64 nsec */
	/* 0x60.0 - 0x60.19 */
	 u_int32_t bath_stab_time;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description - PRBS. Value for Pelican, Shomron overrided */
	/* 0x64.0 - 0x64.19 */
	 u_int32_t bath_errors_opcode;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description - Only for Eth, KR */
	/* 0x68.0 - 0x68.19 */
	 u_int32_t ones_ratio_measure_bits;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - Max DC balance deviation */
	/* 0x6c.0 - 0x6c.19 */
	 u_int32_t ones_ratio_low_threshold_qdr;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description - 0.01 *ones_ratio_measure_bits. Value for Shomron - multiples of 96 bits. Overrided in Condor */
	/* 0x70.0 - 0x70.19 */
	 u_int32_t ones_ratio_low_threshold_idle;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - 0.002*ones_ratio_measure_bits. Value for Shomron - multiples of 96 bits. Overrided in Condor */
	/* 0x74.0 - 0x74.9 */
	 u_int16_t ones_ratio_low_threshold_kr;
	/* Description -  */
	/* 0x74.10 - 0x74.19 */
	 u_int16_t space_search_radius_lm;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description - 0.08 *ones_ratio_measure_bits. Value for Shomron - multiples of 96 bits. Overrided in Condor. Only for Eth, KR. */
	/* 0x78.0 - 0x78.19 */
	 u_int32_t ones_ratio_high_threshold;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - 0.5  *ones_ratio_measure_bits. Value for Shomron - multiples of 96 bits. Overrided in Condor */
	/* 0x7c.0 - 0x7c.19 */
	 u_int32_t ones_ratio_half_measured_bits_eth;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - 0.5  *bath_measure_bits */
	/* 0x80.0 - 0x80.19 */
	 u_int32_t ones_ratio_half_measured_bits_qdr;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x84.19 */
	 u_int32_t lowest_mixer_offset1_val;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description -  */
	/* 0x88.0 - 0x88.19 */
	 u_int32_t highest_mixer_offset1_val;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description - (2^7)*64 nsec */
	/* 0x8c.0 - 0x8c.9 */
	 u_int16_t wait_8_usec_time;
	/* Description -  */
	/* 0x8c.10 - 0x8c.19 */
	 u_int16_t start_points_mask_lm;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description -  */
	/* 0x90.0 - 0x90.9 */
	 u_int16_t space_radius_devision_factor;
	/* Description -  */
	/* 0x90.10 - 0x90.19 */
	 u_int16_t space_bath_last_search_radius;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0x94.19 */
	 u_int32_t grade_similarity_th;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description -  */
	/* 0x98.0 - 0x98.19 */
	 u_int32_t space_ones_ratio_last_search_radius;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description - 9 bit mask. bit per start point. for serial space flow - copper cable */
	/* 0x9c.0 - 0x9c.19 */
	 u_int32_t start_points_mask_s_space;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description - 5 bit mask. bit per start point for parallel detect flow eth */
	/* 0xa0.0 - 0xa0.19 */
	 u_int32_t start_points_mask_eth_pd;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description - 5 bit mask. bit per start point. for parallel space flow */
	/* 0xa4.0 - 0xa4.9 */
	 u_int16_t start_points_mask_reduced_space;
	/* Description - iterations number during space for parallel detect flow eth */
	/* 0xa4.10 - 0xa4.19 */
	 u_int16_t grade_bath_iterations_num_eth_pd;
/*---------------- DWORD[42] (Offset 0xa8) ----------------*/
	/* Description - 1 - modify radius only when central point has the highest grade, 0 - modify radius each search cycle. for parallel detect flow eth */
	/* 0xa8.0 - 0xa8.9 */
	 u_int16_t space_modify_radius_only_if_no_improve_eth_pd;
	/* Description - for parallel detect flow eth */
	/* 0xa8.10 - 0xa8.19 */
	 u_int16_t space_first_search_radius_eth_pd;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description - iterations number during space for parallel space flow */
	/* 0xac.0 - 0xac.9 */
	 u_int16_t grade_bath_iterations_num_reduced_space;
	/* Description - 1 - modify radius only when central point has the highest grade, 0 - modify radius each search cycle. for parallel space flow */
	/* 0xac.10 - 0xac.19 */
	 u_int16_t space_modify_radius_only_if_no_improve_reduced_space;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description - for parallel space flow */
	/* 0xb0.0 - 0xb0.9 */
	 u_int16_t space_first_search_radius_reduced_space;
	/* Description - iterations number during space for serial space flow */
	/* 0xb0.10 - 0xb0.19 */
	 u_int16_t grade_bath_iterations_num_s_space;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description - 1 - modify radius only when central point has the highest grade, 0 - modify radius each search cycle. for serial space flow */
	/* 0xb4.0 - 0xb4.9 */
	 u_int16_t space_modify_radius_only_if_no_improve_s_space;
	/* Description - for serial space flow */
	/* 0xb4.10 - 0xb4.19 */
	 u_int16_t space_first_search_radius_s_space;
/*---------------- DWORD[46] (Offset 0xb8) ----------------*/
	/* Description - 1 usec */
	/* 0xb8.0 - 0xb8.19 */
	 u_int32_t voltage_eo_measure_time_interval;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description - number of errors measure to find voltage eye. =voltage_eo_meas_time / min_voltage_eo_meas_time */
	/* 0xbc.0 - 0xbc.19 */
	 u_int32_t voltage_eo_num_of_intervals;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0xc0.19 */
	 u_int32_t best_rx_set_bath_iterations_num_xor;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc4.19 */
	 u_int32_t global_datapath_input_buffer;
/*---------------- DWORD[51] (Offset 0xcc) ----------------*/
	/* Description -  */
	/* 0xcc.0 - 0xcc.9 */
	 u_int16_t grade_voltage_weight;
	/* Description -  */
	/* 0xcc.10 - 0xcc.19 */
	 u_int16_t grade_phase_weight;
/*---------------- DWORD[52] (Offset 0xd0) ----------------*/
	/* Description -  */
	/* 0xd0.0 - 0xd0.19 */
	 u_int32_t run_similarity_test;
/*---------------- DWORD[53] (Offset 0xd4) ----------------*/
	/* Description -  */
	/* 0xd4.0 - 0xd4.19 */
	 u_int32_t grade_phase_iterations_num;
/*---------------- DWORD[54] (Offset 0xd8) ----------------*/
	/* Description -  */
	/* 0xd8.0 - 0xd8.19 */
	 u_int32_t phase_measuring_en;
/*---------------- DWORD[55] (Offset 0xdc) ----------------*/
	/* Description -  */
	/* 0xdc.0 - 0xdc.19 */
	 u_int32_t phase_measure_bits;
/*---------------- DWORD[56] (Offset 0xe0) ----------------*/
	/* Description -  */
	/* 0xe0.0 - 0xe0.19 */
	 u_int32_t number_of_ffe_taps;
/*---------------- DWORD[57] (Offset 0xe4) ----------------*/
	/* Description - maximum of ffe_taps absolute values sum */
	/* 0xe4.0 - 0xe4.19 */
	 u_int32_t max_allowed_rx_ffe_tap_sum;
/*---------------- DWORD[58] (Offset 0xe8) ----------------*/
	/* Description - multiples of 64 nsec */
	/* 0xe8.0 - 0xe8.19 */
	 u_int32_t best_rx_set_ber_measure_time;
/*---------------- DWORD[59] (Offset 0xec) ----------------*/
	/* Description -  */
	/* 0xec.0 - 0xec.9 */
	 u_int16_t best_rx_set_bath_iterations_num_center;
	/* Description -  */
	/* 0xec.10 - 0xec.19 */
	 u_int16_t best_rx_set_bath_iterations_num_grade;
/*---------------- DWORD[60] (Offset 0xf0) ----------------*/
	/* Description -  */
	/* 0xf0.0 - 0xf0.19 */
	 u_int32_t min_fdr_phase_grade;
/*---------------- DWORD[61] (Offset 0xf4) ----------------*/
	/* Description -  */
	/* 0xf4.0 - 0xf4.19 */
	 u_int32_t best_rx_set_phase_iterations_num;
/*---------------- DWORD[62] (Offset 0xf8) ----------------*/
	/* Description -  */
	/* 0xf8.0 - 0xf8.19 */
	 u_int32_t best_rx_set_bath_mixer_offset1_jump_size;
/*---------------- DWORD[63] (Offset 0xfc) ----------------*/
	/* Description - serdes_error. Value for Pelican, Shomron overrided */
	/* 0xfc.0 - 0xfc.19 */
	 u_int32_t analog_calibration_errors_opcode;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description - weight*1024 */
	/* 0x100.0 - 0x100.19 */
	 u_int32_t ffe_tap0_weight;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap0_weight */
	/* 0x104.0 - 0x104.19 */
	 u_int32_t ffe_tap1_weight;
/*---------------- DWORD[66] (Offset 0x108) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap1_weight */
	/* 0x108.0 - 0x108.19 */
	 u_int32_t ffe_tap2_weight;
/*---------------- DWORD[67] (Offset 0x10c) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap2_weight */
	/* 0x10c.0 - 0x10c.19 */
	 u_int32_t ffe_tap3_weight;
/*---------------- DWORD[68] (Offset 0x110) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap3_weight */
	/* 0x110.0 - 0x110.19 */
	 u_int32_t ffe_tap4_weight;
/*---------------- DWORD[69] (Offset 0x114) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap4_weight */
	/* 0x114.0 - 0x114.19 */
	 u_int32_t ffe_tap5_weight;
/*---------------- DWORD[70] (Offset 0x118) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap5_weight */
	/* 0x118.0 - 0x118.19 */
	 u_int32_t ffe_tap6_weight;
/*---------------- DWORD[71] (Offset 0x11c) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap6_weight */
	/* 0x11c.0 - 0x11c.19 */
	 u_int32_t ffe_tap7_weight;
/*---------------- DWORD[72] (Offset 0x120) ----------------*/
	/* Description - weight*1024, must be sequential to ffe_tap7_weight */
	/* 0x120.0 - 0x120.19 */
	 u_int32_t ffe_tap8_weight;
/*---------------- DWORD[73] (Offset 0x124) ----------------*/
	/* Description -  */
	/* 0x124.0 - 0x124.9 */
	 u_int16_t space_step2_first_search_radius;
	/* Description -  */
	/* 0x124.10 - 0x124.19 */
	 u_int16_t xor_grade_bath_iterations_num;
/*---------------- DWORD[74] (Offset 0x128) ----------------*/
	/* Description -  */
	/* 0x128.0 - 0x128.19 */
	 u_int32_t xor_dp_center_iterations_num;
/*---------------- DWORD[75] (Offset 0x12c) ----------------*/
	/* Description -  */
	/* 0x12c.0 - 0x12c.19 */
	 u_int32_t run_validity_test;
/*---------------- DWORD[76] (Offset 0x130) ----------------*/
	/* Description -  */
	/* 0x130.0 - 0x130.19 */
	 u_int32_t eye_centering_measure_time;
/*---------------- DWORD[77] (Offset 0x134) ----------------*/
	/* Description - sense time base time. 2^X*64n, when X is this value */
	/* 0x134.0 - 0x134.19 */
	 u_int32_t linear_hyb_scan_sense_time;
/*---------------- DWORD[78] (Offset 0x138) ----------------*/
	/* Description - sense time multiplier. sense_time = X*(sense time base time), when X is this value. */
	/* 0x138.0 - 0x138.9 */
	 u_int16_t linear_hyb_scan_sense_multiplier;
	/* Description - stabilization time. X*65u, when X is this value */
	/* 0x138.10 - 0x138.19 */
	 u_int16_t hyb_eye_stab_time_65_usec_multiplier;
/*---------------- DWORD[79] (Offset 0x13c) ----------------*/
	/* Description - minimum valid xor bath grade of a set. under it, run ones ratio bath when validity_test_enable=1 */
	/* 0x13c.0 - 0x13c.19 */
	 u_int32_t validity_min_grade;
/*---------------- DWORD[80] (Offset 0x140) ----------------*/
	/* Description - clkeo and clk00 delta for scanning from the top */
	/* 0x140.0 - 0x140.9 */
	 u_int16_t hyb_eye_scan_from_high_clk_delta;
	/* Description - clkeo and clk00 delta for scanning from the bottom */
	/* 0x140.10 - 0x140.19 */
	 u_int16_t hyb_eye_scan_from_low_clk_delta;
/*---------------- DWORD[81] (Offset 0x144) ----------------*/
	/* Description - maximum of ffe_taps absolute values sum - for link maintenance flow */
	/* 0x144.0 - 0x144.19 */
	 u_int32_t lm_max_allowed_rx_ffe_tap_sum;
/*---------------- DWORD[82] (Offset 0x148) ----------------*/
	/* Description - do phase_eye_opener_for_chosen_rx_set */
	/* 0x148.0 - 0x148.19 */
	 u_int32_t best_rx_set_phase_measuring_en;
/*---------------- DWORD[83] (Offset 0x14c) ----------------*/
	/* Description -  */
	/* 0x14c.0 - 0x14c.19 */
	 u_int32_t eye_opener_dz_factor;
/*---------------- DWORD[84] (Offset 0x150) ----------------*/
	/* Description - 524 micro-sec */
	/* 0x150.0 - 0x150.9 */
	 u_int16_t phase_eo_stab_time;
	/* Description - 2096 micro-sec */
	/* 0x150.10 - 0x150.19 */
	 u_int16_t phase_eo_stab_time_rs_fec;
/*---------------- DWORD[85] (Offset 0x154) ----------------*/
	/* Description -  */
	/* 0x154.0 - 0x168.31 */
	 struct connectx4lx_sd_params_rx_set rx_set_for_tx_tuning;
/*---------------- DWORD[90] (Offset 0x168) ----------------*/
	/* Description -  */
	/* 0x168.0 - 0x1cc.31 */
	 struct connectx4lx_sd_params_rx_set start_point_set[5];
/*---------------- DWORD[115] (Offset 0x1cc) ----------------*/
	/* Description -  */
	/* 0x1cc.0 - 0x280.31 */
	 struct connectx4lx_sd_params_rx_set start_point_set_copper[9];
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_pcie_phy_uc_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 union connectx4lx_pcie_subroutines_db subroutines;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.11 */
	 u_int16_t total_num_of_commands;
	/* Description -  */
	/* 0x20.12 - 0x20.23 */
	 u_int16_t commands_start_line_in_db;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x2c.31 */
	 struct connectx4lx_itoc_param part_type_phy_uc_commands;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_pcie_uc_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.19 */
	 u_int32_t last_tick_in_loop;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - nd phase eye opener wait time. wait time is (2^(wait) * 64ns) */
	/* 0x4.0 - 0x4.19 */
	 u_int32_t nd_eye_opener_wait_time;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_fw_image {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t itoc_ptr;
	/* Description -  */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t is_palladium;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x20.31 */
	 struct connectx4lx_jump_addresses jump_addresses;
};

/* Description -   */
/* Size in bytes - 192 */
struct connectx4lx_pcie_cfg_shomron {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t pcie_max_speed_supported;
	/* Description - [0]-x1\n[1]-x2\n[2]-x4\n[3]-x8\n[4]-x16
Note: This has no effect in Galil while the device is in PCIe Switch Mode. */
	/* 0x0.4 - 0x0.8 */
	 u_int8_t pcie_max_width_supported;
	/* Description - 0 - num of host are according to gpio strapping
1 - force 1 link
2- force 2 links
3- force 4 links */
	/* 0x0.9 - 0x0.11 */
	 u_int8_t force_num_of_hosts;
	/* Description - 0 - perst_ will cause reset iron main
1 - perst_ will be ignored in iron main
 all other values reserved */
	/* 0x0.12 - 0x0.13 */
	 u_int8_t perst_mapping_mode;
	/* Description - Enable up or down configuring the link width */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t upconfigure_capable;
	/* Description - Enable receiver detect as a condition to exit from Detect 
   Notice: Need to configure the receiver detect time */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t receiver_detect_en;
	/* Description - When using receiver detect WA this field define the delay to detect a receiver
   Notice: Using a value too high for a system will cause the PCIe not to link up */
	/* 0x0.20 - 0x0.29 */
	 u_int16_t receiver_detect_time;
	/* Description -  */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t handle_bar_miss_error_by_cr_handler_en;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t pcie_power_reduction_static_conf_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Reference clock indication 1-from connector 0-local oscilator */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t slot_clock_cfg;
	/* Description - if set, the FW will set the default TX taps values from speed change and on while still sending the right coefficients values toward the other side */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t force_gen3_tx_set;
	/* Description - tpt max_read_request_size = 
if 0==value - according to pci configuration space
if 1==value - forced to 128B
if 2==value - forced to 256B
if 3==value - forced to 512B
if 4==value - forced to 1024B
if 5==value - forced to 2048B
if 6==value - forced to 4096B */
	/* 0x4.4 - 0x4.6 */
	 u_int8_t force_tpt_max_read_size;
	/* Description - if set, signal detect in FW will be enabled and rx_power_mode will be set to 0 - affects disable enable L1 and polling compliance */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t signal_detect_en;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 struct connectx4lx_power_configuration power_configuration;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Shomron only. if set, slicer calibration will be performed */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t rx_calibration_en;
	/* Description - select which mixer will be used - 0/1 */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t rx_calibration_mixer_sel;
	/* Description - select which input buffer will be used - 0/1 */
	/* 0x8.2 - 0x8.2 */
	 u_int8_t rx_calibration_ib_sel;
	/* Description -  */
	/* 0x8.8 - 0x8.9 */
	 u_int8_t host0_refclk;
	/* Description -  */
	/* 0x8.10 - 0x8.11 */
	 u_int8_t host1_refclk;
	/* Description -  */
	/* 0x8.12 - 0x8.13 */
	 u_int8_t host2_refclk;
	/* Description -  */
	/* 0x8.14 - 0x8.15 */
	 u_int8_t host3_refclk;
	/* Description -  */
	/* 0x8.16 - 0x8.17 */
	 u_int8_t host0_refclk_2h_mode;
	/* Description -  */
	/* 0x8.18 - 0x8.19 */
	 u_int8_t host1_refclk_2h_mode;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.20 - 0x8.21 */
	 u_int8_t host0_perst;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.22 - 0x8.23 */
	 u_int8_t host1_perst;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.24 - 0x8.25 */
	 u_int8_t host2_perst;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.26 - 0x8.27 */
	 u_int8_t host3_perst;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.28 - 0x8.29 */
	 u_int8_t host0_perst_2h_mode;
	/* Description - holds the bit index in hw_perst_mask for this host */
	/* 0x8.30 - 0x8.31 */
	 u_int8_t host1_perst_2h_mode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - TX sets:
0-receiver detect
1-GEN1
2-GEN2 3.5db
3-GEN2 6db
4-GEN3 default set(backup) */
	/* 0xc.0 - 0x20.31 */
	 struct connectx4lx_pcie_tx_sets tx_sets;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - RX sets */
	/* 0x20.0 - 0x74.31 */
	 struct connectx4lx_pcie_rx_sets rx_sets;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description - wa for FB MH system TX coeffs */
	/* 0x74.0 - 0x7c.31 */
	 struct connectx4lx_eqlz_ph3_array_force_single_entry eqlz_ph3_array_force_single_entry;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description - gen1 tx ob_bias level. values 32-47 are illegal values. this ob_bias is also for receiver detect */
	/* 0x7c.0 - 0x7c.5 */
	 u_int8_t ob_bias_gen1;
	/* Description - gen2 tx ob_bias level. values 32-47 are illegal values */
	/* 0x7c.6 - 0x7c.11 */
	 u_int8_t ob_bias_gen2;
	/* Description - gen3 tx ob_bias level. values 32-47 are illegal values */
	/* 0x7c.12 - 0x7c.17 */
	 u_int8_t ob_bias_gen3;
	/* Description - If disable - TX rail will be 1.2 */
	/* 0x7c.18 - 0x7c.18 */
	 u_int8_t use_1_8_rail_on_tx;
	/* Description -  */
	/* 0x7c.19 - 0x7c.19 */
	 u_int8_t plls_varactors_static_config_gen3;
	/* Description -  */
	/* 0x7c.20 - 0x7c.21 */
	 u_int8_t calib_log_num_of_split;
	/* Description - enable RX defect check as debug flow */
	/* 0x7c.22 - 0x7c.22 */
	 u_int8_t pcie_rx_defect_check_en;
	/* Description - enable RX defect check as debug flow */
	/* 0x7c.23 - 0x7c.23 */
	 u_int8_t pcie_rx_defect_a2d_inv_meas;
	/* Description - modify leva and cml100 reg TX to solve EMI issue */
	/* 0x7c.24 - 0x7c.26 */
	 u_int8_t pcie_tx_config;
	/* Description - cml100_reg configuration - work on tx_config 3 */
	/* 0x7c.27 - 0x7c.31 */
	 u_int8_t pcie_cml100_reg;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description - ref_cml_100_leva1 configuration - work on tx_config 3 */
	/* 0x80.0 - 0x80.4 */
	 u_int8_t pcie_leva;
	/* Description - bit per host. in Galil, bits 0,2,4,6 are used.  */
	/* 0x80.5 - 0x80.12 */
	 u_int8_t polling_compliance_en;
	/* Description - tx_polarity ini :
Each bit set the polarity reversal on the equivilant tx lane */
	/* 0x80.16 - 0x80.31 */
	 u_int16_t pcie_tx_polarity;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x8c.31 */
	 struct connectx4lx_eqlz_ctrl eqlz_ctrl;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description -  */
	/* 0x8c.0 - 0x94.31 */
	 struct connectx4lx_eqlz_ctrl_gen4 eqlz_ctrl_gen4;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0x98.31 */
	 struct connectx4lx_gen4_spec_0_5 gen4_spec_0_5;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description -  */
	/* 0xa0.0 - 0xa4.31 */
	 struct connectx4lx_capi_ini capi;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description - gen4 tx ob_bias level. values 32-47 are illegal values */
	/* 0xb0.0 - 0xb0.5 */
	 u_int8_t ob_bias_gen4;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description - wa for FB MH system TX coeffs */
	/* 0xb4.0 - 0xbc.31 */
	 struct connectx4lx_eqlz_ph3_array_force_single_entry eqlz_ph3_array_force_single_entry_gen4;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description -  */
	/* 0xbc.0 - 0xbc.4 */
	 u_int8_t selgc_ref_cml100_leva;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_vpd_eeprom_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Size of VPD eeprom / flash */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t vpd_size;
	/* Description - Size of each one of the EEEPROM slaves of the VPD */
	/* 0x0.16 - 0x0.20 */
	 u_int8_t log2_vpd_eeprom_size;
	/* Description - Number of EEEPROM slaves of the VPD */
	/* 0x0.24 - 0x0.26 */
	 u_int8_t vpd_num_eeproms;
	/* Description - Set if VPD on eeprom, if on flash */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t vpd_eeprom;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_flex_nic_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Flex NIC mode: 0 - no Flex NIC, 1 - Einstein, 2 - Newton, Other - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t flex_nic_mode;
	/* Description - Index to I2C slaves DB */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t fpga_slv_indx;
	/* Description - Local CX port connected to FPGA */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t fpga_local_port;
	/* Description - if set FW will try loading failsafe image if user-image fail to load */
	/* 0x0.28 - 0x0.28 */
	 u_int8_t fpga_failsafe_en;
	/* Description - if set shutdown fpga on assertion of gpio70 */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t fpga_fatal_temp_shutdown_en;
	/* Description - 0 - read fpga link state from gpio, 1 - read fpga link state from i2c */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t read_link_from_i2c;
	/* Description - if set skip force-load during init_fpga flow if reset was fwreset */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t dont_force_load_after_fwreset;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Size of DDR in a granularity of 1KB */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t fpga_ddr_size;
};

/* Description -   */
/* Size in bytes - 112 */
struct connectx4lx_boards_management {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t compliance_codes_cable_stamping_disable;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t edr_cable_stamping_disable;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t edr20_cable_stamping_disable;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t fdr10_cable_stamping_disable;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t ib_nbl_cable_stamping_disable;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t eth_100g_cable_stamping_disable;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t eth25g_sfp_cable_stamping_disable;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t eth_mlx_phy_speeds_cable_stamping_disable;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t eth_nbl_cable_stamping_disable;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t lr4_40g_long_range_stamping_override;
	/* Description -  */
	/* 0x0.10 - 0x0.11 */
	 u_int8_t sw_health_init_val;
	/* Description - Input buffer oscillator.
0 - input buffer 0
1 - input buffer 1 */
	/* 0x0.12 - 0x0.13 */
	 u_int8_t osc_input_buffer;
	/* Description - thunder cable check */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t en_aoc_no_fec_report_override;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t lr4_100g_long_range_stamping_override;
	/* Description - if set-we will read the module temp */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t module_temp_report_en;
	/* Description - num of sfp module */
	/* 0x0.17 - 0x0.22 */
	 u_int8_t num_of_sfp_module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_jtag_ini jtag;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x14.31 */
	 struct connectx4lx_i2c_devices_smbus_slv_ix i2c_devices_smbus_slv_ix;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - MSPS register fields */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_power_supply_monitoring power_supply_monitoring;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x48.31 */
	 struct connectx4lx_enforce_pn_list_st enforce_pn_list;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - if set we have ability to confige rate sel via i2c */
	/* 0x48.0 - 0x48.0 */
	 u_int8_t rate_select_control_en;
	/* Description -  1- rate select always high, FW can not config diffrenet value */
	/* 0x48.1 - 0x48.1 */
	 u_int8_t rs_stick_high;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.24 - 0x58.23 */
	 char spare_part[13];
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.24 - 0x70.23 */
	 char product_id[25];
};

/* Description -   */
/* Size in bytes - 372 */
struct connectx4lx_ini_gpios {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xc8.31 */
	 struct connectx4lx_gpio_functions functions;
/*---------------- DWORD[50] (Offset 0xc8) ----------------*/
	/* Description -  */
	/* 0xc8.0 - 0x168.31 */
	 struct connectx4lx_gpio_conf_st configurations;
/*---------------- DWORD[90] (Offset 0x168) ----------------*/
	/* Description -   */
	/* 0x168.0 - 0x174.31 */
	 struct connectx4lx_yu_shift_register_init yu_shift_register_init;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_i2c_devices_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - List of all I2C/SMBUS devices */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_i2c_device_entry i2c_device[32];
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_module_database {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_module_data num[2];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_thermal_config_shomron {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0x4.23 */
	 struct connectx4lx_diode_st diode[4];
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - external sensors active, bit per sensor. bit0 = internal EMC1444 sensor
 bit1 = EMC1444 Q1 sensor
 bit2 = EMC1444 Q2 sensor
 bit3 = EMC1444 Q3 sensor
 */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t active_ext_sensors;
	/* Description -  */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t over_temp_warning_gpio_en;
	/* Description -  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t fw_shutdown_disable;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t over_temp_warning_threshold_hi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t over_temp_warning_threshold_low;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t sensor_slv_indx;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t ext_sensor_temp_warning_threshold_hi;
	/* Description -  */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t ext_sensor_temp_warning_threshold_lo;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_system_mng_shomron {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - If set network ports will be reveresed */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port_swap;
	/* Description - If set we won't close the cage power when enter to aux power */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t disable_close_cage_power_in_aux_mode;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_power {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - In case fuse_dvfs_force is set, contain the forced DVFS value for voltage scaling procedure */
	/* 0x0.28 - 0x0.30 */
	 u_int8_t fuse_dvfs;
	/* Description - if set, the DVFS is read from INI instead of reading from fuse */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t fuse_dvfs_force;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_iopl_power iopl_power;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_iopx_power iopx_power;
};

/* Description -   */
/* Size in bytes - 1792 */
struct connectx4lx_port_serdes {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - contains parameters that are board related.
for example: polarity, SD parameters */
	/* 0x0.0 - 0x180.31 */
	 struct connectx4lx_phy_hw_main_config_ip phy_hw_main_config_ip;
/*---------------- DWORD[372] (Offset 0x5d0) ----------------*/
	/* Description -  */
	/* 0x5d0.0 - 0x610.31 */
	 struct connectx4lx_logic_serdes_mapping_node_ini logic_serdes_mapping_node_ini;
/*---------------- DWORD[389] (Offset 0x614) ----------------*/
	/* Description -  */
	/* 0x614.0 - 0x638.31 */
	 struct connectx4lx_pll_params pll_params;
/*---------------- DWORD[398] (Offset 0x638) ----------------*/
	/* Description -  */
	/* 0x638.0 - 0x658.31 */
	 struct connectx4lx_port_mlpn_db mlpn_port[2];
};

/* Description -  format of non volatile configuration loaded from flash for pre plastic flows */
/* Size in bytes - 64 */
struct connectx4lx_nv_config_boot {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_nv_config_boot_global global;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x38.31 */
	 struct connectx4lx_nv_config_boot_port_settings port[2];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_pcie_power_management {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - both for gen12 adn for gen3 */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t delay_in_recovery_lock;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t pcie_l1_en;
	/* Description - Allow_icmc_transpose when enter/exit standby mode */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t close_icmc_on_standby;
	/* Description - shomron or newer only
Allows us to enter L1 while in gen1 or gen2
disabled by default in shomron
see RM 587894 */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t l1_on_gen1_gen2_en;
};

/* Description -  ini values for PCI configuration space */
/* Size in bytes - 64 */
struct connectx4lx_pci_cfg_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x3c.31 */
	 struct connectx4lx_pci_cfg_space_ini pci_cfg_space;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_pcie_transaction {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Max number of pending outbound read requests */
	/* 0x0.0 - 0x0.8 */
	 u_int16_t global_read_task_limit;
	/* Description - Function Level Reset Capability enable */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t function_level_reset_capability;
	/* Description - If and only if set, upon sending Completion with UR status, due to incoming Cfg Type 1 Request, 
will be reported (by FW) as AER advisory-non-fatal (anf) error  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t aer_anf_by_cfg_type_1_en;
	/* Description - If and only if set, upon sending Completion with UR status, due to bad function number in incoming Cfg Request, 
will be reported (by FW) as AER advisory-non-fatal (anf) error  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t aer_anf_by_bad_func_en;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t advisory_non_fatal_en;
	/* Description - advanced error reporting enable */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t aer_cap_en;
	/* Description - Alternatove Rounting-ID capability enable  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t ari_cap_en;
	/* Description - SR-IOV capability enable  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t sriov_cap_en;
	/* Description - VPD  capability enable  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t vpd_cap_en;
	/* Description - enable crspace access via conf space register 22 and 23 */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t pci_crspace_access_en;
	/* Description - MLNX PCI VSEC   capability enable  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t pci_vsec_cap_en;
	/* Description - MLNX PCIE VSEC  - for future use */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t pcie_vsec_cap_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - configuration read/write logger */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_logger_init_info logger_init_info;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_multi_function {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - vport0 will be associate with this host(today port_pf_gvmi) */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t vport0_hix;
	/* Description - multi host will be lid based */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t lid_based;
	/* Description - num of hosts */
	/* 0x0.5 - 0x0.7 */
	 u_int8_t num_hosts;
	/* Description - num of ports */
	/* 0x0.8 - 0x0.10 */
	 u_int8_t num_of_ports;
	/* Description - num of msix vectors per pf */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t pf_msix_table_size;
	/* Description - num of msix vectors per vf */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t vf_msix_table_size;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - mapping from pci HIX to customer host number */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_mh_host_mapping mh_host_mapping;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - UAR Bar width - 0x0=32bit , 0x1=64bit */
	/* 0x8.6 - 0x8.6 */
	 u_int8_t pf_bar_type;
	/* Description - VF Bar width - 0x0=32bit , 0x1=64bit */
	/* 0x8.14 - 0x8.14 */
	 u_int8_t vf_minibar_type;
	/* Description - VF Bar prefetchable property */
	/* 0x8.15 - 0x8.15 */
	 u_int8_t vf_minibar_prefetchable;
	/* Description - function number that requests and enables crspace bar */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t cr_bar_func;
	/* Description - CR Bar width - 0x0=32bit , 0x1=64bit */
	/* 0x8.20 - 0x8.20 */
	 u_int8_t cr_bar_type;
	/* Description - request and enable crspace bar */
	/* 0x8.21 - 0x8.21 */
	 u_int8_t cr_bar_en;
	/* Description - enable/disable the credits blockage fsm */
	/* 0x8.22 - 0x8.22 */
	 u_int8_t credits_blockage_fsm_en;
	/* Description -  */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t log_max_num_of_eqs;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_secure_fw {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - extended capabilities that block write access to flash, crspace... */
	/* 0x4.0 - 0x8.31 */
	 union connectx4lx_fw_block_behavior fw_block_behavior;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_exprom_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t data[64];
};

/* Description -  format of non volatile configuration loaded from flash */
/* Size in bytes - 768 */
struct connectx4lx_nv_config_main {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_nv_config_main_fw_data fw_config;
};

/* Description -   */
/* Size in bytes - 720 */
struct connectx4lx_phy_fw_main_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_phy_fw_main_config_shomron phy_shomron;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description - contains parameters that are FW flows related. 
for example: MLPN bits. speed, width capabilities .. */
	/* 0x100.0 - 0x280.31 */
	 struct connectx4lx_phy_fw_main_config_ip phy_ip;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x2a0.31 */
	 struct connectx4lx_serdes_fw_main_config_prj serdes_prj;
/*---------------- DWORD[168] (Offset 0x2a0) ----------------*/
	/* Description -  */
	/* 0x2a0.0 - 0x2c0.31 */
	 struct connectx4lx_serdes_fw_main_config_ip serdes_ip;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_host_management {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_ncsi_ini ncsi_ini;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x24.31 */
	 struct connectx4lx_ocsd_config ocsd_config;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x40.31 */
	 struct connectx4lx_ibm_thermal_config ibm_thermal_config;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - reset on lan enable for port0 all hosts */
	/* 0x40.0 - 0x40.0 */
	 u_int8_t rol_en_port0;
	/* Description - reset on lan enable for port1 all hosts */
	/* 0x40.1 - 0x40.1 */
	 u_int8_t rol_en_port1;
	/* Description - verification is enabled on leopard server */
	/* 0x40.2 - 0x40.2 */
	 u_int8_t verification_leop;
	/* Description - if set an empty management address tlv with 0 mac will be created */
	/* 0x40.7 - 0x40.7 */
	 u_int8_t lldp_mngmt_addr_en;
	/* Description - enumerator for predefined system description strings */
	/* 0x40.8 - 0x40.15 */
	 u_int8_t lldp_system_pred;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x4c.31 */
	 struct connectx4lx_mctp_ini mctp_ini;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - wake on lan capability */
	/* 0x4c.0 - 0x50.31 */
	 struct connectx4lx_wol_cap_host_port wol_cap;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x5c.31 */
	 struct connectx4lx_pldm_ini pldm_ini;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description - secure_wol_password, 0 if disabled */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t secure_wol_password;
};

/* Description -   */
/* Size in bytes - 384 */
struct connectx4lx_management {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_node_info_ini node_info;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x5c.31 */
	 struct connectx4lx_ib_port_info_ini port_info;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x6c.31 */
	 struct connectx4lx_expander_ini expander_ini;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x74.31 */
	 struct connectx4lx_ovonel_ini ovonel_ini;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0xc0.0 */
	 u_int8_t eeprom_read_disable_p1;
	/* Description -  */
	/* 0xc0.1 - 0xc0.1 */
	 u_int8_t eeprom_read_disable_p2;
	/* Description - override fw cable stamping */
	/* 0xc0.2 - 0xc0.2 */
	 u_int8_t fw_stamping_override;
	/* Description - override read supported cable speed */
	/* 0xc0.3 - 0xc0.3 */
	 u_int8_t cable_speed_override;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc8.31 */
	 struct connectx4lx_extended_port_info_ini extended_port_info;
/*---------------- DWORD[50] (Offset 0xc8) ----------------*/
	/* Description - valid i2c address for cable info mad */
	/* 0xc8.24 - 0xcc.23 */
	 u_int8_t valid_i2c_address[4];
/*---------------- DWORD[52] (Offset 0xd0) ----------------*/
	/* Description -  */
	/* 0xd0.0 - 0xf0.31 */
	 struct connectx4lx_apollo_ini apollo_ini;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x104.31 */
	 struct connectx4lx_fw_vport0_ini fw_vport0;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description -  */
	/* 0x104.0 - 0x108.31 */
	 u_int32_t power_consumption;
/*---------------- DWORD[66] (Offset 0x108) ----------------*/
	/* Description -  */
	/* 0x108.0 - 0x108.0 */
	 u_int8_t disable_power_mng;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_customization {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - the module rx amp range in port1 will be configured according to active_amp_range value */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t active_amp_range_p1;
	/* Description - the module rx amp range in port2 will be configured according to active_amp_range value */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t active_amp_range_p2;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_leds {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Indicates whether the ports leds are bicolor - meaning each port has one led, functiong as green and yellow leds, only one can be ON  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port_leds_gt_mode;
	/* Description - Indicates if the board supports high/low speed LED  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t leds_high_low_speed_support;
	/* Description - Indicates if the high/low speed LED implement by mux and than we use LED control signal  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t led_control_supported_by_mux;
	/* Description - Indicates if the switch support beacon command for uid and local port  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t cap_local_or_uid_only;
	/* Description - Indicates if a back_plane module support LEDs indications */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t port_leds_bplane_support_leds;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4c.31 */
	 struct connectx4lx_leds_patterns leds_patterns;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x4c.15 */
	 struct connectx4lx_port_leds_offsets port_leds_offsets;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_static_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t dwrr_en;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t ifarm_en;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t xrc_use_ib_spec_opcode;
	/* Description - If set madifc will be accepted on all PFs even if not host 0 */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t allowed_madifc_on_all_pfs;
	/* Description - flip flop data protection enable
if error is detected -
ib + pci serdes will give dc stable (i.e all 0's) */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t ffser_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - mask of iriscs that participate in prio group X in dispatcher */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t prio_g_0_ix_mask_no_ifarm;
	/* Description - mask of iriscs that participate in prio group X in dispatcher */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t prio_g_1_ix_mask_no_ifarm;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t gvmi_rl_custom_tokens_mantissa;
	/* Description -  */
	/* 0x8.16 - 0x8.19 */
	 u_int8_t gvmi_rl_custom_tokens_exponent;
	/* Description - 0x0 - no rate limiter, 0x1 - GVMI_RL_10GBPS, 0x2 - GVMI_RL_12_5_GBPS, 0x3 - GVMI_RL_CUSTOM_TOK, 0x4 - QP_RATE_LIMITER, 0x5 - GVMI_RL_25_GBPS, 0x6 - GVMI_RL_50_GBPS, 0x7 - FW_VQOS_MODE */
	/* 0x8.20 - 0x8.22 */
	 u_int8_t gvmi_rl_mode;
	/* Description - when set managment mac address will be base mac address plus 2 (active only when  single port single host single pf per port devices) */
	/* 0x8.28 - 0x8.28 */
	 u_int8_t ocp_bmc_mac_plus_two;
	/* Description - default flow control configuration, bit per port. 0x0 - no pause, 0x1 - global pause on port 1, 0x2 - global pause on port 2, 0x3 - global pause on port 1 and 2 */
	/* 0x8.29 - 0x8.30 */
	 u_int8_t global_pause_en;
	/* Description - allow flash 64kByte sector erase */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t allow_flash_64k_erase;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_guids {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - UIDs (MACs and GUIDs) Allocation Entry.
guids, is used for system GUID, node GUID and port GUID of port 0. ;/Multiple UIDs can be assigned to a single port, to be used for multiple virtual guests, multi host and managment */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_uid_entry guids;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_uid_entry macs;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_module_versions {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_module_version core;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_module_version phy;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 struct connectx4lx_module_version kernel;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 struct connectx4lx_module_version iron_image;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 struct connectx4lx_module_version host_management;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_module_version mad;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_image_size {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - log of next address in bytes to search for an image. Address in bytes is 2^log_step */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t log_step;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Max possible size in bytes of image. Image read / write should not occure beyond this address */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t max_size;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_TRIPPLE_VERSION {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t MAJOR;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t SUBMINOR;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t MINOR;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_operation_key {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t key_modifier;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t key;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_toc_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t address;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t size;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_rst_api_ver {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_reset_level_info reset[8];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_reset_capabilities {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Initial capability for reset level */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t reset_ver_en;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_get_gvmi_rl_ctx_ix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t real_gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t vl;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi_rl_ctx_ix;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t gvmi_tag;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_sysport {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Packet properties */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_sysport_packet_properties pkt_prop;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Packet length in bytes */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t pkt_length;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Packet data */
	/* 0x24.0 - 0x300.31 */
	 struct connectx4lx_sysport_packet_data pkt_data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_drop_counter_read {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t sq_num_to;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_rw_gvmi_fw_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_rw_gvmi_fw_ctx_sub_structs sub_structs;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - DCR_ODP_EVENT = 0x1,
 */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t node_type;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t ix;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_mh_sync {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - input mailbox: state of sync: IDLE, GET_READY, GO */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t input_state;
	/* Description - input mailbox: sync_type - 0x01 = FW_RESET */
	/* 0x0.8 - 0x0.15 */
	 u_int8_t input_sync_type;
	/* Description - input mailbox: when set - ignore inactive hosts */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t input_ignore_inactive_hosts;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - output mailbox: state of sync: IDLE, GET_READY, GO */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t fsm_state;
	/* Description - output mailbox: sync_type - 0x01 = FW_RESET */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t fsm_sync_type;
	/* Description - output mailbox: when set - ignore inactive hosts */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t fsm_ignore_inactive_hosts;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - output mailbox: bit per host - indicates hosts already issued GET_READY */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t fsm_host_ready;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - output mailbox: NIC uptime since last reset in microsecondes at the moment of first GET_READY */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t fsm_start_uptime;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_asn1_force_port_state {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port0_1;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t force_enable_disable;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t state_enable_disable;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_port_admin_state_mng {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - icmd get, 1 - icmd set */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t set_get_;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t portid;
	/* Description - 0 - ignore this mgmt, 1 - set this mgmt. bit 0  - mgmt admin, bit 1 - mgmt ASN.1 */
	/* 0x0.4 - 0x0.5 */
	 u_int8_t mgmt_update_mask;
	/* Description - mgmt values to set. bit 0  - mgmt admin, bit 1 - mgmt ASN.1 */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t mgmt_update_data;
	/* Description - 0 - ignore this klu, 1 - set this klu. bit 0  - KLU Eth, bit 1 - KLU IB, bit 2 - KLU on boot, bit 3 - KLU on standby */
	/* 0x0.12 - 0x0.15 */
	 u_int8_t klu_update_mask;
	/* Description - KLU values to set. bit 0  - KLU Eth, bit 1 - KLU IB, bit 2 - KLU on boot, bit 3 - KLU on standby */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t klu_update_data;
	/* Description - KLU current state. */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t klu_state;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0 - ignore reneg on chage on set, 1 - set reneg on change on set */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t reneg_on_change_set_mask;
	/* Description - 0 - ignore reneg on chage on set, 1 - set reneg on change on set */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t reneg_on_change_set_data;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - gvmi to set_reneg_on_change */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t reneg_on_change_set_gvmi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Renegotiate only on config change (PF array, pf_ix = (host_ix)*max_num_pfs_per_host_ini_value + func_num).                                                                                                                        on set, will set reneg_on_change[0] go reneg on change gvmi */
	/* 0xc.0 - 0x14.31 */
	 struct connectx4lx_pf_array_default_ones reneg_on_change;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - on set - invalid. on get - drivers mask [0-63] per pf */
	/* 0x14.0 - 0x1c.31 */
	 struct connectx4lx_drivers_mask_arr drivers_mask;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - Disable union.
If one bit is set to 1, do not open             the port. */
	/* 0x1c.0 - 0x20.31 */
	 union connectx4lx_disable_mask disable_mask;
};

/* Description -   */
/* Size in bytes - 100 */
struct connectx4lx_icmd_get_packet_pacing_debug_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description - packet pacing rate limit index */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t rate_limit_index;
	/* Description - indicate if rate limit exist for the given index */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rate_limit_active;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - rate in 10^3 bits per second */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rate_kbits;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t burst_upper_bound_bytes;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - burst size that is configured in the schedQ */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t burst_bytes;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t log2qp_rate_limiter_time;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x64.31 */
	 u_int32_t sq_index[20];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_map_event_eq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t set_get_;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t map_unmap_;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t eqn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t event_bitmask;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_internal_query_cap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t opcode;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t opcode_exists_out;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - gvmi to detect */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - gvmi detected in QPC */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t qpi;
	/* Description - gvmi detected in QPC */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t qpc_detection_valid;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - gvmi detected in ICMC */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t icmc_detection_valid;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t va_63_32;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t va_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_temp_warn_gen_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit vector indicating which of the sensor reading is above threshold. Address 00h bit31 is sensor_warning[127] Address 0Ch bit0 is sensor_warning[0] */
	/* 0x0.0 - 0x10.31 */
	 u_int32_t sensors_arr[4];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_cable_error_gen_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port_0_1;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t module;
	/* Description -  */
	/* 0x0.2 - 0x0.5 */
	 u_int8_t module_status;
	/* Description -  */
	/* 0x0.6 - 0x0.9 */
	 u_int8_t error_type;
};

/* Description -   */
/* Size in bytes - 272 */
struct connectx4lx_icmd_mctp_vnd_pci_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_id;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t operation;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t packet_length;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x110.31 */
	 union connectx4lx_icmd_mctp_vnd_pci_debug_data data;
};

/* Description -   */
/* Size in bytes - 144 */
struct connectx4lx_icmd_lldp_set_get_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - input */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_id;
	/* Description - input */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t tx_rx_;
	/* Description - input */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t rw_;
	/* Description - input, for write only: 0-erase, 1-replace, 2-add */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t operation;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - output, with LLDP headers */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t tlv_length;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - input */
	/* 0x8.0 - 0x10.31 */
	 union connectx4lx_lldp_tlv_extended_type tlv_full_type;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x90.31 */
	 union connectx4lx_tlv_data tlv_data;
};

/* Description -   */
/* Size in bytes - 288 */
struct connectx4lx_icmd_lldp_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - input */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_id;
	/* Description - input */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t tx_rx_;
	/* Description - input, 0 - print packet, 3 - rebuild default tx packet (reloads NV config), 4 - read packet */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t operation;
	/* Description - for read packet operation. fragment index. each fragment is 256 bytes */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t frag_ix;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - output */
	/* 0x8.0 - 0x8.1 */
	 u_int8_t enabled;
	/* Description - output, ttl for rx, next send for tx */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t ttl_next_send;
	/* Description - output */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t packet_length;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - output, for read packet operation. copy size in this fragment */
	/* 0xc.0 - 0xc.9 */
	 u_int16_t copy_length;
	/* Description - output, counter that advances every time LLDP packet is updated. Can be used to verify packet was not changed between fragments */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t pkt_seq_num;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - output */
	/* 0x20.0 - 0x120.31 */
	 u_int32_t buffer[64];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_access_register_nodnic_queue_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t nodnic_idx;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t send0_qpi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t send1_qpi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rcv0_qpi;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rcv1_qpi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t cqi;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t eqi;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t drop_qpi;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - if query failed syndrome will be here */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t status;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_set_get_debug_pf_mac {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t port_id;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t host_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t mac_high;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t mac_low;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t pf_idx_in_host_port;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_ocbb_set_event {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t event_data_hi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t event_data_lo;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t event_number;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t event_length;
	/* Description -  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t data_length;
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t data_start_offset;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_ocbb_query_header_stats_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Status of the OCBB header
0: ready
1: busy
2: failed - not enough buffer space
3: failed - maximal instance cards reached
Other values are reserved for future failure conditions. */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t status;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_ocbb_query_etoc_stats_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Status of the OCBB ETOC
0: ready
1: busy
Other values are reserved for future failure conditions. */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t status;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_ocbb_init_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - MSB of OCBB buffer address. */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t address_hi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - LSB of OCBB buffer address. */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t address_lo;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_set_wol_rol_in {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Bitmask field indicates which Wake on LAN modes to be enabled/disabled (valid 
when wol_mode_valid == 1).
The support for each mode is indicated by a field in 
"
ICMD_QUERY_CAPA
BILITY - Get ICMD Interface Capabilities
"
.
Bit 1: wake_on_secured_magic_packet - Supported only when 
ICMD
_
CAP.wol_s==1.
Bit 2: wake_on_magic_packet - Supported only when ICMD_CAP.wol_g==1.
Bit 3: wake_on_ARP - Supported only when ICMD_CAP.wol_a==1.
Bit 4: wake_on_broadcast_packet - Supported only when ICMD_
CAP.wol_b==1.
Bit 5: wake_on_multicast_packet - Supported only when ICMD_
CAP.wol_m==1.
Bit 6: wake_on_unicast_packet - Supported only when ICMD_CAP.wol_u==1.
Bit 7: wake_on_phy_activity - Supported only when ICMDCAP.wol_p==1. */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t wol_mode;
	/* Description - Bitmask field indicates which Reset on LAN modes to be enabled/disabled.(valid 
when rol_mode_valid ==1).
The support for each mode is indicated by a field in 
"
ICMD_QUERY_CAPA
BILITY - Get ICMD Interface Capabilities
"
.
Bit 0: reset
_
on
_
magic
_
packet
 
-
 Supported only when rol_g==1.
Bit 1: reset
_
on
_
secured
_
magic
_
packet
 
-
 Supported only when rol_s==1. */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t rol_mode;
	/* Description - Set to 0x1 to modify 
wol_mode
. */
	/* 0x8.30 - 0x8.30 */
	 u_int8_t wol_mode_valid;
	/* Description - Set to 0x1 to modify 
rol_mode
. */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t rol_mode_valid;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_set_wol_rol_out {
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Bitmask field indicates which Wake on LAN modes to be enabled/disabled (valid 
when wol_mode_valid == 1).
The support for each mode is indicated by a field in 
"
ICMD_QUERY_CAPA
BILITY - Get ICMD Interface Capabilities
"
.
Bit 1: wake_on_secured_magic_packet - Supported only when ICMD_
CAP.wol_s==1.
Bit 2: wake_on_magic_packet - Supported only when ICMD_CAP.wol_g==1.
Bit 3: wake_on_ARP - Supported only when ICMD_CAP.wol_a==1.
Bit 4: wake_on_broadcast_packet - Supported only when ICMD_
CAP.wol_b==1.
Bit 5: wake_on_multicast_packet - Supported only when ICMD_
CAP.wol_m==1.
Bit 6: wake_on_unicast_packet - Supported only when ICMD_CAP.wol_u==1.
Bit 7: wake_on_phy_activity - Supported only when ICMDCAP.wol_p==1. */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t wol_mode;
	/* Description - Bitmask field indicates which Reset on LAN modes to be enabled/disabled (valid 
when rol_mode_valid ==1).
The support for each mode is indicated by a field in 
"
ICMD_QUERY_CAPA
BILITY - Get ICMD Interface Capabilities
"
.
Bit 0: reset
_
on
_
magic
_
packet
 
-
 Supported only when rol_g==1.
Bit 1: reset
_
on
_
secured
_
magic
_
packet
 
-
 Supported only when rol_s==1. */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t rol_mode;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_set_virtual_mac_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - During standby mode (if supported), the device restores the Factory defined 
MAC.
When 
mac_aux_v
 is set, that will happen even if auxiliary power is supplied. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t mac_aux_v;
	/* Description - When set, a virtual MAC is set to replace the Factory defined MAC address */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t virtual_mac_en;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Virtual MAC address currently configured to override the 
permanent_mac
. Valid 
if 
virtual_mac_en
 is set. */
	/* 0xc.0 - 0x14.31 */
	 struct connectx4lx_mac_address_layout virtual_mac;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_query_virtual_mac_out {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - During standby mode (if supported), the device restores the Factory defined 
MAC.
When 
mac_aux_v
 is set, that will happen even if auxiliary power is supplied. */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t mac_aux_v;
	/* Description - When set, a virtual MAC was set to replace the Factory defined MAC address */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t virtual_mac_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Factory defined MAC address for this PF. */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_mac_address_layout permanent_mac;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Virtual MAC address currently configured to override the 
permanent_mac
. Valid 
if 
virtual_mac_en
 is set. */
	/* 0xc.0 - 0x14.31 */
	 struct connectx4lx_mac_address_layout virtual_mac;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_get_pf_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t portid;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t vport_num;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t pf_gvmi;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_vport_shadow vport_shadow;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_vport_info vport_info;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_ocbb_get_pci_api {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - function index. for fpp, this is port index */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t func_index;
	/* Description - host */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t host;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x30.31 */
	 struct connectx4lx_ocbb_pci_data output_data;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_read_ncsi_rdma_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_lled_get_rdma_stat_resp rdma_stat_rep;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x50.7 */
	 u_int8_t hix;
	/* Description -  */
	/* 0x50.16 - 0x50.31 */
	 u_int16_t partition_id;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_ocbb_rndc_get_core_api {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_ocbb_fields output_data;
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description - port_0_1 */
	/* 0x200.0 - 0x200.7 */
	 u_int8_t portid;
	/* Description -  */
	/* 0x200.16 - 0x200.31 */
	 u_int16_t host_ix;
};

/* Description -   */
/* Size in bytes - 60 */
struct connectx4lx_icmd_pre_define_module_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t module;
	/* Description - CABLE_TYPE_INPUT_DATA = 0x0,CABLE_TYPE_COPPER = 0x1,CABLE_TYPE_OPTIC_THUNDER = 0x2 */
	/* 0x0.8 - 0x0.10 */
	 u_int8_t cable_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x3c.31 */
	 struct connectx4lx_module_db_pre_define_st module_database;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_icmd_pmlp_query {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - unmap local port
1 - x1 (lane 0 is used)
2 - x2 (lanes 0,1 are used)
4 - x4 (lanes 0,1,2 and 3 are used)
Other - reserved */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t width;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t local_port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t module0;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to   a local port. */
	/* 0x4.16 - 0x4.17 */
	 u_int8_t lane0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t module1;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to   a local port. */
	/* 0x8.16 - 0x8.17 */
	 u_int8_t lane1;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t module2;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to   a local port. */
	/* 0xc.16 - 0xc.17 */
	 u_int8_t lane2;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t module3;
	/* Description - Lane - up to 4 serdeses in a module can be mapped to   a local port. */
	/* 0x10.16 - 0x10.17 */
	 u_int8_t lane3;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_get_fw_driver_version {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_fw_driver_version fw_driver_version;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - if set, icmd gets the function from hix and func_num */
	/* 0x40.0 - 0x40.0 */
	 u_int8_t use_hix_func_num;
	/* Description -  */
	/* 0x40.16 - 0x40.31 */
	 u_int16_t gvmi;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x44.7 */
	 u_int8_t func_num;
	/* Description -  */
	/* 0x44.8 - 0x44.15 */
	 u_int8_t host_ix;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_set_oc_int {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - module 0 or 1 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t module;
	/* Description - if bit is 1, bad cable flow refers as oc_int gpio is down */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t force_gpio_down;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_gen_assert {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - assert value */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t value;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - assert type, FW enum */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t type;
};

/* Description -   */
/* Size in bytes - 68 */
struct connectx4lx_icmd_read_write_varb_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read = 1 , write = 0 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rw_;
	/* Description - arbiter index [0-2047] */
	/* 0x0.1 - 0x0.12 */
	 u_int16_t arb_id;
	/* Description - gvmi index */
	/* 0x0.13 - 0x0.24 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x24.31 */
	 struct connectx4lx_vqos_arb_ctx data;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x44.31 */
	 struct connectx4lx_vqos_arb_ctx mask;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_debug_calc_sqn {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t port_0_1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t vl;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t sl;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t pp;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t req_res_;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t is_fw_sq;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t sqn;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - use iterator = 0 / calc_sq_iterator */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t calc_sqn_iterator_;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - total iterator iterations */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t iterations;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - iterator skip_vl15 */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t skip_vl_15;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - iterator return sqs even if sl2vl_mismatch */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t include_sl2vl_mismatch;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - iterator will return only iterations are greater then the given number */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t iterator_lowest_iter;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x300.31 */
	 struct connectx4lx_iterator_result iterator_res[89];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_mini_flow_activator {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0=flicks_enable_disable; 1=steering_flush_cache; 2=invalidate_qp_l0_cache; 3=invalidate_dct_l0_caches; 4=invalidate_rxw_l2_cache; 5=invalidate_dirty_rxc_cache_start; 6=invalidate_dirty_sxd_cache_start; 7=update_gvmis_steering_bypasses; 8=invalidate_dirty_ldb_cache_start */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t freq;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_general_fault_injector {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0=no_free_pages; 1=no_pages_for_resource; 2=lock_eq_gw; 3=lock_cqe_gw; 4=rx_fence_type; 5=sx_fence_type; 6=rxt_slices_fence_type; 7=sxd_ec_slices_fence_type; 8=general_fence_type; */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_general_fault_injector_pair config;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - smbus gw. relevant only for type 0x9. */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t param;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_icmd_access_register_pvlc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_pvlc_reg pvlc;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_parse_icm_address {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t addr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t res_type;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t res_num;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_get_steering_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t gvmi_active;
	/* Description -  */
	/* 0x4.2 - 0x4.2 */
	 u_int8_t fpp_enable;
	/* Description -  */
	/* 0x4.3 - 0x4.3 */
	 u_int8_t sriov_enable;
	/* Description -  */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t portid;
	/* Description -  */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t ib_eth_;
	/* Description -  */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t roce_en;
	/* Description -  */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t gvmi_steering_enabled;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t pf_gvmi;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t port_pf_gvmi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t vport_num;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t allowed_uc_list_size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.1 */
	 u_int8_t nic_state;
	/* Description -  */
	/* 0x10.2 - 0x10.3 */
	 u_int8_t esw_state;
	/* Description -  */
	/* 0x10.4 - 0x10.4 */
	 u_int8_t connected_2_steering;
	/* Description -  */
	/* 0x10.8 - 0x10.11 */
	 u_int8_t num_of_hosts;
	/* Description -  */
	/* 0x10.12 - 0x10.15 */
	 u_int8_t num_pfs;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t total_vfs;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 struct connectx4lx_dmfs_ft_type_info esw_egress_info;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 struct connectx4lx_dmfs_ft_type_info esw_ingress_info;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x40.31 */
	 struct connectx4lx_dmfs_data dmfs_data;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_dmfs_gvmi_ctx dmfs_gvmi_ctx;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_read_ste {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_ste data;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t index;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x44.15 */
	 u_int16_t gvmi;
	/* Description - is ste locked in icmc, if so gvmi is reserved */
	/* 0x44.31 - 0x44.31 */
	 u_int8_t locked_in_icmc;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_icmd_get_ste_resources_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ste_resources_list_in in;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_get_ste_resources_list_out out;
};

/* Description -   */
/* Size in bytes - 768 */
union connectx4lx_icmd_get_ste_open_resources {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ste_open_resources_in in;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_get_ste_open_resources_out out;
};

/* Description -   */
/* Size in bytes - 768 */
union connectx4lx_icmd_get_fte {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fte_in in;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_get_fte_out out;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_icmd_get_fte_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fte_list_in in;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fte_list_out out;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_icmd_get_fg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fg_in in;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_get_fg_out out;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_icmd_get_fg_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fg_list_in in;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_fg_list_out out;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_icmd_get_ft_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ft_info_in in;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ft_info_out out;
};

/* Description -   */
/* Size in bytes - 16 */
union connectx4lx_icmd_get_ft_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ft_list_in in;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_ft_list_out out;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_icmd_led_control_mad {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 = GET, 2 = SET */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t method;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - attribute_modifier - choose gourp of leds */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t attribute_mod;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x48.31 */
	 struct connectx4lx_led_control_data data;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_led_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t index;
	/* Description - type: 0=phy; 1=traffic; 2=pci; 3=uid; 4=bad_port; */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t led_type;
	/* Description - pattern; */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t pattern;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Read/Write pattern (for write Enable should be ON = 1) */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t rw;
	/* Description - Enable bit. 
 to reset LED control need to send write(rw=0) with en = 0 */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t en;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_icmd_set_get_port_cntr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t data;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t port_0_1;
	/* Description -  */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t set_get_;
	/* Description - ConnectX4 max_ix=276 ; ConnectIB max_ix=182 */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t cntr_ix;
};

/* Description -   */
/* Size in bytes - 268 */
struct connectx4lx_icmd_access_register_ppcnt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x104.31 */
	 struct connectx4lx_ppcnt_reg ppcnt;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_activate_pll {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster number */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t cl;
	/* Description - pll id */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t pll;
	/* Description - pll id */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t on_off_;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_measure_frequency {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster number */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t cl;
	/* Description - pll id */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t pll;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - measured divider quotient */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t measured_div_quotient;
	/* Description - measured divider fraction */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t measured_div_fraction;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_restore_phy_registers {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t local_port;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_phy_design_ver_if {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t force_tx_for_10g_40g;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t radius_update_xor_ones;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t xor_to_space_step2;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t rx_adaptation_9_start_points;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t phase_centering_rs_fec;
	/* Description -  */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t width_stamping_on_split_port;
	/* Description -  */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t phase_eo_restricted_to_pd;
	/* Description -  */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t fdr_tx_non_equlization_set;
	/* Description -  */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t fix_tx_set_for_active_cable;
	/* Description -  */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t mlpn_phase_eo_during_kr;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t fast_flip_flop_mode_in_pll;
	/* Description -  */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t enable_1gb_for_all_cables;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t parallel_detect_starting_points_0xa;
	/* Description -  */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t support_pmcr_restore;
	/* Description -  */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t PPCNT_statistical_counters_group;
	/* Description -  */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t profile_medium_enable;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t sel_slicer_lctrl_support;
	/* Description -  */
	/* 0x0.17 - 0x0.17 */
	 u_int8_t swap_input_buffer_capability;
	/* Description -  */
	/* 0x0.18 - 0x0.18 */
	 u_int8_t phy_test_mode_50g_kr4_support;
	/* Description -  */
	/* 0x0.19 - 0x0.19 */
	 u_int8_t edr_no_fec_sr;
	/* Description -  */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t sh_errors_are_read_from_ber_count;
	/* Description -  */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t link_maintenance_support;
	/* Description -  */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t rx_starting_points_shift;
	/* Description -  */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t rx_tx_power_reduced_activation;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_run_hyb_eye_opener {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster number */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t cl;
	/* Description - port number (0/1) */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t clp;
	/* Description - phy lane number (0-3) */
	/* 0x0.10 - 0x0.11 */
	 u_int8_t phy_lane;
	/* Description - sense time multiplier. sense_time=X*(sense time base), when X is this value. */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t sense_time_mult;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - sense time base time. 2^X*64n, when X is this value */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t sense_time_base;
	/* Description - stabilization time. X*65u, when X is this value */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t stab_time_mult;
	/* Description - clkeo and clk00 delta for scanning from the top */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t scan_from_high_delta;
	/* Description - clkeo and clk00 delta for scanning from the bottom */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t scan_from_low_delta;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Return: eye's highest value */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t eye_low;
	/* Description - Return: eye's lowest value */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t eye_high;
	/* Description - Return: eye's size */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t eye_size;
	/* Description - Return: eye's center */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t eye_center;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_icmd_varac_calib {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 for cluster4, 0x1 for cluster13, 0x2 for pciex */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t center_pll;
	/* Description - mask of bit per PLL, when set will use PLL values in ICMD database */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t dont_use_def_mask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_pll_varactor_config_value pll[4];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_phy_uc_activate_uc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - start line to run from */
	/* 0x4.0 - 0x4.11 */
	 u_int16_t start_line;
	/* Description - end line to run */
	/* 0x4.16 - 0x4.27 */
	 u_int16_t end_line;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_phy_uc_get_status {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - main uC FSM */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t fsm_ps;
	/* Description - current instruction pointer address */
	/* 0x4.4 - 0x4.15 */
	 u_int16_t current_index;
	/* Description - break point enable */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t bp_en;
	/* Description - break point index */
	/* 0x4.17 - 0x4.28 */
	 u_int16_t bp_index;
	/* Description - step mode is enabled */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t step_mode_en;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - current subroutine depth */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t sub_count;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_icmd_phy_uc_get_array_prop {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - commands start line in the array */
	/* 0x4.0 - 0x4.11 */
	 u_int16_t cmds_start_line;
	/* Description - total number of commands */
	/* 0x4.12 - 0x4.23 */
	 u_int16_t total_cmds;
	/* Description - subroutine lifo size */
	/* 0x4.24 - 0x4.27 */
	 u_int8_t subs_lifo;
	/* Description - version of phy uc icmds */
	/* 0x4.28 - 0x4.31 */
	 u_int8_t phy_uc_icmd_version;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - shared consts size in bytes */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t shared_consts_size_bytes;
	/* Description - serdes params size in bytes */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t serdes_params_size_bytes;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - debug area size in bytes */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t debug_area_size_bytes;
	/* Description - opamp calib size in bytes */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t opamp_calib_size_bytes;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - lane consts size in bytes */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t lane_consts_size_bytes;
	/* Description - lane static vars size in bytes */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t lane_static_vars_size_bytes;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - lane dynamic vars size in bytes */
	/* 0x14.0 - 0x14.15 */
	 u_int16_t lane_dynamic_vars_size_bytes;
	/* Description - lane results size in bytes */
	/* 0x14.16 - 0x14.31 */
	 u_int16_t lane_results_bytes;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - shared consts start addr */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t shared_consts_addr;
	/* Description - port0 serdes start addr */
	/* 0x18.16 - 0x18.31 */
	 u_int16_t port0_serdes_addr;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - port1 serdes start addr */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t port1_serdes_addr;
	/* Description - port0 debug start addr */
	/* 0x1c.16 - 0x1c.31 */
	 u_int16_t port0_debug_addr;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - port1 debug start addr */
	/* 0x20.0 - 0x20.15 */
	 u_int16_t port1_debug_addr;
	/* Description - opamp calib start addr */
	/* 0x20.16 - 0x20.31 */
	 u_int16_t opamp_calib_addr;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - lane consts start addr */
	/* 0x24.0 - 0x24.15 */
	 u_int16_t lane_consts_addr;
	/* Description - lane static vars start addr */
	/* 0x24.16 - 0x24.31 */
	 u_int16_t lane_static_vars_addr;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - lane dynamic vars start addr */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t lane_dynamic_vars_addr;
	/* Description - lane results start addr */
	/* 0x28.16 - 0x28.31 */
	 u_int16_t lane_results_addr;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_phy_uc_set_get_data_field {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - 1 - set
0 - get
 */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t set_get;
	/* Description - addr as in adabe in bytes */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t addr;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - start of the field inside the 20 bit */
	/* 0x4.0 - 0x4.4 */
	 u_int8_t offset;
	/* Description - width of the field in bits (1-20) */
	/* 0x4.8 - 0x4.12 */
	 u_int8_t width;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 1/4 line field */
	/* 0x8.0 - 0x8.19 */
	 u_int32_t data;
};

/* Description -   */
/* Size in bytes - 196 */
struct connectx4lx_icmd_phy_uc_set_get_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - 1 - set
0 - get
 */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t set_get;
	/* Description - line addr in array to start reading */
	/* 0x0.16 - 0x0.27 */
	 u_int16_t start_addr;
	/* Description - number of lines to read */
	/* 0x0.28 - 0x0.31 */
	 u_int8_t num_of_lines;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - number of lines to read */
	/* 0x4.0 - 0xc4.31 */
	 struct connectx4lx_phy_uc_array_line line[16];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_uc_set_del_bp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - 1 - set
0 - del
 */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t set_del;
	/* Description - line addr in array to add break point */
	/* 0x0.16 - 0x0.27 */
	 u_int16_t line_addr;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_uc_do_step {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_uc_do_continue {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
};

/* Description -   */
/* Size in bytes - 260 */
struct connectx4lx_icmd_phy_get_pddr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Phy Port Debug DataBase */
	/* 0x4.0 - 0x104.31 */
	 struct connectx4lx_pddr_reg phy_port_debug_database;
};

/* Description -   */
/* Size in bytes - 40 */
struct connectx4lx_phy_reg_ppll {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Number of PLL in the PLL group */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t num_plls;
	/* Description - Choose PLL group index, input field */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t pll_group;
	/* Description - Number of PLL groups in the device, in Pelican 3, in Shomron/Golan 2 */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t num_pll_groups;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Varactors calibration flow was executed */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t ae;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - PLL status Data fields */
	/* 0x8.0 - 0x28.31 */
	 struct connectx4lx_pll_status pll_status[4];
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_phy_set_get_ptas {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 - set PTAS, set to all clusters
0 - get PTAS, get cluster 0 settings
 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t set_get;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Phy Tuning Algorithm Settings */
	/* 0x4.0 - 0x30.31 */
	 struct connectx4lx_ptas_reg ptas;
};

/* Description -   */
/* Size in bytes - 164 */
struct connectx4lx_icmd_phy_get_grade_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description -  */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t lanes_mask;
	/* Description - 0 - mV after slicer
1 - ticks */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t eo_offset_units;
	/* Description - 0 - psec ; 1 - ticks */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t eo_phase_units;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Serdes Lane Receive Grade */
	/* 0x4.0 - 0xa4.31 */
	 struct connectx4lx_slrg_reg grade_info_lane[4];
};

/* Description -   */
/* Size in bytes - 280 */
struct connectx4lx_icmd_phy_get_clear_counters {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - 0x1 - get counters, 0x0 - clear counters, based on valid_counters_mask */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t get_clear;
	/* Description - 0x1 - Tools mode, disable counters masking
0x0 - MAD mode, enable counters masking
When mask is enabled (MAD mode) masked counters cannot be cleared or read using this icmd. */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t cnt_mask_dis_en;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  Output: Valid counters mask, according to error correction/retransmition mode and speed

bit0  - PHY_CNT_SYMBOL_ERROR
bit1  - PHY_CNT_SYNC_HEAD_ERROR
bit2  - PHY_CNT_UNKNOWN_BLOCK
bit3  - PHY_CNT_EDPL0
bit4  - PHY_CNT_EDPL1
bit5  - PHY_CNT_EDPL2
bit6  - PHY_CNT_EDPL3
bit7  - PHY_CNT_FEC_CORRECTABLE_BLOCK_LANE0
bit8  - PHY_CNT_FEC_CORRECTABLE_BLOCK_LANE1
bit9  - PHY_CNT_FEC_CORRECTABLE_BLOCK_LANE2
bit10 - PHY_CNT_FEC_CORRECTABLE_BLOCK_LANE3
bit11 - PHY_CNT_FEC_UNCORRECTABLE_BLOCK_LANE0
bit12 - PHY_CNT_FEC_UNCORRECTABLE_BLOCK_LANE1
bit13 - PHY_CNT_FEC_UNCORRECTABLE_BLOCK_LANE2
bit14 - PHY_CNT_FEC_UNCORRECTABLE_BLOCK_LANE3
bit15 - PHY_CNT_PORT_FEC_CORRECTABLE_BLOCK_COUNTER
bit16 - PHY_CNT_PORT_FEC_UNCORRECTABLE_BLOCK_COUNTER
bit17 - PHY_CNT_PORT_FEC_CORRECTED_SYMBOL_COUNTER
bit18  - PHY_CNT_FEC_CORRECTED_SYMBOL_COUNTER_LANE0
bit19  - PHY_CNT_FEC_CORRECTED_SYMBOL_COUNTER_LANE1
bit20  - PHY_CNT_FEC_CORRECTED_SYMBOL_COUNTER_LANE2
bit21 - PHY_CNT_FEC_CORRECTED_SYMBOL_COUNTER_LANE3
bit22 - PHY_CNT_PORT_HYST0
bit23 - PHY_CNT_PORT_HYST1
bit24 - PHY_CNT_LINK_DOWNED
bit25 - PHY_CNT_LINK_ERROR_RECOVERY
bit26 - TIME_SINCE_LAST_CLEAR
bit27 - PRBS_ERROR_LANE0
bit28 - PRBS_ERROR_LANE1
bit29 - PRBS_ERROR_LANE2
bit30 - PRBS_ERROR_LANE3
 */
	/* 0x4.0 - 0x4.30 */
	 u_int32_t valid_counters_mask;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t symbol_err_hi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t symbol_err_lo;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t sync_head_err_hi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t sync_head_err_lo;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t unknown_block_hi;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t unknown_block_lo;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t EDPL0_hi;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t EDPL0_lo;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t EDPL1_hi;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t EDPL1_lo;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t EDPL2_hi;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t EDPL2_lo;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t EDPL3_hi;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t EDPL3_lo;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t fec_correctable_block_lane0_hi;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t fec_correctable_block_lane0_lo;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t fec_correctable_block_lane1_hi;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description -  */
	/* 0x4c.0 - 0x50.31 */
	 u_int32_t fec_correctable_block_lane1_lo;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t fec_correctable_block_lane2_hi;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description -  */
	/* 0x54.0 - 0x58.31 */
	 u_int32_t fec_correctable_block_lane2_lo;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description -  */
	/* 0x58.0 - 0x5c.31 */
	 u_int32_t fec_correctable_block_lane3_hi;
/*---------------- DWORD[23] (Offset 0x5c) ----------------*/
	/* Description -  */
	/* 0x5c.0 - 0x60.31 */
	 u_int32_t fec_correctable_block_lane3_lo;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x64.31 */
	 u_int32_t fec_uncorrectable_block_lane0_hi;
/*---------------- DWORD[25] (Offset 0x64) ----------------*/
	/* Description -  */
	/* 0x64.0 - 0x68.31 */
	 u_int32_t fec_uncorrectable_block_lane0_lo;
/*---------------- DWORD[26] (Offset 0x68) ----------------*/
	/* Description -  */
	/* 0x68.0 - 0x6c.31 */
	 u_int32_t fec_uncorrectable_block_lane1_hi;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x70.31 */
	 u_int32_t fec_uncorrectable_block_lane1_lo;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x74.31 */
	 u_int32_t fec_uncorrectable_block_lane2_hi;
/*---------------- DWORD[29] (Offset 0x74) ----------------*/
	/* Description -  */
	/* 0x74.0 - 0x78.31 */
	 u_int32_t fec_uncorrectable_block_lane2_lo;
/*---------------- DWORD[30] (Offset 0x78) ----------------*/
	/* Description -  */
	/* 0x78.0 - 0x7c.31 */
	 u_int32_t fec_uncorrectable_block_lane3_hi;
/*---------------- DWORD[31] (Offset 0x7c) ----------------*/
	/* Description -  */
	/* 0x7c.0 - 0x80.31 */
	 u_int32_t fec_uncorrectable_block_lane3_lo;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x84.31 */
	 u_int32_t port_fec_correctable_block_hi;
/*---------------- DWORD[33] (Offset 0x84) ----------------*/
	/* Description -  */
	/* 0x84.0 - 0x88.31 */
	 u_int32_t port_fec_correctable_block_lo;
/*---------------- DWORD[34] (Offset 0x88) ----------------*/
	/* Description -  */
	/* 0x88.0 - 0x8c.31 */
	 u_int32_t port_fec_uncorrectable_block_hi;
/*---------------- DWORD[35] (Offset 0x8c) ----------------*/
	/* Description -  */
	/* 0x8c.0 - 0x90.31 */
	 u_int32_t port_fec_uncorrectable_block_lo;
/*---------------- DWORD[36] (Offset 0x90) ----------------*/
	/* Description -  */
	/* 0x90.0 - 0x94.31 */
	 u_int32_t port_fec_corrected_symbol_hi;
/*---------------- DWORD[37] (Offset 0x94) ----------------*/
	/* Description -  */
	/* 0x94.0 - 0x98.31 */
	 u_int32_t port_fec_corrected_symbol_lo;
/*---------------- DWORD[38] (Offset 0x98) ----------------*/
	/* Description -  */
	/* 0x98.0 - 0x9c.31 */
	 u_int32_t fec_corrected_symbol_lane0_hi;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description -  */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t fec_corrected_symbol_lane0_lo;
/*---------------- DWORD[40] (Offset 0xa0) ----------------*/
	/* Description -  */
	/* 0xa0.0 - 0xa4.31 */
	 u_int32_t fec_corrected_symbol_lane1_hi;
/*---------------- DWORD[41] (Offset 0xa4) ----------------*/
	/* Description -  */
	/* 0xa4.0 - 0xa8.31 */
	 u_int32_t fec_corrected_symbol_lane1_lo;
/*---------------- DWORD[42] (Offset 0xa8) ----------------*/
	/* Description -  */
	/* 0xa8.0 - 0xac.31 */
	 u_int32_t fec_corrected_symbol_lane2_hi;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description -  */
	/* 0xac.0 - 0xb0.31 */
	 u_int32_t fec_corrected_symbol_lane2_lo;
/*---------------- DWORD[44] (Offset 0xb0) ----------------*/
	/* Description -  */
	/* 0xb0.0 - 0xb4.31 */
	 u_int32_t fec_corrected_symbol_lane3_hi;
/*---------------- DWORD[45] (Offset 0xb4) ----------------*/
	/* Description -  */
	/* 0xb4.0 - 0xb8.31 */
	 u_int32_t fec_corrected_symbol_lane3_lo;
/*---------------- DWORD[46] (Offset 0xb8) ----------------*/
	/* Description -  */
	/* 0xb8.0 - 0xbc.31 */
	 u_int32_t port_rs_hyst0_hi;
/*---------------- DWORD[47] (Offset 0xbc) ----------------*/
	/* Description -  */
	/* 0xbc.0 - 0xc0.31 */
	 u_int32_t port_rs_hyst0_lo;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0xc4.31 */
	 u_int32_t port_rs_hyst1_hi;
/*---------------- DWORD[49] (Offset 0xc4) ----------------*/
	/* Description -  */
	/* 0xc4.0 - 0xc8.31 */
	 u_int32_t port_rs_hyst1_lo;
/*---------------- DWORD[50] (Offset 0xc8) ----------------*/
	/* Description -  */
	/* 0xc8.0 - 0xcc.31 */
	 u_int32_t link_downed_counter_hi;
/*---------------- DWORD[51] (Offset 0xcc) ----------------*/
	/* Description -  */
	/* 0xcc.0 - 0xd0.31 */
	 u_int32_t link_downed_counter_lo;
/*---------------- DWORD[52] (Offset 0xd0) ----------------*/
	/* Description -  */
	/* 0xd0.0 - 0xd4.31 */
	 u_int32_t link_error_recovery_hi;
/*---------------- DWORD[53] (Offset 0xd4) ----------------*/
	/* Description -  */
	/* 0xd4.0 - 0xd8.31 */
	 u_int32_t link_error_recovery_lo;
/*---------------- DWORD[54] (Offset 0xd8) ----------------*/
	/* Description -  */
	/* 0xd8.0 - 0xdc.31 */
	 u_int32_t time_since_last_clear_msec_hi;
/*---------------- DWORD[55] (Offset 0xdc) ----------------*/
	/* Description -  */
	/* 0xdc.0 - 0xe0.31 */
	 u_int32_t time_since_last_clear_msec_lo;
/*---------------- DWORD[56] (Offset 0xe0) ----------------*/
	/* Description -  */
	/* 0xe0.0 - 0xe4.31 */
	 u_int32_t prbs_error_lane0_hi;
/*---------------- DWORD[57] (Offset 0xe4) ----------------*/
	/* Description -  */
	/* 0xe4.0 - 0xe8.31 */
	 u_int32_t prbs_error_lane0_lo;
/*---------------- DWORD[58] (Offset 0xe8) ----------------*/
	/* Description -  */
	/* 0xe8.0 - 0xec.31 */
	 u_int32_t prbs_error_lane1_hi;
/*---------------- DWORD[59] (Offset 0xec) ----------------*/
	/* Description -  */
	/* 0xec.0 - 0xf0.31 */
	 u_int32_t prbs_error_lane1_lo;
/*---------------- DWORD[60] (Offset 0xf0) ----------------*/
	/* Description -  */
	/* 0xf0.0 - 0xf4.31 */
	 u_int32_t prbs_error_lane2_hi;
/*---------------- DWORD[61] (Offset 0xf4) ----------------*/
	/* Description -  */
	/* 0xf4.0 - 0xf8.31 */
	 u_int32_t prbs_error_lane2_lo;
/*---------------- DWORD[62] (Offset 0xf8) ----------------*/
	/* Description -  */
	/* 0xf8.0 - 0xfc.31 */
	 u_int32_t prbs_error_lane3_hi;
/*---------------- DWORD[63] (Offset 0xfc) ----------------*/
	/* Description -  */
	/* 0xfc.0 - 0x100.31 */
	 u_int32_t prbs_error_lane3_lo;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - Enable/Disable PRBS */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t en_dis;
	/* Description - PRBS_31   = 0,   x^31 + x^28 + 1
PRBS_23   = 1,  // x^23 + x^18 + 1, for legacy partner
PRBS_23_1 = 1,  // x^23 + x^18 + 1
PRBS_23_2 = 2,  // x^23 + x^18 + x^12 + x^16 +1
PRBS_23_3 = 3,  // x^23 + x^22 + x^19 + x^18 +1
PRBS_23_4 = 4,  // x^23 + x^19 + x^18 + x^11 +1
PRBS_7    = 5,  // x^7  + x^6  + 1
PRBS_11   = 6,  // x^11 + x^9  + 1
PRBS_11_1 = 7,  // x^11 + x^10 + x^6 + x^5 + 1
PRBS_11_2 = 8,  // x^11 + x^9 + x^6 + x^5 + 1
PRBS_11_3 = 9,  // x^11 + x^8 + x^6 + x^4 + 1
PRBS_11_4 = 10, // x^11 + x^7 + x^6 + x^4 + 1
PRBS_9    = 11, // x^9  + x^5  + 1 */
	/* 0x0.17 - 0x0.20 */
	 u_int8_t prbs_type;
};

/* Description -   */
/* Size in bytes - 84 */
struct connectx4lx_icmd_phy_set_get_rx_sd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - bit0 - lane0
bit1 - lane1
bit2 - lane2
bit3 - lane3 */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t lanes_mask;
	/* Description - configure Rx taps or get current Rx taps */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t set_get;
	/* Description - select input buffer, 0 or 1 */
	/* 0x0.21 - 0x0.21 */
	 u_int8_t input_buff;
	/* Description - calibration after RX configuration, 0 or 1 */
	/* 0x0.22 - 0x0.22 */
	 u_int8_t do_calib;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - If set_get=1,enter desirerable configurations
If set_get=0, it's output struct
lctrl_input field is dummy */
	/* 0x4.0 - 0x54.31 */
	 struct connectx4lx_sd_params_rx_set ffe_taps[4];
};

/* Description -   */
/* Size in bytes - 56 */
struct connectx4lx_icmd_phy_set_get_tx_sd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - bit0 - lane0
bit1 - lane1
bit2 - lane2
bit3 - lane3 */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t lanes_mask;
	/* Description - configure Tx set or get current Tx set */
	/* 0x0.20 - 0x0.20 */
	 u_int8_t set_get;
	/* Description - 0x1 - PRESET_TX. Relevant inputs: preset_edr_fdr, preset_amp_en, preset_num
0x2 - ABA_TX. Relevant inputs: force_vendor_id, vendor_id, aba_qsfp_atten_5g, aba_qsfp_atten_7g, aba_qsfp_atten_12g
0x3 - MANUAL_TX_SET Relevant inputs: tx_set.
Valid only if set_get = 1 */
	/* 0x0.21 - 0x0.22 */
	 u_int8_t tx_conf_mode;
	/* Description - EDR = 1, FDR = 0. Valid if tx_conf_mode=PRESET_TX */
	/* 0x0.23 - 0x0.23 */
	 u_int8_t preset_edr_fdr;
	/* Description - Valid if tx_conf_mode=PRESET_TX */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t preset_amp_en;
	/* Description - Example: preset_amp_en=1 and preset_num=2 => index=18. Valid if tx_conf_mode=PRESET_TX */
	/* 0x0.26 - 0x0.29 */
	 u_int8_t preset_num;
	/* Description - Valid if tx_conf_mode=ABA_TX */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t force_vendor_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - index for vendor_id sd_type. Valid if tx_conf_mode=ABA_TX and force_vendor_id=1 */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t vendor_id;
	/* Description - index for QDR, FDR10. Valid if tx_conf_mode=ABA_TX and force_vendor_id=0 */
	/* 0x4.4 - 0x4.11 */
	 u_int8_t aba_qsfp_atten_5g;
	/* Description - index for FDR. Valid if tx_conf_mode=ABA_TX and force_vendor_id=0 */
	/* 0x4.12 - 0x4.19 */
	 u_int8_t aba_qsfp_atten_7g;
	/* Description - index for EDR. Valid if tx_conf_mode=ABA_TX and force_vendor_id=0 */
	/* 0x4.20 - 0x4.27 */
	 u_int8_t aba_qsfp_atten_12g;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - If set_get=1 and tx_conf_mode=MANUAL_TX_SET, enter desirerable configurations
 If set_get=0, it's output struct.input_eq, out_emp, rx_amp are dummy fields */
	/* 0x8.0 - 0x38.31 */
	 struct connectx4lx_sd_params_tx_active_set tx_set[4];
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_halt_fsm {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - If 1, all inband ports will operate accoridng to 'fsm_mask' and 'halt_mode' */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t all_ports;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND
Valid only if all_ports=0 */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t port_type;
	/* Description - bit0 - ETH_FSM_HALT
bit1 - IB_FSM_HALT
bit2 - MLX_PHY_FSM_HALT
bit3 - PM_FSM_HALT
Relevant only for halt_mode != STAY_IN_LIN    K_UP */
	/* 0x0.17 - 0x0.20 */
	 u_int8_t fsm_mask;
	/* Description - 0x1 - HALT_FSM
0x2 - RESUME_FSM 
0x3 - STAY_IN_LINKUP, All machines will halt at linkup (ETH, IB, MLX_PHY, HW) */
	/* 0x0.21 - 0x0.22 */
	 u_int8_t halt_mode;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_phy_open_close_port {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - bit0 - SDR
bit1 - DDR
bit2 - QDR
bit3 - FDR
bit4 - EDR
bit8 - QDR is FDR10 */
	/* 0x0.16 - 0x0.24 */
	 u_int16_t speed_en;
	/* Description - 0x0 - OPEN_PORT_NORMAL
0x1 - OPEN_PORT_FORCE_TX
0x2 - OPEN_PORT_MLOOP
0x3 - CLOSE_PORT */
	/* 0x0.25 - 0x0.26 */
	 u_int8_t link_mode;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_icmd_phy_get_link_status {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - FW indication
0x2 - POLLING
0x3 - DISABLE
0x5 - LINKUP */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t phy_link_status;
	/* Description - HW indication
0x1 - LINK_DOWN
0x2 - LINK_INITIALIZE
0x3 - LINK_ARM
0x4 - LINK_ACTIVE
0x5 - LINK_ACTIVE_DIFFER */
	/* 0x0.20 - 0x0.22 */
	 u_int8_t logic_link_status;
	/* Description -  */
	/* 0x0.23 - 0x0.24 */
	 u_int8_t ts3_rev_agreed;
	/* Description - 0x0 - ETH_AN_FSM_ENABLE
0x1 - ETH_AN_FSM_XMIT_DISABLE
0x2 - ETH_AN_FSM_ABILITY_DETECT
0x3 - ETH_AN_FSM_ACK_DETECT
0x4 - ETH_AN_FSM_COMPLETE_ACK
0x5 - ETH_AN_FSM_AN_GOOD_CHECK
0x6 - ETH_AN_FSM_AN_GOOD
0x7 - ETH_AN_FSM_NEXT_PAGE_WAIT
0x8 - ETH_AN_FSM_LINK_STAT_CHECK
0x9 - ETH_AN_FSM_EXTRA_TUNE
0xa - ETH_AN_FSM_FIX_REVERSALS
0xb - ETH_AN_FSM_IB_FAIL */
	/* 0x0.25 - 0x0.28 */
	 u_int8_t eth_an_ps;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x0 - IB_AN_FSM_DISABLED
0x1 - IB_AN_FSM_INITIALY
0x2 - IB_AN_FSM_RCVR_CFG
0x3 - IB_AN_FSM_CFG_TEST
0x4 - IB_AN_FSM_WAIT_RMT_TEST
0x5 - IB_AN_FSM_WAIT_CFG_ENHANCED
0x6 - IB_AN_FSM_CFG_IDLE
0x7 - IB_AN_FSM_LINK_UP */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t ib_an_ps;
	/* Description - 0x0 - MLX_PHY_STATE_IDLE
0x1 - MLX_PHY_STATE_TX_TUNING
0x2 - MLX_PHY_STATE_TX_TUNING_WAIT_RMT
0x3 - MLX_PHY_STATE_RX_TUNING
0x4 - MLX_PHY_STATE_RX_TUNING_WAIT_RMT
0x5 - MLX_PHY_STATE_LINKUP_NEGO_PHY
0x6 - MLX_PHY_STATE_LINKUP_NEGO_LINK
0x7 - MLX_PHY_STATE_WAIT_RMT_DONE
0x8 - MLX_PHY_STATE_MLX_PHY_DONE */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t mlx_phy_an_ps;
	/* Description - HW indication
10-sleeping delay
11-sleeping quiet
20-polling active
21-polling quiet
30-disable
40-config debounce
41-config receiver
42-config wait remote
43-config tx reverse lanes
44-config enhanced    
45-config test
46-confg wait remote test
47-config wait cfg enhanced
48-config idle
50-linkup
60-recover retrain
61-recover wait remote
62-recover idle
70-test
------------------
80 - Force     send ts1 (command may be given only on disable state)
90 - Force send ts2
A0 - Force Sent Idle
B0 -  Force send ts Mlnx
C0 - Force send ts3
D0 - Force LinkUp

 */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t link_phy_state;
	/* Description - FW indication
bit0 - SDR
bit1 - DDR
bit2 - QDR
bit3 - FDR
bit4 - EDR
bit8 - QDR is FDR10 */
	/* 0x4.16 - 0x4.24 */
	 u_int16_t speed_enabled;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - FW indication
bit0 - SDR
bit1 - DDR
bit2 - QDR
bit3 - FDR
bit4 - EDR
bit8 - QDR is FDR10 */
	/* 0x8.0 - 0x8.8 */
	 u_int16_t speed_active;
	/* Description - FW indication
0x1 - WIDTH_1X
0x2 - WIDTH_4X */
	/* 0x8.9 - 0x8.16 */
	 u_int8_t width_enabled;
	/* Description - FW indication
0x1 - WIDTH_1X
0x2 - WIDTH_4X */
	/* 0x8.17 - 0x8.24 */
	 u_int8_t width_active;
	/* Description - FW indication
0 - No MLPN
1 - MLPN1
2 - MLX_PHY */
	/* 0x8.25 - 0x8.26 */
	 u_int8_t mlpn_mode;
	/* Description - FW indication
0 - CABLE_NOT_DEFINED
1 - ACTIVE_CABLE
2 - COPPER_CABLE
3 - NO_CABLE */
	/* 0x8.27 - 0x8.28 */
	 u_int8_t cable_type;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - FW indication
0 - No FEC
1 - Firecode FEC
2 - Standard RS-FEC - RS(528,514)
3 - Standard LL RS-FEC - RS(271,257)
4 - Mellanox     Strong RS-FEC - RS(277,257)
5 - Mellanox LL RS-FEC - RS(163,155)
6 - Mellanox COD
 */
	/* 0xc.0 - 0xc.3 */
	 u_int8_t fec_mode_active;
	/* Description - FW indication
RERTRANSMISSION_MODE_NONE = 0,
RERTRANSMISSION_MODE_LLR  = 1,
RERTRANSMISSION_MODE_PLR  = 2
 */
	/* 0xc.4 - 0xc.5 */
	 u_int8_t rtrn_mode_active;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x24.31 */
	 struct connectx4lx_module_params module_params;
};

/* Description -   */
/* Size in bytes - 260 */
struct connectx4lx_icmd_phy_activate_rx_adap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0x0 - IB_PORT_INPUT, 0x1 - LOCAL_PORT_INPUT */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t ib_port_or_local_port;
	/* Description - Pelican - [1..36]; Shomron - [1,2] */
	/* 0x0.1 - 0x0.7 */
	 u_int8_t ib_port;
	/* Description - Pelican - [1..36]; Shomron - [0,1], pport = local_port + 1 */
	/* 0x0.8 - 0x0.14 */
	 u_int8_t local_port;
	/* Description - 0x0 - PORT_TYPE_INBAND
0x1 - PORT_TYPE_OUT_OF_BAND */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t port_type;
	/* Description - 0x0 - get Rx adaptation results
0x1 - activate Rx adaptation */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t cmd;
	/* Description - activate results rx adaptation only for lanes set in mask */
	/* 0x0.17 - 0x0.20 */
	 u_int8_t lanes_mask;
	/* Description - set the subrouting index from the list:  phy_uc_config.subroutines.by_index.subroutine
Relevant only for activate mode */
	/* 0x0.21 - 0x0.26 */
	 u_int8_t subroutine;
	/* Description - 0 - MEASURE_METHOD_BATH, 1 - MEASURE_METHOD_ONES, 2 - MEASURE_METHOD_IET, 3 - MEASURE_METHOD_XOR */
	/* 0x0.27 - 0x0.28 */
	 u_int8_t measure_method;
	/* Description - valid bit for shifting starting points (when working with non mlnx devices) */
	/* 0x0.29 - 0x0.29 */
	 u_int8_t non_mlnx_peer_valid;
	/* Description - shift starting points configuration   (when working with non mlnx devices) */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t non_mlnx_peer_active;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Rx adaptation results for lane 0 */
	/* 0x4.0 - 0x104.31 */
	 struct connectx4lx_best_rx_set rx_adap_res_lane[4];
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_pmaos {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Port operational state
0001 - up
0010 - down */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t oper_status;
	/* Description - Port administrative state (the desired state of the interface)
0001 - up
0010 - down by configuration (default) */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t admin_status;
	/* Description - Local port number */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Event Generation on operational state change
00 - Do not generate event
01 - Generate Unacknowledged Event 
10 - Generate Acknowledged Event */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t e;
	/* Description - Module error details. valid only when oper_status=0011
0x0 - Power budget excedded
0x1 - Long range for non mlnx cable
0x2 - Bus */
	/* 0x4.8 - 0x4.11 */
	 u_int8_t error_type;
	/* Description - Event Update Enable. If this bit is set, Event Generation will be 
updated based on the e field. Only relevant on Set operations */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t ee;
	/* Description - Admin State Update Enable. If this bit is set, Admin State will be 
updated based on admin_state field. Only relevant on Set operations */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t ase;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_sspl_hook {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Enable/Disable Hook. When Enabled, FW Ignor Server PCI Message */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
	/* Description - Slot Power Limit Value, Power Limit (In Watt) Is Calculated By Multiplying in slot_power_limit_scale */
	/* 0x0.1 - 0x0.8 */
	 u_int8_t slot_power_limit_value;
	/* Description - 00b=1, 01b=0.1, 10b=0.01, 11b=0.001 */
	/* 0x0.9 - 0x0.10 */
	 u_int8_t slot_power_limit_scale;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Core Clock- 330/400 */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t core_clk;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Disable Feature */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t disable_power_mng;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_temp_hook {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - module number */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - module number */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t sensor_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - module number */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t hook_temp_value;
};

/* Description -   */
/* Size in bytes - 92 */
struct connectx4lx_icmd_mminit {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t module;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_general_st misc;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x30.31 */
	 struct connectx4lx_qsfp_st qsfp;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x3c.31 */
	 struct connectx4lx_sfp_st sfp;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x40.31 */
	 union connectx4lx_com_codes_st com_codes;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 struct connectx4lx_admin_fields_st admin_fields;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x44.7 */
	 u_int8_t module_i2c_device_addr;
	/* Description -  */
	/* 0x44.8 - 0x44.8 */
	 u_int8_t module_pwr_close;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x5c.31 */
	 struct connectx4lx_temperature_fields_st temperature_fields;
};

/* Description -   */
/* Size in bytes - 76 */
struct connectx4lx_icmd_gpio_func {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1- by offset, 0- by name */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t offset_name;
	/* Description -  */
	/* 0x0.1 - 0x0.8 */
	 u_int8_t gpio_func_name;
	/* Description - gpio offset  */
	/* 0x0.9 - 0x0.18 */
	 u_int16_t gpio_func_offset;
	/* Description - offset in group (not valid for modsel) */
	/* 0x0.19 - 0x0.25 */
	 u_int8_t index_in_group;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0-query, 1-write, 2-config  */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t write_query_config;
	/* Description - value to write, for modsel- module to choose */
	/* 0x4.2 - 0x4.8 */
	 u_int8_t value;
	/* Description - 0- close module, 1- open module, relevant only for modsel! */
	/* 0x4.9 - 0x4.9 */
	 u_int8_t open_close_module;
	/* Description - present gpio data in. read only!  */
	/* 0x4.10 - 0x4.16 */
	 u_int8_t data_in;
	/* Description - present gpio data out. read only! */
	/* 0x4.17 - 0x4.23 */
	 u_int8_t data_out;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - enable write to mode */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t mode_we;
	/* Description - value to write to mode (0-input ; 1,2,3- different types of output) */
	/* 0x8.1 - 0x8.2 */
	 u_int8_t mode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - enable write to functional enable */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t functional_en_we;
	/* Description - value to write to functional enable */
	/* 0xc.1 - 0xc.2 */
	 u_int8_t functional_en;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - enable write to write to pull */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t pull_we;
	/* Description - value to write to pull en */
	/* 0x10.1 - 0x10.1 */
	 u_int8_t pull_en;
	/* Description - value to write to pull up */
	/* 0x10.2 - 0x10.2 */
	 u_int8_t pull_up;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - enable to write to polarity (not valid by offset) */
	/* 0x14.0 - 0x14.0 */
	 u_int8_t polarity_we;
	/* Description - value to write to polarity */
	/* 0x14.1 - 0x14.1 */
	 u_int8_t polarity;
	/* Description - 1 - no gpio function name in the system (relevant only for polarity) */
	/* 0x14.2 - 0x14.2 */
	 u_int8_t no_gpio_function;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - enable write to cause */
	/* 0x18.0 - 0x18.0 */
	 u_int8_t cause_we;
	/* Description - 1-set, 0-clear  */
	/* 0x18.1 - 0x18.1 */
	 u_int8_t rise_set_clear;
	/* Description - 1-set, 0-clear */
	/* 0x18.2 - 0x18.2 */
	 u_int8_t fall_set_clear;
};

/* Description -   */
/* Size in bytes - 68 */
struct connectx4lx_icmd_access_reg_ptys {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x44.31 */
	 struct connectx4lx_ptys_reg ptys;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_icmd_access_register_pmtu {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_pmtu_reg pmtu;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_access_register_mlcr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x10.31 */
	 struct connectx4lx_mlcr mlcr;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_plpc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x2c.31 */
	 struct connectx4lx_plpc_reg plpc;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_pplm {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x1c.31 */
	 struct connectx4lx_pplm_reg pplm;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_pplr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_pplr_reg pplr;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_ppamp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x30.31 */
	 struct connectx4lx_pamp_reg ppamp;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_ptas {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x30.31 */
	 struct connectx4lx_ptas_reg ptas;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_icmd_access_register_ppaos {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_ppaos_reg ppaos;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_icmd_access_register_pprt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x24.31 */
	 struct connectx4lx_pprt_reg pprt;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_access_register_pptt {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x20.31 */
	 struct connectx4lx_pptt_reg pptt;
};

/* Description -   */
/* Size in bytes - 44 */
struct connectx4lx_icmd_access_register_slrg {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x2c.31 */
	 struct connectx4lx_slrg_reg slrg;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_icmd_access_register_sltp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x18.31 */
	 struct connectx4lx_sltp_reg sltp;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_access_register_slrp {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x2c.31 */
	 struct connectx4lx_slrp_reg slrp;
};

/* Description -   */
/* Size in bytes - 20 */
struct connectx4lx_icmd_access_register_paos {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_paos_reg paos;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_enable_tools_pf {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t disable_enable_;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_set_toolpf_tracer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t PA;
};

/* Description -   */
/* Size in bytes - 272 */
struct connectx4lx_icmd_nvcfg_rw_tlv {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.20 - 0x0.23 */
	 u_int8_t writer_id;
	/* Description - debug - commit a nvct flow */
	/* 0x0.24 - 0x0.24 */
	 u_int8_t apply;
	/* Description - debug - write tlv to shadow list */
	/* 0x0.25 - 0x0.25 */
	 u_int8_t shadow;
	/* Description - debug - tlv ovr_en */
	/* 0x0.26 - 0x0.26 */
	 u_int8_t ovr_en;
	/* Description - debug - tlv rd_en */
	/* 0x0.27 - 0x0.27 */
	 u_int8_t rd_en;
	/* Description - debug - tlv priority */
	/* 0x0.28 - 0x0.29 */
	 u_int8_t prio;
	/* Description - read tlv defaults from ini */
	/* 0x0.30 - 0x0.30 */
	 u_int8_t read_defaults;
	/* Description - read or write bit */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - tlv type */
	/* 0x4.0 - 0x8.31 */
	 union connectx4lx_nv_tlv_type type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - data length in bytes */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t data_len_bytes;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - status returned from the rw tlv function icmd uses */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t status;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - data */
	/* 0x10.0 - 0x110.31 */
	 u_int32_t data[64];
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_fpga_flex_nic_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t flex_nic_mode;
	/* Description -  */
	/* 0x0.8 - 0x0.10 */
	 u_int8_t qp_idx;
	/* Description -  */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t operation;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x84.31 */
	 struct connectx4lx_fpga_flex_nic_ctrl_data data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_mng_smbus_freq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - scl frequency.
For set, only 100, 400 and 1000 are currently supported */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t freq_khz;
	/* Description - smbus gw id to operate on */
	/* 0x0.24 - 0x0.26 */
	 u_int8_t gw;
	/* Description - query or set the selected gw scl frequency */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t rw_;
};

/* Description -   */
/* Size in bytes - 320 */
struct connectx4lx_icmd_smbus_master_access {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t device_idx;
	/* Description - When set, the smbus transaction will be polled for completion by the icmd.
When cleared, the transaction will use HW cause to emmit state change. */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t poll_mode;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Numbet of bytes to send in write phase.
0 means there's no write phase. */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t write_size;
	/* Description - Numbet of bytes to read in read phase.
0 means there's no read phase.
The data is read to the data array below, overwriting the given write data.
See smbus_block_en for more details */
	/* 0x4.8 - 0x4.15 */
	 u_int8_t read_size;
	/* Description - When read_size == write_size == 0 , q quick command is sent:
start, slave-addr with rw_ bit, stop
This field is the rw_bit value in quick command. */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t quick_rw;
	/* Description - When set, and I2C transaction to a device 
with 'internal address' (e.G.: eeprom).
The address is taken from the iaddr field.
iaddr byte syze is taken from teh device db.  */
	/* 0x4.17 - 0x4.17 */
	 u_int8_t iaddr_en;
	/* Description - When set, a an smbus block transaction is sent.
In block transaction:
The command is taken from the smbus_command field.
write_size holds payload size only (without the command and block_size bytes)
read_size > 0 signifes block read phase.
The actual data read is returned in the bytes_read field. */
	/* 0x4.23 - 0x4.23 */
	 u_int8_t smbus_block_en;
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t smbus_command;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t iaddr;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Actual read byte count */
	/* 0xc.0 - 0xc.7 */
	 u_int8_t bytes_read;
	/* Description - Actual written byte count (not includding control bytes, such as internal
address, or smbus command + block size). */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t bytes_written;
	/* Description - SMB_TRANS_SUCCEEDED                      = 0, // Transaction succeeded
SMB_TRANS_WAIT_FOR_FW                    = 1,
SMB_TRANS_FAILED_NACK_RCV                = 2,
SMB_TRANS_FAILED_READ_SIZE_ERROR         = 3,
SMB_TRANS_FAILED_STRECH_TIMEOUT          = 4,
SMB_TRANS_FAILED_ARB_LOST                = 5,
SMB_TRANS_FAILED_RCV_UNEXPECTED_START    = 6,
SMB_TRANS_FAILED_RCV_UNEXPECTED_STOP     = 7,
SMB_TRANS_FAILED_PUT_STOP_FAILED         = 8,
SMB_TRANS_FAILED_PUT_START_FAILED        = 9,
SMB_TRANS_FAILED_OTHER                   = 10 */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t trans_status;
	/* Description - SMB_RES_SUCCESS = 0x0
SMB_RES_ERROR   = 0x1
SMB_RES_GW_BUSY = 0x2
SMB_RES_TRANS_FAILED = 0x3
SMB_RES_TRANS_IN_PROGRESS = 0x4
SMB_RES_RETRY   = 0x5
SMB_RES_BAD_FREQ = 0x6
SMB_RES_SLAVE_UNLOCKED = 0x7
SMB_RES_BAD_PARAM = 0x8 */
	/* 0xc.24 - 0xc.31 */
	 u_int8_t status;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.24 - 0x90.23 */
	 u_int8_t data[128];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_xport_xonfig {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - XPORT_CONFIG_ACK_TIMEOUT
 */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bitmask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - read=1, write=0, for read - bitmask must be 0, for write: at least 1 bit should be set in bitmask */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t rw_;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t ack_timeout;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_gvmi_via_vsec {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t hix;
	/* Description -  */
	/* 0x0.24 - 0x0.27 */
	 u_int8_t pfs_per_host;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.3 */
	 u_int8_t num_physical_ports;
	/* Description -  */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t port_pfs_per_host;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t device_id;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_steering_table_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_steering_table_info table_info;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - defined in steering_inner.h */
	/* 0x40.0 - 0x40.23 */
	 u_int32_t steering_table;
	/* Description -  */
	/* 0x40.31 - 0x40.31 */
	 u_int8_t portid;
};

/* Description -   */
/* Size in bytes - 68 */
struct connectx4lx_icmd_access_steering_root {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_hw_ste data;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x40.0 */
	 u_int8_t sx_rx_;
	/* Description -  */
	/* 0x40.1 - 0x40.1 */
	 u_int8_t portid;
	/* Description -  */
	/* 0x40.2 - 0x40.2 */
	 u_int8_t mc_uc_;
	/* Description - valid only for SX, in HW indication come from QP */
	/* 0x40.3 - 0x40.3 */
	 u_int8_t special_root;
	/* Description -  */
	/* 0x40.4 - 0x40.4 */
	 u_int8_t enable_disable_;
	/* Description -  */
	/* 0x40.31 - 0x40.31 */
	 u_int8_t rw_;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_phy_update_calib_vals {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cluster */
	/* 0x0.0 - 0x0.4 */
	 u_int8_t cluster;
	/* Description - lane in cluster */
	/* 0x0.8 - 0x0.11 */
	 u_int8_t lane;
	/* Description - get set values */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t set_get_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t mixer_calib_feedback;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t clear_mixer_vals;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t perform_mixer_calib;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t perform_slicer_calib;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t delta_from_edges_neg;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t delta_from_edges_pos;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t stab_time;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t measure_time;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_dcr_ll_next_dcr_list {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t start_dcri;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t list_length;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x300.31 */
	 struct connectx4lx_dcr_info dcr_info[128];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_dcr_ll_trvrs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t start_dcri;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t list_length;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t last_dcri;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_flr_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read - update in_standby_mode and times. write - simulate exit/enter icmc power save flow (caller should set exit_enter_) */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t flow_id;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t flow_data_0;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t flow_data_1;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_push_db {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x4.24 - 0x4.24 */
	 u_int8_t req_res_;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_ver_data {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - determines specific behavior. 1-set atomic size,  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t opcode;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - for general use */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t user_data;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x50.31 */
	 union connectx4lx_icmd_ver_data_cmd_specific cmd_specific;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_pcie_ver_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_pcie_ver_device device;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x30.31 */
	 struct connectx4lx_icmd_pcie_ver_cables cables[2];
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 struct connectx4lx_icmd_pcie_ver_frequency frequency;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_error_flow_trigger {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - RXT */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t type;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_error_flow_trigger_union triggers;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_icmd_stop_toggler {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - DC_CNAK    = 0
RXT_CHECKS = 1
TIMERS     = 2
SX_ERROR   = 3
RX_ERROR   = 4
MX_ERROR   = 5
MAD_TRAP   = 6
RXT_SLICE       = 0x7
QOS_ARBITER     = 0x8
RXB_XMIT_HOLD     = 0x9
FW_SCHED_Q     = 0xa */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - HW/FW will be working/stopped (according to mostly_working config) for a fraction of 1/(2^log_stress) each duty cycle. Duty cycle is: approx. 50uSec * 2^log_duty_cycle */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t mostly_working;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0 = remove stress */
	/* 0x8.0 - 0x8.4 */
	 u_int8_t log_duty_cycle;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - must be less than log_duty_cycle */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t log_stress;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - bit per prio/vl (vl_mask[8] = vl15) */
	/* 0x20.0 - 0x20.8 */
	 u_int16_t xmit_hold_vl_mask;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - port number 1 or 2 */
	/* 0x24.0 - 0x24.7 */
	 u_int8_t xmit_hold_port_num;
};

/* Description -   */
/* Size in bytes - 264 */
struct connectx4lx_icmd_code_coverage_read {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t data[64];
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description - dword to start reading the data from */
	/* 0x100.0 - 0x100.15 */
	 u_int16_t start_dw;
	/* Description - number of dword to read. Max number is buffer size in dwords or number of dwords left in HW queue from start */
	/* 0x100.16 - 0x100.31 */
	 u_int16_t num_dw;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_code_coverage_control {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - reg access is shared with smp mads that are limited to 0x40B */
	/* 0x4.0 - 0xc.31 */
	 struct connectx4lx_code_coverage_control code_coverage_control;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_esw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_fw_esw fw_esw;
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description -  */
	/* 0x200.0 - 0x280.31 */
	 struct connectx4lx_vport_real_state vport_real_state;
/*---------------- DWORD[189] (Offset 0x2f4) ----------------*/
	/* Description -  */
	/* 0x2f4.29 - 0x2f4.29 */
	 u_int8_t port_is_ib;
	/* Description -  */
	/* 0x2f4.30 - 0x2f4.30 */
	 u_int8_t rw_;
	/* Description -  */
	/* 0x2f4.31 - 0x2f4.31 */
	 u_int8_t portid;
/*---------------- DWORD[190] (Offset 0x2f8) ----------------*/
	/* Description -  */
	/* 0x2f8.0 - 0x2fc.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[191] (Offset 0x2fc) ----------------*/
	/* Description -  */
	/* 0x2fc.0 - 0x300.31 */
	 u_int32_t num_of_vport;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_rw_gvmix {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_gvmix_sub_structs sub_structs;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - ICMD_RW_GVMIX_CMD_CTX = 0x1,
ICMD_RW_GVMIX_DUMMY_ADDR = 0x2,
ICMD_RW_GVMIX_HCA_PARAMS = 0x3,
ICMD_RW_GVMIX_PAGE_MANAGER = 0x4, */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t node_type;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x4c.31 */
	 u_int32_t ix;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_gen_eqe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t eqn;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x50.31 */
	 struct connectx4lx_sw_eqe eqe;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_pcie_tools_pointers {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t pcie_endpoint_data_ptr;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t pcie_timestamps_ptr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t pcie_transaction_ptr;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t pcie_debug_equalization_debug_ptr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t pcie_debug_ts_debug_ptr;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t pcie_debug_internal_error_debug_ptr;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t pcie_phy_gen3_equalization_ptr;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t pcie_phy_pcie_eye_centering_ptr;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t pcie_phy_first_calibration_results_ptr;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t pcie_phy_pcie_rx_adaptation_ptr;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t pcie_phy_pcie_tx_adaptation_ptr;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t pcie_phy_tracer_ptr;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t pcie_pfs_ptr;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_phy_ver_overwrite {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - port1, 1 - port2 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port_id;
	/* Description - 0x00 - CABLE_STAMP
0x01 - MLPN_EN
0x02 - MLPN_SUP
0x03 - MLPN_REQ
0x04 - SPEC_1_2
0x05 - SPEC_1_3
0x06 - FEC_REQ_FDR
0x07 - FEC_REQ_FDR10 */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t field_id;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - New value to overwrite.
 For MLPN_SUP and MLPN_REQ full DW
 */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t field_value;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_init_ocsd {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t addr_hi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t addr_low;
};

/* Description -   */
/* Size in bytes - 556 */
struct connectx4lx_inject_ncsi {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - bmc index */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bmc_ix;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - command */
	/* 0x4.0 - 0x114.31 */
	 struct connectx4lx_ncsi_cmd ncsi_cmd;
/*---------------- DWORD[69] (Offset 0x114) ----------------*/
	/* Description - response */
	/* 0x114.0 - 0x228.31 */
	 struct connectx4lx_ncsi_response ncsi_response;
/*---------------- DWORD[138] (Offset 0x228) ----------------*/
	/* Description - unknown bmc index */
	/* 0x228.0 - 0x22c.31 */
	 u_int32_t unknown_bmc_ix;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_init_ncsi {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - number of bmcs */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t num_of_bmc;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - number of channels per package */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t num_of_channels;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_dc_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - DC_CONFIG_BIT_HANDSHAKE
1 -DC_CONFIG_LOG_DCR_LIFO_SIZE
7 - DC_CONFIG_LOG_DCR_HASH_SIZE
8 - DC_CONFIG_FORCE_NO_DCRS
9 - DC_CONFIG_FORCE_GARBAGE_COLLECT
10 - DC_CONFIG_GARBAGE_COLLECT_PACKET_DROP
11 - DC_CONFIG_GHOST_BUSTER_ENABLE
 12 - DC_CONFIG_MAX_CNAK_BUFFER_SIZE
13 - DC_CONFIG_CNAK_QP_ON_THRESHOLD
14 - DC_CONFIG_CNAK_QP_OFF_THRESHOLD
 15 - DC_CONFIG_DCR_LIFO_SIZE */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t bitmask;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - read=1, write=0, for read - bitmask must be 0, for write: at least 1 bit should be set in bitmask */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t rw_;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - must be configured before init hca (deprecated, mutexed with dcr_lifo_size) */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t log_dcr_lifo_size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - must be configured before init_hca */
	/* 0x10.0 - 0x10.4 */
	 u_int8_t log_dcr_hash_size;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - set all qps opened from this point with full_handshake = 0/1 */
	/* 0x14.0 - 0x14.0 */
	 u_int8_t full_handshake_enable;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description - RO - current number of free dcrs in lifo */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t available_lifo_size;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description - when GARBAGE_COLLECTION bit is set in bitmask, icmd will return OK if done, or OPERATIONAL_ERROR if garbage collection doesn't finish with this number of ticks (~50usec) */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t force_garbage_collection_fail_threshold;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description - number of ghost busters currently active. should be 0 once garbage collection is done */
	/* 0x3c.0 - 0x40.31 */
	 u_int32_t number_of_active_ghost_busters;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - N next dcr cleanup connects will be dropped */
	/* 0x40.0 - 0x44.31 */
	 u_int32_t cleanup_drop_n_connects;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - N next dcr cleanup disconnects will be dropped */
	/* 0x44.0 - 0x48.31 */
	 u_int32_t cleanup_drop_n_disconnects;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description - enables/disable ghost buster mechanism */
	/* 0x48.0 - 0x48.0 */
	 u_int8_t ghost_buster_enable;
/*---------------- DWORD[19] (Offset 0x4c) ----------------*/
	/* Description - max entries in cnak buffer */
	/* 0x4c.0 - 0x4c.15 */
	 u_int16_t max_cnak_buffer_size;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - lower threshold - below this num credits - cnak_qp will be turned on */
	/* 0x50.0 - 0x50.23 */
	 u_int32_t cnak_qp_on_threshold;
/*---------------- DWORD[21] (Offset 0x54) ----------------*/
	/* Description - upper threshold - above this num credits - cnak_qp will be turned off */
	/* 0x54.0 - 0x54.23 */
	 u_int32_t cnak_qp_off_threshold;
/*---------------- DWORD[22] (Offset 0x58) ----------------*/
	/* Description - mutexed with log_dcr_lifo_size */
	/* 0x58.0 - 0x58.23 */
	 u_int32_t dcr_lifo_size;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_read_icmc_tags_and_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - data[0] + data[1] = set[first_set][way[0]], data[2] + data[3] = set[first_set][way[1]]  */
	/* 0x0.0 - 0x2fc.31 */
	 u_int32_t data[191];
/*---------------- DWORD[191] (Offset 0x2fc) ----------------*/
	/* Description - read icmc tags start from first set */
	/* 0x2fc.0 - 0x2fc.11 */
	 u_int16_t first_set;
	/* Description - number of set read by icmd */
	/* 0x2fc.12 - 0x2fc.23 */
	 u_int16_t number_of_sets;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_access_icm_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t data[16];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.31 - 0x40.31 */
	 u_int8_t rw_;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x50.31 */
	 u_int64_t addr;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_check_sqpc_status {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t qpn;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description - 0:all good
1:db_record!=sxdc_pi
2:pi!=ci;\3:ci!=ccwi */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t result_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - the diff */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t result_diff;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_lock_unlock_resource {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_lock_tag lock_tag;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t lock_unlock_;
	/* Description -  */
	/* 0xc.8 - 0xc.10 */
	 u_int8_t irisc_ix;
	/* Description - when this bit is set, locking will impersonate irisc specified in irisc_ix field */
	/* 0xc.11 - 0xc.11 */
	 u_int8_t spy_en;
};

/* Description -   */
/* Size in bytes - 296 */
struct connectx4lx_icmd_generic_access_register {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_reg_access_oper_tlv oper_tlv;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x124.31 */
	 struct connectx4lx_icmd_generic_reg_access_reg_tlv generic_reg_tlv;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_kdnet_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 union connectx4lx_icmd_kdnet_ctrl_io io;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 struct connectx4lx_nv_config_kdnet_data data;
};

/* Description -   */
/* Size in bytes - 8 */
union connectx4lx_icmd_query_capabilities {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_query_cap_in cap_in;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_query_cap_general cap_general;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_icmd_get_icm_ctx_addr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - defined in icm_resources.h */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t icm_res_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ctx_num_hi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ctx_num_lo;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t icm_addr_hi;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t icm_addr_lo;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_phy_nego_ctrl_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t force_link_up_port0;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t halt_fw_phy_fsm_port0;
	/* Description -  */
	/* 0x0.2 - 0x0.2 */
	 u_int8_t force_link_up_port1;
	/* Description -  */
	/* 0x0.3 - 0x0.3 */
	 u_int8_t halt_fw_phy_fsm_port1;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_eye_opening_read_st {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_num;
	/* Description -  */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t lane_num;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t amplitude_high;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t amplitude_low;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t phase_high;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t phase_low;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t tx_set_chosen;
	/* Description -  */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t rx_set_chosen;
};

/* Description -   */
/* Size in bytes - 24 */
struct connectx4lx_icmd_alloc_dealloc_resource {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x0.16 - 0x0.16 */
	 u_int8_t alloc_dealloc;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - defined in icm_resources.h */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t icm_res_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t res_num_hi;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t res_num_lo;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t return_status;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_icmd_get_icm_res_prop {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - valid types defined at icm_resources.h */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t input_icm_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t table_base_hi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t table_base_lo;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t offset;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t log2_stride;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t log2_size;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t log2_table_size;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t dummy_idx;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t sw_type;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_icmd_emad_mcia {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - write = 1
query = 0
 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t write_query_;
	/* Description - PASSED_SANITY_CHECKS     = 0,
MODULE_TYPE_NOT_SUPPORTED = 1,
I2C_ERROR = 2,
MODULE_DISABLED = 3,
NO_EEPROM = 4,
MODULE_NOT_CONNECTED = 5,
INVALID_SLAVE_ADDR = 6,
BAD_PARAM_PAGE_NUM  = 7,
BAD_PARAM = 8,
RETRY = 9,
BUSY = 10,
LONG_PROCESS = 11,

This field will provide information of the sanity checks run over the emad input  */
	/* 0x0.16 - 0x0.19 */
	 u_int8_t sanity_checks_sts;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0h - GOOD.
1h - NO_EEPROM_MODULE. No response from module's EPROM.
2h - MODULE_NOT_SUPPORTED. Module type not supported by the device.
3h - MODULE_NOT_CONNECTED. No module present indication.
4h - MODULE_TYPE_INVALID - if the module is not qsfp or sfp - ini configuration.
9h - I2C_ERROR. Error occurred while trying to access the module's EPROM using I2C
10h - MODULE_DISABLED - module is disabled (using Disable Command).
 */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t status;
	/* Description - Module number */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t module;
	/* Description - Cable Info Lock Page bit - when set there will be no page select for the module, the page number field is ignored */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t l;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - The address to read/write in the module */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t device_address;
	/* Description - The page from which to read/write in the module, last page is cached, when the page is changed a page select transaction will be occured  */
	/* 0x8.16 - 0x8.23 */
	 u_int8_t page_number;
	/* Description - The module's i2c slave address - usually 0x50 */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t i2c_device_address;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Desired read/write size in bytes */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t size;
	/* Description - Password capability */
	/* 0xc.29 - 0xc.29 */
	 u_int8_t passwd_cap;
	/* Description - If set to 1 will force the password to be cleared from the module password field at the end of the module access. */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t passwd_clr;
	/* Description - If set to 1 the Password field is valid and is written to the module password field (address 123-126) before accessing the page. */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t passwd_v;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The password that is written to the module password field. */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t password;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - Write transaction - Data to write ,
query transaction - Returned read data,
 */
	/* 0x14.0 - 0x44.31 */
	 u_int32_t dword[12];
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - internal icmd implementation */
	/* 0x44.0 - 0x44.0 */
	 u_int8_t internal_state;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_icmd_cable_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1 = GET, 2 = SET */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t method;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - return status */
	/* 0x4.16 - 0x4.30 */
	 u_int16_t status;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x14.7 */
	 u_int8_t module;
	/* Description - when set, no page select will be made */
	/* 0x14.31 - 0x14.31 */
	 u_int8_t lock_bit;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_cable_info data;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_cable_plug_out_in {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Bit per port. 0x1 - port1, 0x2 - port2, 0x3 - both ports, others reserved. */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t port;
	/* Description - Simulate plug out (0x1) or plug in (0x0), this mode will work if delay=0 */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t plug_out_in;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_standby {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read - update in_standby_mode and times. write - simulate exit/enter icmc power save flow (caller should set exit_enter_) */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t rw_;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x0 - enter power save mode, 0x1 - exit power save mode */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t exit_enter_;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 0x0 - ports, 0x1 - icmc, 0x2 - arrays, 0x3- clock */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t in_standby_mode;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - last iron down time usec. update on icmd read */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t last_iron_down_time_usec;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - 0 - icmc standby flow , 1 - arrays standby flow, 2 - clock standby flow, 3 - full standby flow */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t flow_id;
};

/* Description -   */
/* Size in bytes - 512 */
struct connectx4lx_icmd_grepper {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - icmd will run grepper operation - 0x0 - icmc_write, 0x1 - icmc_copy, 0x2 - icmc_copy_and_lock, 0x3 - icmc unlock and invalidate */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t icmd_grepper_flow;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - address to read */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t read_addr;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - address to write */
	/* 0x10.0 - 0x18.31 */
	 u_int64_t write_addr;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - read stride size (log) */
	/* 0x18.0 - 0x18.4 */
	 u_int8_t log_read_stride;
	/* Description - write stride size (log) */
	/* 0x18.5 - 0x18.9 */
	 u_int8_t log_write_stride;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - offset from the first line */
	/* 0x1c.0 - 0x1c.25 */
	 u_int32_t line_start_offset;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - number of iterations */
	/* 0x20.0 - 0x20.25 */
	 u_int32_t iterations;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Address of first hit (read only) */
	/* 0x24.0 - 0x24.25 */
	 u_int32_t first_line_hit;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - number of hits (read only) */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t number_of_hits;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description - write_data */
	/* 0x2c.0 - 0x6c.31 */
	 struct connectx4lx_grepper_dwords write_data;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description - write_mask */
	/* 0x6c.0 - 0xac.31 */
	 struct connectx4lx_grepper_dwords write_mask;
/*---------------- DWORD[43] (Offset 0xac) ----------------*/
	/* Description - compare_data */
	/* 0xac.0 - 0xec.31 */
	 struct connectx4lx_grepper_dwords compare_data;
/*---------------- DWORD[75] (Offset 0x12c) ----------------*/
	/* Description - compare_mask */
	/* 0x12c.0 - 0x16c.31 */
	 struct connectx4lx_grepper_dwords compare_mask;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_packet_drop {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - port 0 / 1 */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t port;
	/* Description - drop frequency. drop drop_burst packets every drop_freq packets. zero disable */
	/* 0x0.1 - 0x0.12 */
	 u_int16_t drop_freq;
	/* Description - see drop_freq */
	/* 0x0.26 - 0x0.30 */
	 u_int8_t drop_burst;
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_execute_fw_log {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_itrace itrace;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - see in icmd.c */
	/* 0x10.0 - 0x10.3 */
	 u_int8_t opcode;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x30.31 */
	 u_int32_t log_var[7];
};

/* Description -   */
/* Size in bytes - 48 */
struct connectx4lx_icmd_debug_fw_tracer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 u_int32_t arg[8];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - Number of arguments passed to the icmd */
	/* 0x20.0 - 0x20.3 */
	 u_int8_t num_of_args;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - Number of print iterations to execute */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t num_of_iterations;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description - Delay between iterations in msec */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t iter_delay;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_get_highest_index {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
	/* Description - defined in icm_resources.h */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t icm_res_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - highest free list index */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t highest_internal_index;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - highest icm_res_num */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t highest_icm_res_num;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_get_open_resources {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - defined in icm_resources.h */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t icm_res_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x10.31 */
	 u_int64_t start_index;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - there are more open resources, please query again with the next start index */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t more;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - number of valid entries in open resources table */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t output_size;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x220.31 */
	 struct connectx4lx_index_and_length open_resources[32];
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_icmd_read_icm_dummy_addr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - resource type - see icm_ctx icmd node */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - dummy index: based to icmd_get_icm_res_prop.dummy_idx */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t dummy_idx;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - hop number 3-6 */
	/* 0x8.0 - 0x8.2 */
	 u_int8_t hop_num;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - PA of dummy page */
	/* 0x10.0 - 0x18.31 */
	 u_int64_t dummy_addr;
};

/* Description -   */
/* Size in bytes - 80 */
struct connectx4lx_icmd_read_icm_tlb_line {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int64_t data[8];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x48.31 */
	 u_int64_t tlb_addr;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x48.3 */
	 u_int8_t hop_number;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_config_cc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - ICMD_CONFIG_CC_OPCODE_SET_CC_SETTINGS = 0x0
ICMD_CONFIG_CC_OPCODE_GET_CC_SETTINGS = 0x1
ICMD_CONFIG_CC_OPCODE_SET_CCT = 0x2
ICMD_CONFIG_CC_OPCODE_GET_CCT = 0x3 */
	/* 0x0.0 - 0x0.1 */
	 u_int8_t opcode;
	/* Description -  */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t portid;
	/* Description -  */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t cc_mode;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t sl_map;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.7 */
	 u_int8_t base;
	/* Description -  */
	/* 0x4.16 - 0x4.23 */
	 u_int8_t num_entries;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description - specifies a list of 16 CA congestion entries, one per SL */
	/* 0x100.0 - 0x180.31 */
	 struct connectx4lx_ca_congestion_entry ca_congestion_entry_list[16];
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description - specifies a list of 64 CCT entries */
	/* 0x200.16 - 0x280.15 */
	 struct connectx4lx_cc_table_entry ccti_entry_list[64];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_ud_to_raw {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t port;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t vl15;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_update_rq_ci {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 0 - RQ, 1 - RMP, 2 - XRC_SRQ, 3 - SRQ, 4 - XRQ */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t context_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - gvmi of context */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t context_num;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - new consumer index (i.e number of wqe posts) */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t new_ci;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - for link list: pointer for next wq  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t new_next_index;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_write_dc_cnak_lid {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t port;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t lid;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_icmd_congestion_log {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t port;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_congestion_log_event_entry log_entry;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_get_port_sniffer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t sx_port1;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t sx_port2;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t rx_port1;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t rx_port2;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_set_port_sniffer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t sx_rx_;
	/* Description -  */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t attach_detach_;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.24 - 0x8.31 */
	 u_int8_t port;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t sniffer_qpn;
};

/* Description -   */
/* Size in bytes - 260 */
struct connectx4lx_icmd_special_qps {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_special_qps qps;
/*---------------- DWORD[39] (Offset 0x9c) ----------------*/
	/* Description - QP Index of GVMI_MNG_TRAP_QP */
	/* 0x9c.0 - 0xa0.31 */
	 u_int32_t host_mng_qpn;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x100.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x100.16 - 0x100.16 */
	 u_int8_t port;
};

/* Description -   */
/* Size in bytes - 260 */
struct connectx4lx_eqn4type {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t eqn[64];
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x100.15 */
	 u_int16_t gvmi;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_icmd_access_cmdq {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_cmdif_hdr cmdq;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x40.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x40.16 - 0x40.20 */
	 u_int8_t cmd_ix;
};

/* Description -   */
/* Size in bytes - 72 */
struct connectx4lx_icmd_read_sx_wq_buffer {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t data[16];
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x40.4 */
	 u_int8_t ec;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description -  */
	/* 0x44.0 - 0x44.4 */
	 u_int8_t wqe_idx;
};

/* Description -   */
/* Size in bytes - 192 */
struct connectx4lx_icmd_header_capture {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_header_capture_headers headers;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0xc0.31 */
	 struct connectx4lx_icmd_header_capture_checks checks;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_print_icm {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t enable_specific_gvmi;
	/* Description -  */
	/* 0x0.1 - 0x0.1 */
	 u_int8_t enable_specific_icm_type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description - take from icm_resources.h */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t icm_res_type;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_allowed_madifc_on_all_pfs {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - write 0xBADC0FFE in order to enable */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t protection;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x1 - enable flow
0x2 - disable */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t enable_disable;
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_fw_reset {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - write 0xBADC0FFE in order to enable FW reset */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t protection;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0x1 - upgrade flow
0x2 - dirty MBIST flow */
	/* 0x4.0 - 0x4.1 */
	 u_int8_t reset_mode;
};

/* Description -   */
/* Size in bytes - 264 */
struct connectx4lx_icmd_read_g_rse_slice_desc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_g_rse_hw_decoders desc;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x100.4 */
	 u_int8_t slice;
	/* Description -  */
	/* 0x100.8 - 0x100.11 */
	 u_int8_t array_index;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description - 0x0 STEERING_RES
0x1 PKT_DESC
0x2 RXT_RXS_DESC
0x3 CONTEXT_FETCH_QP_DESC
0x4 STEERING PIPE0
0x5 STEERING PIPE1
0x6 STEERING QPCOMMIT */
	/* 0x104.0 - 0x104.7 */
	 u_int8_t desc_type;
};

/* Description -   */
/* Size in bytes - 524 */
struct connectx4lx_icmd_read_rx_slice_packet {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 u_int32_t data[128];
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description - Total Packet size (returned by ICMD) */
	/* 0x200.0 - 0x200.11 */
	 u_int16_t packet_size;
/*---------------- DWORD[129] (Offset 0x204) ----------------*/
	/* Description -  */
	/* 0x204.0 - 0x204.4 */
	 u_int8_t slice;
/*---------------- DWORD[130] (Offset 0x208) ----------------*/
	/* Description - How many bytes to read in this iteration. (Must be a multiple of 64. Max allowed value is 512) */
	/* 0x208.0 - 0x208.11 */
	 u_int16_t size;
	/* Description - Offset in dw to start from */
	/* 0x208.16 - 0x208.27 */
	 u_int16_t offset_dw;
};

/* Description -   */
/* Size in bytes - 36 */
struct connectx4lx_icmd_get_fw_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_FW_VERSION fw_version;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Hash gen file signature */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t hash_signature;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.24 - 0x24.23 */
	 char psid[17];
};

/* Description -   */
/* Size in bytes - 8 */
struct connectx4lx_icmd_get_link_leds {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1-port1 2-port2 */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t port_number;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t physical_link;
	/* Description -  */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t logical_link;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_get_boot_stage {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t boot_stage;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_icmd_get_irisc_heart_beat {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - bit per irisc */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t irisc_heart_beat;
};

/* Description -   */
/* Size in bytes - 524 */
struct connectx4lx_icmd_read_q_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 u_int32_t data[128];
/*---------------- DWORD[128] (Offset 0x200) ----------------*/
	/* Description -  */
	/* 0x200.0 - 0x200.15 */
	 u_int16_t gvmi;
/*---------------- DWORD[129] (Offset 0x204) ----------------*/
	/* Description -  */
	/* 0x204.0 - 0x204.23 */
	 u_int32_t q_num;
	/* Description - 0=sq 1=rq 2=cq 4=eq 5=rdb 6=srq */
	/* 0x204.24 - 0x204.31 */
	 u_int8_t q_type;
/*---------------- DWORD[130] (Offset 0x208) ----------------*/
	/* Description -  */
	/* 0x208.0 - 0x20c.31 */
	 u_int32_t index;
};

/* Description -   */
/* Size in bytes - 296 */
struct connectx4lx_icmd_access_host_mem {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 u_int32_t data[64];
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x100.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x100.31 - 0x100.31 */
	 u_int8_t rw_;
/*---------------- DWORD[65] (Offset 0x104) ----------------*/
	/* Description - up to 256 bytes */
	/* 0x104.0 - 0x108.31 */
	 u_int32_t num_dwords;
/*---------------- DWORD[66] (Offset 0x108) ----------------*/
	/* Description - CMAS- offset */
	/* 0x108.0 - 0x110.31 */
	 u_int64_t addr;
/*---------------- DWORD[68] (Offset 0x110) ----------------*/
	/* Description - VA - mkey, MTT - ptr */
	/* 0x110.0 - 0x118.31 */
	 u_int64_t key_or_ptr;
/*---------------- DWORD[70] (Offset 0x118) ----------------*/
	/* Description - 0-PA
1-MTT
2-VA
3-OFFSET(signature)
4-CMAS */
	/* 0x118.0 - 0x118.3 */
	 u_int8_t addr_type;
	/* Description - MTT only */
	/* 0x118.16 - 0x118.31 */
	 u_int16_t l2_block_s;
/*---------------- DWORD[71] (Offset 0x11c) ----------------*/
	/* Description - Will be used only if CAPI is enabled */
	/* 0x11c.0 - 0x120.31 */
	 u_int32_t capi_pasid;
/*---------------- DWORD[72] (Offset 0x120) ----------------*/
	/* Description - CMAS only */
	/* 0x120.0 - 0x120.23 */
	 u_int32_t cmas_ix;
	/* Description - CMAS only */
	/* 0x120.24 - 0x120.31 */
	 u_int8_t cmas_type;
};

/* Description -   */
/* Size in bytes - 12 */
struct connectx4lx_icmd_get_pi_ci {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t pi_ci;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x4.16 - 0x4.31 */
	 u_int16_t ctx_type;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t ctx_num;
};

/* Description -   */
/* Size in bytes - 96 */
struct connectx4lx_icmd_access_icm_ctx {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_golan_hw_fw_ctx ctx;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x40.15 */
	 u_int16_t gvmi;
	/* Description -  */
	/* 0x40.31 - 0x40.31 */
	 u_int8_t rw_;
/*---------------- DWORD[17] (Offset 0x44) ----------------*/
	/* Description - 0x5f MTT
 0x01 SQ_QP_LIST_REQ
 0x02 SQ_QP_LIST_RES
 0x03 BSF
 0x04 RDB
 0x05 EXT_RDB
 0x06 ICM_CRC
 0x07 QP_COMMON
  0x08 REQUESTOR_QPC
 0x09 RESPONDER_QPC
 0x0a MKEY
 0x0b SRQ
 0x0c CQ
 0x0d TRANS_STATUS_BSF
 0x0e TRANS_STATUS_KLM
 0x0f PSV
  0x10 EXT_PSV
 0x11 SXDC
 0x12 PIPA
 0x13 TIMER
 0x14 FW_COUNTERS
 0x15 EQ
 0x16 MSIX
 0x17 SXD_GVMI_RATE_LIMITER
 0x18 PORT0_PKEY
 0x19 PORT0_GUID
  0x1a PORT0_INFO
 0x1b PORT0_COUNTERS_GVMI_RX
 0x1c PORT1_PKEY
 0x1d PORT1_GUID
 0x1e PORT1_INFO
 0x1f PORT1_COUNTERS_GVMI_RX
  0x20 STEERING
 0x21 LDB_CACHE
 0x22 REQ_SL_CACHE
 0x23 IRISC
 0x24 SCRATCHPAD
 0x25 SQ_POINTERS
 0x26 SQ_TOKENS_OR_SQ_CONTEXT
 0x27 TOC
  0x28 FW_GVMI_CTX
 0x29 FW_QPC
 0x2a FW_MALLOC
 0x2b FW_PD
 0x2c FW_UAR
 0x2d FW_EQ
 0x2e FW_CQ
 0x2f FW_MKEY
 0x30 FW_SRQ
  0x31 FW_GLOBAL
 0x32 FW_SQ
 0x33 GLOBAL_FW_GVMI_CTX
 0x34 FW_ALT_PATH
 0x36 COUNTERS_QP_RX
 0x36 PORT0_COUNTERS_GVMI_SX
  0x37 PORT1_COUNTERS_GVMI_SX
 0x38 FW_LL_QP_REQ
 0x39 FW_LL_QP_RES
 0x3a  FW_LL_CQ_OVERRUN
 0x3b FW_LL_EQ_OVERRUN_CQ
  0x3c FW_LL_EQ_OVERRUN_EQ
 0x3d EQ_OVERRUN_LIST_META
 0x3e ICM_RES_FW_XRCD
 0x3f ICM_RES_FW_FREE_LIST
 0x4e COUNTERS_QP_SX
 0x5e FW_PORT_INFO */
	/* 0x44.0 - 0x44.15 */
	 u_int16_t ctx_type;
/*---------------- DWORD[18] (Offset 0x48) ----------------*/
	/* Description -  */
	/* 0x48.0 - 0x50.31 */
	 u_int64_t ctx_num;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description - second index - for reading RDB */
	/* 0x50.0 - 0x54.31 */
	 u_int32_t ctx_num2;
};

/* Description -   */
/* Size in bytes - 768 */
struct connectx4lx_icmd_cmd_as_dwords {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 u_int32_t dword[192];
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_sw_cqe_64b {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rsvd_5;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rsvd_4;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t checksum;
	/* Description -  */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t rsvd_3;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t ip_status;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x10.15 */
	 u_int16_t slid_smac_47_32;
	/* Description -  */
	/* 0x10.16 - 0x10.31 */
	 u_int16_t vlan_ml_path;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t slid_smac_31_0;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.23 */
	 u_int32_t rqpn;
	/* Description -  */
	/* 0x18.24 - 0x18.27 */
	 u_int8_t sl_vlan_type;
	/* Description -  */
	/* 0x18.28 - 0x18.29 */
	 u_int8_t g;
	/* Description -  */
	/* 0x18.30 - 0x18.30 */
	 u_int8_t fl;
	/* Description -  */
	/* 0x18.31 - 0x18.31 */
	 u_int8_t rsvd_bit;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t rss_val;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t srq_num;
	/* Description -  */
	/* 0x20.24 - 0x20.31 */
	 u_int8_t rsvd_1;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t imm_inv_key;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x28.15 */
	 u_int16_t application_info;
	/* Description - when application=tag_matching: 0x1-tag consumed, 0x2-msg arrived expected, 0x3-message_arrived_unexpected, 0x4-message_arrived_no_tag, 0x5-append, 0x5-remove, 0x7-NOP, 0x8-rndv (internal!), 0x9-tag_consumed_sw_rndv, 0xa-tag_consumed_message_arrive, 0xb-tag_consumed_message_arrive_sw_rndv */
	/* 0x28.16 - 0x28.23 */
	 u_int8_t application_opcode;
	/* Description - application specific cqe: 0x1 - tag matching - valid only when QP is tag matching qp */
	/* 0x28.24 - 0x28.31 */
	 u_int8_t application;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t byte_count;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t timestamp_h;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t timestamp_l;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x38.24 - 0x38.31 */
	 u_int8_t swqe_opcode_drop_cntr;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t owner;
	/* Description -  */
	/* 0x3c.1 - 0x3c.1 */
	 u_int8_t se;
	/* Description -  */
	/* 0x3c.2 - 0x3c.3 */
	 u_int8_t cqe_format;
	/* Description -  */
	/* 0x3c.4 - 0x3c.7 */
	 u_int8_t rwqe_opcode;
	/* Description -  */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t signature;
	/* Description -  */
	/* 0x3c.16 - 0x3c.31 */
	 u_int16_t wqe_counter;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_grh_inline_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 u_int32_t grh_inline_data[16];
};

/* Description -   */
/* Size in bytes - 112 */
struct connectx4lx_subroutines_lifo {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t PlaceHolder;
};

/* Description -   */
/* Size in bytes - 144 */
struct connectx4lx_lane_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x90.31 */
	 struct connectx4lx_best_rx_debug best_rx;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_lane_results {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_best_rx_set best_rx_set;
};

/* Description -   */
/* Size in bytes - 160 */
struct connectx4lx_lane_vars {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0xa0.31 */
	 struct connectx4lx_data_line var[40];
};

/* Description -   */
/* Size in bytes - 1072 */
struct connectx4lx_lane_static_vars {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_lane_search_vars search_vars;
/*---------------- DWORD[20] (Offset 0x50) ----------------*/
	/* Description -  */
	/* 0x50.0 - 0x2d0.31 */
	 struct connectx4lx_start_point_data start_point[10];
/*---------------- DWORD[180] (Offset 0x2d0) ----------------*/
	/* Description -  */
	/* 0x2d0.0 - 0x2d0.19 */
	 u_int32_t curr_start_point_index;
/*---------------- DWORD[181] (Offset 0x2d4) ----------------*/
	/* Description -  */
	/* 0x2d4.0 - 0x2d4.19 */
	 u_int32_t local_best_grade;
/*---------------- DWORD[182] (Offset 0x2d8) ----------------*/
	/* Description -  */
	/* 0x2d8.0 - 0x2d8.19 */
	 u_int32_t start_point_in_process_mask;
/*---------------- DWORD[183] (Offset 0x2dc) ----------------*/
	/* Description - Calibration Inner function Variable */
	/* 0x2dc.0 - 0x2dc.19 */
	 u_int32_t calib_var0;
/*---------------- DWORD[184] (Offset 0x2e0) ----------------*/
	/* Description -  */
	/* 0x2e0.0 - 0x2e0.19 */
	 u_int32_t ffe_tap_en_mask_in_process;
/*---------------- DWORD[185] (Offset 0x2e4) ----------------*/
	/* Description -  */
	/* 0x2e4.0 - 0x2e4.19 */
	 u_int32_t curr_errors_count;
/*---------------- DWORD[186] (Offset 0x2e8) ----------------*/
	/* Description -  */
	/* 0x2e8.0 - 0x2e8.19 */
	 u_int32_t grade;
/*---------------- DWORD[187] (Offset 0x2ec) ----------------*/
	/* Description -  */
	/* 0x2ec.0 - 0x2ec.19 */
	 u_int32_t shadow_rx_set_is_fine;
/*---------------- DWORD[188] (Offset 0x2f0) ----------------*/
	/* Description -  */
	/* 0x2f0.0 - 0x2f0.19 */
	 u_int32_t sum_of_pos_abs_val;
/*---------------- DWORD[189] (Offset 0x2f4) ----------------*/
	/* Description -  */
	/* 0x2f4.0 - 0x2f4.19 */
	 u_int32_t sum_of_neg_abs_val;
/*---------------- DWORD[190] (Offset 0x2f8) ----------------*/
	/* Description -  */
	/* 0x2f8.0 - 0x2f8.0 */
	 u_int8_t ffe_tap0_sign;
	/* Description -  */
	/* 0x2f8.1 - 0x2f8.1 */
	 u_int8_t ffe_tap1_sign;
	/* Description -  */
	/* 0x2f8.2 - 0x2f8.2 */
	 u_int8_t ffe_tap2_sign;
	/* Description -  */
	/* 0x2f8.3 - 0x2f8.3 */
	 u_int8_t ffe_tap3_sign;
	/* Description -  */
	/* 0x2f8.4 - 0x2f8.4 */
	 u_int8_t ffe_tap4_sign;
	/* Description -  */
	/* 0x2f8.5 - 0x2f8.5 */
	 u_int8_t ffe_tap5_sign;
	/* Description -  */
	/* 0x2f8.6 - 0x2f8.6 */
	 u_int8_t ffe_tap6_sign;
	/* Description -  */
	/* 0x2f8.7 - 0x2f8.7 */
	 u_int8_t ffe_tap7_sign;
	/* Description -  */
	/* 0x2f8.8 - 0x2f8.8 */
	 u_int8_t ffe_tap8_sign;
/*---------------- DWORD[191] (Offset 0x2fc) ----------------*/
	/* Description - must be the only field in the word */
	/* 0x2fc.0 - 0x2fc.7 */
	 u_int8_t ffe_tap0_abs_val;
/*---------------- DWORD[192] (Offset 0x300) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap0_abs_val */
	/* 0x300.0 - 0x300.7 */
	 u_int8_t ffe_tap1_abs_val;
/*---------------- DWORD[193] (Offset 0x304) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap1_abs_val */
	/* 0x304.0 - 0x304.7 */
	 u_int8_t ffe_tap2_abs_val;
/*---------------- DWORD[194] (Offset 0x308) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap2_abs_val */
	/* 0x308.0 - 0x308.7 */
	 u_int8_t ffe_tap3_abs_val;
/*---------------- DWORD[195] (Offset 0x30c) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap3_abs_val */
	/* 0x30c.0 - 0x30c.7 */
	 u_int8_t ffe_tap4_abs_val;
/*---------------- DWORD[196] (Offset 0x310) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap4_abs_val */
	/* 0x310.0 - 0x310.7 */
	 u_int8_t ffe_tap5_abs_val;
/*---------------- DWORD[197] (Offset 0x314) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap5_abs_val */
	/* 0x314.0 - 0x314.7 */
	 u_int8_t ffe_tap6_abs_val;
/*---------------- DWORD[198] (Offset 0x318) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap6_abs_val */
	/* 0x318.0 - 0x318.7 */
	 u_int8_t ffe_tap7_abs_val;
/*---------------- DWORD[199] (Offset 0x31c) ----------------*/
	/* Description - must be the only field in the word, must be sequential to ffe_tap7_abs_val */
	/* 0x31c.0 - 0x31c.7 */
	 u_int8_t ffe_tap8_abs_val;
/*---------------- DWORD[200] (Offset 0x320) ----------------*/
	/* Description -  */
	/* 0x320.0 - 0x320.19 */
	 u_int32_t fixed_polarity_rx_sets_counter;
/*---------------- DWORD[201] (Offset 0x324) ----------------*/
	/* Description -  */
	/* 0x324.0 - 0x324.19 */
	 u_int32_t temp2;
/*---------------- DWORD[202] (Offset 0x328) ----------------*/
	/* Description -  */
	/* 0x328.0 - 0x328.19 */
	 u_int32_t temp3;
/*---------------- DWORD[203] (Offset 0x32c) ----------------*/
	/* Description -  */
	/* 0x32c.0 - 0x32c.19 */
	 u_int32_t shadow_ffe_tap0;
/*---------------- DWORD[204] (Offset 0x330) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap0 */
	/* 0x330.0 - 0x330.19 */
	 u_int32_t shadow_ffe_tap1;
/*---------------- DWORD[205] (Offset 0x334) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap1 */
	/* 0x334.0 - 0x334.19 */
	 u_int32_t shadow_ffe_tap2;
/*---------------- DWORD[206] (Offset 0x338) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap2 */
	/* 0x338.0 - 0x338.19 */
	 u_int32_t shadow_ffe_tap3;
/*---------------- DWORD[207] (Offset 0x33c) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap3 */
	/* 0x33c.0 - 0x33c.19 */
	 u_int32_t shadow_ffe_tap4;
/*---------------- DWORD[208] (Offset 0x340) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap4 */
	/* 0x340.0 - 0x340.19 */
	 u_int32_t shadow_ffe_tap5;
/*---------------- DWORD[209] (Offset 0x344) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap5 */
	/* 0x344.0 - 0x344.19 */
	 u_int32_t shadow_ffe_tap6;
/*---------------- DWORD[210] (Offset 0x348) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap6 */
	/* 0x348.0 - 0x348.19 */
	 u_int32_t shadow_ffe_tap7;
/*---------------- DWORD[211] (Offset 0x34c) ----------------*/
	/* Description - must be sequential to shadow_ffe_tap7 */
	/* 0x34c.0 - 0x34c.19 */
	 u_int32_t shadow_ffe_tap8;
/*---------------- DWORD[212] (Offset 0x350) ----------------*/
	/* Description -  */
	/* 0x350.0 - 0x350.19 */
	 u_int32_t shadow_lctrl_input;
/*---------------- DWORD[213] (Offset 0x354) ----------------*/
	/* Description -  */
	/* 0x354.0 - 0x354.19 */
	 u_int32_t active_input_buffer;
/*---------------- DWORD[214] (Offset 0x358) ----------------*/
	/* Description -  */
	/* 0x358.0 - 0x358.19 */
	 u_int32_t iterations_counter;
/*---------------- DWORD[215] (Offset 0x35c) ----------------*/
	/* Description - 0-bath, 1-ones_ratio, 2-iet, 3-xor */
	/* 0x35c.0 - 0x35c.19 */
	 u_int32_t measure_method;
/*---------------- DWORD[216] (Offset 0x360) ----------------*/
	/* Description -  */
	/* 0x360.0 - 0x360.19 */
	 u_int32_t valid_center_iterations;
/*---------------- DWORD[217] (Offset 0x364) ----------------*/
	/* Description - Count rx set that are tested during rx_algo (space) */
	/* 0x364.0 - 0x364.19 */
	 u_int32_t tested_rx_sets_counter;
/*---------------- DWORD[218] (Offset 0x368) ----------------*/
	/* Description -  */
	/* 0x368.0 - 0x368.19 */
	 u_int32_t recover_low_threshold;
/*---------------- DWORD[219] (Offset 0x36c) ----------------*/
	/* Description -  */
	/* 0x36c.0 - 0x36c.19 */
	 u_int32_t mixer_offset1_jump_size;
/*---------------- DWORD[220] (Offset 0x370) ----------------*/
	/* Description -  */
	/* 0x370.0 - 0x370.19 */
	 u_int32_t input_buffer_to_config;
/*---------------- DWORD[221] (Offset 0x374) ----------------*/
	/* Description -  */
	/* 0x374.0 - 0x374.19 */
	 u_int32_t max_tap_offset1;
/*---------------- DWORD[222] (Offset 0x378) ----------------*/
	/* Description -  */
	/* 0x378.0 - 0x378.19 */
	 u_int32_t search_step_counter;
/*---------------- DWORD[223] (Offset 0x37c) ----------------*/
	/* Description -  */
	/* 0x37c.0 - 0x37c.19 */
	 u_int32_t phase_or_height;
/*---------------- DWORD[224] (Offset 0x380) ----------------*/
	/* Description -  */
	/* 0x380.0 - 0x380.19 */
	 u_int32_t eo_grade;
/*---------------- DWORD[225] (Offset 0x384) ----------------*/
	/* Description -  */
	/* 0x384.0 - 0x384.19 */
	 u_int32_t eo_center;
/*---------------- DWORD[226] (Offset 0x388) ----------------*/
	/* Description -  */
	/* 0x388.0 - 0x388.19 */
	 u_int32_t data_path_input_buffer;
/*---------------- DWORD[227] (Offset 0x38c) ----------------*/
	/* Description -  */
	/* 0x38c.0 - 0x38c.7 */
	 u_int8_t lowest_tick_in_search;
	/* Description -  */
	/* 0x38c.8 - 0x38c.15 */
	 u_int8_t highest_tick_in_search;
	/* Description - set when serdes set_phase needed */
	/* 0x38c.16 - 0x38c.16 */
	 u_int8_t set_phase_valid;
/*---------------- DWORD[228] (Offset 0x390) ----------------*/
	/* Description -  */
	/* 0x390.0 - 0x390.19 */
	 u_int32_t open_bath_during_space_counter;
/*---------------- DWORD[229] (Offset 0x394) ----------------*/
	/* Description -  */
	/* 0x394.0 - 0x394.19 */
	 u_int32_t all_best_baths_are_open_cause;
/*---------------- DWORD[230] (Offset 0x398) ----------------*/
	/* Description - 0-low to high. 1 - high to low */
	/* 0x398.0 - 0x398.19 */
	 u_int32_t bath_direction;
/*---------------- DWORD[231] (Offset 0x39c) ----------------*/
	/* Description - current best grade. input to similarity test subroutin */
	/* 0x39c.0 - 0x39c.19 */
	 u_int32_t curr_best_grade;
/*---------------- DWORD[232] (Offset 0x3a0) ----------------*/
	/* Description - current set grade. input to similarity test subroutine */
	/* 0x3a0.0 - 0x3a0.19 */
	 u_int32_t best_grade_candidate;
/*---------------- DWORD[233] (Offset 0x3a4) ----------------*/
	/* Description -  */
	/* 0x3a4.0 - 0x3a4.19 */
	 u_int32_t update_best_rx_set;
/*---------------- DWORD[234] (Offset 0x3a8) ----------------*/
	/* Description -  */
	/* 0x3a8.0 - 0x3a8.19 */
	 u_int32_t similar_bath_grades;
/*---------------- DWORD[235] (Offset 0x3ac) ----------------*/
	/* Description -  */
	/* 0x3ac.0 - 0x3ac.19 */
	 u_int32_t start_point_best_volt_eo_grade;
/*---------------- DWORD[236] (Offset 0x3b0) ----------------*/
	/* Description -  */
	/* 0x3b0.0 - 0x3b0.19 */
	 u_int32_t grade_is_ones_ratio;
/*---------------- DWORD[237] (Offset 0x3b4) ----------------*/
	/* Description -  */
	/* 0x3b4.0 - 0x3b4.19 */
	 u_int32_t best_is_ones_ratio;
/*---------------- DWORD[238] (Offset 0x3b8) ----------------*/
	/* Description -  */
	/* 0x3b8.0 - 0x3b8.19 */
	 u_int32_t voltage_eo_counter;
/*---------------- DWORD[239] (Offset 0x3bc) ----------------*/
	/* Description -  */
	/* 0x3bc.0 - 0x3bc.19 */
	 u_int32_t ones_ratio_counter;
/*---------------- DWORD[240] (Offset 0x3c0) ----------------*/
	/* Description -  */
	/* 0x3c0.0 - 0x3c0.19 */
	 u_int32_t check_similarity_test_results;
/*---------------- DWORD[241] (Offset 0x3c4) ----------------*/
	/* Description -  */
	/* 0x3c4.0 - 0x3c4.19 */
	 u_int32_t best_local_voltage_eo_valid;
/*---------------- DWORD[242] (Offset 0x3c8) ----------------*/
	/* Description -  */
	/* 0x3c8.0 - 0x3c8.19 */
	 u_int32_t voltage_eo_edge_found;
/*---------------- DWORD[243] (Offset 0x3cc) ----------------*/
	/* Description -  */
	/* 0x3cc.0 - 0x3cc.19 */
	 u_int32_t voltage_eo_intervals_loop_mode;
/*---------------- DWORD[244] (Offset 0x3d0) ----------------*/
	/* Description -  */
	/* 0x3d0.0 - 0x3d0.19 */
	 u_int32_t voltage_eo_intervals_counter;
/*---------------- DWORD[245] (Offset 0x3d4) ----------------*/
	/* Description - 0- no shift
1- main taps 0,2
2- main taps 0,1 */
	/* 0x3d4.0 - 0x3d4.19 */
	 u_int32_t ffe_tap_shift_left_mode;
/*---------------- DWORD[246] (Offset 0x3d8) ----------------*/
	/* Description -  */
	/* 0x3d8.0 - 0x3d8.19 */
	 u_int32_t phase_margin_is_low;
/*---------------- DWORD[247] (Offset 0x3dc) ----------------*/
	/* Description -  */
	/* 0x3dc.0 - 0x3f0.31 */
	 struct connectx4lx_sd_params_rx_set temp_shadow_ffe_taps;
/*---------------- DWORD[252] (Offset 0x3f0) ----------------*/
	/* Description -  */
	/* 0x3f0.0 - 0x42c.31 */
	 struct connectx4lx_local_best_rx_set link_maintenance_best_rx_set;
};

/* Description -   */
/* Size in bytes - 1216 */
struct connectx4lx_port_opamp_calibration_results {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4b8.31 */
	 struct connectx4lx_opamp_data opamp_data[302];
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_port_debug {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t PlaceHolder;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_eth_segment {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.13 */
	 u_int16_t mss;
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t l3cs_inner;
	/* Description -  */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t l4cs_inner;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t l3cs;
	/* Description -  */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t l4cs;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t inline_headers;
	/* Description -  */
	/* 0xc.16 - 0xc.25 */
	 u_int16_t inline_header_size;
};

/* Description -   */
/* Size in bytes - 4 */
struct connectx4lx_wqe_inline_header {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.9 */
	 u_int16_t byte_count;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t wqe_inline;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_gather_scatter_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.30 */
	 u_int32_t byte_count;
	/* Description -  */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t wqe_inline;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t local_key;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t local_address_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t local_address_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_srq_next {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t next_wqe_index;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t signature;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_signature {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t signature;
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_wqe_extended_atomic_fetch_add {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_4byte byte4;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_8byte byte8;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_16byte byte16;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_32byte byte32;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_64byte byte64;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_wqe_extended_atomic_fetch_add_128byte byte128;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_atomic_fetch_add {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t add_data_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t add_data_31_0;
};

/* Description -   */
/* Size in bytes - 512 */
union connectx4lx_wqe_extended_atomic_cmp_swap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte byte4;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte byte8;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte byte16;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte byte32;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte byte64;
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte byte126;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_atomic_cmp_swap {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t swap_data_63_32;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t swap_data_31_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t compare_data_63_32;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t compare_data_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_rdma_read {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 u_int64_t remote_va;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t remote_key;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_wqe_address_vector_ext {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t auto_1;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t auto_2;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.7 */
	 u_int8_t hop_limit;
	/* Description -  */
	/* 0x8.8 - 0x8.15 */
	 u_int8_t tclass;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.19 */
	 u_int32_t flow_label;
	/* Description -  */
	/* 0xc.20 - 0xc.27 */
	 u_int8_t my_gid_index1;
	/* Description -  */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t grh;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rgid_127_96;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t rgid_95_64;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t rgid_63_32;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t rgid_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_address_vector_basic {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t dca_key_63_32_qkey;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t dca_key_31_0;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t destination_qp_dct;
	/* Description - Used only in DC. Sent in "Connect" packet. */
	/* 0x8.24 - 0x8.27 */
	 u_int8_t reverse_sl;
	/* Description - Ext=1:AV global extension exist. Ext=0:AV global extension doesn't exist. */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t ext;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t rlid_15_0;
	/* Description -  */
	/* 0xc.16 - 0xc.23 */
	 u_int8_t slid;
	/* Description -  */
	/* 0xc.24 - 0xc.27 */
	 u_int8_t sl;
	/* Description -  */
	/* 0xc.28 - 0xc.31 */
	 u_int8_t static_rate;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_xrc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t xrc;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_mlx {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.16 - 0x4.19 */
	 u_int8_t sl;
	/* Description -  */
	/* 0x4.20 - 0x4.23 */
	 u_int8_t static_rate;
	/* Description - Force loopback
0-packet is sent to loopback\serdes according to Loopback Resolution
1-packet is sent to loopback only (used for opening QP's between application on the same guest before SM gives the link layer the LID) */
	/* 0x4.26 - 0x4.26 */
	 u_int8_t fl;
	/* Description - 1 - Don't add ICRC (raw packet, or ICRC calculated by driver)
0 - Replace last DW with ICRC */
	/* 0x4.27 - 0x4.27 */
	 u_int8_t ic;
	/* Description -  */
	/* 0x4.28 - 0x4.28 */
	 u_int8_t fc;
	/* Description - SLID MSB taken from:
0-(PortInfo - Per GVMI,Port)
1-packetSLID MSB taken from:
0-(PortInfo - Per GVMI,Port)
1-packet */
	/* 0x4.29 - 0x4.29 */
	 u_int8_t slr;
	/* Description -  */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t vl15;
	/* Description - When set VLAN should 
be transmitted with VLAN.
(Inserted if no vlan in the packet/ replaced by WQE.VLAN if vlan exists)


Ethertype is a configuration.
VLAN_ID is located in VLAN */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t v;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0x8.15 */
	 u_int16_t dmac_dlid_47_32;
	/* Description - VLAN to add to the packet. */
	/* 0x8.16 - 0x8.31 */
	 u_int16_t vlan;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t dmac_dlid_31_0;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_wqe_control {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.7 */
	 u_int8_t opcode;
	/* Description -  */
	/* 0x0.8 - 0x0.23 */
	 u_int16_t wqe_index;
	/* Description -  */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t opc_mod;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - WQE size in octwords (16 byte)
needed only for gather list size
valid values: 1-63 */
	/* 0x4.0 - 0x4.5 */
	 u_int8_t ds;
	/* Description -  */
	/* 0x4.8 - 0x4.31 */
	 u_int32_t qpn;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - interrupt bit */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t interrupt;
	/* Description - solicited event  */
	/* 0x8.1 - 0x8.1 */
	 u_int8_t se;
	/* Description - CQE and EQE control
00 - generate CQE only on error WQE completion. (note - per IB spec, if completion with error, generate event)
01 - No CQE, No EQE (even on error)
10 - Gen CQE on WQE completion (good or bad)
11 - Gen CQE and EQE (loccal Solicited event).
 */
	/* 0x8.2 - 0x8.3 */
	 u_int8_t ce;
	/* Description - nop bit
no supported in golan
 */
	/* 0x8.4 - 0x8.4 */
	 u_int8_t nop;
	/* Description - fence mode
000 - No Fence
001 - Initiator Small Fence.
Wait as long as there are WQEs that are currently locally in execution (doing gather / memop etc.)
010 - Fence - the WQE will start execution only after all previous Read/Atomic WQEs complete.
011 - Strong Ordering - when set, the WQE will be executed only after all previous WQEs have been executed. Can be set for RC WQEs only. .
100 - Fence and Initiator Small Fence.
101-111 - reserved */
	/* 0x8.5 - 0x8.7 */
	 u_int8_t fm;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t immediate_invalidation_key;
};

/* Description -   */
/* Size in bytes - 2304 */
struct connectx4lx_public_keys {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x900.31 */
	 struct connectx4lx_file_public_keys file_public_keys[8];
};

/* Description -   */
/* Size in bytes - 320 */
struct connectx4lx_image_signature {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - time based UUID for this signature */
	/* 0x0.0 - 0x10.31 */
	 u_int32_t signature_uuid[4];
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - The UUID of the keypair used for signing this file */
	/* 0x10.0 - 0x20.31 */
	 u_int32_t keypair_uuid[4];
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - The signature itself */
	/* 0x20.0 - 0x120.31 */
	 u_int32_t signature[64];
};

/* Description -   */
/* Size in bytes - 65536 */
struct connectx4lx_nv_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_nv_config_header header;
};

/* Description -   */
/* Size in bytes - 11392 */
struct connectx4lx_phy_uc_consts {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x280.31 */
	 struct connectx4lx_shared_consts shared_consts;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x2c80.31 */
	 struct connectx4lx_cluster_consts cluster;
};

/* Description -   */
/* Size in bytes - 320 */
struct connectx4lx_hw_boot_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Address on flash of manufacturing info */
	/* 0x0.0 - 0x0.23 */
	 u_int32_t manufacture_info_address;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - Address on flash of read only manufacturing info */
	/* 0x4.0 - 0x4.23 */
	 u_int32_t ro_manufacture_info_address;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - Address on flash of VPD info, copy 1 */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t vpd_info_address_1;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - Address on flash  of VPD info, copy 2 */
	/* 0xc.0 - 0xc.23 */
	 u_int32_t vpd_info_address_2;
	/* Description - True if the nic hac a circuitry that can indicate when the device is working on AUX power */
	/* 0xc.24 - 0xc.24 */
	 u_int8_t aux_power_indication_gpio_en;
	/* Description - Offset of Aux power indication GPIO */
	/* 0xc.25 - 0xc.31 */
	 u_int8_t aux_power_indication_gpio_offset;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Describes info about the vpd */
	/* 0x10.0 - 0x18.31 */
	 struct connectx4lx_vpd_eeprom_info vpd_eeprom;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - used to enable hw tracer for code coverage */
	/* 0x18.0 - 0x20.31 */
	 struct connectx4lx_code_coverage_control code_coverage;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0xe0.31 */
	 struct connectx4lx_pcie_cfg_shomron pcie_cfg;
/*---------------- DWORD[56] (Offset 0xe0) ----------------*/
	/* Description -  */
	/* 0xe0.0 - 0x100.31 */
	 struct connectx4lx_fw_image fw_image;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x110.31 */
	 struct connectx4lx_pcie_uc_consts pcie_uc_consts;
/*---------------- DWORD[68] (Offset 0x110) ----------------*/
	/* Description -  */
	/* 0x110.0 - 0x140.31 */
	 struct connectx4lx_pcie_phy_uc_config pcie_phy_uc_config;
};

/* Description -   */
/* Size in bytes - 2816 */
struct connectx4lx_hw_main_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x700.31 */
	 struct connectx4lx_port_serdes ports_serdes;
/*---------------- DWORD[448] (Offset 0x700) ----------------*/
	/* Description -  */
	/* 0x700.0 - 0x710.31 */
	 struct connectx4lx_power power;
/*---------------- DWORD[452] (Offset 0x710) ----------------*/
	/* Description -  */
	/* 0x710.0 - 0x714.31 */
	 struct connectx4lx_system_mng_shomron system_mng;
/*---------------- DWORD[453] (Offset 0x714) ----------------*/
	/* Description -  */
	/* 0x714.0 - 0x724.31 */
	 struct connectx4lx_thermal_config_shomron thermal;
/*---------------- DWORD[464] (Offset 0x740) ----------------*/
	/* Description - modules (QSFP/SFP/CXP) data base.
each module is /hardwire to the serdes and leds.
the local port mapping can be change via ini and cmd. */
	/* 0x740.0 - 0x7c0.31 */
	 struct connectx4lx_module_database module;
/*---------------- DWORD[496] (Offset 0x7c0) ----------------*/
	/* Description - Board I2C information */
	/* 0x7c0.0 - 0x840.31 */
	 struct connectx4lx_i2c_devices_db i2c_devices;
/*---------------- DWORD[528] (Offset 0x840) ----------------*/
	/* Description - Board GPIO information */
	/* 0x840.0 - 0x9b4.31 */
	 struct connectx4lx_ini_gpios gpios;
/*---------------- DWORD[621] (Offset 0x9b4) ----------------*/
	/* Description -  */
	/* 0x9b4.0 - 0xa24.31 */
	 struct connectx4lx_boards_management boards_management;
/*---------------- DWORD[649] (Offset 0xa24) ----------------*/
	/* Description -  */
	/* 0xa24.0 - 0xa64.31 */
	 struct connectx4lx_flex_nic_ini flex_nic_ini;
};

/* Description -   */
/* Size in bytes - 1216 */
struct connectx4lx_fw_boot_config {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_FW_VERSION fw_version;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - All multi_function pconfigurable parameters */
	/* 0x10.0 - 0x1c.31 */
	 struct connectx4lx_multi_function multi_function;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - All Transaction Layer flags */
	/* 0x1c.0 - 0x24.31 */
	 struct connectx4lx_pcie_transaction pcie_transaction;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - ini PCIe cfg space data */
	/* 0x24.0 - 0x64.31 */
	 struct connectx4lx_pci_cfg_ini pcie_cfg_data;
/*---------------- DWORD[272] (Offset 0x440) ----------------*/
	/* Description - power management (L1) configuration */
	/* 0x440.0 - 0x444.31 */
	 struct connectx4lx_pcie_power_management pcie_power_management;
/*---------------- DWORD[273] (Offset 0x444) ----------------*/
	/* Description - data later to be overridden by NV config */
	/* 0x444.0 - 0x484.31 */
	 struct connectx4lx_nv_config_boot nv_config;
};

/* Description -   */
/* Size in bytes - 4096 */
struct connectx4lx_fw_main_config {
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x4.2 */
	 u_int8_t log_max_num_rdbs;
	/* Description - size is 2^(value): 6-64B, 7- reserverd. A value > 5 causes extended RDBs to be mapped and increases memory consumption */
	/* 0x4.4 - 0x4.7 */
	 u_int8_t log_max_atomic_size;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_static_config static_config;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x70.31 */
	 struct connectx4lx_leds leds;
/*---------------- DWORD[48] (Offset 0xc0) ----------------*/
	/* Description -  */
	/* 0xc0.0 - 0x100.31 */
	 struct connectx4lx_customization customization;
/*---------------- DWORD[64] (Offset 0x100) ----------------*/
	/* Description -  */
	/* 0x100.0 - 0x280.31 */
	 struct connectx4lx_management management;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x300.31 */
	 struct connectx4lx_host_management host_management;
/*---------------- DWORD[192] (Offset 0x300) ----------------*/
	/* Description -  */
	/* 0x300.0 - 0x5d0.31 */
	 struct connectx4lx_phy_fw_main_config phy_fw_main_config;
/*---------------- DWORD[372] (Offset 0x5d0) ----------------*/
	/* Description - data later to be overridden ny NV config */
	/* 0x5d0.0 - 0x8d0.31 */
	 struct connectx4lx_nv_config_main nv_config;
/*---------------- DWORD[564] (Offset 0x8d0) ----------------*/
	/* Description - exprom configuration defaults values - stored as tlvs sractures with raw data */
	/* 0x8d0.0 - 0x9d0.31 */
	 struct connectx4lx_exprom_config exprom_config;
/*---------------- DWORD[628] (Offset 0x9d0) ----------------*/
	/* Description -  */
	/* 0x9d0.0 - 0x9d8.31 */
	 struct connectx4lx_secure_fw secure_fw;
};

/* Description -   */
/* Size in bytes - 320 */
struct connectx4lx_mfg_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.24 - 0x10.23 */
	 char psid[17];
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - When this bit is set, the GUIDs should be taken from the device_info node.
When this bit is cleared, the GUIDs should be taken from the mfg_info node. */
	/* 0x1c.0 - 0x1c.0 */
	 u_int8_t guids_override_en;
	/* Description - MFG_INFO section minor version */
	/* 0x1c.16 - 0x1c.23 */
	 u_int8_t minor_version;
	/* Description - MFG_INFO section major version */
	/* 0x1c.24 - 0x1c.31 */
	 u_int8_t major_version;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x60.31 */
	 struct connectx4lx_guids guids;
};

/* Description -   */
/* Size in bytes - 1024 */
struct connectx4lx_image_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - OEM lifecycle NVCONFIG files are signed */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t signed_vendor_nvconfig_files;
	/* Description - Mellanox lifecycle NVCONFIG files are signed */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t signed_mlnx_nvconfig_files;
	/* Description - Factory re-customizationflow is supported */
	/* 0x0.11 - 0x0.11 */
	 u_int8_t frc_supported;
	/* Description - Customer Support Tokens are supported */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t cs_tokens_supported;
	/* Description - This is a debug firmware */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t debug_fw;
	/* Description - [MCC/MCDA flow] if set, the SHA 256 digest is encrypted - enabled by default for secure_fw - cr-space not closed */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t signed_fw;
	/* Description - [MCC/MCDA flow] cr-space closed */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t secured_fw;
	/* Description - IMAGE_INFO section minor version */
	/* 0x0.16 - 0x0.23 */
	 u_int8_t minor_version;
	/* Description - IMAGE_INFO section major version */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t major_version;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x14.31 */
	 struct connectx4lx_FW_VERSION FW_VERSION;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x1c.31 */
	 struct connectx4lx_TRIPPLE_VERSION mic_version;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.24 - 0x34.23 */
	 char psid[17];
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.15 */
	 u_int16_t vsd_vendor_id;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.24 - 0x108.23 */
	 char vsd[209];
/*---------------- DWORD[66] (Offset 0x108) ----------------*/
	/* Description - image size parameters */
	/* 0x108.0 - 0x110.31 */
	 struct connectx4lx_image_size image_size;
/*---------------- DWORD[70] (Offset 0x118) ----------------*/
	/* Description - HW device(s) supported by this FW image.
0 means invalid entry.
For Golan A0, first entry should be 0x1ff
 */
	/* 0x118.0 - 0x128.31 */
	 u_int32_t supported_hw_id[4];
/*---------------- DWORD[74] (Offset 0x128) ----------------*/
	/* Description -  */
	/* 0x128.0 - 0x12c.31 */
	 u_int32_t ini_file_num;
/*---------------- DWORD[112] (Offset 0x1c0) ----------------*/
	/* Description - Product Version is the unified version of the FW and expansion ROM.
Format is defined by the packager.
When set to a non-empty string the FW update tool burns the image as a monolythic entity and refuses to update rom only or FW only. */
	/* 0x1c0.24 - 0x1d0.23 */
	 char prod_ver[17];
/*---------------- DWORD[192] (Offset 0x300) ----------------*/
	/* Description -  */
	/* 0x300.0 - 0x340.31 */
	 struct connectx4lx_module_versions module_versions;
};

/* Description -   */
/* Size in bytes - 512 */
struct connectx4lx_device_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t signature0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t signature1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t signature2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t signature3;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Format version for this struct */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t minor_version;
	/* Description - Format version for this struct */
	/* 0x10.8 - 0x10.16 */
	 u_int16_t major_version;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x60.31 */
	 struct connectx4lx_guids guids;
/*---------------- DWORD[27] (Offset 0x6c) ----------------*/
	/* Description -  */
	/* 0x6c.0 - 0x6c.15 */
	 u_int16_t vsd_vendor_id;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.24 - 0x140.23 */
	 char vsd[209];
/*---------------- DWORD[88] (Offset 0x160) ----------------*/
	/* Description -  */
	/* 0x160.0 - 0x1a0.31 */
	 struct connectx4lx_operation_key keys[4];
};

/* Description -   */
/* Size in bytes - 256 */
union connectx4lx_dtoc_pointers {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_toc_data device_info_0;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_toc_data nv_data_0;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_toc_data nv_data_1;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_toc_data fw_nv_log;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_toc_data mfg_info;
};

/* Description -   */
/* Size in bytes - 256 */
struct connectx4lx_reset_info {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - capability mask for reset database */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_reset_capabilities rst_cap_mask;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - versions for data structures that need to be maintained acrros different reset levels */
	/* 0x10.0 - 0x90.31 */
	 struct connectx4lx_rst_api_ver rst_api_ver;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_boot_record_dotan {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - SPI clock frequenct equal = E1ClockFreq / (2*(n+1))
where n is is value of this register

e.g.
oscillator freq = 156.25:
n=1 --> SPI clock=39MHz

e.g.
oscillator freq = 78.125:
n=0 --> SPI clock=39MHz
 */
	/* 0x0.0 - 0x0.3 */
	 u_int8_t flash_div;
	/* Description - if value=0, hot_reset request from px will be ignored */
	/* 0x0.4 - 0x0.4 */
	 u_int8_t hot_reset_enable;
	/* Description - core PLL PowerDown */
	/* 0x0.5 - 0x0.5 */
	 u_int8_t core_pd;
	/* Description - Core PLL bypass.
When set, pad and core clock are the same.

default is 0 */
	/* 0x0.6 - 0x0.6 */
	 u_int8_t core_bypass;
	/* Description - intended for live fish only
should be 0x0 otherwise. */
	/* 0x0.7 - 0x0.7 */
	 u_int8_t osc_strap_en;
	/* Description - PLL debug feature */
	/* 0x0.8 - 0x0.8 */
	 u_int8_t core_test;
	/* Description - i1clk will come from serdes instead of core PLL
will be used as chicken in case core PLL doesnt work */
	/* 0x0.9 - 0x0.9 */
	 u_int8_t i1clk_from_serdes;
	/* Description -  */
	/* 0x0.10 - 0x0.10 */
	 u_int8_t pvs_en;
	/* Description - CoreFreq = PadFreq * (F+1) / ((R+1) * (OD+1))
BWADJ must equal F. */
	/* 0x0.11 - 0x0.16 */
	 u_int8_t core_f;
	/* Description -  */
	/* 0x0.17 - 0x0.20 */
	 u_int8_t core_od;
	/* Description -  */
	/* 0x0.21 - 0x0.24 */
	 u_int8_t core_r;
	/* Description - BWADJ must equal F. */
	/* 0x0.25 - 0x0.30 */
	 u_int8_t core_bwadj;
	/* Description - Reserved for parity bit from the flash */
	/* 0x0.31 - 0x0.31 */
	 u_int8_t parity_reserved0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 0 - iopx will be powered down while perst is asserted.
1 - iopx will NOT be powered down while perst is asserted. */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t perst_action_iopx_powerdown_disable;
	/* Description - 0 - ALL resert will NOT occur on perst change.
1 - ALL resert will occur on perst change (rise and fall). */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t perst_action_all_reset;
	/* Description - //Choose which PLL to debug: lock on GPIO21 and clock on GPIO22
//[3:0] debug_pll_id
// 0-0000 - the PAD are controled by the regular GPIO logic
// 1-0001 - iop0 lock/clock 0
// 2-0010 - iop0 lock/clock 1
// 3-0011 - iop0 lock/clock 3
// 4-0100 - iop0 lock/clock 2
// 5-0101 - iop1 lock/clock 0
// 6-0110 - iop1 lock/clock 1
// 7-0111 - iop1 lock/clock 3
// 8-1000 - iop1 lock/clock 2
// 9-1001 - iopx lock/clock 0
//10-1010 - iopx lock/clock 1
//11-1011  - iopx lock/clock 3
//12-1100 - iopx lock/clock 2
//13-1101 - core pll input (rfslip)
//14-1110 - core pll output (rbslip)
//15-1111 - i1clk (rfslip | rbslip)

//[6:4] debug_pll_id
//000 - div by 1
//001 - div by 2
//010 - div by 4
//011 - div by 8 
//100- div by 16
//101- div by 64
//110 - div by 128
//111 - div by 512
 */
	/* 0x4.2 - 0x4.8 */
	 u_int8_t pll_debug;
	/* Description - bit[0] gpio weak pull (up/down) enable together with gpio_pull_enable
bit[1] jtag weak pull up/down enable */
	/* 0x4.9 - 0x4.10 */
	 u_int8_t gpio_pull_en;
	/* Description - CoreFreq = PadFreq * 2(F+1) / ((R+1)*(2^OD)) */
	/* 0x4.11 - 0x4.16 */
	 u_int8_t core_f_secondary;
	/* Description -  */
	/* 0x4.17 - 0x4.20 */
	 u_int8_t core_od_secondary;
	/* Description -  */
	/* 0x4.21 - 0x4.24 */
	 u_int8_t core_r_secondary;
	/* Description -  */
	/* 0x4.25 - 0x4.30 */
	 u_int8_t core_bwadj_secondary;
	/* Description - Reserved for parity bit from the flash */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t parity_reserved1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 2^mbist_group_size wrappers will run simultaniously */
	/* 0x8.0 - 0x8.3 */
	 u_int8_t mbist_group_size;
	/* Description - 2^mbist_unit_size units will run simultaniously */
	/* 0x8.4 - 0x8.6 */
	 u_int8_t mbist_unit_size;
	/* Description - Enable MBIST run */
	/* 0x8.7 - 0x8.7 */
	 u_int8_t mbist_en;
	/* Description -  */
	/* 0x8.8 - 0x8.12 */
	 u_int8_t dc2dc_stabilize;
	/* Description - when enabled, arrays will shutdown on FATAL. */
	/* 0x8.13 - 0x8.13 */
	 u_int8_t temp_fatal_array_shutdown_en;
	/* Description - When YU termal diode is "too hot", over_temp_shutdown GPIO will be set.
 */
	/* 0x8.14 - 0x8.14 */
	 u_int8_t yu_temp_gpio_en;
	/* Description - When YU termal diode is "too hot", chip will enter FATAL.
FATAL is graduall closure of all Serdes and clock gates. */
	/* 0x8.15 - 0x8.15 */
	 u_int8_t yu_temp_fatal_en;
	/* Description -  */
	/* 0x8.16 - 0x8.22 */
	 u_int8_t i2c_slave_addr;
	/* Description - i2c slave enable */
	/* 0x8.23 - 0x8.23 */
	 u_int8_t i2c_slave_en;
	/* Description - value 0 will disabe yu_fuse read/write requests to reach the fuse (in case Fuse is malfunctioning).
upon reads, data recieved will be hard wired zeros.
upon write, efuse_done will rise after 1 cycle. */
	/* 0x8.24 - 0x8.24 */
	 u_int8_t fuse_enable;
	/* Description - value 0 will disabe yu_fuse write requests to reach the fuse (to protect from writing in system)
upon write, efuse_done will rise after 1 cycle. */
	/* 0x8.25 - 0x8.25 */
	 u_int8_t fuse_write_enable;
	/* Description - the boot machine will wait 2^(this value) e1clk
by spec, need to wait ~100us for PLL to stabilize
With clock of 156.25MHz this gives = (2^17)*6.4 = ~1ms
With clock of 78.125MHz this gives ~2ms */
	/* 0x8.26 - 0x8.30 */
	 u_int8_t pll_stabilize;
	/* Description - Reserved for parity bit from the flash */
	/* 0x8.31 - 0x8.31 */
	 u_int8_t parity_reserved2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - logic bist pattern count (LSB)
MSB is in the extended boot record
When {MSB,LSB}=0 lbist will run 2^32 patterns */
	/* 0xc.0 - 0xc.15 */
	 u_int16_t lbist_pat_cnt_lsb;
	/* Description - adds (2^x - 1) relax cycles between captures of different units */
	/* 0xc.16 - 0xc.18 */
	 u_int8_t lbist_capture_delay;
	/* Description - value is the number of captures per pattern
value=0 means no capture state at all.
last pattern is controled by lbist_capture_last */
	/* 0xc.19 - 0xc.21 */
	 u_int8_t lbist_capture;
	/* Description - at each capture 2 selected units work together for gaining full chip coverage */
	/* 0xc.22 - 0xc.22 */
	 u_int8_t lbist_capt_2;
	/* Description - shift cycle every corepll clocks:
f = 2^x (f = 1,2,4,8,..,128)
0-1, 1-2, 2-4, 3-8... */
	/* 0xc.23 - 0xc.25 */
	 u_int8_t lbist_shift_clk_divider;
	/* Description - same as lbist_capture but only for the last pattern, part of the stop function.
if lbist_capture == 0 => lbist_capture_last = don't care
if lbist_capture != 0 => lbist_capture_last must be > 0
 */
	/* 0xc.27 - 0xc.29 */
	 u_int8_t lbist_capture_last;
	/* Description - Logic BIST enable */
	/* 0xc.30 - 0xc.30 */
	 u_int8_t lbist_en;
	/* Description - Reserved for parity bit from the flash */
	/* 0xc.31 - 0xc.31 */
	 u_int8_t parity_reserved3;
};

/* Description -   */
/* Size in bytes - 16 */
struct connectx4lx_icmd_ctrl {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Protection against accidently writing to contexts
To enable write 0xBADC0FFE */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t destructive_op_unlock;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - from the function */
	/* 0x4.0 - 0x4.15 */
	 u_int16_t gvmi;
	/* Description - when set limited icmd are supported */
	/* 0x4.16 - 0x4.16 */
	 u_int8_t public_icmd;
	/* Description - for commands with state machines */
	/* 0x4.24 - 0x4.31 */
	 u_int8_t state;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - external syndrome (cmdif syndrom for cmd_access_reg command) */
	/* 0x8.0 - 0x8.23 */
	 u_int32_t syndrome;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - set by user, cleared by firmware */
	/* 0xc.0 - 0xc.0 */
	 u_int8_t busy;
	/* Description -  0x00 OK
 0x01 INVALID_OPCODE
 0x02 INVALID_CMD
 0x03 OPERATIONAL_ERROR
 0x04 BAD_PARAM
 0x05 BUSY */
	/* 0xc.8 - 0xc.15 */
	 u_int8_t status;
	/* Description -     0x1000 = ICMD_OPCODE_MNG_MMINIT
  0x1001 = ICMD_OPCODE_MNG_GPIO_FUNC
  0x2000 = ICMD_OPCODE_PRE_DEFINE_MODULE_DB
  0x2800 = ICMD_OPCODE_GET_FW_DRIVER_VERSION
  0x2801 = ICMD_OPCODE_OCBB_RNDC_GET_CORE_API
  0x2802 = ICMD_OPCODE_OCBB_GET_PCI_API
  0x2803 = ICMD_OPCODE_READ_NCSI_RDMA_COUNTERS
  0x2804 = ICMD_OPCODE_CABLE_ERROR_GEN_EVENT
  0x2805 = ICMD_OPCODE_LED_CMD
  0x2806 = ICMD_READ_ICMC_TAGS_AND_INFO
  0x2807 = ICMD_OPCODE_OVONEL_MNG_INITIAL_CMD
  0x2810 = ICMD_OPCODE_LED_CONTROL_MAD
  0x2811 = ICMD_OPCODE_TEMP_WARN_GEN_EVENT
  0x2812 = ICMD_OPCODE_ENABLE_DISABLE_PORT
  0x2814 = ICMD_OPCODE_ASN1_FORCE_PORT_STATE
  0x2815 = ICMD_OPCODE_SET_STEERING_LOOPBACK
  0x2816 = ICMD_OPCODE_DROP_COUNTER_READ
  0x2817 = ICMD_OPCODE_PORT_ADMIN_STATE_MNG
  0x2820 = ICMD_OPCODE_INTERNAL_QUERY_CAP
  0x2821 = ICMD_OPCODE_ALLOWED_PFS_MADIFC
  0x2823 = ICMD_OPCODE_SYSPORT
  0x6001 = ICMD_OPCODE_PHY_UC_DO_CONTINUE
  0x6002 = ICMD_OPCODE_PHY_UC_DO_STEP
  0x6003 = ICMD_OPCODE_PHY_UC_SET_DEL_BP
  0x6004 = ICMD_OPCODE_PHY_UC_SET_GET_DATA
  0x6005 = ICMD_OPCODE_PHY_UC_GET_ARRAY_PROP
  0x6006 = ICMD_OPCODE_PHY_UC_GET_STATUS
  0x6007 = ICMD_OPCODE_PHY_ACTIVATE_RX_ADAP
  0x6008 = ICMD_OPCODE_PHY_UC_SET_GET_DATA_FIELD
  0x6009 = ICMD_OPCODE_PHY_UC_ACTIVATE_UC
  0x600b = ICMD_OPCODE_PHY_GET_LINK_STATUS
  0x600c = ICMD_OPCODE_PHY_OPEN_CLOSE_PORT
  0x600d = ICMD_OPCODE_PHY_PLL_VARACTOR_CALIB
  0x600e = ICMD_OPCODE_PHY_HALT_FSM
  0x600f = ICMD_OPCODE_PHY_SET_GET_TX_SD
  0x6010 = ICMD_OPCODE_PHY_SET_GET_RX_SD
  0x6011 = ICMD_OPCODE_PHY_TRANS_OR_SYNC
  0x6013 = ICMD_OPCODE_PHY_GET_CLEAR_COUNTERS
  0x6014 = ICMD_OPCODE_PHY_UPDATE_CALIB_VALS
  0x6015 = ICMD_OPCODE_PHY_GET_GRADE_INFO
  0x6016 = ICMD_OPCODE_PHY_SET_GET_PTAS
  0x6017 = ICMD_OPCODE_PHY_GET_PPAMP
  0x6018 = ICMD_OPCODE_PHY_GET_PPLL
  0x6019 = ICMD_OPCODE_PHY_GET_PDDR
  0x601a = ICMD_OPCODE_PHY_RUN_HYB_EYE_OPENER
  0x601b = ICMD_OPCODE_PHY_DESIGN_VER_IF
  0x601c = ICMD_OPCODE_RESTORE_PHY_REGISTERS
  0x601d = ICMD_OPCODE_PHY_MEASURE_FREQUENCY
  0x601e = ICMD_OPCODE_PHY_ACTIVATE_PLL
  0x8000 = ACCESS_ICM_LINE
  0x8001 = ACCESS_ICM_CTX
  0x8002 = ACCESS_HOST_MEM
  0x8003 = READ_Q_ENTRY
  0x8004 = GET_IRISC_HEAR_BEAT
  0x8005 = GET_BOOT_STAGE
  0x8006 = GET_LINK_LEDS
  0x8007 = GET_FW_VERSION
  0x8008 = READ_RX_SLICE_PACKET
  0x8009 = READ_G_RSE_SLICE_DESC
  0x8010 = READ_SX_WQ_BUFFER
  0x8011 = READ_ICM_TLB_LINE
  0x8012 = READ_ICM_DUMMY_ADDRESS
  0x8013 = DEBUG_FW_TRACER
  0x8014 = CABLE_PLUG_OUT_IN
  0x8015 = GET_ICM_RES_PROP
  0x8017 = GET_ICM_CTX_ADDR
  0x8018 = CHECK_SQPC_STATUS
  0x8019 = ALLOC_DEALLOC_RESOURCE
  0x801a = LOCK_UNLOCK
  0x801b = ICMD_DB_RECOVERY
  0x801c = ICMD_READ_ICMC_TAG
  0x8020 = ICMD_RW_GVMIX
  0x8021 = ICMD_ICMC_LOCKED_HISTOGRAM
  0x8022 = ICMD_DC_CONFIG
  0x8023 = ICMD_OPCODE_PUSH_DB
  0x8024 = GET_OPEN_RESOURCES
  0x8025 = RW_ESW
  0x8026 = ACCESS_REG_PMTU
  0x8027 = ICMD_OPCODE_ACCESS_REGISTER_PAOS
  0x8028 = ACCESS_REG_PPCNT
  0x8029 = ACCESS_REG_PTYS
  0x8030 = ICMD_OPCODE_ACCESS_REGISTER_SLRP
  0x8031 = ICMD_OPCODE_ACCESS_REGISTER_SLTP
  0x8032 = ICMD_OPCODE_ACCESS_REGISTER_SLRG
  0x8033 = ICMD_OPCODE_ACCESS_REGISTER_PTAS
  0x8034 = ICMD_OPCODE_ACCESS_REGISTER_PPAMP
  0x8035 = ICMD_OPCODE_ACCESS_REGISTER_PPLR
  0x8036 = ICMD_OPCODE_ACCESS_REGISTER_PLPC
  0x8037 = ICMD_OPCODE_ACCESS_REGISTER_PPLM
  0x8038 = ICMD_OPCODE_ACCESS_REGISTER_PPTT
  0x8039 = ICMD_OPCODE_ACCESS_REGISTER_PPRT
  0x8040 = ICMD_OPCODE_ACCESS_REGISTER_PPAOS
  0x802a = ACCESS_REG_PVLC
  0x8100 = DEBUG_PRINT_ICM
  0x8101 = GET_HEADER_CAPTURE
  0x8200 = ICMD_OPCODE_SET_GET_PORT_CNTR
  0x8201 = ICMD_OPCODE_GET_PF_CTX
  0x8202 = GET_PI_CI
  0x8300 = GET_FT_LIST
  0x8301 = GET_FT_INFO
  0x8302 = GET_FG_LIST
  0x8303 = GET_FG
  0x8304 = GET_FTE_LIST
  0x8305 = GET_FTE
  0x8306 = GET_STE_OPEN_RESOURCES
  0x8307 = GET_STE_RESOURCES_LIST
  0x8308 = READ_STE
  0x8309 = GET_STEERING_INFO
  0x830a = PARSE_ICM_ADDRESS
  0x830b = ICMD_OPCODE_DEBUG_LLDP
  0x830c = ICMD_OPCODE_GET_SET_LLDP_TLV
  0x830d = ICMD_OPCODE_DEBUG_MCTP_VND_PCI
  0x830e = ICMD_OPCODE_EXECUTE_FW_LOG
  0x830f = ICMD_OPCODE_PACKET_DROP
  0x8310 = GET_HIGHEST_INDEX
  0x8400 = ICMD_QUERY_CAPABILITIES
  0x8401 = ICMD_KDNET_CTRL
  0x8402 = ICMD_OPCODE_MH_SYNC
  0x8403 = ICMD_OPCODE_MH_SYNC_STATUS
  0x9001 = ICMD_ACCESS_REGISTER
  0x9002 = ICMD_OPCODE_NVCONF_RW_TLV_DEBUG
  0x9003 = ICMD_OPCODE_QUERY_VIRTUAL_MAC
  0x9004 = ICMD_OPCODE_SET_VIRTUAL_MAC
  0x9005 = ICMD_QUERY_WOL_ROL
  0x9006 = ICMD_SET_WOL_ROL
  0x9007 = ICMD_OCBB_INIT
  0x9008 = ICMD_OCBB_QUERY_HEADER_STATUS
  0x9009 = ICMD_OCBB_QUERY_ETOC_STATUS
  0x900a = ICMD_OCBB_SET_EVENT
  0x902b = ICMD_OPCODE_ACCESS_REGISTER_MLCR
  0xa000 = FW_SW_RESET
  0xb000 = READ_COMMAND
  0xa004 = ICMD_OPCODE_PMAOS_WRITE
  0xa005 = ICMD_OPCODE_PMAOS_QUERY
  0xa008 = ICMD_OPCODE_MNG_EMAD_MCIA
  0xc000 = READ_EQ4TYPE
  0xc001 = READ_SPECIAL_QPS
  0xc002 = SET_PORT_SNIFFER
  0xc003 = GET_PORT_SNIFFER
  0xc004 = ICMD_OPCODE_WRITE_CC_LOG
  0xc005 = ICMD_OPCODE_CONFIG_CC
  0xc006 = ICMD_OPCODE_WRITE_DC_CNAK_LID
  0xc007 = ICMD_OPCODE_UPDATE_RQ_CI
  0xc008 = ICMD_OPCODE_UD_TO_RAW
  0xf000 = ICMD_OPCODE_PHY_NEGO_CTRL
  0xf001 = ICMD_OPCODE_EYE_OPENER_READ
  0xf002 = CLEAR_RXT_CHK_CAUSES
  0xf003 = SET_ITRACE
  0xf004 = ICMD_OPCODE_INIT_OCSD
  0xf005 = ICMD_OPCODE_PHY_VER_OVERWRITE
  0xf006 = ICMD_OPCODE_PCIE_TOOLS_POINTERS
  0xf007 = ICMD_OPCODE_CODE_COVERAGE
  0xf008 = ICMD_OPCODE_CODE_COVERAGE_READ
  0xf009 = ICMD_OPCODE_PCIE_VER_DATA
  0xf00a = ICMD_OPCODE_VER_DATA
  0xf00b = ICMD_STOP_TOGGLER
  0xf00c = ICMD_ERROR_FLOW_TRIGGER
  0xf010 = ICMD_OPCODE_GREPPER
  0xf011 = ICMD_OPCODE_STANDBY
  0xf012 = ICMD_OPCODE_FLR_DEBUG
  0xf013 = ICMD_OPCODE_DCR_LL_TRVRS
  0xf014 = ICMD_OPCODE_NEXT_DCR
  0xf015 = ICMD_OPCODE_GENERAL_FAULT_INJECTOR
  0xf016 = ICMD_OPCODE_ACCESS_STEERING_ROOT
  0xf017 = ICMD_OPCODE_GET_STEERING_TABLE_INFO
  0xf018 = ICMD_OPCODE_GET_GVMI_VIA_VSEC
  0xf019 = ICMD_OPCODE_XPORT_CONFIG
  0xf01a = ICMD_OPCODE_MINI_FLOW_ACTIVATOR
  0xf01b = ICMD_OPCODE_ENABLE_TOOLPF
  0xf01c = ICMD_OPCODE_SET_TOOLPF_TRACER;\  0xf01d = ICMD_OPCODE_RW_GVMI_FW_CONTEXT;\  0xa100 = ICMD_OPCODE_SMBUS_MASTER_ACCESS
  0xa102 = ICMD_OPCODE_MNG_SMBUS_GW_FREQ
  0xa200 = ICMD_OPCODE_FPGA_FLEX_NIC_CTRL
  0xff59 = ICMD_OPCODE_GVMI_RL_CTX_IX
  0xff60 = ICMD_OPCODE_CABLE_INFO
  0xff61 = ICMD_OPCODE_GEN_ASSERT
  0xff62 = ICMD_OPCODE_DEBUG_PF_MAC
  0xff63 = ICMD_OPCODE_SET_OC_INT_CAUSE
  0xff65 = ICMD_OPCODE_PMLP_QUERY
  0x2808 = ICMD_OPCODE_INIT_NCSI
  0x2809 = ICMD_OPCODE_INJECT_NCSI
  0xff66 = ICMD_OPCODE_READ_WRITE_VARB_CTX
  0xff67 = ICMD_OPCODE_GET_PACKET_PACING_DEBUG_INFO
  0xff68 = ICMD_OPCODE_DEBUG_CALC_SQN
  0xff69 = ICMD_OPCODE_DETECT_GVMI */
	/* 0xc.16 - 0xc.31 */
	 u_int16_t opcode;
};

/* Description -   */
/* Size in bytes - 768 */
union connectx4lx_icmd_cmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_cmd_as_dwords as_dwords;
	/* Description -  */
	/* 0x0.0 - 0x60.31 */
	 struct connectx4lx_icmd_access_icm_ctx access_icm_ctx;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_get_pi_ci get_pi_ci;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_access_icm_line access_icm_line;
	/* Description -  */
	/* 0x0.0 - 0x128.31 */
	 struct connectx4lx_icmd_access_host_mem access_host_mem;
	/* Description -  */
	/* 0x0.0 - 0x20c.31 */
	 struct connectx4lx_icmd_read_q_entry read_q_entry;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_get_irisc_heart_beat get_irisc_heart_beat;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_get_boot_stage get_boot_stage;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_get_link_leds get_link_leds;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_icmd_get_fw_info get_fw_info;
	/* Description -  */
	/* 0x0.0 - 0x20c.31 */
	 struct connectx4lx_icmd_read_rx_slice_packet read_rx_slice_packet;
	/* Description -  */
	/* 0x0.0 - 0x108.31 */
	 struct connectx4lx_icmd_read_g_rse_slice_desc read_g_rse_slice_desc;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_fw_reset fw_reset;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_allowed_madifc_on_all_pfs allowed_pfs_madifc;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_print_icm debug_print_icm;
	/* Description -  */
	/* 0x0.0 - 0xc0.31 */
	 struct connectx4lx_icmd_header_capture header_capture;
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_icmd_read_sx_wq_buffer read_sx_wq_buffer;
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_icmd_access_cmdq icmd_access_cmdq;
	/* Description -  */
	/* 0x0.0 - 0x104.31 */
	 struct connectx4lx_eqn4type eqn4type;
	/* Description -  */
	/* 0x0.0 - 0x104.31 */
	 struct connectx4lx_icmd_special_qps special_qps;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_set_port_sniffer set_port_sniffer;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_port_sniffer get_port_sniffer;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_congestion_log congestion_log;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_write_dc_cnak_lid write_dc_cnak_lid;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_update_rq_ci update_rq_ci;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_ud_to_raw ud_to_raw;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_config_cc config_cc;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_read_icm_tlb_line read_icm_tlb_line;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_read_icm_dummy_addr read_icm_dummy_addr;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_get_open_resources get_open_resources;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_get_highest_index get_highest_index;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_debug_fw_tracer debug_fw_tracer;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_execute_fw_log execute_fw_log;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_packet_drop packet_drop;
	/* Description -  */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_icmd_grepper grepper;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_standby standby;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_cable_plug_out_in cable_plug_out_in;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_cable_info cable_info;
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_icmd_emad_mcia emad_mcia;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_icmd_get_icm_res_prop get_icm_res_prop;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_icmd_alloc_dealloc_resource alloc_dealloc_resource;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_eye_opening_read_st eye_opening_read;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_phy_nego_ctrl_st phy_nego_ctrl;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_icmd_get_icm_ctx_addr get_icm_ctx_addr;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 union connectx4lx_icmd_query_capabilities query_capabilities;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_kdnet_ctrl kdnet_ctrl;
	/* Description -  */
	/* 0x0.0 - 0x128.31 */
	 struct connectx4lx_icmd_generic_access_register access_register;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_check_sqpc_status check_sqpc_status;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_lock_unlock_resource lock_unlock_resource;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_check_sqpc_status db_recovery;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_access_icm_line read_icmc_tag;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_read_icmc_tags_and_info read_icmc_tags_and_info;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_dc_config dc_config;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_itrace set_itrace;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_init_ncsi init_ncsi;
	/* Description -  */
	/* 0x0.0 - 0x22c.31 */
	 struct connectx4lx_inject_ncsi inject_ncsi;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_init_ocsd init_ocsd;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_phy_ver_overwrite phy_ver_overwrite;
	/* Description - pointers to some tables in pciex scratchpad, for tools usage */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_pcie_tools_pointers pcie_tools_pointers;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_gen_eqe gen_eqe;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_rw_gvmix rw_gvmix;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_esw rw_esw;
	/* Description - used to enable/query HW tracer for code coverage */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_code_coverage_control code_coverage;
	/* Description - Read code coverage bitmask from HW buffer */
	/* 0x0.0 - 0x108.31 */
	 struct connectx4lx_icmd_code_coverage_read code_coverage_read;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_stop_toggler stop_toggler;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_error_flow_trigger error_flow_trigger;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_pcie_ver_data pcie_ver_data;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_ver_data ver_data;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_push_db push_db;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_flr_debug flr_debug;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_dcr_ll_trvrs dcr_ll_trvrs;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_dcr_ll_next_dcr_list dcr_ll_next_dcr_list;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_phy_update_calib_vals phy_update_calib_vals;
	/* Description -  */
	/* 0x0.0 - 0x44.31 */
	 struct connectx4lx_icmd_access_steering_root access_steering_root;
	/* Description -  */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_steering_table_info get_steering_table_info;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_get_gvmi_via_vsec get_gvmi_via_vsec;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_xport_xonfig xport_config;
	/* Description -  */
	/* 0x0.0 - 0x140.31 */
	 struct connectx4lx_icmd_smbus_master_access smbus_master_access;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_mng_smbus_freq smbus_gw_freq;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_fpga_flex_nic_ctrl fpga_flex_nic_ctrl;
	/* Description -  */
	/* 0x0.0 - 0x110.31 */
	 struct connectx4lx_icmd_nvcfg_rw_tlv nv_ram_rw_tlv;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_set_toolpf_tracer set_toolpf_tracer;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_enable_tools_pf enable_tools_pf;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_icmd_access_register_paos access_register_paos;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_slrp access_register_slrp;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_icmd_access_register_sltp access_register_sltp;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_icmd_access_register_slrg access_register_slrg;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_access_register_pptt access_register_pptt;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_icmd_access_register_pprt access_register_pprt;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_icmd_access_register_ppaos access_register_ppaos;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_ptas access_register_ptas;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_ppamp access_register_ppamp;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_pplr access_register_pplr;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_pplm access_register_pplm;
	/* Description -  */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_access_register_plpc access_register_plpc;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_access_register_mlcr access_register_mlcr;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_icmd_access_register_pmtu access_register_pmtu;
	/* Description -  */
	/* 0x0.0 - 0x44.31 */
	 struct connectx4lx_icmd_access_reg_ptys access_register_ptys;
	/* Description -  */
	/* 0x0.0 - 0x4c.31 */
	 struct connectx4lx_icmd_gpio_func gpio_func;
	/* Description - MMINIT - returns fields read from the cable */
	/* 0x0.0 - 0x5c.31 */
	 struct connectx4lx_icmd_mminit mminit;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_temp_hook temp_hook;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_sspl_hook set_slot_pci_limit_hook;
	/* Description - PMAOS - Ports Module Administrative and Operational St     atus Register */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_pmaos pmaos;
	/* Description -  */
	/* 0x0.0 - 0x104.31 */
	 struct connectx4lx_icmd_phy_activate_rx_adap phy_activate_rx_adap;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_icmd_phy_get_link_status phy_get_link_status;
	/* Description - Inputs: local_port, port_type, speed_en, link_mode, Verify fsm_ps = 0 */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_open_close_port phy_open_close_port;
	/* Description - Inputs: local_port, port_type, fsm_mask, halt_mode, all_ports */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_halt_fsm phy_halt_fsm;
	/* Description - Inputs: ib_port, local_port, port_type, lanes_mask, user set */
	/* 0x0.0 - 0x38.31 */
	 struct connectx4lx_icmd_phy_set_get_tx_sd phy_set_get_tx_sd;
	/* Description - Inputs: ib_port, local_port, port_type, lanes_mask, ffe taps, input buffer */
	/* 0x0.0 - 0x54.31 */
	 struct connectx4lx_icmd_phy_set_get_rx_sd phy_set_get_rx_sd;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern phy_trans_or_sync_on_ptrn;
	/* Description -  */
	/* 0x0.0 - 0x118.31 */
	 struct connectx4lx_icmd_phy_get_clear_counters phy_get_clear_counters;
	/* Description -  */
	/* 0x0.0 - 0xa4.31 */
	 struct connectx4lx_icmd_phy_get_grade_info phy_get_grade_info;
	/* Description - Set or get Phy Tuning Algorithm Settings */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_phy_set_get_ptas phy_set_get_ptas;
	/* Description - Port Phy opAMP data */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_pamp_reg phy_get_ppamp;
	/* Description - Phy PLL status register */
	/* 0x0.0 - 0x28.31 */
	 struct connectx4lx_phy_reg_ppll phy_get_ppll;
	/* Description - Phy Port Debug DataBase */
	/* 0x0.0 - 0x104.31 */
	 struct connectx4lx_icmd_phy_get_pddr phy_get_pddr;
	/* Description - release the step mode */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_uc_do_continue phy_uc_do_continue;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_uc_do_step phy_uc_do_step;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_phy_uc_set_del_bp phy_uc_set_del_bp;
	/* Description -  */
	/* 0x0.0 - 0xc4.31 */
	 struct connectx4lx_icmd_phy_uc_set_get_data phy_uc_set_get_data;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_phy_uc_set_get_data_field phy_uc_set_get_data_field;
	/* Description -  */
	/* 0x0.0 - 0x2c.31 */
	 struct connectx4lx_icmd_phy_uc_get_array_prop phy_uc_get_array_prop;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_phy_uc_get_status phy_uc_get_status;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_phy_uc_activate_uc phy_uc_activate_uc;
	/* Description - varactor calibration algorithm run */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_icmd_varac_calib varactor_calib;
	/* Description - run hybrid eye opener DataBase */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_run_hyb_eye_opener run_hyb_eye_opener;
	/* Description - get phy design verification IF */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_phy_design_ver_if phy_design_ver_if;
	/* Description - restore all access registers to thier default values */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_restore_phy_registers restore_phy_registers;
	/* Description - performs frequency measurement */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_measure_frequency measure_frequency;
	/* Description - performs frequency measurement */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_activate_pll activate_pll;
	/* Description -  */
	/* 0x0.0 - 0x10c.31 */
	 struct connectx4lx_icmd_access_register_ppcnt access_register_ppcnt;
	/* Description -  */
	/* 0x0.0 - 0x18.31 */
	 struct connectx4lx_icmd_set_get_port_cntr set_get_port_counter;
	/* Description - Verification tool to get_set LED pattern */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_led_cmd led_cmd;
	/* Description -  */
	/* 0x0.0 - 0x48.31 */
	 struct connectx4lx_icmd_led_control_mad led_control_mad;
	/* Description - FTE dump tool: Flow Table list */
	/* 0x0.0 - 0x10.31 */
	 union connectx4lx_icmd_get_ft_list get_ft_list;
	/* Description - FTE dump tool: Flow Table info */
	/* 0x0.0 - 0x10.31 */
	 union connectx4lx_icmd_get_ft_info get_ft_info;
	/* Description - FTE dump tool: Flow Group list */
	/* 0x0.0 - 0x10.31 */
	 union connectx4lx_icmd_get_fg_list get_fg_list;
	/* Description - FTE dump tool: Flow Group info */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_icmd_get_fg get_fg;
	/* Description - FTE dump tool: Flow Table Entry list */
	/* 0x0.0 - 0x10.31 */
	 union connectx4lx_icmd_get_fte_list get_fte_list;
	/* Description - FTE dump tool: Flow Table Entry info */
	/* 0x0.0 - 0x300.31 */
	 union connectx4lx_icmd_get_fte get_fte;
	/* Description - STE dump tool: STE opened resources */
	/* 0x0.0 - 0x300.31 */
	 union connectx4lx_icmd_get_ste_open_resources get_ste_open_resources;
	/* Description - STE dump tool: STE resources list */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_icmd_get_ste_resources_list get_ste_resources_list;
	/* Description - STE dump tool: STE dump */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_read_ste read_ste;
	/* Description - steering info for debug */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_get_steering_info steering_info;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_parse_icm_address parse_icm_address;
	/* Description -  */
	/* 0x0.0 - 0x14.31 */
	 struct connectx4lx_icmd_access_register_pvlc access_register_pvlc;
	/* Description - injects faults for verification */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_general_fault_injector general_fault_injector;
	/* Description - flicks_enable_disable and cache invalidation */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_mini_flow_activator mini_flow_activator;
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_debug_calc_sqn calc_sqn;
	/* Description -  */
	/* 0x0.0 - 0x44.31 */
	 struct connectx4lx_icmd_read_write_varb_ctx read_write_varb_ctx;
	/* Description - generate assert */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_gen_assert gen_assert;
	/* Description - set oc int */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_set_oc_int set_oc_int;
	/* Description - get fw driver version */
	/* 0x0.0 - 0x50.31 */
	 struct connectx4lx_icmd_get_fw_driver_version get_fw_driver_ver;
	/* Description -  */
	/* 0x0.0 - 0x24.31 */
	 struct connectx4lx_icmd_pmlp_query pmlp_query;
	/* Description -  */
	/* 0x0.0 - 0x3c.31 */
	 struct connectx4lx_icmd_pre_define_module_db pre_define_module_db;
	/* Description - call ocbb apis */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_ocbb_rndc_get_core_api ocbb_rndc_get_core_api;
	/* Description - read rdma counters */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_read_ncsi_rdma_counters read_ncsi_rdma_counters;
	/* Description - call ocbb pci apis */
	/* 0x0.0 - 0x30.31 */
	 struct connectx4lx_icmd_ocbb_get_pci_api ocbb_get_pci_api;
	/* Description - vport_info or vport_shadow */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_get_pf_ctx get_pf_ctx;
	/* Description - query virtual mac */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_query_virtual_mac_out query_virtual_mac;
	/* Description - set virtual mac */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_set_virtual_mac_in set_virtual_mac;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_set_wol_rol_out query_wol_rol;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_set_wol_rol_in set_wol_rol;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_ocbb_init_in ocbb_init;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_ocbb_query_etoc_stats_out ocbb_query_header_status;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_icmd_ocbb_query_header_stats_out ocbb_query_etoc_status;
	/* Description -  */
	/* 0x0.0 - 0xc.31 */
	 struct connectx4lx_icmd_ocbb_set_event ocbb_set_event;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_set_get_debug_pf_mac debug_pf_mac;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_icmd_access_register_nodnic_queue_info nodnic_queue_info;
	/* Description -  */
	/* 0x0.0 - 0x120.31 */
	 struct connectx4lx_icmd_lldp_debug lldp_debug;
	/* Description -  */
	/* 0x0.0 - 0x90.31 */
	 struct connectx4lx_icmd_lldp_set_get_tlv lldp_set_get_tlv;
	/* Description -  */
	/* 0x0.0 - 0x110.31 */
	 struct connectx4lx_icmd_mctp_vnd_pci_debug mctp_vnd_pci_debug;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_cable_error_gen_event cable_error_gen;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_temp_warn_gen_event temp_warn_gen;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc detect_gvmi_in_hw;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_internal_query_cap internal_query_cap;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_map_event_eq map_event_eq;
	/* Description -  */
	/* 0x0.0 - 0x64.31 */
	 struct connectx4lx_icmd_get_packet_pacing_debug_info get_packet_pacing_debug_info;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_icmd_port_admin_state_mng port_admin_state_mng;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_asn1_force_port_state asn1_force_port_state;
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_icmd_mh_sync mh_sync;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_icmd_rw_gvmi_fw_ctx rw_gvmi_fw_ctx;
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 struct connectx4lx_icmd_drop_counter_read drop_counter_read;
	/* Description - operate sysport to send packet */
	/* 0x0.0 - 0x300.31 */
	 struct connectx4lx_icmd_sysport sysport;
	/* Description -  */
	/* 0x0.0 - 0x8.31 */
	 struct connectx4lx_icmd_get_gvmi_rl_ctx_ix get_gvmi_rl_ctx_ix;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_sw_cqe_sigerr {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rsvd_9;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rsvd_8;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rsvd_7;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rsvd_6;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t expected_trans_sig;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t actual_trans_sig;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t expected_ref_tag;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t actual_ref_tag;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.15 */
	 u_int16_t rsvd_5;
	/* Description -  */
	/* 0x20.16 - 0x20.31 */
	 u_int16_t syndrome;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t mkey;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t sig_err_byte_h;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t sig_err_byte_l;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t rsvd_4;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t rsvd_3;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x38.24 - 0x38.31 */
	 u_int8_t rsvd_2;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t owner;
	/* Description -  */
	/* 0x3c.1 - 0x3c.3 */
	 u_int8_t rsvd_0;
	/* Description -  */
	/* 0x3c.4 - 0x3c.7 */
	 u_int8_t opcode;
	/* Description -  */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t signature;
	/* Description -  */
	/* 0x3c.16 - 0x3c.31 */
	 u_int16_t rsvd_1;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_sw_cqe_resize {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t rsvd_14;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rsvd_13;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rsvd_12;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rsvd_11;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rsvd_10;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t rsvd_9;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t rsvd_8;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t rsvd_7;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x24.31 */
	 u_int32_t rsvd_6;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t rsvd_5;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t rsvd_4;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t rsvd_3;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t timestamp_h;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x38.31 */
	 u_int32_t timestamp_l;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x3c.31 */
	 u_int32_t rsvd_2;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t owner;
	/* Description -  */
	/* 0x3c.1 - 0x3c.3 */
	 u_int8_t rsvd_1;
	/* Description -  */
	/* 0x3c.4 - 0x3c.7 */
	 u_int8_t opcode;
	/* Description -  */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t signature;
	/* Description -  */
	/* 0x3c.16 - 0x3c.31 */
	 u_int16_t rsvd_0;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_sw_cqe_error {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x0.15 */
	 u_int16_t wqe_id;
	/* Description -  */
	/* 0x0.16 - 0x0.31 */
	 u_int16_t rsvd_14;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description -  */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t rsvd_13;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description -  */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t rsvd_12;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description -  */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t rsvd_11;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x14.31 */
	 u_int32_t rsvd_10;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.0 - 0x18.31 */
	 u_int32_t rsvd_9;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x1c.31 */
	 u_int32_t rsvd_8;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x20.31 */
	 u_int32_t rsvd_7;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x20.23 */
	 u_int32_t srq_num;
	/* Description -  */
	/* 0x20.24 - 0x20.31 */
	 u_int8_t rsvd_6;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description -  */
	/* 0x24.0 - 0x28.31 */
	 u_int32_t rsvd_5;
/*---------------- DWORD[10] (Offset 0x28) ----------------*/
	/* Description -  */
	/* 0x28.0 - 0x2c.31 */
	 u_int32_t rsvd_4;
/*---------------- DWORD[11] (Offset 0x2c) ----------------*/
	/* Description -  */
	/* 0x2c.0 - 0x30.31 */
	 u_int32_t byte_cnt;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x34.31 */
	 u_int32_t rsvd_2;
/*---------------- DWORD[13] (Offset 0x34) ----------------*/
	/* Description -  */
	/* 0x34.0 - 0x34.7 */
	 u_int8_t syndrome;
	/* Description -  */
	/* 0x34.8 - 0x34.15 */
	 u_int8_t vendor_error_syndrome;
	/* Description -  */
	/* 0x34.16 - 0x34.19 */
	 u_int8_t rsvd_1;
	/* Description -  */
	/* 0x34.20 - 0x34.23 */
	 u_int8_t hw_syndrome_type;
	/* Description -  */
	/* 0x34.24 - 0x34.31 */
	 u_int8_t vendor_hw_syndrome;
/*---------------- DWORD[14] (Offset 0x38) ----------------*/
	/* Description -  */
	/* 0x38.0 - 0x38.23 */
	 u_int32_t qpn;
	/* Description -  */
	/* 0x38.24 - 0x38.31 */
	 u_int8_t swqe_opcode_drop_cntr;
/*---------------- DWORD[15] (Offset 0x3c) ----------------*/
	/* Description -  */
	/* 0x3c.0 - 0x3c.0 */
	 u_int8_t owner;
	/* Description -  */
	/* 0x3c.1 - 0x3c.1 */
	 u_int8_t se;
	/* Description -  */
	/* 0x3c.2 - 0x3c.3 */
	 u_int8_t rsvd_0;
	/* Description -  */
	/* 0x3c.4 - 0x3c.7 */
	 u_int8_t rwqe_opcode;
	/* Description -  */
	/* 0x3c.8 - 0x3c.15 */
	 u_int8_t signature;
	/* Description -  */
	/* 0x3c.16 - 0x3c.31 */
	 u_int16_t wqe_counter;
};

/* Description -   */
/* Size in bytes - 128 */
struct connectx4lx_sw_cqe_128b {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_grh_inline_data grh_inline_data;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description - 64B CQE */
	/* 0x40.0 - 0x80.31 */
	 struct connectx4lx_sw_cqe_64b cqe_64b;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_itoc_entry {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.2 - 0x0.23 */
	 u_int32_t size;
	/* Description - Section ID Section Type DESCRIPTION
0x1 BOOT_CODE FW loader code
0x2 PCI_CODE Code that is required to raise PCIe link.
0x3 MAIN_CODE All non-PCIe FW code
0x8 HW_BOOT_CFG Initial values for the PCI related registers
0x9 HW_MAIN_CFG Initial values for all other registers 
0x10 IMAGE_INFO Management data for the burning tool. See 'Image Info Section' chapter in the Mellanox Flash Programming Application Note
0x11 FW_BOOT_CFG Initial values for user set-able hi level non-hardware related settings, such as number of physical functions
(optional)
0x12 FW_MAIN_CFG Initial values for user set-able hi level non-hardware related settings.
(optional)
0x18 ROM_CODE PXE/Boot over IB code. 
0x30 DBG_LOG_MAP FW logger 'index to string' map. The map is in ASCI text. Format is TBD.
                                          PARAM0 in the iTOC specifies the compression method of this sector:
                                          0. Uncompressed
                                          1. Zlib compress2()
                                          2. LZMA
                                          Others - Reserved 
0x31 DBG_FW_INI The Ini file used in the image generation. The PARAM0 applies the same as in  DBG_LOG_MAP section type.
0x32 DBG_FW_PARAMS FW settable parameters. ASCII text. Format is TBD. The PARAM0 applies the same as in  DBG_LOG_MAP section type.
0xff END_MARKER A type of 0xff marks the end of the iTOC entries array. It is recommended to leave the unused part of the iTOC section blank (that is, 0xff in all unused bytes)
All other values Reserved 
 */
	/* 0x0.24 - 0x0.31 */
	 u_int8_t type;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - if partition type is code or ini then the load address is in here */
	/* 0x4.0 - 0x4.29 */
	 u_int32_t param0;
	/* Description - When this bit is set, Data within the section is protected by per-line crc. See yu.flash.replacement.crc_en */
	/* 0x4.30 - 0x4.30 */
	 u_int8_t cache_line_crc;
	/* Description - When this bit is set, image is zipped */
	/* 0x4.31 - 0x4.31 */
	 u_int8_t zipped_image;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - if partition type is code then the jump address is in here */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t param1;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description -  */
	/* 0x14.2 - 0x14.30 */
	 u_int32_t flash_addr;
	/* Description -  */
	/* 0x14.31 - 0x14.31 */
	 u_int8_t relative_addr;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description -  */
	/* 0x18.0 - 0x18.15 */
	 u_int16_t section_crc;
	/* Description -  */
	/* 0x18.16 - 0x18.16 */
	 u_int8_t no_crc;
	/* Description - When this bit is set, the section pointed by this entry in belongs to teh device tather than to teh FW image.
A device_data section should not be updated in a regular FW update.
Example for device_data section: VPD_R, GUIDs. */
	/* 0x18.17 - 0x18.17 */
	 u_int8_t device_data;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t itoc_entry_crc;
};

/* Description -   */
/* Size in bytes - 32 */
struct connectx4lx_itoc_header {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 49 54 4f 43 */
	/* 0x0.0 - 0x4.31 */
	 u_int32_t signature0;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - 04 08 15 16 */
	/* 0x4.0 - 0x8.31 */
	 u_int32_t signature1;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - 23 42 ca fa */
	/* 0x8.0 - 0xc.31 */
	 u_int32_t signature2;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - ba ca fe 00 */
	/* 0xc.0 - 0x10.31 */
	 u_int32_t signature3;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - Current version: 1 */
	/* 0x10.0 - 0x10.7 */
	 u_int8_t version;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description -  */
	/* 0x1c.0 - 0x1c.15 */
	 u_int16_t itoc_entry_crc;
};

/* Description -   */
/* Size in bytes - 2272 */
struct connectx4lx_lane_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read only parameters per lane */
	/* 0x0.0 - 0x2c0.31 */
	 struct connectx4lx_lane_consts consts;
/*---------------- DWORD[176] (Offset 0x2c0) ----------------*/
	/* Description - variables used by UC while active - static allocation */
	/* 0x2c0.0 - 0x6f0.31 */
	 struct connectx4lx_lane_static_vars static_vars;
/*---------------- DWORD[444] (Offset 0x6f0) ----------------*/
	/* Description - variables used by UC while active - dynamic allocation */
	/* 0x6f0.0 - 0x790.31 */
	 struct connectx4lx_lane_vars dynamic_vars;
/*---------------- DWORD[484] (Offset 0x790) ----------------*/
	/* Description - write - by UC, read - by FW */
	/* 0x790.0 - 0x7d0.31 */
	 struct connectx4lx_lane_results results;
/*---------------- DWORD[500] (Offset 0x7d0) ----------------*/
	/* Description -  */
	/* 0x7d0.0 - 0x860.31 */
	 struct connectx4lx_lane_debug debug;
/*---------------- DWORD[536] (Offset 0x860) ----------------*/
	/* Description -  */
	/* 0x860.0 - 0x870.31 */
	 struct connectx4lx_bath_debug temp_bath;
/*---------------- DWORD[540] (Offset 0x870) ----------------*/
	/* Description - subroutines stack, read and write - only by UC */
	/* 0x870.0 - 0x8e0.31 */
	 struct connectx4lx_subroutines_lifo subroutines_lifo;
};

/* Description -   */
/* Size in bytes - 2432 */
struct connectx4lx_opamp_calibration_results_ports {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x980.31 */
	 struct connectx4lx_port_opamp_calibration_results port[2];
};

/* Description -   */
/* Size in bytes - 2176 */
struct connectx4lx_port_data {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read only parameters per port */
	/* 0x0.0 - 0x870.31 */
	 struct connectx4lx_port_shared_const_sd_params serdes_params;
/*---------------- DWORD[540] (Offset 0x870) ----------------*/
	/* Description -  */
	/* 0x870.0 - 0x880.31 */
	 struct connectx4lx_port_debug debug;
};

/* Description -   */
/* Size in bytes - 1024 */
struct connectx4lx_sw_wqe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_wqe_control conrtol;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description -  */
	/* 0x10.0 - 0x20.31 */
	 struct connectx4lx_wqe_mlx mlx;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description -  */
	/* 0x20.0 - 0x30.31 */
	 struct connectx4lx_wqe_xrc xrc;
/*---------------- DWORD[12] (Offset 0x30) ----------------*/
	/* Description -  */
	/* 0x30.0 - 0x40.31 */
	 struct connectx4lx_wqe_address_vector_basic address_vector_basic;
/*---------------- DWORD[16] (Offset 0x40) ----------------*/
	/* Description -  */
	/* 0x40.0 - 0x60.31 */
	 struct connectx4lx_wqe_address_vector_ext address_vector_ext;
/*---------------- DWORD[24] (Offset 0x60) ----------------*/
	/* Description -  */
	/* 0x60.0 - 0x70.31 */
	 struct connectx4lx_wqe_rdma_read rdma_read;
/*---------------- DWORD[28] (Offset 0x70) ----------------*/
	/* Description -  */
	/* 0x70.0 - 0x80.31 */
	 struct connectx4lx_wqe_atomic_cmp_swap atomic_cmp_swap;
/*---------------- DWORD[32] (Offset 0x80) ----------------*/
	/* Description -  */
	/* 0x80.0 - 0x280.31 */
	 union connectx4lx_wqe_extended_atomic_cmp_swap ext_atom_cmp_swap;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x290.31 */
	 struct connectx4lx_wqe_atomic_fetch_add atomic_fetch_add;
/*---------------- DWORD[164] (Offset 0x290) ----------------*/
	/* Description -  */
	/* 0x290.0 - 0x390.31 */
	 union connectx4lx_wqe_extended_atomic_fetch_add ext_atom_fetch_add;
/*---------------- DWORD[228] (Offset 0x390) ----------------*/
	/* Description -  */
	/* 0x390.0 - 0x3a0.31 */
	 struct connectx4lx_wqe_signature signature;
/*---------------- DWORD[232] (Offset 0x3a0) ----------------*/
	/* Description -  */
	/* 0x3a0.0 - 0x3b0.31 */
	 struct connectx4lx_wqe_srq_next srq_next;
/*---------------- DWORD[236] (Offset 0x3b0) ----------------*/
	/* Description -  */
	/* 0x3b0.0 - 0x3c0.31 */
	 struct connectx4lx_wqe_gather_scatter_entry gather_scatter_entry;
/*---------------- DWORD[240] (Offset 0x3c0) ----------------*/
	/* Description -  */
	/* 0x3c0.0 - 0x3c4.31 */
	 struct connectx4lx_wqe_inline_header inline_header;
/*---------------- DWORD[244] (Offset 0x3d0) ----------------*/
	/* Description -  */
	/* 0x3d0.0 - 0x3e0.31 */
	 struct connectx4lx_wqe_eth_segment eth_segment;
};

/* Description -  All ini  fields */
/* Size in bytes - 65536 */
union connectx4lx_ini {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - 1. Boot record endianes: reserved1 is the fist Byte that should be written on the NVRAM (address 0)
2. Each line is protected by parity bit (bit 31) the xor of the 32 read bits should be 1 */
	/* 0x0.0 - 0x10.31 */
	 struct connectx4lx_boot_record_dotan boot_record;
	/* Description -  */
	/* 0x0.0 - 0x100.31 */
	 struct connectx4lx_reset_info reset_info;
	/* Description - This is a 'dummy' section.
It holds teh pointers for the dTOC entries.
Used by the mic tool */
	/* 0x0.0 - 0x100.31 */
	 union connectx4lx_dtoc_pointers dtoc_pointers;
	/* Description - This struct contains device specific info, such as GUIDs, VSD, Keys, etc...
It is not a part of teh FW image.
 */
	/* 0x0.0 - 0x200.31 */
	 struct connectx4lx_device_info device_info;
	/* Description - This section contains info which is shared by FW and burning tool */
	/* 0x0.0 - 0x400.31 */
	 struct connectx4lx_image_info image_info;
	/* Description -  */
	/* 0x0.0 - 0x140.31 */
	 struct connectx4lx_mfg_info mfg_info;
	/* Description - plastic fw config data */
	/* 0x0.0 - 0x1000.31 */
	 struct connectx4lx_fw_main_config fw_main_config;
	/* Description - boot + iron fw config data */
	/* 0x0.0 - 0x4c0.31 */
	 struct connectx4lx_fw_boot_config fw_boot_config;
	/* Description - plastic hw and board config data */
	/* 0x0.0 - 0xb00.31 */
	 struct connectx4lx_hw_main_config hw_main_config;
	/* Description - boot and iron hw and board config data */
	/* 0x0.0 - 0x140.31 */
	 struct connectx4lx_hw_boot_config hw_boot_config;
	/* Description -  */
	/* 0x0.0 - 0x2c80.31 */
	 struct connectx4lx_phy_uc_consts phy_uc_consts;
	/* Description -  */
	/* 0x0.0 - 0x10000.31 */
	 struct connectx4lx_nv_data nv_data_0;
	/* Description -  */
	/* 0x0.0 - 0x10000.31 */
	 struct connectx4lx_nv_data nv_data_1;
	/* Description -  */
	/* 0x0.0 - 0x10000.31 */
	 struct connectx4lx_nv_data fw_nv_log;
	/* Description - This section holds the pending images signature and keypair_uuid */
	/* 0x0.0 - 0x140.31 */
	 struct connectx4lx_image_signature image_signature;
	/* Description - This section holds the current image's signature and keypair_uuid */
	/* 0x0.0 - 0x900.31 */
	 struct connectx4lx_public_keys public_keys;
};

/* Description -   */
/* Size in bytes - 64 */
struct connectx4lx_a2d_core {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - d2a & bandgap power up */
	/* 0x0.0 - 0x0.0 */
	 u_int8_t power_up;
	/* Description - selects the division of input clock to binsearch machine:
0 - clk65536
1 - clk32768
2 - clk16384
3 - clk8192
4 - clk2048
5 - clk512
6 - clk256
7 - clk64 */
	/* 0x0.1 - 0x0.3 */
	 u_int8_t clock_div;
	/* Description - Sel analog in to a2d
0 - tempnet
1 - 8 analog in
9 - prb_calib_p
10 - prb_calib_n
11 - refin_vssp_1200mv
12 - refin_vssp900mv
13 - refin_vssp600mv
14 - refin_vssp450mv
15 - bandgap */
	/* 0x0.4 - 0x0.7 */
	 u_int8_t probe_sel;
	/* Description - Define the A2D measure mode (not thermal protect)
0: Disable
1: Theshold compare according to measure_value (FW)
2: binary search
3: circuit binary search - DON'T ACTIVATE THIS FEATURE - CAUSES A FATAL BUG 390716 IN PROTECTION.
Disable protection prior moving to mode 3.
 */
	/* 0x0.8 - 0x0.9 */
	 u_int8_t measure_mode;
	/* Description - Selects the input clock to the binsearch machine
0 - oscilator
1-3 - NA 

only to Core Thermal Diodes */
	/* 0x0.10 - 0x0.11 */
	 u_int8_t clock_sel;
	/* Description -  */
	/* 0x0.12 - 0x0.12 */
	 u_int8_t bin_search_comperator_polarity;
	/* Description - sets the polarity of the bin_search algorithm. i.e. wheather to go up or down on each d2a results.
Note - default value is wrong and this should be '1'. */
	/* 0x0.13 - 0x0.13 */
	 u_int8_t measure_polarity;
	/* Description - PowerUp the a2d ring oscillator

only to Core Thermal Diodes */
	/* 0x0.14 - 0x0.14 */
	 u_int8_t oscillator_power_up;
	/* Description - 
This register controlls only the PLL Thermal Diode */
	/* 0x0.15 - 0x0.15 */
	 u_int8_t pwrup_oscilator_pll;
/*---------------- DWORD[1] (Offset 0x4) ----------------*/
	/* Description - defines the direction of the spike direction */
	/* 0x4.0 - 0x4.0 */
	 u_int8_t spike_direction;
	/* Description - power up to spike direction circuit */
	/* 0x4.1 - 0x4.1 */
	 u_int8_t spike_detect_enable;
	/* Description - CAUTION - this register causes charge sharing over pllx4
Select d2a half range:
0 - 450mv
1 - 600mv
2 - 900mv 
3 - 1200mv
It means that d2a range will be 0.9V,1.2V,1.8V or 2.4V accordingly


0: 0.9V  (best for temperature)
1: 1.2V  (best for vddcore)
2: 1.8V  (best for vddhs)
3: 2.4V  (best for biases and analog) */
	/* 0x4.2 - 0x4.3 */
	 u_int8_t dynamic_range;
	/* Description -  */
	/* 0x4.4 - 0x4.4 */
	 u_int8_t a2d_yu_bandgap_startup_powerup;
	/* Description - Selects positive leg between analog input to d2a as destination to a2d open loop opamp comperator */
	/* 0x4.5 - 0x4.5 */
	 u_int8_t sel_cmp_ap;
	/* Description - Selects negative leg between d2a to analog input as destination to a2d open loop opamp comperator */
	/* 0x4.6 - 0x4.6 */
	 u_int8_t sel_cmp_an;
	/* Description - When this register is set then the too hot indication (a2d_compare)
will be send to yu (too hot) and the A2D will run protection flow

In YU/LBs, default is 0x1, else default is 0x0
Disable before moving to measure_mode==3
 */
	/* 0x4.7 - 0x4.7 */
	 u_int8_t thermal_protect_en;
	/* Description - Only in YU.
Set in order to use cr_thermal_protect */
	/* 0x4.8 - 0x4.8 */
	 u_int8_t allow_yu_thermal_protection_using_cr;
/*---------------- DWORD[2] (Offset 0x8) ----------------*/
	/* Description - threshold cross sticky bit
write 0 to clear */
	/* 0x8.0 - 0x8.0 */
	 u_int8_t spike_detect;
/*---------------- DWORD[3] (Offset 0xc) ----------------*/
	/* Description - 
stabilization time:  2^ in i1 clocks
This time purpose is to wait for the HW a2d to stabilize and give a good output.
The time starts counting once inputs are good and control will disregard a2d output
as long time not ended.
 */
	/* 0xc.0 - 0xc.4 */
	 u_int8_t stabilization_time;
	/* Description - enable probe out of analog in input to the a2d comperator */
	/* 0xc.5 - 0xc.5 */
	 u_int8_t en_prb_pad_out_a2d;
	/* Description - These bits choose between:
0 - divided clock 
1 - rclk
2 - padclk */
	/* 0xc.6 - 0xc.7 */
	 u_int8_t sel_a2d_clk;
	/* Description - Selects the input clock to the binsearch machine - relevant only to Thermal Diode in PLL
0 - rclk
2 - internal Ring oscilator

1,3 - NA

This register controlls only the PLL Thermal Diode
 */
	/* 0xc.8 - 0xc.9 */
	 u_int8_t clk_sel_pll;
/*---------------- DWORD[4] (Offset 0x10) ----------------*/
	/* Description - set by HW upon receiving valid from circuit binary machine, may be cleared by FW */
	/* 0x10.0 - 0x10.0 */
	 u_int8_t circuit_binary_done;
/*---------------- DWORD[5] (Offset 0x14) ----------------*/
	/* Description - These are the 10 bits determine d2a value 
which is being compared. 
Ideal, d2a value should be:
(2*half_range/1024)*(decimal value of d2a_in<9:0>)

On read - returnes last value.
On write when FW mode - d2a value */
	/* 0x14.0 - 0x14.9 */
	 u_int16_t measure_value;
/*---------------- DWORD[6] (Offset 0x18) ----------------*/
	/* Description - max a2d value
writable by crspace */
	/* 0x18.0 - 0x18.9 */
	 u_int16_t measure_max;
/*---------------- DWORD[7] (Offset 0x1c) ----------------*/
	/* Description - min a2d value
writable by crspace */
	/* 0x1c.0 - 0x1c.9 */
	 u_int16_t measure_min;
/*---------------- DWORD[8] (Offset 0x20) ----------------*/
	/* Description - temperature value as measured before VDDCORE was powered up
temp values are in reverse order to temperture */
	/* 0x20.0 - 0x20.9 */
	 u_int16_t calib_value;
	/* Description - Not in use */
	/* 0x20.10 - 0x20.10 */
	 u_int8_t calib_value_valid;
	/* Description - compare value from A2D block
1-too hot / analog below threshold
0-cold / analog above threshold */
	/* 0x20.11 - 0x20.11 */
	 u_int8_t a2d_compare;
	/* Description - compare value from A2D block on the last measure cycle
1-too hot / analog below threshold
0-cold / analog above threshold */
	/* 0x20.12 - 0x20.12 */
	 u_int8_t measure_compare;
/*---------------- DWORD[9] (Offset 0x24) ----------------*/
	/* Description - This value is driven to HW a2d to compare when protect mode is on
temp values are in reverse order to temperture.

NOTE - this register will "or" with fuse_thermal_th (Only in YU)
 */
	/* 0x24.0 - 0x24.9 */
	 u_int16_t protect_value;
	/* Description - sets polarity of the protection mode or the too_hot indication going towards YU */
	/* 0x24.10 - 0x24.10 */
	 u_int8_t protect_polarity;
};

/* Description -   */
/* Size in bytes - 1024 */
struct connectx4lx_icmd {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x300.31 */
	 union connectx4lx_icmd_cmd cmd;
/*---------------- DWORD[252] (Offset 0x3f0) ----------------*/
	/* Description -  */
	/* 0x3f0.0 - 0x400.31 */
	 struct connectx4lx_icmd_ctrl ctrl;
};

/* Description -   */
/* Size in bytes - 128 */
union connectx4lx_sw_cqe {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - cqe 64B layout */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_sw_cqe_64b cqe_64b;
	/* Description - cqe 128B layout */
	/* 0x0.0 - 0x80.31 */
	 struct connectx4lx_sw_cqe_128b cqe_128b;
	/* Description - error cqe layout */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_sw_cqe_error cqe_error;
	/* Description - CQ resize cqe layout */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_sw_cqe_resize cqe_resize;
	/* Description - signature error cqe layout */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_sw_cqe_sigerr cqe_sigerr;
};

/* Description -  All nodes */
/* Size in bytes - 32 */
union connectx4lx_itoc {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - Size must be multiple of 16B */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_itoc_header header;
	/* Description - Size must be multiple of 16B. When the no_crc bit is set, the section_crc should not be checked.
 */
	/* 0x0.0 - 0x20.31 */
	 struct connectx4lx_itoc_entry entry;
};

/* Description -   */
/* Size in bytes - 25600 */
struct connectx4lx_phy_uc_data_ports {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description - read only parameters for all lanes */
	/* 0x0.0 - 0x280.31 */
	 struct connectx4lx_shared_consts shared_consts;
/*---------------- DWORD[160] (Offset 0x280) ----------------*/
	/* Description -  */
	/* 0x280.0 - 0x1380.31 */
	 struct connectx4lx_port_data port[2];
/*---------------- DWORD[1248] (Offset 0x1380) ----------------*/
	/* Description -  */
	/* 0x1380.0 - 0x1d00.31 */
	 struct connectx4lx_opamp_calibration_results_ports opamp_calibration_results;
/*---------------- DWORD[1856] (Offset 0x1d00) ----------------*/
	/* Description -  */
	/* 0x1d00.0 - 0x6400.31 */
	 struct connectx4lx_lane_data lane[8];
};

/* Description -   */
/* Size in bytes - 65536 */
union connectx4lx_connectx4lx_Nodes {
/*---------------- DWORD[0] (Offset 0x0) ----------------*/
	/* Description -  */
	/* 0x0.0 - 0x6400.31 */
	 struct connectx4lx_phy_uc_data_ports phy_uc_data_ports;
	/* Description -  */
	/* 0x0.0 - 0x20.31 */
	 union connectx4lx_itoc itoc;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 union connectx4lx_hw_hca_contexts hw_hca_contexts;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_guids guids;
	/* Description -  */
	/* 0x0.0 - 0x80.31 */
	 union connectx4lx_sw_cqe sw_cqe;
	/* Description -  */
	/* 0x0.0 - 0x400.31 */
	 struct connectx4lx_icmd icmd;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_a2d_core a2d_core;
	/* Description -  */
	/* 0x0.0 - 0x10000.31 */
	 union connectx4lx_ini ini;
	/* Description -  */
	/* 0x0.0 - 0x400.31 */
	 struct connectx4lx_sw_wqe sw_wqe;
	/* Description -  */
	/* 0x0.0 - 0x40.31 */
	 struct connectx4lx_sw_eqe sw_eqe;
};


/*================= PACK/UNPACK/PRINT FUNCTIONS ======================*/
/* cmdif_ctx_special_qp_commands_uapp */
void connectx4lx_cmdif_ctx_special_qp_commands_uapp_pack(const struct connectx4lx_cmdif_ctx_special_qp_commands_uapp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_uapp_unpack(struct connectx4lx_cmdif_ctx_special_qp_commands_uapp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_uapp_print(const struct connectx4lx_cmdif_ctx_special_qp_commands_uapp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_uapp_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_UAPP_SIZE    (0xc)
void connectx4lx_cmdif_ctx_special_qp_commands_uapp_dump(const struct connectx4lx_cmdif_ctx_special_qp_commands_uapp *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands_underlay */
void connectx4lx_cmdif_ctx_special_qp_commands_underlay_pack(const struct connectx4lx_cmdif_ctx_special_qp_commands_underlay *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_underlay_unpack(struct connectx4lx_cmdif_ctx_special_qp_commands_underlay *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_underlay_print(const struct connectx4lx_cmdif_ctx_special_qp_commands_underlay *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_underlay_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_UNDERLAY_SIZE    (0xc)
void connectx4lx_cmdif_ctx_special_qp_commands_underlay_dump(const struct connectx4lx_cmdif_ctx_special_qp_commands_underlay *ptr_struct, FILE* file);
/* pddr_advanced_opcode */
void connectx4lx_pddr_advanced_opcode_pack(const struct connectx4lx_pddr_advanced_opcode *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_advanced_opcode_unpack(struct connectx4lx_pddr_advanced_opcode *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_advanced_opcode_print(const struct connectx4lx_pddr_advanced_opcode *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_advanced_opcode_size(void);
#define CONNECTX4LX_PDDR_ADVANCED_OPCODE_SIZE    (0x4)
void connectx4lx_pddr_advanced_opcode_dump(const struct connectx4lx_pddr_advanced_opcode *ptr_struct, FILE* file);
/* pddr_monitor_opcode */
void connectx4lx_pddr_monitor_opcode_pack(const struct connectx4lx_pddr_monitor_opcode *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_monitor_opcode_unpack(struct connectx4lx_pddr_monitor_opcode *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_monitor_opcode_print(const struct connectx4lx_pddr_monitor_opcode *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_monitor_opcode_size(void);
#define CONNECTX4LX_PDDR_MONITOR_OPCODE_SIZE    (0x4)
void connectx4lx_pddr_monitor_opcode_dump(const struct connectx4lx_pddr_monitor_opcode *ptr_struct, FILE* file);
/* regular_qp_eth */
void connectx4lx_regular_qp_eth_pack(const struct connectx4lx_regular_qp_eth *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_regular_qp_eth_unpack(struct connectx4lx_regular_qp_eth *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_regular_qp_eth_print(const struct connectx4lx_regular_qp_eth *ptr_struct, FILE* file, int indent_level);
int connectx4lx_regular_qp_eth_size(void);
#define CONNECTX4LX_REGULAR_QP_ETH_SIZE    (0x4)
void connectx4lx_regular_qp_eth_dump(const struct connectx4lx_regular_qp_eth *ptr_struct, FILE* file);
/* regular_qp_ipoib */
void connectx4lx_regular_qp_ipoib_pack(const struct connectx4lx_regular_qp_ipoib *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_regular_qp_ipoib_unpack(struct connectx4lx_regular_qp_ipoib *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_regular_qp_ipoib_print(const struct connectx4lx_regular_qp_ipoib *ptr_struct, FILE* file, int indent_level);
int connectx4lx_regular_qp_ipoib_size(void);
#define CONNECTX4LX_REGULAR_QP_IPOIB_SIZE    (0x4)
void connectx4lx_regular_qp_ipoib_dump(const struct connectx4lx_regular_qp_ipoib *ptr_struct, FILE* file);
/* ste_flex_parser_tnl_header_tag */
void connectx4lx_ste_flex_parser_tnl_header_tag_pack(const struct connectx4lx_ste_flex_parser_tnl_header_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_flex_parser_tnl_header_tag_unpack(struct connectx4lx_ste_flex_parser_tnl_header_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_flex_parser_tnl_header_tag_print(const struct connectx4lx_ste_flex_parser_tnl_header_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_flex_parser_tnl_header_tag_size(void);
#define CONNECTX4LX_STE_FLEX_PARSER_TNL_HEADER_TAG_SIZE    (0x10)
void connectx4lx_ste_flex_parser_tnl_header_tag_dump(const struct connectx4lx_ste_flex_parser_tnl_header_tag *ptr_struct, FILE* file);
/* ste_gre_tag */
void connectx4lx_ste_gre_tag_pack(const struct connectx4lx_ste_gre_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_gre_tag_unpack(struct connectx4lx_ste_gre_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_gre_tag_print(const struct connectx4lx_ste_gre_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_gre_tag_size(void);
#define CONNECTX4LX_STE_GRE_TAG_SIZE    (0x10)
void connectx4lx_ste_gre_tag_dump(const struct connectx4lx_ste_gre_tag *ptr_struct, FILE* file);
/* ste_eth_l3_ipv6_src_tag */
void connectx4lx_ste_eth_l3_ipv6_src_tag_pack(const struct connectx4lx_ste_eth_l3_ipv6_src_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv6_src_tag_unpack(struct connectx4lx_ste_eth_l3_ipv6_src_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv6_src_tag_print(const struct connectx4lx_ste_eth_l3_ipv6_src_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l3_ipv6_src_tag_size(void);
#define CONNECTX4LX_STE_ETH_L3_IPV6_SRC_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l3_ipv6_src_tag_dump(const struct connectx4lx_ste_eth_l3_ipv6_src_tag *ptr_struct, FILE* file);
/* ste_eth_l3_ipv6_des_tag */
void connectx4lx_ste_eth_l3_ipv6_des_tag_pack(const struct connectx4lx_ste_eth_l3_ipv6_des_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv6_des_tag_unpack(struct connectx4lx_ste_eth_l3_ipv6_des_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv6_des_tag_print(const struct connectx4lx_ste_eth_l3_ipv6_des_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l3_ipv6_des_tag_size(void);
#define CONNECTX4LX_STE_ETH_L3_IPV6_DES_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l3_ipv6_des_tag_dump(const struct connectx4lx_ste_eth_l3_ipv6_des_tag *ptr_struct, FILE* file);
/* ste_eth_l3_ipv4_5_tuple_tag */
void connectx4lx_ste_eth_l3_ipv4_5_tuple_tag_pack(const struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv4_5_tuple_tag_unpack(struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l3_ipv4_5_tuple_tag_print(const struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l3_ipv4_5_tuple_tag_size(void);
#define CONNECTX4LX_STE_ETH_L3_IPV4_5_TUPLE_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l3_ipv4_5_tuple_tag_dump(const struct connectx4lx_ste_eth_l3_ipv4_5_tuple_tag *ptr_struct, FILE* file);
/* ste_eth_l4_tag */
void connectx4lx_ste_eth_l4_tag_pack(const struct connectx4lx_ste_eth_l4_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l4_tag_unpack(struct connectx4lx_ste_eth_l4_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l4_tag_print(const struct connectx4lx_ste_eth_l4_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l4_tag_size(void);
#define CONNECTX4LX_STE_ETH_L4_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l4_tag_dump(const struct connectx4lx_ste_eth_l4_tag *ptr_struct, FILE* file);
/* ste_eth_l2_tnl_tag */
void connectx4lx_ste_eth_l2_tnl_tag_pack(const struct connectx4lx_ste_eth_l2_tnl_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_tnl_tag_unpack(struct connectx4lx_ste_eth_l2_tnl_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_tnl_tag_print(const struct connectx4lx_ste_eth_l2_tnl_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l2_tnl_tag_size(void);
#define CONNECTX4LX_STE_ETH_L2_TNL_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l2_tnl_tag_dump(const struct connectx4lx_ste_eth_l2_tnl_tag *ptr_struct, FILE* file);
/* ste_eth_l2_src_tag */
void connectx4lx_ste_eth_l2_src_tag_pack(const struct connectx4lx_ste_eth_l2_src_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_src_tag_unpack(struct connectx4lx_ste_eth_l2_src_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_src_tag_print(const struct connectx4lx_ste_eth_l2_src_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l2_src_tag_size(void);
#define CONNECTX4LX_STE_ETH_L2_SRC_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l2_src_tag_dump(const struct connectx4lx_ste_eth_l2_src_tag *ptr_struct, FILE* file);
/* ste_eth_l2_des_tag */
void connectx4lx_ste_eth_l2_des_tag_pack(const struct connectx4lx_ste_eth_l2_des_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_des_tag_unpack(struct connectx4lx_ste_eth_l2_des_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_eth_l2_des_tag_print(const struct connectx4lx_ste_eth_l2_des_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_eth_l2_des_tag_size(void);
#define CONNECTX4LX_STE_ETH_L2_DES_TAG_SIZE    (0x10)
void connectx4lx_ste_eth_l2_des_tag_dump(const struct connectx4lx_ste_eth_l2_des_tag *ptr_struct, FILE* file);
/* ste_ib_l4_tag */
void connectx4lx_ste_ib_l4_tag_pack(const struct connectx4lx_ste_ib_l4_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l4_tag_unpack(struct connectx4lx_ste_ib_l4_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l4_tag_print(const struct connectx4lx_ste_ib_l4_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_ib_l4_tag_size(void);
#define CONNECTX4LX_STE_IB_L4_TAG_SIZE    (0x10)
void connectx4lx_ste_ib_l4_tag_dump(const struct connectx4lx_ste_ib_l4_tag *ptr_struct, FILE* file);
/* ste_ib_l3_extended_tag */
void connectx4lx_ste_ib_l3_extended_tag_pack(const struct connectx4lx_ste_ib_l3_extended_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l3_extended_tag_unpack(struct connectx4lx_ste_ib_l3_extended_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l3_extended_tag_print(const struct connectx4lx_ste_ib_l3_extended_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_ib_l3_extended_tag_size(void);
#define CONNECTX4LX_STE_IB_L3_EXTENDED_TAG_SIZE    (0x10)
void connectx4lx_ste_ib_l3_extended_tag_dump(const struct connectx4lx_ste_ib_l3_extended_tag *ptr_struct, FILE* file);
/* ste_ib_l3_tag */
void connectx4lx_ste_ib_l3_tag_pack(const struct connectx4lx_ste_ib_l3_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l3_tag_unpack(struct connectx4lx_ste_ib_l3_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_ib_l3_tag_print(const struct connectx4lx_ste_ib_l3_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_ib_l3_tag_size(void);
#define CONNECTX4LX_STE_IB_L3_TAG_SIZE    (0x10)
void connectx4lx_ste_ib_l3_tag_dump(const struct connectx4lx_ste_ib_l3_tag *ptr_struct, FILE* file);
/* ste_port_ib_l2_tag */
void connectx4lx_ste_port_ib_l2_tag_pack(const struct connectx4lx_ste_port_ib_l2_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_port_ib_l2_tag_unpack(struct connectx4lx_ste_port_ib_l2_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_port_ib_l2_tag_print(const struct connectx4lx_ste_port_ib_l2_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_port_ib_l2_tag_size(void);
#define CONNECTX4LX_STE_PORT_IB_L2_TAG_SIZE    (0x10)
void connectx4lx_ste_port_ib_l2_tag_dump(const struct connectx4lx_ste_port_ib_l2_tag *ptr_struct, FILE* file);
/* ste_loopback_tag */
void connectx4lx_ste_loopback_tag_pack(const struct connectx4lx_ste_loopback_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_loopback_tag_unpack(struct connectx4lx_ste_loopback_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_loopback_tag_print(const struct connectx4lx_ste_loopback_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_loopback_tag_size(void);
#define CONNECTX4LX_STE_LOOPBACK_TAG_SIZE    (0x10)
void connectx4lx_ste_loopback_tag_dump(const struct connectx4lx_ste_loopback_tag *ptr_struct, FILE* file);
/* hw_ste_tag_bulk */
void connectx4lx_hw_ste_tag_bulk_pack(const struct connectx4lx_hw_ste_tag_bulk *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_ste_tag_bulk_unpack(struct connectx4lx_hw_ste_tag_bulk *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_ste_tag_bulk_print(const struct connectx4lx_hw_ste_tag_bulk *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_ste_tag_bulk_size(void);
#define CONNECTX4LX_HW_STE_TAG_BULK_SIZE    (0x10)
void connectx4lx_hw_ste_tag_bulk_dump(const struct connectx4lx_hw_ste_tag_bulk *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands_inner */
void connectx4lx_cmdif_ctx_special_qp_commands_inner_pack(const union connectx4lx_cmdif_ctx_special_qp_commands_inner *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_inner_unpack(union connectx4lx_cmdif_ctx_special_qp_commands_inner *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_inner_print(const union connectx4lx_cmdif_ctx_special_qp_commands_inner *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_inner_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_INNER_SIZE    (0xc)
void connectx4lx_cmdif_ctx_special_qp_commands_inner_dump(const union connectx4lx_cmdif_ctx_special_qp_commands_inner *ptr_struct, FILE* file);
/* pmlp_code_style_lane */
void connectx4lx_pmlp_code_style_lane_pack(const struct connectx4lx_pmlp_code_style_lane *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmlp_code_style_lane_unpack(struct connectx4lx_pmlp_code_style_lane *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmlp_code_style_lane_print(const struct connectx4lx_pmlp_code_style_lane *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmlp_code_style_lane_size(void);
#define CONNECTX4LX_PMLP_CODE_STYLE_LANE_SIZE    (0x4)
void connectx4lx_pmlp_code_style_lane_dump(const struct connectx4lx_pmlp_code_style_lane *ptr_struct, FILE* file);
/* dw */
void connectx4lx_dw_pack(const struct connectx4lx_dw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dw_unpack(struct connectx4lx_dw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dw_print(const struct connectx4lx_dw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dw_size(void);
#define CONNECTX4LX_DW_SIZE    (0x4)
void connectx4lx_dw_dump(const struct connectx4lx_dw *ptr_struct, FILE* file);
/* nv_tlv_type_nvlog */
void connectx4lx_nv_tlv_type_nvlog_pack(const struct connectx4lx_nv_tlv_type_nvlog *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_nvlog_unpack(struct connectx4lx_nv_tlv_type_nvlog *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_nvlog_print(const struct connectx4lx_nv_tlv_type_nvlog *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_nvlog_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_NVLOG_SIZE    (0x4)
void connectx4lx_nv_tlv_type_nvlog_dump(const struct connectx4lx_nv_tlv_type_nvlog *ptr_struct, FILE* file);
/* nv_tlv_type_eswitch */
void connectx4lx_nv_tlv_type_eswitch_pack(const struct connectx4lx_nv_tlv_type_eswitch *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_eswitch_unpack(struct connectx4lx_nv_tlv_type_eswitch *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_eswitch_print(const struct connectx4lx_nv_tlv_type_eswitch *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_eswitch_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_ESWITCH_SIZE    (0x4)
void connectx4lx_nv_tlv_type_eswitch_dump(const struct connectx4lx_nv_tlv_type_eswitch *ptr_struct, FILE* file);
/* nv_tlv_type_per_host */
void connectx4lx_nv_tlv_type_per_host_pack(const struct connectx4lx_nv_tlv_type_per_host *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_per_host_unpack(struct connectx4lx_nv_tlv_type_per_host *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_per_host_print(const struct connectx4lx_nv_tlv_type_per_host *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_per_host_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_PER_HOST_SIZE    (0x4)
void connectx4lx_nv_tlv_type_per_host_dump(const struct connectx4lx_nv_tlv_type_per_host *ptr_struct, FILE* file);
/* nv_tlv_type_bmc */
void connectx4lx_nv_tlv_type_bmc_pack(const struct connectx4lx_nv_tlv_type_bmc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_bmc_unpack(struct connectx4lx_nv_tlv_type_bmc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_bmc_print(const struct connectx4lx_nv_tlv_type_bmc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_bmc_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_BMC_SIZE    (0x4)
void connectx4lx_nv_tlv_type_bmc_dump(const struct connectx4lx_nv_tlv_type_bmc *ptr_struct, FILE* file);
/* nv_tlv_type_physical_port */
void connectx4lx_nv_tlv_type_physical_port_pack(const struct connectx4lx_nv_tlv_type_physical_port *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_physical_port_unpack(struct connectx4lx_nv_tlv_type_physical_port *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_physical_port_print(const struct connectx4lx_nv_tlv_type_physical_port *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_physical_port_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_PHYSICAL_PORT_SIZE    (0x4)
void connectx4lx_nv_tlv_type_physical_port_dump(const struct connectx4lx_nv_tlv_type_physical_port *ptr_struct, FILE* file);
/* nv_tlv_type_global */
void connectx4lx_nv_tlv_type_global_pack(const struct connectx4lx_nv_tlv_type_global *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_global_unpack(struct connectx4lx_nv_tlv_type_global *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_global_print(const struct connectx4lx_nv_tlv_type_global *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_global_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_GLOBAL_SIZE    (0x4)
void connectx4lx_nv_tlv_type_global_dump(const struct connectx4lx_nv_tlv_type_global *ptr_struct, FILE* file);
/* pddr_monitor_opcode_pddr_advanced_opcode_auto */
void connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto_pack(const union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto_unpack(union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto_print(const union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto_size(void);
#define CONNECTX4LX_PDDR_MONITOR_OPCODE_PDDR_ADVANCED_OPCODE_AUTO_SIZE    (0x4)
void connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto_dump(const union connectx4lx_pddr_monitor_opcode_pddr_advanced_opcode_auto *ptr_struct, FILE* file);
/* regular_qp_sub_type */
void connectx4lx_regular_qp_sub_type_pack(const union connectx4lx_regular_qp_sub_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_regular_qp_sub_type_unpack(union connectx4lx_regular_qp_sub_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_regular_qp_sub_type_print(const union connectx4lx_regular_qp_sub_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_regular_qp_sub_type_size(void);
#define CONNECTX4LX_REGULAR_QP_SUB_TYPE_SIZE    (0x4)
void connectx4lx_regular_qp_sub_type_dump(const union connectx4lx_regular_qp_sub_type *ptr_struct, FILE* file);
/* hw_ste_tag */
void connectx4lx_hw_ste_tag_pack(const union connectx4lx_hw_ste_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_ste_tag_unpack(union connectx4lx_hw_ste_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_ste_tag_print(const union connectx4lx_hw_ste_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_ste_tag_size(void);
#define CONNECTX4LX_HW_STE_TAG_SIZE    (0x10)
void connectx4lx_hw_ste_tag_dump(const union connectx4lx_hw_ste_tag *ptr_struct, FILE* file);
/* mlx_phy_speed_ini */
void connectx4lx_mlx_phy_speed_ini_pack(const struct connectx4lx_mlx_phy_speed_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlx_phy_speed_ini_unpack(struct connectx4lx_mlx_phy_speed_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlx_phy_speed_ini_print(const struct connectx4lx_mlx_phy_speed_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlx_phy_speed_ini_size(void);
#define CONNECTX4LX_MLX_PHY_SPEED_INI_SIZE    (0x4)
void connectx4lx_mlx_phy_speed_ini_dump(const struct connectx4lx_mlx_phy_speed_ini *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands_other */
void connectx4lx_cmdif_ctx_special_qp_commands_other_pack(const struct connectx4lx_cmdif_ctx_special_qp_commands_other *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_other_unpack(struct connectx4lx_cmdif_ctx_special_qp_commands_other *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_other_print(const struct connectx4lx_cmdif_ctx_special_qp_commands_other *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_other_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_OTHER_SIZE    (0x10)
void connectx4lx_cmdif_ctx_special_qp_commands_other_dump(const struct connectx4lx_cmdif_ctx_special_qp_commands_other *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands_rts2rts */
void connectx4lx_cmdif_ctx_special_qp_commands_rts2rts_pack(const struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_rts2rts_unpack(struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_rts2rts_print(const struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_rts2rts_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_RTS2RTS_SIZE    (0x10)
void connectx4lx_cmdif_ctx_special_qp_commands_rts2rts_dump(const struct connectx4lx_cmdif_ctx_special_qp_commands_rts2rts *ptr_struct, FILE* file);
/* ip_filter_mode */
void connectx4lx_ip_filter_mode_pack(const struct connectx4lx_ip_filter_mode *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ip_filter_mode_unpack(struct connectx4lx_ip_filter_mode *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ip_filter_mode_print(const struct connectx4lx_ip_filter_mode *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ip_filter_mode_size(void);
#define CONNECTX4LX_IP_FILTER_MODE_SIZE    (0x1)
void connectx4lx_ip_filter_mode_dump(const struct connectx4lx_ip_filter_mode *ptr_struct, FILE* file);
/* pmlp_code_style */
void connectx4lx_pmlp_code_style_pack(const struct connectx4lx_pmlp_code_style *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmlp_code_style_unpack(struct connectx4lx_pmlp_code_style *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmlp_code_style_print(const struct connectx4lx_pmlp_code_style *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmlp_code_style_size(void);
#define CONNECTX4LX_PMLP_CODE_STYLE_SIZE    (0x24)
void connectx4lx_pmlp_code_style_dump(const struct connectx4lx_pmlp_code_style *ptr_struct, FILE* file);
/* pmlp_prm_style */
void connectx4lx_pmlp_prm_style_pack(const struct connectx4lx_pmlp_prm_style *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmlp_prm_style_unpack(struct connectx4lx_pmlp_prm_style *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmlp_prm_style_print(const struct connectx4lx_pmlp_prm_style *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmlp_prm_style_size(void);
#define CONNECTX4LX_PMLP_PRM_STYLE_SIZE    (0x24)
void connectx4lx_pmlp_prm_style_dump(const struct connectx4lx_pmlp_prm_style *ptr_struct, FILE* file);
/* register_access_data_reduced */
void connectx4lx_register_access_data_reduced_pack(const struct connectx4lx_register_access_data_reduced *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_access_data_reduced_unpack(struct connectx4lx_register_access_data_reduced *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_access_data_reduced_print(const struct connectx4lx_register_access_data_reduced *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_access_data_reduced_size(void);
#define CONNECTX4LX_REGISTER_ACCESS_DATA_REDUCED_SIZE    (0x10)
void connectx4lx_register_access_data_reduced_dump(const struct connectx4lx_register_access_data_reduced *ptr_struct, FILE* file);
/* nv_tlv_hdr */
void connectx4lx_nv_tlv_hdr_pack(const struct connectx4lx_nv_tlv_hdr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_hdr_unpack(struct connectx4lx_nv_tlv_hdr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_hdr_print(const struct connectx4lx_nv_tlv_hdr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_hdr_size(void);
#define CONNECTX4LX_NV_TLV_HDR_SIZE    (0xc)
void connectx4lx_nv_tlv_hdr_dump(const struct connectx4lx_nv_tlv_hdr *ptr_struct, FILE* file);
/* nv_tlv_type */
void connectx4lx_nv_tlv_type_pack(const union connectx4lx_nv_tlv_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_unpack(union connectx4lx_nv_tlv_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_type_print(const union connectx4lx_nv_tlv_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_type_size(void);
#define CONNECTX4LX_NV_TLV_TYPE_SIZE    (0x4)
void connectx4lx_nv_tlv_type_dump(const union connectx4lx_nv_tlv_type *ptr_struct, FILE* file);
/* register_access_data */
void connectx4lx_register_access_data_pack(const struct connectx4lx_register_access_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_access_data_unpack(struct connectx4lx_register_access_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_access_data_print(const struct connectx4lx_register_access_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_access_data_size(void);
#define CONNECTX4LX_REGISTER_ACCESS_DATA_SIZE    (0x20)
void connectx4lx_register_access_data_dump(const struct connectx4lx_register_access_data *ptr_struct, FILE* file);
/* mfba_header */
void connectx4lx_mfba_header_pack(const struct connectx4lx_mfba_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mfba_header_unpack(struct connectx4lx_mfba_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mfba_header_print(const struct connectx4lx_mfba_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mfba_header_size(void);
#define CONNECTX4LX_MFBA_HEADER_SIZE    (0xc)
void connectx4lx_mfba_header_dump(const struct connectx4lx_mfba_header *ptr_struct, FILE* file);
/* pmmp_sfp_protocol_override_layout */
void connectx4lx_pmmp_sfp_protocol_override_layout_pack(const struct connectx4lx_pmmp_sfp_protocol_override_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmmp_sfp_protocol_override_layout_unpack(struct connectx4lx_pmmp_sfp_protocol_override_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmmp_sfp_protocol_override_layout_print(const struct connectx4lx_pmmp_sfp_protocol_override_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmmp_sfp_protocol_override_layout_size(void);
#define CONNECTX4LX_PMMP_SFP_PROTOCOL_OVERRIDE_LAYOUT_SIZE    (0xc)
void connectx4lx_pmmp_sfp_protocol_override_layout_dump(const struct connectx4lx_pmmp_sfp_protocol_override_layout *ptr_struct, FILE* file);
/* pmmp_qsfp_protocol_override_layout */
void connectx4lx_pmmp_qsfp_protocol_override_layout_pack(const struct connectx4lx_pmmp_qsfp_protocol_override_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmmp_qsfp_protocol_override_layout_unpack(struct connectx4lx_pmmp_qsfp_protocol_override_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmmp_qsfp_protocol_override_layout_print(const struct connectx4lx_pmmp_qsfp_protocol_override_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmmp_qsfp_protocol_override_layout_size(void);
#define CONNECTX4LX_PMMP_QSFP_PROTOCOL_OVERRIDE_LAYOUT_SIZE    (0xc)
void connectx4lx_pmmp_qsfp_protocol_override_layout_dump(const struct connectx4lx_pmmp_qsfp_protocol_override_layout *ptr_struct, FILE* file);
/* pddr_module_info */
void connectx4lx_pddr_module_info_pack(const struct connectx4lx_pddr_module_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_module_info_unpack(struct connectx4lx_pddr_module_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_module_info_print(const struct connectx4lx_pddr_module_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_module_info_size(void);
#define CONNECTX4LX_PDDR_MODULE_INFO_SIZE    (0xf8)
void connectx4lx_pddr_module_info_dump(const struct connectx4lx_pddr_module_info *ptr_struct, FILE* file);
/* pddr_troubleshooting_page */
void connectx4lx_pddr_troubleshooting_page_pack(const struct connectx4lx_pddr_troubleshooting_page *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_troubleshooting_page_unpack(struct connectx4lx_pddr_troubleshooting_page *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_troubleshooting_page_print(const struct connectx4lx_pddr_troubleshooting_page *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_troubleshooting_page_size(void);
#define CONNECTX4LX_PDDR_TROUBLESHOOTING_PAGE_SIZE    (0xf8)
void connectx4lx_pddr_troubleshooting_page_dump(const struct connectx4lx_pddr_troubleshooting_page *ptr_struct, FILE* file);
/* pddr_phy_info_page */
void connectx4lx_pddr_phy_info_page_pack(const struct connectx4lx_pddr_phy_info_page *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_phy_info_page_unpack(struct connectx4lx_pddr_phy_info_page *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_phy_info_page_print(const struct connectx4lx_pddr_phy_info_page *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_phy_info_page_size(void);
#define CONNECTX4LX_PDDR_PHY_INFO_PAGE_SIZE    (0xf8)
void connectx4lx_pddr_phy_info_page_dump(const struct connectx4lx_pddr_phy_info_page *ptr_struct, FILE* file);
/* pddr_operation_info_page */
void connectx4lx_pddr_operation_info_page_pack(const struct connectx4lx_pddr_operation_info_page *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_operation_info_page_unpack(struct connectx4lx_pddr_operation_info_page *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_operation_info_page_print(const struct connectx4lx_pddr_operation_info_page *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_operation_info_page_size(void);
#define CONNECTX4LX_PDDR_OPERATION_INFO_PAGE_SIZE    (0xf8)
void connectx4lx_pddr_operation_info_page_dump(const struct connectx4lx_pddr_operation_info_page *ptr_struct, FILE* file);
/* pcie_timers_states */
void connectx4lx_pcie_timers_states_pack(const struct connectx4lx_pcie_timers_states *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_timers_states_unpack(struct connectx4lx_pcie_timers_states *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_timers_states_print(const struct connectx4lx_pcie_timers_states *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_timers_states_size(void);
#define CONNECTX4LX_PCIE_TIMERS_STATES_SIZE    (0xf8)
void connectx4lx_pcie_timers_states_dump(const struct connectx4lx_pcie_timers_states *ptr_struct, FILE* file);
/* pcie_lanes_counters */
void connectx4lx_pcie_lanes_counters_pack(const struct connectx4lx_pcie_lanes_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_lanes_counters_unpack(struct connectx4lx_pcie_lanes_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_lanes_counters_print(const struct connectx4lx_pcie_lanes_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_lanes_counters_size(void);
#define CONNECTX4LX_PCIE_LANES_COUNTERS_SIZE    (0xf8)
void connectx4lx_pcie_lanes_counters_dump(const struct connectx4lx_pcie_lanes_counters *ptr_struct, FILE* file);
/* pcie_perf_counters */
void connectx4lx_pcie_perf_counters_pack(const struct connectx4lx_pcie_perf_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_perf_counters_unpack(struct connectx4lx_pcie_perf_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_perf_counters_print(const struct connectx4lx_pcie_perf_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_perf_counters_size(void);
#define CONNECTX4LX_PCIE_PERF_COUNTERS_SIZE    (0xc8)
void connectx4lx_pcie_perf_counters_dump(const struct connectx4lx_pcie_perf_counters *ptr_struct, FILE* file);
/* phys_layer_stat_cntrs */
void connectx4lx_phys_layer_stat_cntrs_pack(const struct connectx4lx_phys_layer_stat_cntrs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phys_layer_stat_cntrs_unpack(struct connectx4lx_phys_layer_stat_cntrs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phys_layer_stat_cntrs_print(const struct connectx4lx_phys_layer_stat_cntrs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phys_layer_stat_cntrs_size(void);
#define CONNECTX4LX_PHYS_LAYER_STAT_CNTRS_SIZE    (0xf8)
void connectx4lx_phys_layer_stat_cntrs_dump(const struct connectx4lx_phys_layer_stat_cntrs *ptr_struct, FILE* file);
/* eth_per_traffic_congestion_grp_data_layout */
void connectx4lx_eth_per_traffic_congestion_grp_data_layout_pack(const struct connectx4lx_eth_per_traffic_congestion_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_per_traffic_congestion_grp_data_layout_unpack(struct connectx4lx_eth_per_traffic_congestion_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_per_traffic_congestion_grp_data_layout_print(const struct connectx4lx_eth_per_traffic_congestion_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_per_traffic_congestion_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_PER_TRAFFIC_CONGESTION_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_per_traffic_congestion_grp_data_layout_dump(const struct connectx4lx_eth_per_traffic_congestion_grp_data_layout *ptr_struct, FILE* file);
/* ib_port_counters */
void connectx4lx_ib_port_counters_pack(const struct connectx4lx_ib_port_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ib_port_counters_unpack(struct connectx4lx_ib_port_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ib_port_counters_print(const struct connectx4lx_ib_port_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ib_port_counters_size(void);
#define CONNECTX4LX_IB_PORT_COUNTERS_SIZE    (0xf8)
void connectx4lx_ib_port_counters_dump(const struct connectx4lx_ib_port_counters *ptr_struct, FILE* file);
/* llr_counters */
void connectx4lx_llr_counters_pack(const struct connectx4lx_llr_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_llr_counters_unpack(struct connectx4lx_llr_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_llr_counters_print(const struct connectx4lx_llr_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_llr_counters_size(void);
#define CONNECTX4LX_LLR_COUNTERS_SIZE    (0xf8)
void connectx4lx_llr_counters_dump(const struct connectx4lx_llr_counters *ptr_struct, FILE* file);
/* discard_cntrs_grp_data */
void connectx4lx_discard_cntrs_grp_data_pack(const struct connectx4lx_discard_cntrs_grp_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_discard_cntrs_grp_data_unpack(struct connectx4lx_discard_cntrs_grp_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_discard_cntrs_grp_data_print(const struct connectx4lx_discard_cntrs_grp_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_discard_cntrs_grp_data_size(void);
#define CONNECTX4LX_DISCARD_CNTRS_GRP_DATA_SIZE    (0xf8)
void connectx4lx_discard_cntrs_grp_data_dump(const struct connectx4lx_discard_cntrs_grp_data *ptr_struct, FILE* file);
/* phys_layer_cntrs */
void connectx4lx_phys_layer_cntrs_pack(const struct connectx4lx_phys_layer_cntrs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phys_layer_cntrs_unpack(struct connectx4lx_phys_layer_cntrs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phys_layer_cntrs_print(const struct connectx4lx_phys_layer_cntrs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phys_layer_cntrs_size(void);
#define CONNECTX4LX_PHYS_LAYER_CNTRS_SIZE    (0xc8)
void connectx4lx_phys_layer_cntrs_dump(const struct connectx4lx_phys_layer_cntrs *ptr_struct, FILE* file);
/* correct_on_demand_layout */
void connectx4lx_correct_on_demand_layout_pack(const struct connectx4lx_correct_on_demand_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_correct_on_demand_layout_unpack(struct connectx4lx_correct_on_demand_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_correct_on_demand_layout_print(const struct connectx4lx_correct_on_demand_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_correct_on_demand_layout_size(void);
#define CONNECTX4LX_CORRECT_ON_DEMAND_LAYOUT_SIZE    (0x38)
void connectx4lx_correct_on_demand_layout_dump(const struct connectx4lx_correct_on_demand_layout *ptr_struct, FILE* file);
/* eth_per_traffic_grp_data_layout */
void connectx4lx_eth_per_traffic_grp_data_layout_pack(const struct connectx4lx_eth_per_traffic_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_per_traffic_grp_data_layout_unpack(struct connectx4lx_eth_per_traffic_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_per_traffic_grp_data_layout_print(const struct connectx4lx_eth_per_traffic_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_per_traffic_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_PER_TRAFFIC_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_per_traffic_grp_data_layout_dump(const struct connectx4lx_eth_per_traffic_grp_data_layout *ptr_struct, FILE* file);
/* eth_per_prio_grp_data_layout */
void connectx4lx_eth_per_prio_grp_data_layout_pack(const struct connectx4lx_eth_per_prio_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_per_prio_grp_data_layout_unpack(struct connectx4lx_eth_per_prio_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_per_prio_grp_data_layout_print(const struct connectx4lx_eth_per_prio_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_per_prio_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_PER_PRIO_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_per_prio_grp_data_layout_dump(const struct connectx4lx_eth_per_prio_grp_data_layout *ptr_struct, FILE* file);
/* eth_extended_cntrs_grp_data_layout */
void connectx4lx_eth_extended_cntrs_grp_data_layout_pack(const struct connectx4lx_eth_extended_cntrs_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_extended_cntrs_grp_data_layout_unpack(struct connectx4lx_eth_extended_cntrs_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_extended_cntrs_grp_data_layout_print(const struct connectx4lx_eth_extended_cntrs_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_extended_cntrs_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_EXTENDED_CNTRS_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_extended_cntrs_grp_data_layout_dump(const struct connectx4lx_eth_extended_cntrs_grp_data_layout *ptr_struct, FILE* file);
/* eth_3635_cntrs_grp_data_layout */
void connectx4lx_eth_3635_cntrs_grp_data_layout_pack(const struct connectx4lx_eth_3635_cntrs_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_3635_cntrs_grp_data_layout_unpack(struct connectx4lx_eth_3635_cntrs_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_3635_cntrs_grp_data_layout_print(const struct connectx4lx_eth_3635_cntrs_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_3635_cntrs_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_3635_CNTRS_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_3635_cntrs_grp_data_layout_dump(const struct connectx4lx_eth_3635_cntrs_grp_data_layout *ptr_struct, FILE* file);
/* eth_2819_cntrs_grp_data_layout */
void connectx4lx_eth_2819_cntrs_grp_data_layout_pack(const struct connectx4lx_eth_2819_cntrs_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_2819_cntrs_grp_data_layout_unpack(struct connectx4lx_eth_2819_cntrs_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_2819_cntrs_grp_data_layout_print(const struct connectx4lx_eth_2819_cntrs_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_2819_cntrs_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_2819_CNTRS_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_2819_cntrs_grp_data_layout_dump(const struct connectx4lx_eth_2819_cntrs_grp_data_layout *ptr_struct, FILE* file);
/* eth_2863_cntrs_grp_data_layout */
void connectx4lx_eth_2863_cntrs_grp_data_layout_pack(const struct connectx4lx_eth_2863_cntrs_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_2863_cntrs_grp_data_layout_unpack(struct connectx4lx_eth_2863_cntrs_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_2863_cntrs_grp_data_layout_print(const struct connectx4lx_eth_2863_cntrs_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_2863_cntrs_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_2863_CNTRS_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_2863_cntrs_grp_data_layout_dump(const struct connectx4lx_eth_2863_cntrs_grp_data_layout *ptr_struct, FILE* file);
/* eth_802_3_cntrs_grp_data_layout */
void connectx4lx_eth_802_3_cntrs_grp_data_layout_pack(const struct connectx4lx_eth_802_3_cntrs_grp_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_802_3_cntrs_grp_data_layout_unpack(struct connectx4lx_eth_802_3_cntrs_grp_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_802_3_cntrs_grp_data_layout_print(const struct connectx4lx_eth_802_3_cntrs_grp_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_802_3_cntrs_grp_data_layout_size(void);
#define CONNECTX4LX_ETH_802_3_CNTRS_GRP_DATA_LAYOUT_SIZE    (0xf8)
void connectx4lx_eth_802_3_cntrs_grp_data_layout_dump(const struct connectx4lx_eth_802_3_cntrs_grp_data_layout *ptr_struct, FILE* file);
/* dct_qp */
void connectx4lx_dct_qp_pack(const struct connectx4lx_dct_qp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dct_qp_unpack(struct connectx4lx_dct_qp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dct_qp_print(const struct connectx4lx_dct_qp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dct_qp_size(void);
#define CONNECTX4LX_DCT_QP_SIZE    (0x10)
void connectx4lx_dct_qp_dump(const struct connectx4lx_dct_qp *ptr_struct, FILE* file);
/* dcr_qp */
void connectx4lx_dcr_qp_pack(const struct connectx4lx_dcr_qp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcr_qp_unpack(struct connectx4lx_dcr_qp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcr_qp_print(const struct connectx4lx_dcr_qp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcr_qp_size(void);
#define CONNECTX4LX_DCR_QP_SIZE    (0x10)
void connectx4lx_dcr_qp_dump(const struct connectx4lx_dcr_qp *ptr_struct, FILE* file);
/* regular_qp */
void connectx4lx_regular_qp_pack(const struct connectx4lx_regular_qp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_regular_qp_unpack(struct connectx4lx_regular_qp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_regular_qp_print(const struct connectx4lx_regular_qp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_regular_qp_size(void);
#define CONNECTX4LX_REGULAR_QP_SIZE    (0x10)
void connectx4lx_regular_qp_dump(const struct connectx4lx_regular_qp *ptr_struct, FILE* file);
/* schedint_cause */
void connectx4lx_schedint_cause_pack(const struct connectx4lx_schedint_cause *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_schedint_cause_unpack(struct connectx4lx_schedint_cause *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_schedint_cause_print(const struct connectx4lx_schedint_cause *ptr_struct, FILE* file, int indent_level);
int connectx4lx_schedint_cause_size(void);
#define CONNECTX4LX_SCHEDINT_CAUSE_SIZE    (0x1)
void connectx4lx_schedint_cause_dump(const struct connectx4lx_schedint_cause *ptr_struct, FILE* file);
/* fw_qpc_ib */
void connectx4lx_fw_qpc_ib_pack(const struct connectx4lx_fw_qpc_ib *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_ib_unpack(struct connectx4lx_fw_qpc_ib *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_ib_print(const struct connectx4lx_fw_qpc_ib *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_ib_size(void);
#define CONNECTX4LX_FW_QPC_IB_SIZE    (0x4)
void connectx4lx_fw_qpc_ib_dump(const struct connectx4lx_fw_qpc_ib *ptr_struct, FILE* file);
/* fw_qpc_eth */
void connectx4lx_fw_qpc_eth_pack(const struct connectx4lx_fw_qpc_eth *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_eth_unpack(struct connectx4lx_fw_qpc_eth *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_eth_print(const struct connectx4lx_fw_qpc_eth *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_eth_size(void);
#define CONNECTX4LX_FW_QPC_ETH_SIZE    (0x4)
void connectx4lx_fw_qpc_eth_dump(const struct connectx4lx_fw_qpc_eth *ptr_struct, FILE* file);
/* hw_msix_context_data1 */
void connectx4lx_hw_msix_context_data1_pack(const struct connectx4lx_hw_msix_context_data1 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data1_unpack(struct connectx4lx_hw_msix_context_data1 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data1_print(const struct connectx4lx_hw_msix_context_data1 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_context_data1_size(void);
#define CONNECTX4LX_HW_MSIX_CONTEXT_DATA1_SIZE    (0x4)
void connectx4lx_hw_msix_context_data1_dump(const struct connectx4lx_hw_msix_context_data1 *ptr_struct, FILE* file);
/* hw_msix_context_data0 */
void connectx4lx_hw_msix_context_data0_pack(const struct connectx4lx_hw_msix_context_data0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data0_unpack(struct connectx4lx_hw_msix_context_data0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data0_print(const struct connectx4lx_hw_msix_context_data0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_context_data0_size(void);
#define CONNECTX4LX_HW_MSIX_CONTEXT_DATA0_SIZE    (0x4)
void connectx4lx_hw_msix_context_data0_dump(const struct connectx4lx_hw_msix_context_data0 *ptr_struct, FILE* file);
/* ste_iterator_decoder */
void connectx4lx_ste_iterator_decoder_pack(const struct connectx4lx_ste_iterator_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_iterator_decoder_unpack(struct connectx4lx_ste_iterator_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_iterator_decoder_print(const struct connectx4lx_ste_iterator_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_iterator_decoder_size(void);
#define CONNECTX4LX_STE_ITERATOR_DECODER_SIZE    (0x34)
void connectx4lx_ste_iterator_decoder_dump(const struct connectx4lx_ste_iterator_decoder *ptr_struct, FILE* file);
/* ste_rss_decoder */
void connectx4lx_ste_rss_decoder_pack(const struct connectx4lx_ste_rss_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_rss_decoder_unpack(struct connectx4lx_ste_rss_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_rss_decoder_print(const struct connectx4lx_ste_rss_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_rss_decoder_size(void);
#define CONNECTX4LX_STE_RSS_DECODER_SIZE    (0x34)
void connectx4lx_ste_rss_decoder_dump(const struct connectx4lx_ste_rss_decoder *ptr_struct, FILE* file);
/* ste_inline_decoder */
void connectx4lx_ste_inline_decoder_pack(const struct connectx4lx_ste_inline_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_inline_decoder_unpack(struct connectx4lx_ste_inline_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_inline_decoder_print(const struct connectx4lx_ste_inline_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_inline_decoder_size(void);
#define CONNECTX4LX_STE_INLINE_DECODER_SIZE    (0x34)
void connectx4lx_ste_inline_decoder_dump(const struct connectx4lx_ste_inline_decoder *ptr_struct, FILE* file);
/* ste_multiple_decoder */
void connectx4lx_ste_multiple_decoder_pack(const struct connectx4lx_ste_multiple_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_multiple_decoder_unpack(struct connectx4lx_ste_multiple_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_multiple_decoder_print(const struct connectx4lx_ste_multiple_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_multiple_decoder_size(void);
#define CONNECTX4LX_STE_MULTIPLE_DECODER_SIZE    (0x34)
void connectx4lx_ste_multiple_decoder_dump(const struct connectx4lx_ste_multiple_decoder *ptr_struct, FILE* file);
/* ste_sx_transmit_decoder */
void connectx4lx_ste_sx_transmit_decoder_pack(const struct connectx4lx_ste_sx_transmit_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ste_sx_transmit_decoder_unpack(struct connectx4lx_ste_sx_transmit_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ste_sx_transmit_decoder_print(const struct connectx4lx_ste_sx_transmit_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ste_sx_transmit_decoder_size(void);
#define CONNECTX4LX_STE_SX_TRANSMIT_DECODER_SIZE    (0x34)
void connectx4lx_ste_sx_transmit_decoder_dump(const struct connectx4lx_ste_sx_transmit_decoder *ptr_struct, FILE* file);
/* data_bulk */
void connectx4lx_data_bulk_pack(const struct connectx4lx_data_bulk *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_data_bulk_unpack(struct connectx4lx_data_bulk *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_data_bulk_print(const struct connectx4lx_data_bulk *ptr_struct, FILE* file, int indent_level);
int connectx4lx_data_bulk_size(void);
#define CONNECTX4LX_DATA_BULK_SIZE    (0x34)
void connectx4lx_data_bulk_dump(const struct connectx4lx_data_bulk *ptr_struct, FILE* file);
/* shared_data */
void connectx4lx_shared_data_pack(const struct connectx4lx_shared_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_data_unpack(struct connectx4lx_shared_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_data_print(const struct connectx4lx_shared_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_data_size(void);
#define CONNECTX4LX_SHARED_DATA_SIZE    (0x34)
void connectx4lx_shared_data_dump(const struct connectx4lx_shared_data *ptr_struct, FILE* file);
/* sd_params_tx_set */
void connectx4lx_sd_params_tx_set_pack(const struct connectx4lx_sd_params_tx_set *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_set_unpack(struct connectx4lx_sd_params_tx_set *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_set_print(const struct connectx4lx_sd_params_tx_set *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_set_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_SET_SIZE    (0x8)
void connectx4lx_sd_params_tx_set_dump(const struct connectx4lx_sd_params_tx_set *ptr_struct, FILE* file);
/* subroutine */
void connectx4lx_subroutine_pack(const struct connectx4lx_subroutine *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_subroutine_unpack(struct connectx4lx_subroutine *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_subroutine_print(const struct connectx4lx_subroutine *ptr_struct, FILE* file, int indent_level);
int connectx4lx_subroutine_size(void);
#define CONNECTX4LX_SUBROUTINE_SIZE    (0x4)
void connectx4lx_subroutine_dump(const struct connectx4lx_subroutine *ptr_struct, FILE* file);
/* profile_ini */
void connectx4lx_profile_ini_pack(const struct connectx4lx_profile_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_profile_ini_unpack(struct connectx4lx_profile_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_profile_ini_print(const struct connectx4lx_profile_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_profile_ini_size(void);
#define CONNECTX4LX_PROFILE_INI_SIZE    (0xc)
void connectx4lx_profile_ini_dump(const struct connectx4lx_profile_ini *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands_specific */
void connectx4lx_cmdif_ctx_special_qp_commands_specific_pack(const union connectx4lx_cmdif_ctx_special_qp_commands_specific *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_specific_unpack(union connectx4lx_cmdif_ctx_special_qp_commands_specific *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_specific_print(const union connectx4lx_cmdif_ctx_special_qp_commands_specific *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_specific_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_SPECIFIC_SIZE    (0x10)
void connectx4lx_cmdif_ctx_special_qp_commands_specific_dump(const union connectx4lx_cmdif_ctx_special_qp_commands_specific *ptr_struct, FILE* file);
/* nic_part_capa */
void connectx4lx_nic_part_capa_pack(const struct connectx4lx_nic_part_capa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nic_part_capa_unpack(struct connectx4lx_nic_part_capa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nic_part_capa_print(const struct connectx4lx_nic_part_capa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nic_part_capa_size(void);
#define CONNECTX4LX_NIC_PART_CAPA_SIZE    (0x1)
void connectx4lx_nic_part_capa_dump(const struct connectx4lx_nic_part_capa *ptr_struct, FILE* file);
/* e_switch_capa */
void connectx4lx_e_switch_capa_pack(const struct connectx4lx_e_switch_capa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_e_switch_capa_unpack(struct connectx4lx_e_switch_capa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_e_switch_capa_print(const struct connectx4lx_e_switch_capa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_e_switch_capa_size(void);
#define CONNECTX4LX_E_SWITCH_CAPA_SIZE    (0x1)
void connectx4lx_e_switch_capa_dump(const struct connectx4lx_e_switch_capa *ptr_struct, FILE* file);
/* cap_15_0 */
void connectx4lx_cap_15_0_pack(const struct connectx4lx_cap_15_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cap_15_0_unpack(struct connectx4lx_cap_15_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cap_15_0_print(const struct connectx4lx_cap_15_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cap_15_0_size(void);
#define CONNECTX4LX_CAP_15_0_SIZE    (0x2)
void connectx4lx_cap_15_0_dump(const struct connectx4lx_cap_15_0 *ptr_struct, FILE* file);
/* dcb_capa */
void connectx4lx_dcb_capa_pack(const struct connectx4lx_dcb_capa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcb_capa_unpack(struct connectx4lx_dcb_capa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcb_capa_print(const struct connectx4lx_dcb_capa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcb_capa_size(void);
#define CONNECTX4LX_DCB_CAPA_SIZE    (0x1)
void connectx4lx_dcb_capa_dump(const struct connectx4lx_dcb_capa *ptr_struct, FILE* file);
/* cap_31_16 */
void connectx4lx_cap_31_16_pack(const struct connectx4lx_cap_31_16 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cap_31_16_unpack(struct connectx4lx_cap_31_16 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cap_31_16_print(const struct connectx4lx_cap_31_16 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cap_31_16_size(void);
#define CONNECTX4LX_CAP_31_16_SIZE    (0x2)
void connectx4lx_cap_31_16_dump(const struct connectx4lx_cap_31_16 *ptr_struct, FILE* file);
/* lled_get_interface_sensor_resp_qsfp */
void connectx4lx_lled_get_interface_sensor_resp_qsfp_pack(const struct connectx4lx_lled_get_interface_sensor_resp_qsfp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_qsfp_unpack(struct connectx4lx_lled_get_interface_sensor_resp_qsfp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_qsfp_print(const struct connectx4lx_lled_get_interface_sensor_resp_qsfp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_interface_sensor_resp_qsfp_size(void);
#define CONNECTX4LX_LLED_GET_INTERFACE_SENSOR_RESP_QSFP_SIZE    (0x30)
void connectx4lx_lled_get_interface_sensor_resp_qsfp_dump(const struct connectx4lx_lled_get_interface_sensor_resp_qsfp *ptr_struct, FILE* file);
/* lled_get_interface_sensor_resp_sfp */
void connectx4lx_lled_get_interface_sensor_resp_sfp_pack(const struct connectx4lx_lled_get_interface_sensor_resp_sfp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_sfp_unpack(struct connectx4lx_lled_get_interface_sensor_resp_sfp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_sfp_print(const struct connectx4lx_lled_get_interface_sensor_resp_sfp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_interface_sensor_resp_sfp_size(void);
#define CONNECTX4LX_LLED_GET_INTERFACE_SENSOR_RESP_SFP_SIZE    (0x1c)
void connectx4lx_lled_get_interface_sensor_resp_sfp_dump(const struct connectx4lx_lled_get_interface_sensor_resp_sfp *ptr_struct, FILE* file);
/* lled_get_interface_sensor_resp_common_fields */
void connectx4lx_lled_get_interface_sensor_resp_common_fields_pack(const struct connectx4lx_lled_get_interface_sensor_resp_common_fields *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_common_fields_unpack(struct connectx4lx_lled_get_interface_sensor_resp_common_fields *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_common_fields_print(const struct connectx4lx_lled_get_interface_sensor_resp_common_fields *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_interface_sensor_resp_common_fields_size(void);
#define CONNECTX4LX_LLED_GET_INTERFACE_SENSOR_RESP_COMMON_FIELDS_SIZE    (0x24)
void connectx4lx_lled_get_interface_sensor_resp_common_fields_dump(const struct connectx4lx_lled_get_interface_sensor_resp_common_fields *ptr_struct, FILE* file);
/* affinity */
void connectx4lx_affinity_pack(const struct connectx4lx_affinity *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_affinity_unpack(struct connectx4lx_affinity *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_affinity_print(const struct connectx4lx_affinity *ptr_struct, FILE* file, int indent_level);
int connectx4lx_affinity_size(void);
#define CONNECTX4LX_AFFINITY_SIZE    (0x34)
void connectx4lx_affinity_dump(const struct connectx4lx_affinity *ptr_struct, FILE* file);
/* pmcr_reg */
void connectx4lx_pmcr_reg_pack(const struct connectx4lx_pmcr_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmcr_reg_unpack(struct connectx4lx_pmcr_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmcr_reg_print(const struct connectx4lx_pmcr_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmcr_reg_size(void);
#define CONNECTX4LX_PMCR_REG_SIZE    (0x18)
void connectx4lx_pmcr_reg_dump(const struct connectx4lx_pmcr_reg *ptr_struct, FILE* file);
/* mpein_reg */
void connectx4lx_mpein_reg_pack(const struct connectx4lx_mpein_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mpein_reg_unpack(struct connectx4lx_mpein_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mpein_reg_print(const struct connectx4lx_mpein_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mpein_reg_size(void);
#define CONNECTX4LX_MPEIN_REG_SIZE    (0x2c)
void connectx4lx_mpein_reg_dump(const struct connectx4lx_mpein_reg *ptr_struct, FILE* file);
/* mvts */
void connectx4lx_mvts_pack(const struct connectx4lx_mvts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mvts_unpack(struct connectx4lx_mvts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mvts_print(const struct connectx4lx_mvts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mvts_size(void);
#define CONNECTX4LX_MVTS_SIZE    (0x14)
void connectx4lx_mvts_dump(const struct connectx4lx_mvts *ptr_struct, FILE* file);
/* pmlp */
void connectx4lx_pmlp_pack(const union connectx4lx_pmlp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmlp_unpack(union connectx4lx_pmlp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmlp_print(const union connectx4lx_pmlp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmlp_size(void);
#define CONNECTX4LX_PMLP_SIZE    (0x24)
void connectx4lx_pmlp_dump(const union connectx4lx_pmlp *ptr_struct, FILE* file);
/* pplm_reg */
void connectx4lx_pplm_reg_pack(const struct connectx4lx_pplm_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pplm_reg_unpack(struct connectx4lx_pplm_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pplm_reg_print(const struct connectx4lx_pplm_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pplm_reg_size(void);
#define CONNECTX4LX_PPLM_REG_SIZE    (0x18)
void connectx4lx_pplm_reg_dump(const struct connectx4lx_pplm_reg *ptr_struct, FILE* file);
/* plpc_reg */
void connectx4lx_plpc_reg_pack(const struct connectx4lx_plpc_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_plpc_reg_unpack(struct connectx4lx_plpc_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_plpc_reg_print(const struct connectx4lx_plpc_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_plpc_reg_size(void);
#define CONNECTX4LX_PLPC_REG_SIZE    (0x28)
void connectx4lx_plpc_reg_dump(const struct connectx4lx_plpc_reg *ptr_struct, FILE* file);
/* pplr_reg */
void connectx4lx_pplr_reg_pack(const struct connectx4lx_pplr_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pplr_reg_unpack(struct connectx4lx_pplr_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pplr_reg_print(const struct connectx4lx_pplr_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pplr_reg_size(void);
#define CONNECTX4LX_PPLR_REG_SIZE    (0x8)
void connectx4lx_pplr_reg_dump(const struct connectx4lx_pplr_reg *ptr_struct, FILE* file);
/* project_nvgn */
void connectx4lx_project_nvgn_pack(const struct connectx4lx_project_nvgn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_nvgn_unpack(struct connectx4lx_project_nvgn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_nvgn_print(const struct connectx4lx_project_nvgn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_nvgn_size(void);
#define CONNECTX4LX_PROJECT_NVGN_SIZE    (0x2c)
void connectx4lx_project_nvgn_dump(const struct connectx4lx_project_nvgn *ptr_struct, FILE* file);
/* project_nvia */
void connectx4lx_project_nvia_pack(const struct connectx4lx_project_nvia *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_nvia_unpack(struct connectx4lx_project_nvia *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_nvia_print(const struct connectx4lx_project_nvia *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_nvia_size(void);
#define CONNECTX4LX_PROJECT_NVIA_SIZE    (0x8)
void connectx4lx_project_nvia_dump(const struct connectx4lx_project_nvia *ptr_struct, FILE* file);
/* project_nvgc */
void connectx4lx_project_nvgc_pack(const struct connectx4lx_project_nvgc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_nvgc_unpack(struct connectx4lx_project_nvgc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_nvgc_print(const struct connectx4lx_project_nvgc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_nvgc_size(void);
#define CONNECTX4LX_PROJECT_NVGC_SIZE    (0x10)
void connectx4lx_project_nvgc_dump(const struct connectx4lx_project_nvgc *ptr_struct, FILE* file);
/* project_nvqc */
void connectx4lx_project_nvqc_pack(const struct connectx4lx_project_nvqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_nvqc_unpack(struct connectx4lx_project_nvqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_nvqc_print(const struct connectx4lx_project_nvqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_nvqc_size(void);
#define CONNECTX4LX_PROJECT_NVQC_SIZE    (0x8)
void connectx4lx_project_nvqc_dump(const struct connectx4lx_project_nvqc *ptr_struct, FILE* file);
/* project_nvda */
void connectx4lx_project_nvda_pack(const struct connectx4lx_project_nvda *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_nvda_unpack(struct connectx4lx_project_nvda *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_nvda_print(const struct connectx4lx_project_nvda *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_nvda_size(void);
#define CONNECTX4LX_PROJECT_NVDA_SIZE    (0x2c)
void connectx4lx_project_nvda_dump(const struct connectx4lx_project_nvda *ptr_struct, FILE* file);
/* pmtu_reg */
void connectx4lx_pmtu_reg_pack(const struct connectx4lx_pmtu_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmtu_reg_unpack(struct connectx4lx_pmtu_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmtu_reg_print(const struct connectx4lx_pmtu_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmtu_reg_size(void);
#define CONNECTX4LX_PMTU_REG_SIZE    (0x10)
void connectx4lx_pmtu_reg_dump(const struct connectx4lx_pmtu_reg *ptr_struct, FILE* file);
/* pamp_reg */
void connectx4lx_pamp_reg_pack(const struct connectx4lx_pamp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pamp_reg_unpack(struct connectx4lx_pamp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pamp_reg_print(const struct connectx4lx_pamp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pamp_reg_size(void);
#define CONNECTX4LX_PAMP_REG_SIZE    (0x2c)
void connectx4lx_pamp_reg_dump(const struct connectx4lx_pamp_reg *ptr_struct, FILE* file);
/* ppaos_reg */
void connectx4lx_ppaos_reg_pack(const struct connectx4lx_ppaos_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ppaos_reg_unpack(struct connectx4lx_ppaos_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ppaos_reg_print(const struct connectx4lx_ppaos_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ppaos_reg_size(void);
#define CONNECTX4LX_PPAOS_REG_SIZE    (0x10)
void connectx4lx_ppaos_reg_dump(const struct connectx4lx_ppaos_reg *ptr_struct, FILE* file);
/* pprt_reg */
void connectx4lx_pprt_reg_pack(const struct connectx4lx_pprt_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pprt_reg_unpack(struct connectx4lx_pprt_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pprt_reg_print(const struct connectx4lx_pprt_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pprt_reg_size(void);
#define CONNECTX4LX_PPRT_REG_SIZE    (0x20)
void connectx4lx_pprt_reg_dump(const struct connectx4lx_pprt_reg *ptr_struct, FILE* file);
/* pptt_reg */
void connectx4lx_pptt_reg_pack(const struct connectx4lx_pptt_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pptt_reg_unpack(struct connectx4lx_pptt_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pptt_reg_print(const struct connectx4lx_pptt_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pptt_reg_size(void);
#define CONNECTX4LX_PPTT_REG_SIZE    (0x1c)
void connectx4lx_pptt_reg_dump(const struct connectx4lx_pptt_reg *ptr_struct, FILE* file);
/* slrg_reg */
void connectx4lx_slrg_reg_pack(const struct connectx4lx_slrg_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_slrg_reg_unpack(struct connectx4lx_slrg_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_slrg_reg_print(const struct connectx4lx_slrg_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_slrg_reg_size(void);
#define CONNECTX4LX_SLRG_REG_SIZE    (0x28)
void connectx4lx_slrg_reg_dump(const struct connectx4lx_slrg_reg *ptr_struct, FILE* file);
/* ptas_reg */
void connectx4lx_ptas_reg_pack(const struct connectx4lx_ptas_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ptas_reg_unpack(struct connectx4lx_ptas_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ptas_reg_print(const struct connectx4lx_ptas_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ptas_reg_size(void);
#define CONNECTX4LX_PTAS_REG_SIZE    (0x2c)
void connectx4lx_ptas_reg_dump(const struct connectx4lx_ptas_reg *ptr_struct, FILE* file);
/* sltp_reg */
void connectx4lx_sltp_reg_pack(const struct connectx4lx_sltp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sltp_reg_unpack(struct connectx4lx_sltp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sltp_reg_print(const struct connectx4lx_sltp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sltp_reg_size(void);
#define CONNECTX4LX_SLTP_REG_SIZE    (0x14)
void connectx4lx_sltp_reg_dump(const struct connectx4lx_sltp_reg *ptr_struct, FILE* file);
/* slrp_reg */
void connectx4lx_slrp_reg_pack(const struct connectx4lx_slrp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_slrp_reg_unpack(struct connectx4lx_slrp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_slrp_reg_print(const struct connectx4lx_slrp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_slrp_reg_size(void);
#define CONNECTX4LX_SLRP_REG_SIZE    (0x28)
void connectx4lx_slrp_reg_dump(const struct connectx4lx_slrp_reg *ptr_struct, FILE* file);
/* paos_reg */
void connectx4lx_paos_reg_pack(const struct connectx4lx_paos_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_paos_reg_unpack(struct connectx4lx_paos_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_paos_reg_print(const struct connectx4lx_paos_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_paos_reg_size(void);
#define CONNECTX4LX_PAOS_REG_SIZE    (0x10)
void connectx4lx_paos_reg_dump(const struct connectx4lx_paos_reg *ptr_struct, FILE* file);
/* mjtag */
void connectx4lx_mjtag_pack(const struct connectx4lx_mjtag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mjtag_unpack(struct connectx4lx_mjtag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mjtag_print(const struct connectx4lx_mjtag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mjtag_size(void);
#define CONNECTX4LX_MJTAG_SIZE    (0x2c)
void connectx4lx_mjtag_dump(const struct connectx4lx_mjtag *ptr_struct, FILE* file);
/* mqis_reg */
void connectx4lx_mqis_reg_pack(const struct connectx4lx_mqis_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mqis_reg_unpack(struct connectx4lx_mqis_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mqis_reg_print(const struct connectx4lx_mqis_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mqis_reg_size(void);
#define CONNECTX4LX_MQIS_REG_SIZE    (0x14)
void connectx4lx_mqis_reg_dump(const struct connectx4lx_mqis_reg *ptr_struct, FILE* file);
/* mcda_reg */
void connectx4lx_mcda_reg_pack(const struct connectx4lx_mcda_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcda_reg_unpack(struct connectx4lx_mcda_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcda_reg_print(const struct connectx4lx_mcda_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcda_reg_size(void);
#define CONNECTX4LX_MCDA_REG_SIZE    (0x14)
void connectx4lx_mcda_reg_dump(const struct connectx4lx_mcda_reg *ptr_struct, FILE* file);
/* mcc_reg */
void connectx4lx_mcc_reg_pack(const struct connectx4lx_mcc_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcc_reg_unpack(struct connectx4lx_mcc_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcc_reg_print(const struct connectx4lx_mcc_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcc_reg_size(void);
#define CONNECTX4LX_MCC_REG_SIZE    (0x20)
void connectx4lx_mcc_reg_dump(const struct connectx4lx_mcc_reg *ptr_struct, FILE* file);
/* mcqi_reg */
void connectx4lx_mcqi_reg_pack(const struct connectx4lx_mcqi_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcqi_reg_unpack(struct connectx4lx_mcqi_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcqi_reg_print(const struct connectx4lx_mcqi_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcqi_reg_size(void);
#define CONNECTX4LX_MCQI_REG_SIZE    (0x1c)
void connectx4lx_mcqi_reg_dump(const struct connectx4lx_mcqi_reg *ptr_struct, FILE* file);
/* mcqs_reg */
void connectx4lx_mcqs_reg_pack(const struct connectx4lx_mcqs_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcqs_reg_unpack(struct connectx4lx_mcqs_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcqs_reg_print(const struct connectx4lx_mcqs_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcqs_reg_size(void);
#define CONNECTX4LX_MCQS_REG_SIZE    (0x10)
void connectx4lx_mcqs_reg_dump(const struct connectx4lx_mcqs_reg *ptr_struct, FILE* file);
/* mfbe */
void connectx4lx_mfbe_pack(const struct connectx4lx_mfbe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mfbe_unpack(struct connectx4lx_mfbe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mfbe_print(const struct connectx4lx_mfbe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mfbe_size(void);
#define CONNECTX4LX_MFBE_SIZE    (0xc)
void connectx4lx_mfbe_dump(const struct connectx4lx_mfbe *ptr_struct, FILE* file);
/* project_mfba */
void connectx4lx_project_mfba_pack(const struct connectx4lx_project_mfba *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_project_mfba_unpack(struct connectx4lx_project_mfba *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_project_mfba_print(const struct connectx4lx_project_mfba *ptr_struct, FILE* file, int indent_level);
int connectx4lx_project_mfba_size(void);
#define CONNECTX4LX_PROJECT_MFBA_SIZE    (0x2c)
void connectx4lx_project_mfba_dump(const struct connectx4lx_project_mfba *ptr_struct, FILE* file);
/* register_misc_counters */
void connectx4lx_register_misc_counters_pack(const struct connectx4lx_register_misc_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_misc_counters_unpack(struct connectx4lx_register_misc_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_misc_counters_print(const struct connectx4lx_register_misc_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_misc_counters_size(void);
#define CONNECTX4LX_REGISTER_MISC_COUNTERS_SIZE    (0x20)
void connectx4lx_register_misc_counters_dump(const struct connectx4lx_register_misc_counters *ptr_struct, FILE* file);
/* mtmp */
void connectx4lx_mtmp_pack(const struct connectx4lx_mtmp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mtmp_unpack(struct connectx4lx_mtmp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mtmp_print(const struct connectx4lx_mtmp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mtmp_size(void);
#define CONNECTX4LX_MTMP_SIZE    (0x20)
void connectx4lx_mtmp_dump(const struct connectx4lx_mtmp *ptr_struct, FILE* file);
/* register_mfrl */
void connectx4lx_register_mfrl_pack(const struct connectx4lx_register_mfrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_mfrl_unpack(struct connectx4lx_register_mfrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_mfrl_print(const struct connectx4lx_register_mfrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_mfrl_size(void);
#define CONNECTX4LX_REGISTER_MFRL_SIZE    (0x10)
void connectx4lx_register_mfrl_dump(const struct connectx4lx_register_mfrl *ptr_struct, FILE* file);
/* register_mfai */
void connectx4lx_register_mfai_pack(const struct connectx4lx_register_mfai *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_mfai_unpack(struct connectx4lx_register_mfai *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_mfai_print(const struct connectx4lx_register_mfai *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_mfai_size(void);
#define CONNECTX4LX_REGISTER_MFAI_SIZE    (0x10)
void connectx4lx_register_mfai_dump(const struct connectx4lx_register_mfai *ptr_struct, FILE* file);
/* mfpa */
void connectx4lx_mfpa_pack(const struct connectx4lx_mfpa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mfpa_unpack(struct connectx4lx_mfpa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mfpa_print(const struct connectx4lx_mfpa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mfpa_size(void);
#define CONNECTX4LX_MFPA_SIZE    (0x20)
void connectx4lx_mfpa_dump(const struct connectx4lx_mfpa *ptr_struct, FILE* file);
/* fpga_shell_caps */
void connectx4lx_fpga_shell_caps_pack(const struct connectx4lx_fpga_shell_caps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_shell_caps_unpack(struct connectx4lx_fpga_shell_caps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_shell_caps_print(const struct connectx4lx_fpga_shell_caps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_shell_caps_size(void);
#define CONNECTX4LX_FPGA_SHELL_CAPS_SIZE    (0x40)
void connectx4lx_fpga_shell_caps_dump(const struct connectx4lx_fpga_shell_caps *ptr_struct, FILE* file);
/* pmmp_sfp_protocol_override_layout_auto */
void connectx4lx_pmmp_sfp_protocol_override_layout_auto_pack(const union connectx4lx_pmmp_sfp_protocol_override_layout_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmmp_sfp_protocol_override_layout_auto_unpack(union connectx4lx_pmmp_sfp_protocol_override_layout_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmmp_sfp_protocol_override_layout_auto_print(const union connectx4lx_pmmp_sfp_protocol_override_layout_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmmp_sfp_protocol_override_layout_auto_size(void);
#define CONNECTX4LX_PMMP_SFP_PROTOCOL_OVERRIDE_LAYOUT_AUTO_SIZE    (0xc)
void connectx4lx_pmmp_sfp_protocol_override_layout_auto_dump(const union connectx4lx_pmmp_sfp_protocol_override_layout_auto *ptr_struct, FILE* file);
/* pmmp_qsfp_protocol_override_layout_auto */
void connectx4lx_pmmp_qsfp_protocol_override_layout_auto_pack(const union connectx4lx_pmmp_qsfp_protocol_override_layout_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmmp_qsfp_protocol_override_layout_auto_unpack(union connectx4lx_pmmp_qsfp_protocol_override_layout_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmmp_qsfp_protocol_override_layout_auto_print(const union connectx4lx_pmmp_qsfp_protocol_override_layout_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmmp_qsfp_protocol_override_layout_auto_size(void);
#define CONNECTX4LX_PMMP_QSFP_PROTOCOL_OVERRIDE_LAYOUT_AUTO_SIZE    (0xc)
void connectx4lx_pmmp_qsfp_protocol_override_layout_auto_dump(const union connectx4lx_pmmp_qsfp_protocol_override_layout_auto *ptr_struct, FILE* file);
/* pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto */
void connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto_pack(const union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto_unpack(union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto_print(const union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto_size(void);
#define CONNECTX4LX_PDDR_OPERATION_INFO_PAGE_PDDR_PHY_INFO_PAGE_PDDR_TROUBLESHOOTING_PAGE_PDDR_MODULE_INFO_AUTO_SIZE    (0xf8)
void connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto_dump(const union connectx4lx_pddr_operation_info_page_pddr_phy_info_page_pddr_troubleshooting_page_pddr_module_info_auto *ptr_struct, FILE* file);
/* pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto */
void connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto_pack(const union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto_unpack(union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto_print(const union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto_size(void);
#define CONNECTX4LX_PCIE_PERF_COUNTERS_PCIE_LANES_COUNTERS_PCIE_TIMERS_STATES_AUTO_SIZE    (0xf8)
void connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto_dump(const union connectx4lx_pcie_perf_counters_pcie_lanes_counters_pcie_timers_states_auto *ptr_struct, FILE* file);
/* eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto */
void connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto_pack(const union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto_unpack(union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto_print(const union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto_size(void);
#define CONNECTX4LX_ETH_802_3_CNTRS_GRP_DATA_LAYOUT_ETH_2863_CNTRS_GRP_DATA_LAYOUT_ETH_2819_CNTRS_GRP_DATA_LAYOUT_ETH_3635_CNTRS_GRP_DATA_LAYOUT_ETH_EXTENDED_CNTRS_GRP_DATA_LAYOUT_ETH_PER_PRIO_GRP_DATA_LAYOUT_ETH_PER_TRAFFIC_GRP_DATA_LAYOUT_PHYS_LAYER_CNTRS_AUTO_SIZE    (0xf8)
void connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto_dump(const union connectx4lx_eth_802_3_cntrs_grp_data_layout_eth_2863_cntrs_grp_data_layout_eth_2819_cntrs_grp_data_layout_eth_3635_cntrs_grp_data_layout_eth_extended_cntrs_grp_data_layout_eth_per_prio_grp_data_layout_eth_per_traffic_grp_data_layout_phys_layer_cntrs_auto *ptr_struct, FILE* file);
/* access_register_unit_perf_counters_data_line */
void connectx4lx_access_register_unit_perf_counters_data_line_pack(const struct connectx4lx_access_register_unit_perf_counters_data_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_data_line_unpack(struct connectx4lx_access_register_unit_perf_counters_data_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_data_line_print(const struct connectx4lx_access_register_unit_perf_counters_data_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_unit_perf_counters_data_line_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_UNIT_PERF_COUNTERS_DATA_LINE_SIZE    (0x4)
void connectx4lx_access_register_unit_perf_counters_data_line_dump(const struct connectx4lx_access_register_unit_perf_counters_data_line *ptr_struct, FILE* file);
/* access_register_unit_perf_counters_cfg_line */
void connectx4lx_access_register_unit_perf_counters_cfg_line_pack(const struct connectx4lx_access_register_unit_perf_counters_cfg_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_cfg_line_unpack(struct connectx4lx_access_register_unit_perf_counters_cfg_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_cfg_line_print(const struct connectx4lx_access_register_unit_perf_counters_cfg_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_unit_perf_counters_cfg_line_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_UNIT_PERF_COUNTERS_CFG_LINE_SIZE    (0x4)
void connectx4lx_access_register_unit_perf_counters_cfg_line_dump(const struct connectx4lx_access_register_unit_perf_counters_cfg_line *ptr_struct, FILE* file);
/* node_description */
void connectx4lx_node_description_pack(const struct connectx4lx_node_description *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_node_description_unpack(struct connectx4lx_node_description *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_node_description_print(const struct connectx4lx_node_description *ptr_struct, FILE* file, int indent_level);
int connectx4lx_node_description_size(void);
#define CONNECTX4LX_NODE_DESCRIPTION_SIZE    (0x40)
void connectx4lx_node_description_dump(const struct connectx4lx_node_description *ptr_struct, FILE* file);
/* application_prio_entry */
void connectx4lx_application_prio_entry_pack(const struct connectx4lx_application_prio_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_application_prio_entry_unpack(struct connectx4lx_application_prio_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_application_prio_entry_print(const struct connectx4lx_application_prio_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_application_prio_entry_size(void);
#define CONNECTX4LX_APPLICATION_PRIO_ENTRY_SIZE    (0x4)
void connectx4lx_application_prio_entry_dump(const struct connectx4lx_application_prio_entry *ptr_struct, FILE* file);
/* tc_qos_configuration */
void connectx4lx_tc_qos_configuration_pack(const struct connectx4lx_tc_qos_configuration *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tc_qos_configuration_unpack(struct connectx4lx_tc_qos_configuration *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tc_qos_configuration_print(const struct connectx4lx_tc_qos_configuration *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tc_qos_configuration_size(void);
#define CONNECTX4LX_TC_QOS_CONFIGURATION_SIZE    (0x8)
void connectx4lx_tc_qos_configuration_dump(const struct connectx4lx_tc_qos_configuration *ptr_struct, FILE* file);
/* fw_ref_count */
void connectx4lx_fw_ref_count_pack(const struct connectx4lx_fw_ref_count *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_ref_count_unpack(struct connectx4lx_fw_ref_count *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_ref_count_print(const struct connectx4lx_fw_ref_count *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_ref_count_size(void);
#define CONNECTX4LX_FW_REF_COUNT_SIZE    (0x4)
void connectx4lx_fw_ref_count_dump(const struct connectx4lx_fw_ref_count *ptr_struct, FILE* file);
/* mac_address_layout */
void connectx4lx_mac_address_layout_pack(const struct connectx4lx_mac_address_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mac_address_layout_unpack(struct connectx4lx_mac_address_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mac_address_layout_print(const struct connectx4lx_mac_address_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mac_address_layout_size(void);
#define CONNECTX4LX_MAC_ADDRESS_LAYOUT_SIZE    (0x8)
void connectx4lx_mac_address_layout_dump(const struct connectx4lx_mac_address_layout *ptr_struct, FILE* file);
/* tir_dmfs */
void connectx4lx_tir_dmfs_pack(const struct connectx4lx_tir_dmfs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tir_dmfs_unpack(struct connectx4lx_tir_dmfs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tir_dmfs_print(const struct connectx4lx_tir_dmfs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tir_dmfs_size(void);
#define CONNECTX4LX_TIR_DMFS_SIZE    (0x10)
void connectx4lx_tir_dmfs_dump(const struct connectx4lx_tir_dmfs *ptr_struct, FILE* file);
/* rx_hash_field_select */
void connectx4lx_rx_hash_field_select_pack(const struct connectx4lx_rx_hash_field_select *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rx_hash_field_select_unpack(struct connectx4lx_rx_hash_field_select *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rx_hash_field_select_print(const struct connectx4lx_rx_hash_field_select *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rx_hash_field_select_size(void);
#define CONNECTX4LX_RX_HASH_FIELD_SELECT_SIZE    (0x4)
void connectx4lx_rx_hash_field_select_dump(const struct connectx4lx_rx_hash_field_select *ptr_struct, FILE* file);
/* fw_qpc_special */
void connectx4lx_fw_qpc_special_pack(const union connectx4lx_fw_qpc_special *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_special_unpack(union connectx4lx_fw_qpc_special *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_special_print(const union connectx4lx_fw_qpc_special *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_special_size(void);
#define CONNECTX4LX_FW_QPC_SPECIAL_SIZE    (0x10)
void connectx4lx_fw_qpc_special_dump(const union connectx4lx_fw_qpc_special *ptr_struct, FILE* file);
/* fw_qpc_q */
void connectx4lx_fw_qpc_q_pack(const struct connectx4lx_fw_qpc_q *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_q_unpack(struct connectx4lx_fw_qpc_q *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_q_print(const struct connectx4lx_fw_qpc_q *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_q_size(void);
#define CONNECTX4LX_FW_QPC_Q_SIZE    (0x10)
void connectx4lx_fw_qpc_q_dump(const struct connectx4lx_fw_qpc_q *ptr_struct, FILE* file);
/* fw_qpc_ts_special */
void connectx4lx_fw_qpc_ts_special_pack(const union connectx4lx_fw_qpc_ts_special *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_ts_special_unpack(union connectx4lx_fw_qpc_ts_special *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_ts_special_print(const union connectx4lx_fw_qpc_ts_special *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_ts_special_size(void);
#define CONNECTX4LX_FW_QPC_TS_SPECIAL_SIZE    (0x4)
void connectx4lx_fw_qpc_ts_special_dump(const union connectx4lx_fw_qpc_ts_special *ptr_struct, FILE* file);
/* fw_xrqc */
void connectx4lx_fw_xrqc_pack(const struct connectx4lx_fw_xrqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_xrqc_unpack(struct connectx4lx_fw_xrqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_xrqc_print(const struct connectx4lx_fw_xrqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_xrqc_size(void);
#define CONNECTX4LX_FW_XRQC_SIZE    (0x20)
void connectx4lx_fw_xrqc_dump(const struct connectx4lx_fw_xrqc *ptr_struct, FILE* file);
/* hw_msix_context_data */
void connectx4lx_hw_msix_context_data_pack(const union connectx4lx_hw_msix_context_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data_unpack(union connectx4lx_hw_msix_context_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_data_print(const union connectx4lx_hw_msix_context_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_context_data_size(void);
#define CONNECTX4LX_HW_MSIX_CONTEXT_DATA_SIZE    (0x4)
void connectx4lx_hw_msix_context_data_dump(const union connectx4lx_hw_msix_context_data *ptr_struct, FILE* file);
/* steering_qp_entry */
void connectx4lx_steering_qp_entry_pack(const struct connectx4lx_steering_qp_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_steering_qp_entry_unpack(struct connectx4lx_steering_qp_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_steering_qp_entry_print(const struct connectx4lx_steering_qp_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_steering_qp_entry_size(void);
#define CONNECTX4LX_STEERING_QP_ENTRY_SIZE    (0x4)
void connectx4lx_steering_qp_entry_dump(const struct connectx4lx_steering_qp_entry *ptr_struct, FILE* file);
/* entry_data_union */
void connectx4lx_entry_data_union_pack(const union connectx4lx_entry_data_union *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_entry_data_union_unpack(union connectx4lx_entry_data_union *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_entry_data_union_print(const union connectx4lx_entry_data_union *ptr_struct, FILE* file, int indent_level);
int connectx4lx_entry_data_union_size(void);
#define CONNECTX4LX_ENTRY_DATA_UNION_SIZE    (0x34)
void connectx4lx_entry_data_union_dump(const union connectx4lx_entry_data_union *ptr_struct, FILE* file);
/* hw_dct_cvlan_to_cqe */
void connectx4lx_hw_dct_cvlan_to_cqe_pack(const struct connectx4lx_hw_dct_cvlan_to_cqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cvlan_to_cqe_unpack(struct connectx4lx_hw_dct_cvlan_to_cqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cvlan_to_cqe_print(const struct connectx4lx_hw_dct_cvlan_to_cqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cvlan_to_cqe_size(void);
#define CONNECTX4LX_HW_DCT_CVLAN_TO_CQE_SIZE    (0x40)
void connectx4lx_hw_dct_cvlan_to_cqe_dump(const struct connectx4lx_hw_dct_cvlan_to_cqe *ptr_struct, FILE* file);
/* hw_dct_vlan_prio */
void connectx4lx_hw_dct_vlan_prio_pack(const struct connectx4lx_hw_dct_vlan_prio *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_vlan_prio_unpack(struct connectx4lx_hw_dct_vlan_prio *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_vlan_prio_print(const struct connectx4lx_hw_dct_vlan_prio *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_vlan_prio_size(void);
#define CONNECTX4LX_HW_DCT_VLAN_PRIO_SIZE    (0x40)
void connectx4lx_hw_dct_vlan_prio_dump(const struct connectx4lx_hw_dct_vlan_prio *ptr_struct, FILE* file);
/* hw_dct_e2e_lack_call_fw */
void connectx4lx_hw_dct_e2e_lack_call_fw_pack(const struct connectx4lx_hw_dct_e2e_lack_call_fw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_e2e_lack_call_fw_unpack(struct connectx4lx_hw_dct_e2e_lack_call_fw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_e2e_lack_call_fw_print(const struct connectx4lx_hw_dct_e2e_lack_call_fw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_e2e_lack_call_fw_size(void);
#define CONNECTX4LX_HW_DCT_E2E_LACK_CALL_FW_SIZE    (0x40)
void connectx4lx_hw_dct_e2e_lack_call_fw_dump(const struct connectx4lx_hw_dct_e2e_lack_call_fw *ptr_struct, FILE* file);
/* hw_dct_force_ecn */
void connectx4lx_hw_dct_force_ecn_pack(const struct connectx4lx_hw_dct_force_ecn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_ecn_unpack(struct connectx4lx_hw_dct_force_ecn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_ecn_print(const struct connectx4lx_hw_dct_force_ecn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_force_ecn_size(void);
#define CONNECTX4LX_HW_DCT_FORCE_ECN_SIZE    (0x40)
void connectx4lx_hw_dct_force_ecn_dump(const struct connectx4lx_hw_dct_force_ecn *ptr_struct, FILE* file);
/* hw_dct_cqe_tip_source */
void connectx4lx_hw_dct_cqe_tip_source_pack(const struct connectx4lx_hw_dct_cqe_tip_source *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cqe_tip_source_unpack(struct connectx4lx_hw_dct_cqe_tip_source *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cqe_tip_source_print(const struct connectx4lx_hw_dct_cqe_tip_source *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cqe_tip_source_size(void);
#define CONNECTX4LX_HW_DCT_CQE_TIP_SOURCE_SIZE    (0x40)
void connectx4lx_hw_dct_cqe_tip_source_dump(const struct connectx4lx_hw_dct_cqe_tip_source *ptr_struct, FILE* file);
/* hw_dct_force_dscp */
void connectx4lx_hw_dct_force_dscp_pack(const struct connectx4lx_hw_dct_force_dscp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_dscp_unpack(struct connectx4lx_hw_dct_force_dscp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_dscp_print(const struct connectx4lx_hw_dct_force_dscp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_force_dscp_size(void);
#define CONNECTX4LX_HW_DCT_FORCE_DSCP_SIZE    (0x40)
void connectx4lx_hw_dct_force_dscp_dump(const struct connectx4lx_hw_dct_force_dscp *ptr_struct, FILE* file);
/* hw_dct_cntag_enable */
void connectx4lx_hw_dct_cntag_enable_pack(const struct connectx4lx_hw_dct_cntag_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cntag_enable_unpack(struct connectx4lx_hw_dct_cntag_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cntag_enable_print(const struct connectx4lx_hw_dct_cntag_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cntag_enable_size(void);
#define CONNECTX4LX_HW_DCT_CNTAG_ENABLE_SIZE    (0x40)
void connectx4lx_hw_dct_cntag_enable_dump(const struct connectx4lx_hw_dct_cntag_enable *ptr_struct, FILE* file);
/* hw_dct_can_use_reserved_lkey */
void connectx4lx_hw_dct_can_use_reserved_lkey_pack(const struct connectx4lx_hw_dct_can_use_reserved_lkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_can_use_reserved_lkey_unpack(struct connectx4lx_hw_dct_can_use_reserved_lkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_can_use_reserved_lkey_print(const struct connectx4lx_hw_dct_can_use_reserved_lkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_can_use_reserved_lkey_size(void);
#define CONNECTX4LX_HW_DCT_CAN_USE_RESERVED_LKEY_SIZE    (0x40)
void connectx4lx_hw_dct_can_use_reserved_lkey_dump(const struct connectx4lx_hw_dct_can_use_reserved_lkey *ptr_struct, FILE* file);
/* hw_dct_force_sl */
void connectx4lx_hw_dct_force_sl_pack(const struct connectx4lx_hw_dct_force_sl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_sl_unpack(struct connectx4lx_hw_dct_force_sl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_sl_print(const struct connectx4lx_hw_dct_force_sl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_force_sl_size(void);
#define CONNECTX4LX_HW_DCT_FORCE_SL_SIZE    (0x40)
void connectx4lx_hw_dct_force_sl_dump(const struct connectx4lx_hw_dct_force_sl *ptr_struct, FILE* file);
/* hw_dct_sl */
void connectx4lx_hw_dct_sl_pack(const struct connectx4lx_hw_dct_sl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_sl_unpack(struct connectx4lx_hw_dct_sl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_sl_print(const struct connectx4lx_hw_dct_sl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_sl_size(void);
#define CONNECTX4LX_HW_DCT_SL_SIZE    (0x40)
void connectx4lx_hw_dct_sl_dump(const struct connectx4lx_hw_dct_sl *ptr_struct, FILE* file);
/* hw_dct_cntag_flowid */
void connectx4lx_hw_dct_cntag_flowid_pack(const struct connectx4lx_hw_dct_cntag_flowid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cntag_flowid_unpack(struct connectx4lx_hw_dct_cntag_flowid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cntag_flowid_print(const struct connectx4lx_hw_dct_cntag_flowid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cntag_flowid_size(void);
#define CONNECTX4LX_HW_DCT_CNTAG_FLOWID_SIZE    (0x40)
void connectx4lx_hw_dct_cntag_flowid_dump(const struct connectx4lx_hw_dct_cntag_flowid *ptr_struct, FILE* file);
/* hw_dct_link_type_mac */
void connectx4lx_hw_dct_link_type_mac_pack(const struct connectx4lx_hw_dct_link_type_mac *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_link_type_mac_unpack(struct connectx4lx_hw_dct_link_type_mac *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_link_type_mac_print(const struct connectx4lx_hw_dct_link_type_mac *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_link_type_mac_size(void);
#define CONNECTX4LX_HW_DCT_LINK_TYPE_MAC_SIZE    (0x40)
void connectx4lx_hw_dct_link_type_mac_dump(const struct connectx4lx_hw_dct_link_type_mac *ptr_struct, FILE* file);
/* hw_dct_allow_grh_type */
void connectx4lx_hw_dct_allow_grh_type_pack(const struct connectx4lx_hw_dct_allow_grh_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_allow_grh_type_unpack(struct connectx4lx_hw_dct_allow_grh_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_allow_grh_type_print(const struct connectx4lx_hw_dct_allow_grh_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_allow_grh_type_size(void);
#define CONNECTX4LX_HW_DCT_ALLOW_GRH_TYPE_SIZE    (0x40)
void connectx4lx_hw_dct_allow_grh_type_dump(const struct connectx4lx_hw_dct_allow_grh_type *ptr_struct, FILE* file);
/* hw_dct_allow_roce_type */
void connectx4lx_hw_dct_allow_roce_type_pack(const struct connectx4lx_hw_dct_allow_roce_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_allow_roce_type_unpack(struct connectx4lx_hw_dct_allow_roce_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_allow_roce_type_print(const struct connectx4lx_hw_dct_allow_roce_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_allow_roce_type_size(void);
#define CONNECTX4LX_HW_DCT_ALLOW_ROCE_TYPE_SIZE    (0x40)
void connectx4lx_hw_dct_allow_roce_type_dump(const struct connectx4lx_hw_dct_allow_roce_type *ptr_struct, FILE* file);
/* hw_dct_cqe_qpn */
void connectx4lx_hw_dct_cqe_qpn_pack(const struct connectx4lx_hw_dct_cqe_qpn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cqe_qpn_unpack(struct connectx4lx_hw_dct_cqe_qpn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cqe_qpn_print(const struct connectx4lx_hw_dct_cqe_qpn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cqe_qpn_size(void);
#define CONNECTX4LX_HW_DCT_CQE_QPN_SIZE    (0x40)
void connectx4lx_hw_dct_cqe_qpn_dump(const struct connectx4lx_hw_dct_cqe_qpn *ptr_struct, FILE* file);
/* hw_dct_cache_alignment_end */
void connectx4lx_hw_dct_cache_alignment_end_pack(const struct connectx4lx_hw_dct_cache_alignment_end *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cache_alignment_end_unpack(struct connectx4lx_hw_dct_cache_alignment_end *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cache_alignment_end_print(const struct connectx4lx_hw_dct_cache_alignment_end *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cache_alignment_end_size(void);
#define CONNECTX4LX_HW_DCT_CACHE_ALIGNMENT_END_SIZE    (0x40)
void connectx4lx_hw_dct_cache_alignment_end_dump(const struct connectx4lx_hw_dct_cache_alignment_end *ptr_struct, FILE* file);
/* hw_dct_max_encapsulation_size */
void connectx4lx_hw_dct_max_encapsulation_size_pack(const struct connectx4lx_hw_dct_max_encapsulation_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_encapsulation_size_unpack(struct connectx4lx_hw_dct_max_encapsulation_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_encapsulation_size_print(const struct connectx4lx_hw_dct_max_encapsulation_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_max_encapsulation_size_size(void);
#define CONNECTX4LX_HW_DCT_MAX_ENCAPSULATION_SIZE_SIZE    (0x40)
void connectx4lx_hw_dct_max_encapsulation_size_dump(const struct connectx4lx_hw_dct_max_encapsulation_size *ptr_struct, FILE* file);
/* hw_dct_force_cnack */
void connectx4lx_hw_dct_force_cnack_pack(const struct connectx4lx_hw_dct_force_cnack *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_cnack_unpack(struct connectx4lx_hw_dct_force_cnack *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_force_cnack_print(const struct connectx4lx_hw_dct_force_cnack *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_force_cnack_size(void);
#define CONNECTX4LX_HW_DCT_FORCE_CNACK_SIZE    (0x40)
void connectx4lx_hw_dct_force_cnack_dump(const struct connectx4lx_hw_dct_force_cnack *ptr_struct, FILE* file);
/* hw_dct_port_number */
void connectx4lx_hw_dct_port_number_pack(const struct connectx4lx_hw_dct_port_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_port_number_unpack(struct connectx4lx_hw_dct_port_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_port_number_print(const struct connectx4lx_hw_dct_port_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_port_number_size(void);
#define CONNECTX4LX_HW_DCT_PORT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_dct_port_number_dump(const struct connectx4lx_hw_dct_port_number *ptr_struct, FILE* file);
/* hw_dct_adaptive_routing */
void connectx4lx_hw_dct_adaptive_routing_pack(const struct connectx4lx_hw_dct_adaptive_routing *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_adaptive_routing_unpack(struct connectx4lx_hw_dct_adaptive_routing *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_adaptive_routing_print(const struct connectx4lx_hw_dct_adaptive_routing *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_adaptive_routing_size(void);
#define CONNECTX4LX_HW_DCT_ADAPTIVE_ROUTING_SIZE    (0x40)
void connectx4lx_hw_dct_adaptive_routing_dump(const struct connectx4lx_hw_dct_adaptive_routing *ptr_struct, FILE* file);
/* hw_dct_tcu_trap */
void connectx4lx_hw_dct_tcu_trap_pack(const struct connectx4lx_hw_dct_tcu_trap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tcu_trap_unpack(struct connectx4lx_hw_dct_tcu_trap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tcu_trap_print(const struct connectx4lx_hw_dct_tcu_trap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_tcu_trap_size(void);
#define CONNECTX4LX_HW_DCT_TCU_TRAP_SIZE    (0x40)
void connectx4lx_hw_dct_tcu_trap_dump(const struct connectx4lx_hw_dct_tcu_trap *ptr_struct, FILE* file);
/* hw_dct_tcu_drop */
void connectx4lx_hw_dct_tcu_drop_pack(const struct connectx4lx_hw_dct_tcu_drop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tcu_drop_unpack(struct connectx4lx_hw_dct_tcu_drop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tcu_drop_print(const struct connectx4lx_hw_dct_tcu_drop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_tcu_drop_size(void);
#define CONNECTX4LX_HW_DCT_TCU_DROP_SIZE    (0x40)
void connectx4lx_hw_dct_tcu_drop_dump(const struct connectx4lx_hw_dct_tcu_drop *ptr_struct, FILE* file);
/* hw_dct_dc_access_key_log_num_byte */
void connectx4lx_hw_dct_dc_access_key_log_num_byte_pack(const struct connectx4lx_hw_dct_dc_access_key_log_num_byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_log_num_byte_unpack(struct connectx4lx_hw_dct_dc_access_key_log_num_byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_log_num_byte_print(const struct connectx4lx_hw_dct_dc_access_key_log_num_byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_dc_access_key_log_num_byte_size(void);
#define CONNECTX4LX_HW_DCT_DC_ACCESS_KEY_LOG_NUM_BYTE_SIZE    (0x40)
void connectx4lx_hw_dct_dc_access_key_log_num_byte_dump(const struct connectx4lx_hw_dct_dc_access_key_log_num_byte *ptr_struct, FILE* file);
/* hw_dct_fast_path */
void connectx4lx_hw_dct_fast_path_pack(const struct connectx4lx_hw_dct_fast_path *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_fast_path_unpack(struct connectx4lx_hw_dct_fast_path *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_fast_path_print(const struct connectx4lx_hw_dct_fast_path *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_fast_path_size(void);
#define CONNECTX4LX_HW_DCT_FAST_PATH_SIZE    (0x40)
void connectx4lx_hw_dct_fast_path_dump(const struct connectx4lx_hw_dct_fast_path *ptr_struct, FILE* file);
/* hw_dct_mtu */
void connectx4lx_hw_dct_mtu_pack(const struct connectx4lx_hw_dct_mtu *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_mtu_unpack(struct connectx4lx_hw_dct_mtu *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_mtu_print(const struct connectx4lx_hw_dct_mtu *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_mtu_size(void);
#define CONNECTX4LX_HW_DCT_MTU_SIZE    (0x40)
void connectx4lx_hw_dct_mtu_dump(const struct connectx4lx_hw_dct_mtu *ptr_struct, FILE* file);
/* hw_dct_read_enable */
void connectx4lx_hw_dct_read_enable_pack(const struct connectx4lx_hw_dct_read_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_read_enable_unpack(struct connectx4lx_hw_dct_read_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_read_enable_print(const struct connectx4lx_hw_dct_read_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_read_enable_size(void);
#define CONNECTX4LX_HW_DCT_READ_ENABLE_SIZE    (0x40)
void connectx4lx_hw_dct_read_enable_dump(const struct connectx4lx_hw_dct_read_enable *ptr_struct, FILE* file);
/* hw_dct_send_with_invalidate_enable */
void connectx4lx_hw_dct_send_with_invalidate_enable_pack(const struct connectx4lx_hw_dct_send_with_invalidate_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_send_with_invalidate_enable_unpack(struct connectx4lx_hw_dct_send_with_invalidate_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_send_with_invalidate_enable_print(const struct connectx4lx_hw_dct_send_with_invalidate_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_send_with_invalidate_enable_size(void);
#define CONNECTX4LX_HW_DCT_SEND_WITH_INVALIDATE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_dct_send_with_invalidate_enable_dump(const struct connectx4lx_hw_dct_send_with_invalidate_enable *ptr_struct, FILE* file);
/* hw_dct_ignore_pkey_check */
void connectx4lx_hw_dct_ignore_pkey_check_pack(const struct connectx4lx_hw_dct_ignore_pkey_check *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ignore_pkey_check_unpack(struct connectx4lx_hw_dct_ignore_pkey_check *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ignore_pkey_check_print(const struct connectx4lx_hw_dct_ignore_pkey_check *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_ignore_pkey_check_size(void);
#define CONNECTX4LX_HW_DCT_IGNORE_PKEY_CHECK_SIZE    (0x40)
void connectx4lx_hw_dct_ignore_pkey_check_dump(const struct connectx4lx_hw_dct_ignore_pkey_check *ptr_struct, FILE* file);
/* hw_dct_max_message_size */
void connectx4lx_hw_dct_max_message_size_pack(const struct connectx4lx_hw_dct_max_message_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_message_size_unpack(struct connectx4lx_hw_dct_max_message_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_message_size_print(const struct connectx4lx_hw_dct_max_message_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_max_message_size_size(void);
#define CONNECTX4LX_HW_DCT_MAX_MESSAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_dct_max_message_size_dump(const struct connectx4lx_hw_dct_max_message_size *ptr_struct, FILE* file);
/* hw_dct_inline_scatter */
void connectx4lx_hw_dct_inline_scatter_pack(const struct connectx4lx_hw_dct_inline_scatter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_inline_scatter_unpack(struct connectx4lx_hw_dct_inline_scatter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_inline_scatter_print(const struct connectx4lx_hw_dct_inline_scatter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_inline_scatter_size(void);
#define CONNECTX4LX_HW_DCT_INLINE_SCATTER_SIZE    (0x40)
void connectx4lx_hw_dct_inline_scatter_dump(const struct connectx4lx_hw_dct_inline_scatter *ptr_struct, FILE* file);
/* hw_dct_write_enable */
void connectx4lx_hw_dct_write_enable_pack(const struct connectx4lx_hw_dct_write_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_write_enable_unpack(struct connectx4lx_hw_dct_write_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_write_enable_print(const struct connectx4lx_hw_dct_write_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_write_enable_size(void);
#define CONNECTX4LX_HW_DCT_WRITE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_dct_write_enable_dump(const struct connectx4lx_hw_dct_write_enable *ptr_struct, FILE* file);
/* hw_dct_rnr_timer */
void connectx4lx_hw_dct_rnr_timer_pack(const struct connectx4lx_hw_dct_rnr_timer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_rnr_timer_unpack(struct connectx4lx_hw_dct_rnr_timer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_rnr_timer_print(const struct connectx4lx_hw_dct_rnr_timer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_rnr_timer_size(void);
#define CONNECTX4LX_HW_DCT_RNR_TIMER_SIZE    (0x40)
void connectx4lx_hw_dct_rnr_timer_dump(const struct connectx4lx_hw_dct_rnr_timer *ptr_struct, FILE* file);
/* hw_dct_atomic_like_write */
void connectx4lx_hw_dct_atomic_like_write_pack(const struct connectx4lx_hw_dct_atomic_like_write *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_atomic_like_write_unpack(struct connectx4lx_hw_dct_atomic_like_write *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_atomic_like_write_print(const struct connectx4lx_hw_dct_atomic_like_write *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_atomic_like_write_size(void);
#define CONNECTX4LX_HW_DCT_ATOMIC_LIKE_WRITE_SIZE    (0x40)
void connectx4lx_hw_dct_atomic_like_write_dump(const struct connectx4lx_hw_dct_atomic_like_write *ptr_struct, FILE* file);
/* hw_dct_my_lid */
void connectx4lx_hw_dct_my_lid_pack(const struct connectx4lx_hw_dct_my_lid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_my_lid_unpack(struct connectx4lx_hw_dct_my_lid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_my_lid_print(const struct connectx4lx_hw_dct_my_lid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_my_lid_size(void);
#define CONNECTX4LX_HW_DCT_MY_LID_SIZE    (0x40)
void connectx4lx_hw_dct_my_lid_dump(const struct connectx4lx_hw_dct_my_lid *ptr_struct, FILE* file);
/* hw_dct_qp_valid */
void connectx4lx_hw_dct_qp_valid_pack(const struct connectx4lx_hw_dct_qp_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_qp_valid_unpack(struct connectx4lx_hw_dct_qp_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_qp_valid_print(const struct connectx4lx_hw_dct_qp_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_qp_valid_size(void);
#define CONNECTX4LX_HW_DCT_QP_VALID_SIZE    (0x40)
void connectx4lx_hw_dct_qp_valid_dump(const struct connectx4lx_hw_dct_qp_valid *ptr_struct, FILE* file);
/* hw_dct_max_read_atomic */
void connectx4lx_hw_dct_max_read_atomic_pack(const struct connectx4lx_hw_dct_max_read_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_read_atomic_unpack(struct connectx4lx_hw_dct_max_read_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_max_read_atomic_print(const struct connectx4lx_hw_dct_max_read_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_max_read_atomic_size(void);
#define CONNECTX4LX_HW_DCT_MAX_READ_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_dct_max_read_atomic_dump(const struct connectx4lx_hw_dct_max_read_atomic *ptr_struct, FILE* file);
/* hw_dct_flow_label */
void connectx4lx_hw_dct_flow_label_pack(const struct connectx4lx_hw_dct_flow_label *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_flow_label_unpack(struct connectx4lx_hw_dct_flow_label *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_flow_label_print(const struct connectx4lx_hw_dct_flow_label *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_flow_label_size(void);
#define CONNECTX4LX_HW_DCT_FLOW_LABEL_SIZE    (0x40)
void connectx4lx_hw_dct_flow_label_dump(const struct connectx4lx_hw_dct_flow_label *ptr_struct, FILE* file);
/* hw_dct_counter_index */
void connectx4lx_hw_dct_counter_index_pack(const struct connectx4lx_hw_dct_counter_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_counter_index_unpack(struct connectx4lx_hw_dct_counter_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_counter_index_print(const struct connectx4lx_hw_dct_counter_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_counter_index_size(void);
#define CONNECTX4LX_HW_DCT_COUNTER_INDEX_SIZE    (0x40)
void connectx4lx_hw_dct_counter_index_dump(const struct connectx4lx_hw_dct_counter_index *ptr_struct, FILE* file);
/* hw_dct_srq_number */
void connectx4lx_hw_dct_srq_number_pack(const struct connectx4lx_hw_dct_srq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_srq_number_unpack(struct connectx4lx_hw_dct_srq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_srq_number_print(const struct connectx4lx_hw_dct_srq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_srq_number_size(void);
#define CONNECTX4LX_HW_DCT_SRQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_dct_srq_number_dump(const struct connectx4lx_hw_dct_srq_number *ptr_struct, FILE* file);
/* hw_dct_ts */
void connectx4lx_hw_dct_ts_pack(const struct connectx4lx_hw_dct_ts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ts_unpack(struct connectx4lx_hw_dct_ts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ts_print(const struct connectx4lx_hw_dct_ts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_ts_size(void);
#define CONNECTX4LX_HW_DCT_TS_SIZE    (0x40)
void connectx4lx_hw_dct_ts_dump(const struct connectx4lx_hw_dct_ts *ptr_struct, FILE* file);
/* hw_dct_ipd */
void connectx4lx_hw_dct_ipd_pack(const struct connectx4lx_hw_dct_ipd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ipd_unpack(struct connectx4lx_hw_dct_ipd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_ipd_print(const struct connectx4lx_hw_dct_ipd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_ipd_size(void);
#define CONNECTX4LX_HW_DCT_IPD_SIZE    (0x40)
void connectx4lx_hw_dct_ipd_dump(const struct connectx4lx_hw_dct_ipd *ptr_struct, FILE* file);
/* hw_dct_my_gid_mac_index */
void connectx4lx_hw_dct_my_gid_mac_index_pack(const struct connectx4lx_hw_dct_my_gid_mac_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_my_gid_mac_index_unpack(struct connectx4lx_hw_dct_my_gid_mac_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_my_gid_mac_index_print(const struct connectx4lx_hw_dct_my_gid_mac_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_my_gid_mac_index_size(void);
#define CONNECTX4LX_HW_DCT_MY_GID_MAC_INDEX_SIZE    (0x40)
void connectx4lx_hw_dct_my_gid_mac_index_dump(const struct connectx4lx_hw_dct_my_gid_mac_index *ptr_struct, FILE* file);
/* hw_dct_extended_atomic */
void connectx4lx_hw_dct_extended_atomic_pack(const struct connectx4lx_hw_dct_extended_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_extended_atomic_unpack(struct connectx4lx_hw_dct_extended_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_extended_atomic_print(const struct connectx4lx_hw_dct_extended_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_extended_atomic_size(void);
#define CONNECTX4LX_HW_DCT_EXTENDED_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_dct_extended_atomic_dump(const struct connectx4lx_hw_dct_extended_atomic *ptr_struct, FILE* file);
/* hw_dct_pkey_table_index */
void connectx4lx_hw_dct_pkey_table_index_pack(const struct connectx4lx_hw_dct_pkey_table_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_pkey_table_index_unpack(struct connectx4lx_hw_dct_pkey_table_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_pkey_table_index_print(const struct connectx4lx_hw_dct_pkey_table_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_pkey_table_index_size(void);
#define CONNECTX4LX_HW_DCT_PKEY_TABLE_INDEX_SIZE    (0x40)
void connectx4lx_hw_dct_pkey_table_index_dump(const struct connectx4lx_hw_dct_pkey_table_index *ptr_struct, FILE* file);
/* hw_dct_hop_limit */
void connectx4lx_hw_dct_hop_limit_pack(const struct connectx4lx_hw_dct_hop_limit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_hop_limit_unpack(struct connectx4lx_hw_dct_hop_limit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_hop_limit_print(const struct connectx4lx_hw_dct_hop_limit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_hop_limit_size(void);
#define CONNECTX4LX_HW_DCT_HOP_LIMIT_SIZE    (0x40)
void connectx4lx_hw_dct_hop_limit_dump(const struct connectx4lx_hw_dct_hop_limit *ptr_struct, FILE* file);
/* hw_dct_cq_number */
void connectx4lx_hw_dct_cq_number_pack(const struct connectx4lx_hw_dct_cq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cq_number_unpack(struct connectx4lx_hw_dct_cq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_cq_number_print(const struct connectx4lx_hw_dct_cq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_cq_number_size(void);
#define CONNECTX4LX_HW_DCT_CQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_dct_cq_number_dump(const struct connectx4lx_hw_dct_cq_number *ptr_struct, FILE* file);
/* hw_dct_tclass */
void connectx4lx_hw_dct_tclass_pack(const struct connectx4lx_hw_dct_tclass *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tclass_unpack(struct connectx4lx_hw_dct_tclass *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_tclass_print(const struct connectx4lx_hw_dct_tclass *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_tclass_size(void);
#define CONNECTX4LX_HW_DCT_TCLASS_SIZE    (0x40)
void connectx4lx_hw_dct_tclass_dump(const struct connectx4lx_hw_dct_tclass *ptr_struct, FILE* file);
/* hw_dct_context_number */
void connectx4lx_hw_dct_context_number_pack(const struct connectx4lx_hw_dct_context_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_context_number_unpack(struct connectx4lx_hw_dct_context_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_context_number_print(const struct connectx4lx_hw_dct_context_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_context_number_size(void);
#define CONNECTX4LX_HW_DCT_CONTEXT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_dct_context_number_dump(const struct connectx4lx_hw_dct_context_number *ptr_struct, FILE* file);
/* hw_dct_dc_access_key_63_32 */
void connectx4lx_hw_dct_dc_access_key_63_32_pack(const struct connectx4lx_hw_dct_dc_access_key_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_63_32_unpack(struct connectx4lx_hw_dct_dc_access_key_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_63_32_print(const struct connectx4lx_hw_dct_dc_access_key_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_dc_access_key_63_32_size(void);
#define CONNECTX4LX_HW_DCT_DC_ACCESS_KEY_63_32_SIZE    (0x40)
void connectx4lx_hw_dct_dc_access_key_63_32_dump(const struct connectx4lx_hw_dct_dc_access_key_63_32 *ptr_struct, FILE* file);
/* hw_dct_dc_access_key_31_0 */
void connectx4lx_hw_dct_dc_access_key_31_0_pack(const struct connectx4lx_hw_dct_dc_access_key_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_31_0_unpack(struct connectx4lx_hw_dct_dc_access_key_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_dc_access_key_31_0_print(const struct connectx4lx_hw_dct_dc_access_key_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_dc_access_key_31_0_size(void);
#define CONNECTX4LX_HW_DCT_DC_ACCESS_KEY_31_0_SIZE    (0x40)
void connectx4lx_hw_dct_dc_access_key_31_0_dump(const struct connectx4lx_hw_dct_dc_access_key_31_0 *ptr_struct, FILE* file);
/* hw_r_qpc_lro_outer_sip_31_0 */
void connectx4lx_hw_r_qpc_lro_outer_sip_31_0_pack(const struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_31_0_unpack(struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_31_0_print(const struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_outer_sip_31_0_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OUTER_SIP_31_0_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_outer_sip_31_0_dump(const struct connectx4lx_hw_r_qpc_lro_outer_sip_31_0 *ptr_struct, FILE* file);
/* hw_r_qpc_fcs_check_enable */
void connectx4lx_hw_r_qpc_fcs_check_enable_pack(const struct connectx4lx_hw_r_qpc_fcs_check_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fcs_check_enable_unpack(struct connectx4lx_hw_r_qpc_fcs_check_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fcs_check_enable_print(const struct connectx4lx_hw_r_qpc_fcs_check_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_fcs_check_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_FCS_CHECK_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_fcs_check_enable_dump(const struct connectx4lx_hw_r_qpc_fcs_check_enable *ptr_struct, FILE* file);
/* hw_r_qpc_fcs_scatter */
void connectx4lx_hw_r_qpc_fcs_scatter_pack(const struct connectx4lx_hw_r_qpc_fcs_scatter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fcs_scatter_unpack(struct connectx4lx_hw_r_qpc_fcs_scatter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fcs_scatter_print(const struct connectx4lx_hw_r_qpc_fcs_scatter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_fcs_scatter_size(void);
#define CONNECTX4LX_HW_R_QPC_FCS_SCATTER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_fcs_scatter_dump(const struct connectx4lx_hw_r_qpc_fcs_scatter *ptr_struct, FILE* file);
/* hw_r_qpc_l2_tunnel_decapsulation_enable */
void connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable_pack(const struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable_unpack(struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable_print(const struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_L2_TUNNEL_DECAPSULATION_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable_dump(const struct connectx4lx_hw_r_qpc_l2_tunnel_decapsulation_enable *ptr_struct, FILE* file);
/* hw_r_qpc_lro_cvlan_valid */
void connectx4lx_hw_r_qpc_lro_cvlan_valid_pack(const struct connectx4lx_hw_r_qpc_lro_cvlan_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cvlan_valid_unpack(struct connectx4lx_hw_r_qpc_lro_cvlan_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cvlan_valid_print(const struct connectx4lx_hw_r_qpc_lro_cvlan_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_cvlan_valid_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_CVLAN_VALID_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_cvlan_valid_dump(const struct connectx4lx_hw_r_qpc_lro_cvlan_valid *ptr_struct, FILE* file);
/* hw_r_qpc_lro_tunnel_enable */
void connectx4lx_hw_r_qpc_lro_tunnel_enable_pack(const struct connectx4lx_hw_r_qpc_lro_tunnel_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tunnel_enable_unpack(struct connectx4lx_hw_r_qpc_lro_tunnel_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tunnel_enable_print(const struct connectx4lx_hw_r_qpc_lro_tunnel_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_tunnel_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_TUNNEL_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_tunnel_enable_dump(const struct connectx4lx_hw_r_qpc_lro_tunnel_enable *ptr_struct, FILE* file);
/* hw_r_qpc_lro_timer_granularity */
void connectx4lx_hw_r_qpc_lro_timer_granularity_pack(const struct connectx4lx_hw_r_qpc_lro_timer_granularity *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_timer_granularity_unpack(struct connectx4lx_hw_r_qpc_lro_timer_granularity *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_timer_granularity_print(const struct connectx4lx_hw_r_qpc_lro_timer_granularity *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_timer_granularity_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_TIMER_GRANULARITY_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_timer_granularity_dump(const struct connectx4lx_hw_r_qpc_lro_timer_granularity *ptr_struct, FILE* file);
/* hw_r_qpc_lro_tunnel */
void connectx4lx_hw_r_qpc_lro_tunnel_pack(const struct connectx4lx_hw_r_qpc_lro_tunnel *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tunnel_unpack(struct connectx4lx_hw_r_qpc_lro_tunnel *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tunnel_print(const struct connectx4lx_hw_r_qpc_lro_tunnel *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_tunnel_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_TUNNEL_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_tunnel_dump(const struct connectx4lx_hw_r_qpc_lro_tunnel *ptr_struct, FILE* file);
/* hw_r_qpc_rx_strip_cntag */
void connectx4lx_hw_r_qpc_rx_strip_cntag_pack(const struct connectx4lx_hw_r_qpc_rx_strip_cntag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_strip_cntag_unpack(struct connectx4lx_hw_r_qpc_rx_strip_cntag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_strip_cntag_print(const struct connectx4lx_hw_r_qpc_rx_strip_cntag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rx_strip_cntag_size(void);
#define CONNECTX4LX_HW_R_QPC_RX_STRIP_CNTAG_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rx_strip_cntag_dump(const struct connectx4lx_hw_r_qpc_rx_strip_cntag *ptr_struct, FILE* file);
/* hw_r_qpc_cvlan_to_cqe */
void connectx4lx_hw_r_qpc_cvlan_to_cqe_pack(const struct connectx4lx_hw_r_qpc_cvlan_to_cqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cvlan_to_cqe_unpack(struct connectx4lx_hw_r_qpc_cvlan_to_cqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cvlan_to_cqe_print(const struct connectx4lx_hw_r_qpc_cvlan_to_cqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_cvlan_to_cqe_size(void);
#define CONNECTX4LX_HW_R_QPC_CVLAN_TO_CQE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_cvlan_to_cqe_dump(const struct connectx4lx_hw_r_qpc_cvlan_to_cqe *ptr_struct, FILE* file);
/* hw_r_qpc_tunnel_enable */
void connectx4lx_hw_r_qpc_tunnel_enable_pack(const struct connectx4lx_hw_r_qpc_tunnel_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tunnel_enable_unpack(struct connectx4lx_hw_r_qpc_tunnel_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tunnel_enable_print(const struct connectx4lx_hw_r_qpc_tunnel_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_tunnel_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_TUNNEL_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_tunnel_enable_dump(const struct connectx4lx_hw_r_qpc_tunnel_enable *ptr_struct, FILE* file);
/* hw_r_qpc_grh_to_cqe */
void connectx4lx_hw_r_qpc_grh_to_cqe_pack(const struct connectx4lx_hw_r_qpc_grh_to_cqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_grh_to_cqe_unpack(struct connectx4lx_hw_r_qpc_grh_to_cqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_grh_to_cqe_print(const struct connectx4lx_hw_r_qpc_grh_to_cqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_grh_to_cqe_size(void);
#define CONNECTX4LX_HW_R_QPC_GRH_TO_CQE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_grh_to_cqe_dump(const struct connectx4lx_hw_r_qpc_grh_to_cqe *ptr_struct, FILE* file);
/* hw_r_qpc_drop_my_self_multicast */
void connectx4lx_hw_r_qpc_drop_my_self_multicast_pack(const struct connectx4lx_hw_r_qpc_drop_my_self_multicast *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_drop_my_self_multicast_unpack(struct connectx4lx_hw_r_qpc_drop_my_self_multicast *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_drop_my_self_multicast_print(const struct connectx4lx_hw_r_qpc_drop_my_self_multicast *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_drop_my_self_multicast_size(void);
#define CONNECTX4LX_HW_R_QPC_DROP_MY_SELF_MULTICAST_SIZE    (0x40)
void connectx4lx_hw_r_qpc_drop_my_self_multicast_dump(const struct connectx4lx_hw_r_qpc_drop_my_self_multicast *ptr_struct, FILE* file);
/* hw_r_qpc_responder_session_id_23_16 */
void connectx4lx_hw_r_qpc_responder_session_id_23_16_pack(const struct connectx4lx_hw_r_qpc_responder_session_id_23_16 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_responder_session_id_23_16_unpack(struct connectx4lx_hw_r_qpc_responder_session_id_23_16 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_responder_session_id_23_16_print(const struct connectx4lx_hw_r_qpc_responder_session_id_23_16 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_responder_session_id_23_16_size(void);
#define CONNECTX4LX_HW_R_QPC_RESPONDER_SESSION_ID_23_16_SIZE    (0x40)
void connectx4lx_hw_r_qpc_responder_session_id_23_16_dump(const struct connectx4lx_hw_r_qpc_responder_session_id_23_16 *ptr_struct, FILE* file);
/* hw_r_qpc_responder_session_id_15_0 */
void connectx4lx_hw_r_qpc_responder_session_id_15_0_pack(const struct connectx4lx_hw_r_qpc_responder_session_id_15_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_responder_session_id_15_0_unpack(struct connectx4lx_hw_r_qpc_responder_session_id_15_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_responder_session_id_15_0_print(const struct connectx4lx_hw_r_qpc_responder_session_id_15_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_responder_session_id_15_0_size(void);
#define CONNECTX4LX_HW_R_QPC_RESPONDER_SESSION_ID_15_0_SIZE    (0x40)
void connectx4lx_hw_r_qpc_responder_session_id_15_0_dump(const struct connectx4lx_hw_r_qpc_responder_session_id_15_0 *ptr_struct, FILE* file);
/* hw_r_qpc_hds_first_segment_empty */
void connectx4lx_hw_r_qpc_hds_first_segment_empty_pack(const struct connectx4lx_hw_r_qpc_hds_first_segment_empty *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_first_segment_empty_unpack(struct connectx4lx_hw_r_qpc_hds_first_segment_empty *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_first_segment_empty_print(const struct connectx4lx_hw_r_qpc_hds_first_segment_empty *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hds_first_segment_empty_size(void);
#define CONNECTX4LX_HW_R_QPC_HDS_FIRST_SEGMENT_EMPTY_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hds_first_segment_empty_dump(const struct connectx4lx_hw_r_qpc_hds_first_segment_empty *ptr_struct, FILE* file);
/* hw_r_qpc_atomic_like_write */
void connectx4lx_hw_r_qpc_atomic_like_write_pack(const struct connectx4lx_hw_r_qpc_atomic_like_write *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_atomic_like_write_unpack(struct connectx4lx_hw_r_qpc_atomic_like_write *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_atomic_like_write_print(const struct connectx4lx_hw_r_qpc_atomic_like_write *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_atomic_like_write_size(void);
#define CONNECTX4LX_HW_R_QPC_ATOMIC_LIKE_WRITE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_atomic_like_write_dump(const struct connectx4lx_hw_r_qpc_atomic_like_write *ptr_struct, FILE* file);
/* hw_r_qpc_hds_split_en */
void connectx4lx_hw_r_qpc_hds_split_en_pack(const struct connectx4lx_hw_r_qpc_hds_split_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_split_en_unpack(struct connectx4lx_hw_r_qpc_hds_split_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_split_en_print(const struct connectx4lx_hw_r_qpc_hds_split_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hds_split_en_size(void);
#define CONNECTX4LX_HW_R_QPC_HDS_SPLIT_EN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hds_split_en_dump(const struct connectx4lx_hw_r_qpc_hds_split_en *ptr_struct, FILE* file);
/* hw_r_qpc_write_enable */
void connectx4lx_hw_r_qpc_write_enable_pack(const struct connectx4lx_hw_r_qpc_write_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_enable_unpack(struct connectx4lx_hw_r_qpc_write_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_enable_print(const struct connectx4lx_hw_r_qpc_write_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_write_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_WRITE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_write_enable_dump(const struct connectx4lx_hw_r_qpc_write_enable *ptr_struct, FILE* file);
/* hw_r_qpc_hds_lookahead_en */
void connectx4lx_hw_r_qpc_hds_lookahead_en_pack(const struct connectx4lx_hw_r_qpc_hds_lookahead_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_lookahead_en_unpack(struct connectx4lx_hw_r_qpc_hds_lookahead_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_lookahead_en_print(const struct connectx4lx_hw_r_qpc_hds_lookahead_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hds_lookahead_en_size(void);
#define CONNECTX4LX_HW_R_QPC_HDS_LOOKAHEAD_EN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hds_lookahead_en_dump(const struct connectx4lx_hw_r_qpc_hds_lookahead_en *ptr_struct, FILE* file);
/* hw_r_qpc_send_with_invalidate_enable */
void connectx4lx_hw_r_qpc_send_with_invalidate_enable_pack(const struct connectx4lx_hw_r_qpc_send_with_invalidate_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_send_with_invalidate_enable_unpack(struct connectx4lx_hw_r_qpc_send_with_invalidate_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_send_with_invalidate_enable_print(const struct connectx4lx_hw_r_qpc_send_with_invalidate_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_send_with_invalidate_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_SEND_WITH_INVALIDATE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_send_with_invalidate_enable_dump(const struct connectx4lx_hw_r_qpc_send_with_invalidate_enable *ptr_struct, FILE* file);
/* hw_r_qpc_lro_opaque_vld */
void connectx4lx_hw_r_qpc_lro_opaque_vld_pack(const struct connectx4lx_hw_r_qpc_lro_opaque_vld *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque_vld_unpack(struct connectx4lx_hw_r_qpc_lro_opaque_vld *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque_vld_print(const struct connectx4lx_hw_r_qpc_lro_opaque_vld *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_opaque_vld_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OPAQUE_VLD_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_opaque_vld_dump(const struct connectx4lx_hw_r_qpc_lro_opaque_vld *ptr_struct, FILE* file);
/* hw_r_qpc_read_enable */
void connectx4lx_hw_r_qpc_read_enable_pack(const struct connectx4lx_hw_r_qpc_read_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_read_enable_unpack(struct connectx4lx_hw_r_qpc_read_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_read_enable_print(const struct connectx4lx_hw_r_qpc_read_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_read_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_READ_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_read_enable_dump(const struct connectx4lx_hw_r_qpc_read_enable *ptr_struct, FILE* file);
/* hw_r_qpc_post_receive_slave_enable */
void connectx4lx_hw_r_qpc_post_receive_slave_enable_pack(const struct connectx4lx_hw_r_qpc_post_receive_slave_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_post_receive_slave_enable_unpack(struct connectx4lx_hw_r_qpc_post_receive_slave_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_post_receive_slave_enable_print(const struct connectx4lx_hw_r_qpc_post_receive_slave_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_post_receive_slave_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_POST_RECEIVE_SLAVE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_post_receive_slave_enable_dump(const struct connectx4lx_hw_r_qpc_post_receive_slave_enable *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_fetch_enable */
void connectx4lx_hw_r_qpc_e2e_fetch_enable_pack(const struct connectx4lx_hw_r_qpc_e2e_fetch_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_fetch_enable_unpack(struct connectx4lx_hw_r_qpc_e2e_fetch_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_fetch_enable_print(const struct connectx4lx_hw_r_qpc_e2e_fetch_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_fetch_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_FETCH_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_fetch_enable_dump(const struct connectx4lx_hw_r_qpc_e2e_fetch_enable *ptr_struct, FILE* file);
/* hw_r_qpc_no_direct_access */
void connectx4lx_hw_r_qpc_no_direct_access_pack(const struct connectx4lx_hw_r_qpc_no_direct_access *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_no_direct_access_unpack(struct connectx4lx_hw_r_qpc_no_direct_access *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_no_direct_access_print(const struct connectx4lx_hw_r_qpc_no_direct_access *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_no_direct_access_size(void);
#define CONNECTX4LX_HW_R_QPC_NO_DIRECT_ACCESS_SIZE    (0x40)
void connectx4lx_hw_r_qpc_no_direct_access_dump(const struct connectx4lx_hw_r_qpc_no_direct_access *ptr_struct, FILE* file);
/* hw_r_qpc_ignore_pkey_check */
void connectx4lx_hw_r_qpc_ignore_pkey_check_pack(const struct connectx4lx_hw_r_qpc_ignore_pkey_check *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ignore_pkey_check_unpack(struct connectx4lx_hw_r_qpc_ignore_pkey_check *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ignore_pkey_check_print(const struct connectx4lx_hw_r_qpc_ignore_pkey_check *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_ignore_pkey_check_size(void);
#define CONNECTX4LX_HW_R_QPC_IGNORE_PKEY_CHECK_SIZE    (0x40)
void connectx4lx_hw_r_qpc_ignore_pkey_check_dump(const struct connectx4lx_hw_r_qpc_ignore_pkey_check *ptr_struct, FILE* file);
/* hw_r_qpc_rx_heartbeat */
void connectx4lx_hw_r_qpc_rx_heartbeat_pack(const struct connectx4lx_hw_r_qpc_rx_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_heartbeat_unpack(struct connectx4lx_hw_r_qpc_rx_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_heartbeat_print(const struct connectx4lx_hw_r_qpc_rx_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rx_heartbeat_size(void);
#define CONNECTX4LX_HW_R_QPC_RX_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rx_heartbeat_dump(const struct connectx4lx_hw_r_qpc_rx_heartbeat *ptr_struct, FILE* file);
/* hw_r_qpc_tcu_drop */
void connectx4lx_hw_r_qpc_tcu_drop_pack(const struct connectx4lx_hw_r_qpc_tcu_drop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tcu_drop_unpack(struct connectx4lx_hw_r_qpc_tcu_drop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tcu_drop_print(const struct connectx4lx_hw_r_qpc_tcu_drop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_tcu_drop_size(void);
#define CONNECTX4LX_HW_R_QPC_TCU_DROP_SIZE    (0x40)
void connectx4lx_hw_r_qpc_tcu_drop_dump(const struct connectx4lx_hw_r_qpc_tcu_drop *ptr_struct, FILE* file);
/* hw_r_qpc_tcu_trap */
void connectx4lx_hw_r_qpc_tcu_trap_pack(const struct connectx4lx_hw_r_qpc_tcu_trap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tcu_trap_unpack(struct connectx4lx_hw_r_qpc_tcu_trap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_tcu_trap_print(const struct connectx4lx_hw_r_qpc_tcu_trap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_tcu_trap_size(void);
#define CONNECTX4LX_HW_R_QPC_TCU_TRAP_SIZE    (0x40)
void connectx4lx_hw_r_qpc_tcu_trap_dump(const struct connectx4lx_hw_r_qpc_tcu_trap *ptr_struct, FILE* file);
/* hw_r_qpc_rnr_timer */
void connectx4lx_hw_r_qpc_rnr_timer_pack(const struct connectx4lx_hw_r_qpc_rnr_timer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rnr_timer_unpack(struct connectx4lx_hw_r_qpc_rnr_timer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rnr_timer_print(const struct connectx4lx_hw_r_qpc_rnr_timer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rnr_timer_size(void);
#define CONNECTX4LX_HW_R_QPC_RNR_TIMER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rnr_timer_dump(const struct connectx4lx_hw_r_qpc_rnr_timer *ptr_struct, FILE* file);
/* hw_r_qpc_qp_valid */
void connectx4lx_hw_r_qpc_qp_valid_pack(const struct connectx4lx_hw_r_qpc_qp_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_qp_valid_unpack(struct connectx4lx_hw_r_qpc_qp_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_qp_valid_print(const struct connectx4lx_hw_r_qpc_qp_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_qp_valid_size(void);
#define CONNECTX4LX_HW_R_QPC_QP_VALID_SIZE    (0x40)
void connectx4lx_hw_r_qpc_qp_valid_dump(const struct connectx4lx_hw_r_qpc_qp_valid *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_credits_prefetch_threshold */
void connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold_pack(const struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold_unpack(struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold_print(const struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_CREDITS_PREFETCH_THRESHOLD_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold_dump(const struct connectx4lx_hw_r_qpc_e2e_credits_prefetch_threshold *ptr_struct, FILE* file);
/* hw_r_qpc_fast_path */
void connectx4lx_hw_r_qpc_fast_path_pack(const struct connectx4lx_hw_r_qpc_fast_path *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fast_path_unpack(struct connectx4lx_hw_r_qpc_fast_path *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_fast_path_print(const struct connectx4lx_hw_r_qpc_fast_path *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_fast_path_size(void);
#define CONNECTX4LX_HW_R_QPC_FAST_PATH_SIZE    (0x40)
void connectx4lx_hw_r_qpc_fast_path_dump(const struct connectx4lx_hw_r_qpc_fast_path *ptr_struct, FILE* file);
/* hw_r_qpc_can_use_reserved_lkey */
void connectx4lx_hw_r_qpc_can_use_reserved_lkey_pack(const struct connectx4lx_hw_r_qpc_can_use_reserved_lkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_can_use_reserved_lkey_unpack(struct connectx4lx_hw_r_qpc_can_use_reserved_lkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_can_use_reserved_lkey_print(const struct connectx4lx_hw_r_qpc_can_use_reserved_lkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_can_use_reserved_lkey_size(void);
#define CONNECTX4LX_HW_R_QPC_CAN_USE_RESERVED_LKEY_SIZE    (0x40)
void connectx4lx_hw_r_qpc_can_use_reserved_lkey_dump(const struct connectx4lx_hw_r_qpc_can_use_reserved_lkey *ptr_struct, FILE* file);
/* hw_r_qpc_rwq_type */
void connectx4lx_hw_r_qpc_rwq_type_pack(const struct connectx4lx_hw_r_qpc_rwq_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwq_type_unpack(struct connectx4lx_hw_r_qpc_rwq_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwq_type_print(const struct connectx4lx_hw_r_qpc_rwq_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rwq_type_size(void);
#define CONNECTX4LX_HW_R_QPC_RWQ_TYPE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rwq_type_dump(const struct connectx4lx_hw_r_qpc_rwq_type *ptr_struct, FILE* file);
/* hw_r_qpc_lro_cqe_tip */
void connectx4lx_hw_r_qpc_lro_cqe_tip_pack(const struct connectx4lx_hw_r_qpc_lro_cqe_tip *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cqe_tip_unpack(struct connectx4lx_hw_r_qpc_lro_cqe_tip *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cqe_tip_print(const struct connectx4lx_hw_r_qpc_lro_cqe_tip *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_cqe_tip_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_CQE_TIP_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_cqe_tip_dump(const struct connectx4lx_hw_r_qpc_lro_cqe_tip *ptr_struct, FILE* file);
/* hw_r_qpc_first_non_acked_psn */
void connectx4lx_hw_r_qpc_first_non_acked_psn_pack(const struct connectx4lx_hw_r_qpc_first_non_acked_psn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_first_non_acked_psn_unpack(struct connectx4lx_hw_r_qpc_first_non_acked_psn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_first_non_acked_psn_print(const struct connectx4lx_hw_r_qpc_first_non_acked_psn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_first_non_acked_psn_size(void);
#define CONNECTX4LX_HW_R_QPC_FIRST_NON_ACKED_PSN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_first_non_acked_psn_dump(const struct connectx4lx_hw_r_qpc_first_non_acked_psn *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_credits_enabled */
void connectx4lx_hw_r_qpc_e2e_credits_enabled_pack(const struct connectx4lx_hw_r_qpc_e2e_credits_enabled *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_credits_enabled_unpack(struct connectx4lx_hw_r_qpc_e2e_credits_enabled *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_credits_enabled_print(const struct connectx4lx_hw_r_qpc_e2e_credits_enabled *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_credits_enabled_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_CREDITS_ENABLED_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_credits_enabled_dump(const struct connectx4lx_hw_r_qpc_e2e_credits_enabled *ptr_struct, FILE* file);
/* hw_r_qpc_ack_type */
void connectx4lx_hw_r_qpc_ack_type_pack(const struct connectx4lx_hw_r_qpc_ack_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ack_type_unpack(struct connectx4lx_hw_r_qpc_ack_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ack_type_print(const struct connectx4lx_hw_r_qpc_ack_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_ack_type_size(void);
#define CONNECTX4LX_HW_R_QPC_ACK_TYPE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_ack_type_dump(const struct connectx4lx_hw_r_qpc_ack_type *ptr_struct, FILE* file);
/* hw_r_qpc_sx_heartbeat */
void connectx4lx_hw_r_qpc_sx_heartbeat_pack(const struct connectx4lx_hw_r_qpc_sx_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_sx_heartbeat_unpack(struct connectx4lx_hw_r_qpc_sx_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_sx_heartbeat_print(const struct connectx4lx_hw_r_qpc_sx_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_sx_heartbeat_size(void);
#define CONNECTX4LX_HW_R_QPC_SX_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_r_qpc_sx_heartbeat_dump(const struct connectx4lx_hw_r_qpc_sx_heartbeat *ptr_struct, FILE* file);
/* hw_r_qpc_lro_coalesce_segment */
void connectx4lx_hw_r_qpc_lro_coalesce_segment_pack(const struct connectx4lx_hw_r_qpc_lro_coalesce_segment *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_coalesce_segment_unpack(struct connectx4lx_hw_r_qpc_lro_coalesce_segment *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_coalesce_segment_print(const struct connectx4lx_hw_r_qpc_lro_coalesce_segment *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_coalesce_segment_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_COALESCE_SEGMENT_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_coalesce_segment_dump(const struct connectx4lx_hw_r_qpc_lro_coalesce_segment *ptr_struct, FILE* file);
/* hw_r_qpc_max_read_atomic */
void connectx4lx_hw_r_qpc_max_read_atomic_pack(const struct connectx4lx_hw_r_qpc_max_read_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_max_read_atomic_unpack(struct connectx4lx_hw_r_qpc_max_read_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_max_read_atomic_print(const struct connectx4lx_hw_r_qpc_max_read_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_max_read_atomic_size(void);
#define CONNECTX4LX_HW_R_QPC_MAX_READ_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_r_qpc_max_read_atomic_dump(const struct connectx4lx_hw_r_qpc_max_read_atomic *ptr_struct, FILE* file);
/* hw_r_qpc_lro_max_message_size */
void connectx4lx_hw_r_qpc_lro_max_message_size_pack(const struct connectx4lx_hw_r_qpc_lro_max_message_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_max_message_size_unpack(struct connectx4lx_hw_r_qpc_lro_max_message_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_max_message_size_print(const struct connectx4lx_hw_r_qpc_lro_max_message_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_max_message_size_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_MAX_MESSAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_max_message_size_dump(const struct connectx4lx_hw_r_qpc_lro_max_message_size *ptr_struct, FILE* file);
/* hw_r_qpc_lro_cvlan */
void connectx4lx_hw_r_qpc_lro_cvlan_pack(const struct connectx4lx_hw_r_qpc_lro_cvlan *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cvlan_unpack(struct connectx4lx_hw_r_qpc_lro_cvlan *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_cvlan_print(const struct connectx4lx_hw_r_qpc_lro_cvlan *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_cvlan_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_CVLAN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_cvlan_dump(const struct connectx4lx_hw_r_qpc_lro_cvlan *ptr_struct, FILE* file);
/* hw_r_qpc_expected_psn */
void connectx4lx_hw_r_qpc_expected_psn_pack(const struct connectx4lx_hw_r_qpc_expected_psn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_expected_psn_unpack(struct connectx4lx_hw_r_qpc_expected_psn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_expected_psn_print(const struct connectx4lx_hw_r_qpc_expected_psn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_expected_psn_size(void);
#define CONNECTX4LX_HW_R_QPC_EXPECTED_PSN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_expected_psn_dump(const struct connectx4lx_hw_r_qpc_expected_psn *ptr_struct, FILE* file);
/* hw_r_qpc_rdb_write_pointer */
void connectx4lx_hw_r_qpc_rdb_write_pointer_pack(const struct connectx4lx_hw_r_qpc_rdb_write_pointer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rdb_write_pointer_unpack(struct connectx4lx_hw_r_qpc_rdb_write_pointer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rdb_write_pointer_print(const struct connectx4lx_hw_r_qpc_rdb_write_pointer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rdb_write_pointer_size(void);
#define CONNECTX4LX_HW_R_QPC_RDB_WRITE_POINTER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rdb_write_pointer_dump(const struct connectx4lx_hw_r_qpc_rdb_write_pointer *ptr_struct, FILE* file);
/* hw_r_qpc_lro_opaque2 */
void connectx4lx_hw_r_qpc_lro_opaque2_pack(const struct connectx4lx_hw_r_qpc_lro_opaque2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque2_unpack(struct connectx4lx_hw_r_qpc_lro_opaque2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque2_print(const struct connectx4lx_hw_r_qpc_lro_opaque2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_opaque2_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OPAQUE2_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_opaque2_dump(const struct connectx4lx_hw_r_qpc_lro_opaque2 *ptr_struct, FILE* file);
/* hw_r_qpc_lro_outer_sip_95_64 */
void connectx4lx_hw_r_qpc_lro_outer_sip_95_64_pack(const struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_95_64_unpack(struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_95_64_print(const struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_outer_sip_95_64_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OUTER_SIP_95_64_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_outer_sip_95_64_dump(const struct connectx4lx_hw_r_qpc_lro_outer_sip_95_64 *ptr_struct, FILE* file);
/* hw_r_qpc_lro_opaque1 */
void connectx4lx_hw_r_qpc_lro_opaque1_pack(const struct connectx4lx_hw_r_qpc_lro_opaque1 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque1_unpack(struct connectx4lx_hw_r_qpc_lro_opaque1 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque1_print(const struct connectx4lx_hw_r_qpc_lro_opaque1 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_opaque1_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OPAQUE1_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_opaque1_dump(const struct connectx4lx_hw_r_qpc_lro_opaque1 *ptr_struct, FILE* file);
/* hw_r_qpc_rx_length_committed */
void connectx4lx_hw_r_qpc_rx_length_committed_pack(const struct connectx4lx_hw_r_qpc_rx_length_committed *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_length_committed_unpack(struct connectx4lx_hw_r_qpc_rx_length_committed *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rx_length_committed_print(const struct connectx4lx_hw_r_qpc_rx_length_committed *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rx_length_committed_size(void);
#define CONNECTX4LX_HW_R_QPC_RX_LENGTH_COMMITTED_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rx_length_committed_dump(const struct connectx4lx_hw_r_qpc_rx_length_committed *ptr_struct, FILE* file);
/* hw_r_qpc_lro_enable */
void connectx4lx_hw_r_qpc_lro_enable_pack(const struct connectx4lx_hw_r_qpc_lro_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_enable_unpack(struct connectx4lx_hw_r_qpc_lro_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_enable_print(const struct connectx4lx_hw_r_qpc_lro_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_enable_dump(const struct connectx4lx_hw_r_qpc_lro_enable *ptr_struct, FILE* file);
/* hw_r_qpc_allow_grh_type */
void connectx4lx_hw_r_qpc_allow_grh_type_pack(const struct connectx4lx_hw_r_qpc_allow_grh_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_allow_grh_type_unpack(struct connectx4lx_hw_r_qpc_allow_grh_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_allow_grh_type_print(const struct connectx4lx_hw_r_qpc_allow_grh_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_allow_grh_type_size(void);
#define CONNECTX4LX_HW_R_QPC_ALLOW_GRH_TYPE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_allow_grh_type_dump(const struct connectx4lx_hw_r_qpc_allow_grh_type *ptr_struct, FILE* file);
/* hw_r_qpc_allow_roce_type */
void connectx4lx_hw_r_qpc_allow_roce_type_pack(const struct connectx4lx_hw_r_qpc_allow_roce_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_allow_roce_type_unpack(struct connectx4lx_hw_r_qpc_allow_roce_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_allow_roce_type_print(const struct connectx4lx_hw_r_qpc_allow_roce_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_allow_roce_type_size(void);
#define CONNECTX4LX_HW_R_QPC_ALLOW_ROCE_TYPE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_allow_roce_type_dump(const struct connectx4lx_hw_r_qpc_allow_roce_type *ptr_struct, FILE* file);
/* hw_r_qpc_no_wqe_drop_count */
void connectx4lx_hw_r_qpc_no_wqe_drop_count_pack(const struct connectx4lx_hw_r_qpc_no_wqe_drop_count *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_no_wqe_drop_count_unpack(struct connectx4lx_hw_r_qpc_no_wqe_drop_count *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_no_wqe_drop_count_print(const struct connectx4lx_hw_r_qpc_no_wqe_drop_count *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_no_wqe_drop_count_size(void);
#define CONNECTX4LX_HW_R_QPC_NO_WQE_DROP_COUNT_SIZE    (0x40)
void connectx4lx_hw_r_qpc_no_wqe_drop_count_dump(const struct connectx4lx_hw_r_qpc_no_wqe_drop_count *ptr_struct, FILE* file);
/* hw_r_qpc_write_rkey */
void connectx4lx_hw_r_qpc_write_rkey_pack(const struct connectx4lx_hw_r_qpc_write_rkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_rkey_unpack(struct connectx4lx_hw_r_qpc_write_rkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_rkey_print(const struct connectx4lx_hw_r_qpc_write_rkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_write_rkey_size(void);
#define CONNECTX4LX_HW_R_QPC_WRITE_RKEY_SIZE    (0x40)
void connectx4lx_hw_r_qpc_write_rkey_dump(const struct connectx4lx_hw_r_qpc_write_rkey *ptr_struct, FILE* file);
/* hw_r_qpc_lro_rx_length_committed */
void connectx4lx_hw_r_qpc_lro_rx_length_committed_pack(const struct connectx4lx_hw_r_qpc_lro_rx_length_committed *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_rx_length_committed_unpack(struct connectx4lx_hw_r_qpc_lro_rx_length_committed *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_rx_length_committed_print(const struct connectx4lx_hw_r_qpc_lro_rx_length_committed *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_rx_length_committed_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_RX_LENGTH_COMMITTED_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_rx_length_committed_dump(const struct connectx4lx_hw_r_qpc_lro_rx_length_committed *ptr_struct, FILE* file);
/* hw_r_qpc_inline_scatter */
void connectx4lx_hw_r_qpc_inline_scatter_pack(const struct connectx4lx_hw_r_qpc_inline_scatter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_inline_scatter_unpack(struct connectx4lx_hw_r_qpc_inline_scatter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_inline_scatter_print(const struct connectx4lx_hw_r_qpc_inline_scatter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_inline_scatter_size(void);
#define CONNECTX4LX_HW_R_QPC_INLINE_SCATTER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_inline_scatter_dump(const struct connectx4lx_hw_r_qpc_inline_scatter *ptr_struct, FILE* file);
/* hw_r_qpc_connection_state */
void connectx4lx_hw_r_qpc_connection_state_pack(const struct connectx4lx_hw_r_qpc_connection_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_connection_state_unpack(struct connectx4lx_hw_r_qpc_connection_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_connection_state_print(const struct connectx4lx_hw_r_qpc_connection_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_connection_state_size(void);
#define CONNECTX4LX_HW_R_QPC_CONNECTION_STATE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_connection_state_dump(const struct connectx4lx_hw_r_qpc_connection_state *ptr_struct, FILE* file);
/* hw_r_qpc_last_opcode */
void connectx4lx_hw_r_qpc_last_opcode_pack(const struct connectx4lx_hw_r_qpc_last_opcode *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_last_opcode_unpack(struct connectx4lx_hw_r_qpc_last_opcode *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_last_opcode_print(const struct connectx4lx_hw_r_qpc_last_opcode *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_last_opcode_size(void);
#define CONNECTX4LX_HW_R_QPC_LAST_OPCODE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_last_opcode_dump(const struct connectx4lx_hw_r_qpc_last_opcode *ptr_struct, FILE* file);
/* hw_r_qpc_mtu_byte */
void connectx4lx_hw_r_qpc_mtu_byte_pack(const struct connectx4lx_hw_r_qpc_mtu_byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_mtu_byte_unpack(struct connectx4lx_hw_r_qpc_mtu_byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_mtu_byte_print(const struct connectx4lx_hw_r_qpc_mtu_byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_mtu_byte_size(void);
#define CONNECTX4LX_HW_R_QPC_MTU_BYTE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_mtu_byte_dump(const struct connectx4lx_hw_r_qpc_mtu_byte *ptr_struct, FILE* file);
/* hw_r_qpc_sqn */
void connectx4lx_hw_r_qpc_sqn_pack(const struct connectx4lx_hw_r_qpc_sqn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_sqn_unpack(struct connectx4lx_hw_r_qpc_sqn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_sqn_print(const struct connectx4lx_hw_r_qpc_sqn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_sqn_size(void);
#define CONNECTX4LX_HW_R_QPC_SQN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_sqn_dump(const struct connectx4lx_hw_r_qpc_sqn *ptr_struct, FILE* file);
/* hw_r_qpc_rwqe_limit_event */
void connectx4lx_hw_r_qpc_rwqe_limit_event_pack(const struct connectx4lx_hw_r_qpc_rwqe_limit_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_limit_event_unpack(struct connectx4lx_hw_r_qpc_rwqe_limit_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_limit_event_print(const struct connectx4lx_hw_r_qpc_rwqe_limit_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rwqe_limit_event_size(void);
#define CONNECTX4LX_HW_R_QPC_RWQE_LIMIT_EVENT_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rwqe_limit_event_dump(const struct connectx4lx_hw_r_qpc_rwqe_limit_event *ptr_struct, FILE* file);
/* hw_r_qpc_rdb_read_pointer */
void connectx4lx_hw_r_qpc_rdb_read_pointer_pack(const struct connectx4lx_hw_r_qpc_rdb_read_pointer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rdb_read_pointer_unpack(struct connectx4lx_hw_r_qpc_rdb_read_pointer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rdb_read_pointer_print(const struct connectx4lx_hw_r_qpc_rdb_read_pointer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rdb_read_pointer_size(void);
#define CONNECTX4LX_HW_R_QPC_RDB_READ_POINTER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rdb_read_pointer_dump(const struct connectx4lx_hw_r_qpc_rdb_read_pointer *ptr_struct, FILE* file);
/* hw_r_qpc_lro_outer_sip_63_32 */
void connectx4lx_hw_r_qpc_lro_outer_sip_63_32_pack(const struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_63_32_unpack(struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_outer_sip_63_32_print(const struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_outer_sip_63_32_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OUTER_SIP_63_32_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_outer_sip_63_32_dump(const struct connectx4lx_hw_r_qpc_lro_outer_sip_63_32 *ptr_struct, FILE* file);
/* hw_r_qpc_lro_opaque3 */
void connectx4lx_hw_r_qpc_lro_opaque3_pack(const struct connectx4lx_hw_r_qpc_lro_opaque3 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque3_unpack(struct connectx4lx_hw_r_qpc_lro_opaque3 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_opaque3_print(const struct connectx4lx_hw_r_qpc_lro_opaque3 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_opaque3_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_OPAQUE3_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_opaque3_dump(const struct connectx4lx_hw_r_qpc_lro_opaque3 *ptr_struct, FILE* file);
/* hw_r_qpc_requestor_session_id */
void connectx4lx_hw_r_qpc_requestor_session_id_pack(const struct connectx4lx_hw_r_qpc_requestor_session_id *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_requestor_session_id_unpack(struct connectx4lx_hw_r_qpc_requestor_session_id *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_requestor_session_id_print(const struct connectx4lx_hw_r_qpc_requestor_session_id *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_requestor_session_id_size(void);
#define CONNECTX4LX_HW_R_QPC_REQUESTOR_SESSION_ID_SIZE    (0x40)
void connectx4lx_hw_r_qpc_requestor_session_id_dump(const struct connectx4lx_hw_r_qpc_requestor_session_id *ptr_struct, FILE* file);
/* hw_r_qpc_lro_tenant_id */
void connectx4lx_hw_r_qpc_lro_tenant_id_pack(const struct connectx4lx_hw_r_qpc_lro_tenant_id *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tenant_id_unpack(struct connectx4lx_hw_r_qpc_lro_tenant_id *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tenant_id_print(const struct connectx4lx_hw_r_qpc_lro_tenant_id *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_tenant_id_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_TENANT_ID_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_tenant_id_dump(const struct connectx4lx_hw_r_qpc_lro_tenant_id *ptr_struct, FILE* file);
/* hw_r_qpc_lro_tcp_sn */
void connectx4lx_hw_r_qpc_lro_tcp_sn_pack(const struct connectx4lx_hw_r_qpc_lro_tcp_sn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tcp_sn_unpack(struct connectx4lx_hw_r_qpc_lro_tcp_sn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_tcp_sn_print(const struct connectx4lx_hw_r_qpc_lro_tcp_sn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_tcp_sn_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_TCP_SN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_tcp_sn_dump(const struct connectx4lx_hw_r_qpc_lro_tcp_sn *ptr_struct, FILE* file);
/* hw_r_qpc_write_va_63_32 */
void connectx4lx_hw_r_qpc_write_va_63_32_pack(const struct connectx4lx_hw_r_qpc_write_va_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_va_63_32_unpack(struct connectx4lx_hw_r_qpc_write_va_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_va_63_32_print(const struct connectx4lx_hw_r_qpc_write_va_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_write_va_63_32_size(void);
#define CONNECTX4LX_HW_R_QPC_WRITE_VA_63_32_SIZE    (0x40)
void connectx4lx_hw_r_qpc_write_va_63_32_dump(const struct connectx4lx_hw_r_qpc_write_va_63_32 *ptr_struct, FILE* file);
/* hw_r_qpc_write_va_31_0 */
void connectx4lx_hw_r_qpc_write_va_31_0_pack(const struct connectx4lx_hw_r_qpc_write_va_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_va_31_0_unpack(struct connectx4lx_hw_r_qpc_write_va_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_write_va_31_0_print(const struct connectx4lx_hw_r_qpc_write_va_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_write_va_31_0_size(void);
#define CONNECTX4LX_HW_R_QPC_WRITE_VA_31_0_SIZE    (0x40)
void connectx4lx_hw_r_qpc_write_va_31_0_dump(const struct connectx4lx_hw_r_qpc_write_va_31_0 *ptr_struct, FILE* file);
/* hw_r_qpc_lro_rwqe_max_stride */
void connectx4lx_hw_r_qpc_lro_rwqe_max_stride_pack(const struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_rwqe_max_stride_unpack(struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_rwqe_max_stride_print(const struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_rwqe_max_stride_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_RWQE_MAX_STRIDE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_rwqe_max_stride_dump(const struct connectx4lx_hw_r_qpc_lro_rwqe_max_stride *ptr_struct, FILE* file);
/* hw_r_qpc_rwqe_consumer_stride_index */
void connectx4lx_hw_r_qpc_rwqe_consumer_stride_index_pack(const struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_consumer_stride_index_unpack(struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_consumer_stride_index_print(const struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rwqe_consumer_stride_index_size(void);
#define CONNECTX4LX_HW_R_QPC_RWQE_CONSUMER_STRIDE_INDEX_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rwqe_consumer_stride_index_dump(const struct connectx4lx_hw_r_qpc_rwqe_consumer_stride_index *ptr_struct, FILE* file);
/* hw_r_qpc_rcyclic_producer */
void connectx4lx_hw_r_qpc_rcyclic_producer_pack(const struct connectx4lx_hw_r_qpc_rcyclic_producer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rcyclic_producer_unpack(struct connectx4lx_hw_r_qpc_rcyclic_producer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rcyclic_producer_print(const struct connectx4lx_hw_r_qpc_rcyclic_producer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rcyclic_producer_size(void);
#define CONNECTX4LX_HW_R_QPC_RCYCLIC_PRODUCER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rcyclic_producer_dump(const struct connectx4lx_hw_r_qpc_rcyclic_producer *ptr_struct, FILE* file);
/* hw_r_qpc_msn */
void connectx4lx_hw_r_qpc_msn_pack(const struct connectx4lx_hw_r_qpc_msn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_msn_unpack(struct connectx4lx_hw_r_qpc_msn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_msn_print(const struct connectx4lx_hw_r_qpc_msn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_msn_size(void);
#define CONNECTX4LX_HW_R_QPC_MSN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_msn_dump(const struct connectx4lx_hw_r_qpc_msn *ptr_struct, FILE* file);
/* hw_r_qpc_ts */
void connectx4lx_hw_r_qpc_ts_pack(const struct connectx4lx_hw_r_qpc_ts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ts_unpack(struct connectx4lx_hw_r_qpc_ts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_ts_print(const struct connectx4lx_hw_r_qpc_ts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_ts_size(void);
#define CONNECTX4LX_HW_R_QPC_TS_SIZE    (0x40)
void connectx4lx_hw_r_qpc_ts_dump(const struct connectx4lx_hw_r_qpc_ts *ptr_struct, FILE* file);
/* hw_r_qpc_lro_context_exist */
void connectx4lx_hw_r_qpc_lro_context_exist_pack(const struct connectx4lx_hw_r_qpc_lro_context_exist *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_context_exist_unpack(struct connectx4lx_hw_r_qpc_lro_context_exist *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_context_exist_print(const struct connectx4lx_hw_r_qpc_lro_context_exist *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_context_exist_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_CONTEXT_EXIST_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_context_exist_dump(const struct connectx4lx_hw_r_qpc_lro_context_exist *ptr_struct, FILE* file);
/* hw_r_qpc_hds_log2_header_buf_size */
void connectx4lx_hw_r_qpc_hds_log2_header_buf_size_pack(const struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_log2_header_buf_size_unpack(struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_log2_header_buf_size_print(const struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hds_log2_header_buf_size_size(void);
#define CONNECTX4LX_HW_R_QPC_HDS_LOG2_HEADER_BUF_SIZE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hds_log2_header_buf_size_dump(const struct connectx4lx_hw_r_qpc_hds_log2_header_buf_size *ptr_struct, FILE* file);
/* hw_r_qpc_extended_atomic */
void connectx4lx_hw_r_qpc_extended_atomic_pack(const struct connectx4lx_hw_r_qpc_extended_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_extended_atomic_unpack(struct connectx4lx_hw_r_qpc_extended_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_extended_atomic_print(const struct connectx4lx_hw_r_qpc_extended_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_extended_atomic_size(void);
#define CONNECTX4LX_HW_R_QPC_EXTENDED_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_r_qpc_extended_atomic_dump(const struct connectx4lx_hw_r_qpc_extended_atomic *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_lack_call_fw */
void connectx4lx_hw_r_qpc_e2e_lack_call_fw_pack(const struct connectx4lx_hw_r_qpc_e2e_lack_call_fw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_lack_call_fw_unpack(struct connectx4lx_hw_r_qpc_e2e_lack_call_fw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_lack_call_fw_print(const struct connectx4lx_hw_r_qpc_e2e_lack_call_fw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_lack_call_fw_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_LACK_CALL_FW_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_lack_call_fw_dump(const struct connectx4lx_hw_r_qpc_e2e_lack_call_fw *ptr_struct, FILE* file);
/* hw_r_qpc_hds_log2_lookahead_size */
void connectx4lx_hw_r_qpc_hds_log2_lookahead_size_pack(const struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_log2_lookahead_size_unpack(struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hds_log2_lookahead_size_print(const struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hds_log2_lookahead_size_size(void);
#define CONNECTX4LX_HW_R_QPC_HDS_LOG2_LOOKAHEAD_SIZE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hds_log2_lookahead_size_dump(const struct connectx4lx_hw_r_qpc_hds_log2_lookahead_size *ptr_struct, FILE* file);
/* hw_r_qpc_cntag_enable */
void connectx4lx_hw_r_qpc_cntag_enable_pack(const struct connectx4lx_hw_r_qpc_cntag_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cntag_enable_unpack(struct connectx4lx_hw_r_qpc_cntag_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cntag_enable_print(const struct connectx4lx_hw_r_qpc_cntag_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_cntag_enable_size(void);
#define CONNECTX4LX_HW_R_QPC_CNTAG_ENABLE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_cntag_enable_dump(const struct connectx4lx_hw_r_qpc_cntag_enable *ptr_struct, FILE* file);
/* hw_r_qpc_lro_ipv6_flow_label */
void connectx4lx_hw_r_qpc_lro_ipv6_flow_label_pack(const struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_ipv6_flow_label_unpack(struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_lro_ipv6_flow_label_print(const struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_lro_ipv6_flow_label_size(void);
#define CONNECTX4LX_HW_R_QPC_LRO_IPV6_FLOW_LABEL_SIZE    (0x40)
void connectx4lx_hw_r_qpc_lro_ipv6_flow_label_dump(const struct connectx4lx_hw_r_qpc_lro_ipv6_flow_label *ptr_struct, FILE* file);
/* hw_r_qpc_cntag_flowid */
void connectx4lx_hw_r_qpc_cntag_flowid_pack(const struct connectx4lx_hw_r_qpc_cntag_flowid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cntag_flowid_unpack(struct connectx4lx_hw_r_qpc_cntag_flowid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cntag_flowid_print(const struct connectx4lx_hw_r_qpc_cntag_flowid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_cntag_flowid_size(void);
#define CONNECTX4LX_HW_R_QPC_CNTAG_FLOWID_SIZE    (0x40)
void connectx4lx_hw_r_qpc_cntag_flowid_dump(const struct connectx4lx_hw_r_qpc_cntag_flowid *ptr_struct, FILE* file);
/* hw_r_qpc_rwqe_consumer_index */
void connectx4lx_hw_r_qpc_rwqe_consumer_index_pack(const struct connectx4lx_hw_r_qpc_rwqe_consumer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_consumer_index_unpack(struct connectx4lx_hw_r_qpc_rwqe_consumer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_consumer_index_print(const struct connectx4lx_hw_r_qpc_rwqe_consumer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rwqe_consumer_index_size(void);
#define CONNECTX4LX_HW_R_QPC_RWQE_CONSUMER_INDEX_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rwqe_consumer_index_dump(const struct connectx4lx_hw_r_qpc_rwqe_consumer_index *ptr_struct, FILE* file);
/* hw_r_qpc_rwqe_producer_index */
void connectx4lx_hw_r_qpc_rwqe_producer_index_pack(const struct connectx4lx_hw_r_qpc_rwqe_producer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_producer_index_unpack(struct connectx4lx_hw_r_qpc_rwqe_producer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rwqe_producer_index_print(const struct connectx4lx_hw_r_qpc_rwqe_producer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rwqe_producer_index_size(void);
#define CONNECTX4LX_HW_R_QPC_RWQE_PRODUCER_INDEX_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rwqe_producer_index_dump(const struct connectx4lx_hw_r_qpc_rwqe_producer_index *ptr_struct, FILE* file);
/* hw_r_qpc_rcyclic_consumer */
void connectx4lx_hw_r_qpc_rcyclic_consumer_pack(const struct connectx4lx_hw_r_qpc_rcyclic_consumer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rcyclic_consumer_unpack(struct connectx4lx_hw_r_qpc_rcyclic_consumer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_rcyclic_consumer_print(const struct connectx4lx_hw_r_qpc_rcyclic_consumer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_rcyclic_consumer_size(void);
#define CONNECTX4LX_HW_R_QPC_RCYCLIC_CONSUMER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_rcyclic_consumer_dump(const struct connectx4lx_hw_r_qpc_rcyclic_consumer *ptr_struct, FILE* file);
/* hw_r_qpc_counter_index */
void connectx4lx_hw_r_qpc_counter_index_pack(const struct connectx4lx_hw_r_qpc_counter_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_counter_index_unpack(struct connectx4lx_hw_r_qpc_counter_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_counter_index_print(const struct connectx4lx_hw_r_qpc_counter_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_counter_index_size(void);
#define CONNECTX4LX_HW_R_QPC_COUNTER_INDEX_SIZE    (0x40)
void connectx4lx_hw_r_qpc_counter_index_dump(const struct connectx4lx_hw_r_qpc_counter_index *ptr_struct, FILE* file);
/* hw_r_qpc_cq_number */
void connectx4lx_hw_r_qpc_cq_number_pack(const struct connectx4lx_hw_r_qpc_cq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cq_number_unpack(struct connectx4lx_hw_r_qpc_cq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cq_number_print(const struct connectx4lx_hw_r_qpc_cq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_cq_number_size(void);
#define CONNECTX4LX_HW_R_QPC_CQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_cq_number_dump(const struct connectx4lx_hw_r_qpc_cq_number *ptr_struct, FILE* file);
/* hw_r_qpc_dct_gvmi */
void connectx4lx_hw_r_qpc_dct_gvmi_pack(const struct connectx4lx_hw_r_qpc_dct_gvmi *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dct_gvmi_unpack(struct connectx4lx_hw_r_qpc_dct_gvmi *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dct_gvmi_print(const struct connectx4lx_hw_r_qpc_dct_gvmi *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_dct_gvmi_size(void);
#define CONNECTX4LX_HW_R_QPC_DCT_GVMI_SIZE    (0x40)
void connectx4lx_hw_r_qpc_dct_gvmi_dump(const struct connectx4lx_hw_r_qpc_dct_gvmi *ptr_struct, FILE* file);
/* hw_r_qpc_cache_alignment_end */
void connectx4lx_hw_r_qpc_cache_alignment_end_pack(const struct connectx4lx_hw_r_qpc_cache_alignment_end *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cache_alignment_end_unpack(struct connectx4lx_hw_r_qpc_cache_alignment_end *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_cache_alignment_end_print(const struct connectx4lx_hw_r_qpc_cache_alignment_end *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_cache_alignment_end_size(void);
#define CONNECTX4LX_HW_R_QPC_CACHE_ALIGNMENT_END_SIZE    (0x40)
void connectx4lx_hw_r_qpc_cache_alignment_end_dump(const struct connectx4lx_hw_r_qpc_cache_alignment_end *ptr_struct, FILE* file);
/* hw_r_qpc_dct_number */
void connectx4lx_hw_r_qpc_dct_number_pack(const struct connectx4lx_hw_r_qpc_dct_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dct_number_unpack(struct connectx4lx_hw_r_qpc_dct_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dct_number_print(const struct connectx4lx_hw_r_qpc_dct_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_dct_number_size(void);
#define CONNECTX4LX_HW_R_QPC_DCT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_dct_number_dump(const struct connectx4lx_hw_r_qpc_dct_number *ptr_struct, FILE* file);
/* hw_r_qpc_srq_number */
void connectx4lx_hw_r_qpc_srq_number_pack(const struct connectx4lx_hw_r_qpc_srq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_srq_number_unpack(struct connectx4lx_hw_r_qpc_srq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_srq_number_print(const struct connectx4lx_hw_r_qpc_srq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_srq_number_size(void);
#define CONNECTX4LX_HW_R_QPC_SRQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_r_qpc_srq_number_dump(const struct connectx4lx_hw_r_qpc_srq_number *ptr_struct, FILE* file);
/* hw_r_qpc_hand_shake_done */
void connectx4lx_hw_r_qpc_hand_shake_done_pack(const struct connectx4lx_hw_r_qpc_hand_shake_done *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hand_shake_done_unpack(struct connectx4lx_hw_r_qpc_hand_shake_done *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_hand_shake_done_print(const struct connectx4lx_hw_r_qpc_hand_shake_done *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_hand_shake_done_size(void);
#define CONNECTX4LX_HW_R_QPC_HAND_SHAKE_DONE_SIZE    (0x40)
void connectx4lx_hw_r_qpc_hand_shake_done_dump(const struct connectx4lx_hw_r_qpc_hand_shake_done *ptr_struct, FILE* file);
/* hw_r_qpc_dcr_connected */
void connectx4lx_hw_r_qpc_dcr_connected_pack(const struct connectx4lx_hw_r_qpc_dcr_connected *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dcr_connected_unpack(struct connectx4lx_hw_r_qpc_dcr_connected *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_dcr_connected_print(const struct connectx4lx_hw_r_qpc_dcr_connected *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_dcr_connected_size(void);
#define CONNECTX4LX_HW_R_QPC_DCR_CONNECTED_SIZE    (0x40)
void connectx4lx_hw_r_qpc_dcr_connected_dump(const struct connectx4lx_hw_r_qpc_dcr_connected *ptr_struct, FILE* file);
/* hw_r_qpc_next_dcr */
void connectx4lx_hw_r_qpc_next_dcr_pack(const struct connectx4lx_hw_r_qpc_next_dcr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_next_dcr_unpack(struct connectx4lx_hw_r_qpc_next_dcr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_next_dcr_print(const struct connectx4lx_hw_r_qpc_next_dcr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_next_dcr_size(void);
#define CONNECTX4LX_HW_R_QPC_NEXT_DCR_SIZE    (0x40)
void connectx4lx_hw_r_qpc_next_dcr_dump(const struct connectx4lx_hw_r_qpc_next_dcr *ptr_struct, FILE* file);
/* hw_r_qpc_mpi_uar */
void connectx4lx_hw_r_qpc_mpi_uar_pack(const struct connectx4lx_hw_r_qpc_mpi_uar *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_mpi_uar_unpack(struct connectx4lx_hw_r_qpc_mpi_uar *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_mpi_uar_print(const struct connectx4lx_hw_r_qpc_mpi_uar *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_mpi_uar_size(void);
#define CONNECTX4LX_HW_R_QPC_MPI_UAR_SIZE    (0x40)
void connectx4lx_hw_r_qpc_mpi_uar_dump(const struct connectx4lx_hw_r_qpc_mpi_uar *ptr_struct, FILE* file);
/* hw_r_qpc_xrc_domain */
void connectx4lx_hw_r_qpc_xrc_domain_pack(const struct connectx4lx_hw_r_qpc_xrc_domain *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_xrc_domain_unpack(struct connectx4lx_hw_r_qpc_xrc_domain *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_xrc_domain_print(const struct connectx4lx_hw_r_qpc_xrc_domain *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_xrc_domain_size(void);
#define CONNECTX4LX_HW_R_QPC_XRC_DOMAIN_SIZE    (0x40)
void connectx4lx_hw_r_qpc_xrc_domain_dump(const struct connectx4lx_hw_r_qpc_xrc_domain *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_pa_63_34 */
void connectx4lx_hw_r_qpc_e2e_pa_63_34_pack(const struct connectx4lx_hw_r_qpc_e2e_pa_63_34 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_pa_63_34_unpack(struct connectx4lx_hw_r_qpc_e2e_pa_63_34 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_pa_63_34_print(const struct connectx4lx_hw_r_qpc_e2e_pa_63_34 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_pa_63_34_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_PA_63_34_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_pa_63_34_dump(const struct connectx4lx_hw_r_qpc_e2e_pa_63_34 *ptr_struct, FILE* file);
/* hw_r_qpc_e2e_pa_33_2 */
void connectx4lx_hw_r_qpc_e2e_pa_33_2_pack(const struct connectx4lx_hw_r_qpc_e2e_pa_33_2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_pa_33_2_unpack(struct connectx4lx_hw_r_qpc_e2e_pa_33_2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_e2e_pa_33_2_print(const struct connectx4lx_hw_r_qpc_e2e_pa_33_2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_e2e_pa_33_2_size(void);
#define CONNECTX4LX_HW_R_QPC_E2E_PA_33_2_SIZE    (0x40)
void connectx4lx_hw_r_qpc_e2e_pa_33_2_dump(const struct connectx4lx_hw_r_qpc_e2e_pa_33_2 *ptr_struct, FILE* file);
/* pf_vf_vpd */
void connectx4lx_pf_vf_vpd_pack(const struct connectx4lx_pf_vf_vpd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pf_vf_vpd_unpack(struct connectx4lx_pf_vf_vpd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pf_vf_vpd_print(const struct connectx4lx_pf_vf_vpd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pf_vf_vpd_size(void);
#define CONNECTX4LX_PF_VF_VPD_SIZE    (0x8)
void connectx4lx_pf_vf_vpd_dump(const struct connectx4lx_pf_vf_vpd *ptr_struct, FILE* file);
/* pf_vf_sriov */
void connectx4lx_pf_vf_sriov_pack(const struct connectx4lx_pf_vf_sriov *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pf_vf_sriov_unpack(struct connectx4lx_pf_vf_sriov *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pf_vf_sriov_print(const struct connectx4lx_pf_vf_sriov *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pf_vf_sriov_size(void);
#define CONNECTX4LX_PF_VF_SRIOV_SIZE    (0x8)
void connectx4lx_pf_vf_sriov_dump(const struct connectx4lx_pf_vf_sriov *ptr_struct, FILE* file);
/* lane_const_sd_params_tx_preset_speed */
void connectx4lx_lane_const_sd_params_tx_preset_speed_pack(const struct connectx4lx_lane_const_sd_params_tx_preset_speed *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_tx_preset_speed_unpack(struct connectx4lx_lane_const_sd_params_tx_preset_speed *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_tx_preset_speed_print(const struct connectx4lx_lane_const_sd_params_tx_preset_speed *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_const_sd_params_tx_preset_speed_size(void);
#define CONNECTX4LX_LANE_CONST_SD_PARAMS_TX_PRESET_SPEED_SIZE    (0xf8)
void connectx4lx_lane_const_sd_params_tx_preset_speed_dump(const struct connectx4lx_lane_const_sd_params_tx_preset_speed *ptr_struct, FILE* file);
/* sd_params_rx_set */
void connectx4lx_sd_params_rx_set_pack(const struct connectx4lx_sd_params_rx_set *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_rx_set_unpack(struct connectx4lx_sd_params_rx_set *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_rx_set_print(const struct connectx4lx_sd_params_rx_set *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_rx_set_size(void);
#define CONNECTX4LX_SD_PARAMS_RX_SET_SIZE    (0x14)
void connectx4lx_sd_params_rx_set_dump(const struct connectx4lx_sd_params_rx_set *ptr_struct, FILE* file);
/* sd_params_tx_active_set */
void connectx4lx_sd_params_tx_active_set_pack(const struct connectx4lx_sd_params_tx_active_set *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_active_set_unpack(struct connectx4lx_sd_params_tx_active_set *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_active_set_print(const struct connectx4lx_sd_params_tx_active_set *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_active_set_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_ACTIVE_SET_SIZE    (0xc)
void connectx4lx_sd_params_tx_active_set_dump(const struct connectx4lx_sd_params_tx_active_set *ptr_struct, FILE* file);
/* sd_params_tx_aba_speed */
void connectx4lx_sd_params_tx_aba_speed_pack(const struct connectx4lx_sd_params_tx_aba_speed *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_aba_speed_unpack(struct connectx4lx_sd_params_tx_aba_speed *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_aba_speed_print(const struct connectx4lx_sd_params_tx_aba_speed *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_aba_speed_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_ABA_SPEED_SIZE    (0x100)
void connectx4lx_sd_params_tx_aba_speed_dump(const struct connectx4lx_sd_params_tx_aba_speed *ptr_struct, FILE* file);
/* local_num_local_lane_and_serdes */
void connectx4lx_local_num_local_lane_and_serdes_pack(const struct connectx4lx_local_num_local_lane_and_serdes *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_local_num_local_lane_and_serdes_unpack(struct connectx4lx_local_num_local_lane_and_serdes *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_local_num_local_lane_and_serdes_print(const struct connectx4lx_local_num_local_lane_and_serdes *ptr_struct, FILE* file, int indent_level);
int connectx4lx_local_num_local_lane_and_serdes_size(void);
#define CONNECTX4LX_LOCAL_NUM_LOCAL_LANE_AND_SERDES_SIZE    (0x4)
void connectx4lx_local_num_local_lane_and_serdes_dump(const struct connectx4lx_local_num_local_lane_and_serdes *ptr_struct, FILE* file);
/* pf_array_default_ones */
void connectx4lx_pf_array_default_ones_pack(const struct connectx4lx_pf_array_default_ones *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pf_array_default_ones_unpack(struct connectx4lx_pf_array_default_ones *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pf_array_default_ones_print(const struct connectx4lx_pf_array_default_ones *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pf_array_default_ones_size(void);
#define CONNECTX4LX_PF_ARRAY_DEFAULT_ONES_SIZE    (0x8)
void connectx4lx_pf_array_default_ones_dump(const struct connectx4lx_pf_array_default_ones *ptr_struct, FILE* file);
/* nv_wol_conf */
void connectx4lx_nv_wol_conf_pack(const struct connectx4lx_nv_wol_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_wol_conf_unpack(struct connectx4lx_nv_wol_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_wol_conf_print(const struct connectx4lx_nv_wol_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_wol_conf_size(void);
#define CONNECTX4LX_NV_WOL_CONF_SIZE    (0x8)
void connectx4lx_nv_wol_conf_dump(const struct connectx4lx_nv_wol_conf *ptr_struct, FILE* file);
/* nv_ets_tcN_config_reg */
void connectx4lx_nv_ets_tcN_config_reg_pack(const struct connectx4lx_nv_ets_tcN_config_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_ets_tcN_config_reg_unpack(struct connectx4lx_nv_ets_tcN_config_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_ets_tcN_config_reg_print(const struct connectx4lx_nv_ets_tcN_config_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_ets_tcN_config_reg_size(void);
#define CONNECTX4LX_NV_ETS_TCN_CONFIG_REG_SIZE    (0x8)
void connectx4lx_nv_ets_tcN_config_reg_dump(const struct connectx4lx_nv_ets_tcN_config_reg *ptr_struct, FILE* file);
/* subroutines_db_index */
void connectx4lx_subroutines_db_index_pack(const struct connectx4lx_subroutines_db_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_index_unpack(struct connectx4lx_subroutines_db_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_index_print(const struct connectx4lx_subroutines_db_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_subroutines_db_index_size(void);
#define CONNECTX4LX_SUBROUTINES_DB_INDEX_SIZE    (0x100)
void connectx4lx_subroutines_db_index_dump(const struct connectx4lx_subroutines_db_index *ptr_struct, FILE* file);
/* subroutines_db_name */
void connectx4lx_subroutines_db_name_pack(const struct connectx4lx_subroutines_db_name *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_name_unpack(struct connectx4lx_subroutines_db_name *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_name_print(const struct connectx4lx_subroutines_db_name *ptr_struct, FILE* file, int indent_level);
int connectx4lx_subroutines_db_name_size(void);
#define CONNECTX4LX_SUBROUTINES_DB_NAME_SIZE    (0x100)
void connectx4lx_subroutines_db_name_dump(const struct connectx4lx_subroutines_db_name *ptr_struct, FILE* file);
/* phy_profile_ini_db */
void connectx4lx_phy_profile_ini_db_pack(const struct connectx4lx_phy_profile_ini_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_profile_ini_db_unpack(struct connectx4lx_phy_profile_ini_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_profile_ini_db_print(const struct connectx4lx_phy_profile_ini_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_profile_ini_db_size(void);
#define CONNECTX4LX_PHY_PROFILE_INI_DB_SIZE    (0x18)
void connectx4lx_phy_profile_ini_db_dump(const struct connectx4lx_phy_profile_ini_db *ptr_struct, FILE* file);
/* cmdif_ctx_fpga_cap */
void connectx4lx_cmdif_ctx_fpga_cap_pack(const struct connectx4lx_cmdif_ctx_fpga_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_fpga_cap_unpack(struct connectx4lx_cmdif_ctx_fpga_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_fpga_cap_print(const struct connectx4lx_cmdif_ctx_fpga_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_fpga_cap_size(void);
#define CONNECTX4LX_CMDIF_CTX_FPGA_CAP_SIZE    (0x20)
void connectx4lx_cmdif_ctx_fpga_cap_dump(const struct connectx4lx_cmdif_ctx_fpga_cap *ptr_struct, FILE* file);
/* cmdif_ctx_fpga_access_reg */
void connectx4lx_cmdif_ctx_fpga_access_reg_pack(const struct connectx4lx_cmdif_ctx_fpga_access_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_fpga_access_reg_unpack(struct connectx4lx_cmdif_ctx_fpga_access_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_fpga_access_reg_print(const struct connectx4lx_cmdif_ctx_fpga_access_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_fpga_access_reg_size(void);
#define CONNECTX4LX_CMDIF_CTX_FPGA_ACCESS_REG_SIZE    (0x20)
void connectx4lx_cmdif_ctx_fpga_access_reg_dump(const struct connectx4lx_cmdif_ctx_fpga_access_reg *ptr_struct, FILE* file);
/* cmdif_create_lag */
void connectx4lx_cmdif_create_lag_pack(const struct connectx4lx_cmdif_create_lag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_create_lag_unpack(struct connectx4lx_cmdif_create_lag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_create_lag_print(const struct connectx4lx_cmdif_create_lag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_create_lag_size(void);
#define CONNECTX4LX_CMDIF_CREATE_LAG_SIZE    (0x20)
void connectx4lx_cmdif_create_lag_dump(const struct connectx4lx_cmdif_create_lag *ptr_struct, FILE* file);
/* cmdif_modify_sq */
void connectx4lx_cmdif_modify_sq_pack(const struct connectx4lx_cmdif_modify_sq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_modify_sq_unpack(struct connectx4lx_cmdif_modify_sq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_modify_sq_print(const struct connectx4lx_cmdif_modify_sq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_modify_sq_size(void);
#define CONNECTX4LX_CMDIF_MODIFY_SQ_SIZE    (0x20)
void connectx4lx_cmdif_modify_sq_dump(const struct connectx4lx_cmdif_modify_sq *ptr_struct, FILE* file);
/* cmdif_modify_rq */
void connectx4lx_cmdif_modify_rq_pack(const struct connectx4lx_cmdif_modify_rq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_modify_rq_unpack(struct connectx4lx_cmdif_modify_rq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_modify_rq_print(const struct connectx4lx_cmdif_modify_rq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_modify_rq_size(void);
#define CONNECTX4LX_CMDIF_MODIFY_RQ_SIZE    (0x20)
void connectx4lx_cmdif_modify_rq_dump(const struct connectx4lx_cmdif_modify_rq *ptr_struct, FILE* file);
/* cmdif_ctx_l2_table */
void connectx4lx_cmdif_ctx_l2_table_pack(const struct connectx4lx_cmdif_ctx_l2_table *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_l2_table_unpack(struct connectx4lx_cmdif_ctx_l2_table *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_l2_table_print(const struct connectx4lx_cmdif_ctx_l2_table *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_l2_table_size(void);
#define CONNECTX4LX_CMDIF_CTX_L2_TABLE_SIZE    (0x20)
void connectx4lx_cmdif_ctx_l2_table_dump(const struct connectx4lx_cmdif_ctx_l2_table *ptr_struct, FILE* file);
/* cmdif_ctx_dmfs_ft */
void connectx4lx_cmdif_ctx_dmfs_ft_pack(const struct connectx4lx_cmdif_ctx_dmfs_ft *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_ft_unpack(struct connectx4lx_cmdif_ctx_dmfs_ft *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_ft_print(const struct connectx4lx_cmdif_ctx_dmfs_ft *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_dmfs_ft_size(void);
#define CONNECTX4LX_CMDIF_CTX_DMFS_FT_SIZE    (0x20)
void connectx4lx_cmdif_ctx_dmfs_ft_dump(const struct connectx4lx_cmdif_ctx_dmfs_ft *ptr_struct, FILE* file);
/* cmdif_ctx_dmfs_fg */
void connectx4lx_cmdif_ctx_dmfs_fg_pack(const struct connectx4lx_cmdif_ctx_dmfs_fg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_fg_unpack(struct connectx4lx_cmdif_ctx_dmfs_fg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_fg_print(const struct connectx4lx_cmdif_ctx_dmfs_fg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_dmfs_fg_size(void);
#define CONNECTX4LX_CMDIF_CTX_DMFS_FG_SIZE    (0x20)
void connectx4lx_cmdif_ctx_dmfs_fg_dump(const struct connectx4lx_cmdif_ctx_dmfs_fg *ptr_struct, FILE* file);
/* cmdif_ctx_dmfs_fte */
void connectx4lx_cmdif_ctx_dmfs_fte_pack(const struct connectx4lx_cmdif_ctx_dmfs_fte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_fte_unpack(struct connectx4lx_cmdif_ctx_dmfs_fte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_dmfs_fte_print(const struct connectx4lx_cmdif_ctx_dmfs_fte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_dmfs_fte_size(void);
#define CONNECTX4LX_CMDIF_CTX_DMFS_FTE_SIZE    (0x20)
void connectx4lx_cmdif_ctx_dmfs_fte_dump(const struct connectx4lx_cmdif_ctx_dmfs_fte *ptr_struct, FILE* file);
/* cmdif_ctx_create_mtt */
void connectx4lx_cmdif_ctx_create_mtt_pack(const struct connectx4lx_cmdif_ctx_create_mtt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_create_mtt_unpack(struct connectx4lx_cmdif_ctx_create_mtt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_create_mtt_print(const struct connectx4lx_cmdif_ctx_create_mtt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_create_mtt_size(void);
#define CONNECTX4LX_CMDIF_CTX_CREATE_MTT_SIZE    (0x20)
void connectx4lx_cmdif_ctx_create_mtt_dump(const struct connectx4lx_cmdif_ctx_create_mtt *ptr_struct, FILE* file);
/* cmdif_ctx_psv */
void connectx4lx_cmdif_ctx_psv_pack(const struct connectx4lx_cmdif_ctx_psv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_psv_unpack(struct connectx4lx_cmdif_ctx_psv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_psv_print(const struct connectx4lx_cmdif_ctx_psv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_psv_size(void);
#define CONNECTX4LX_CMDIF_CTX_PSV_SIZE    (0x20)
void connectx4lx_cmdif_ctx_psv_dump(const struct connectx4lx_cmdif_ctx_psv *ptr_struct, FILE* file);
/* cmdif_ctx_mcg */
void connectx4lx_cmdif_ctx_mcg_pack(const struct connectx4lx_cmdif_ctx_mcg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_mcg_unpack(struct connectx4lx_cmdif_ctx_mcg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_mcg_print(const struct connectx4lx_cmdif_ctx_mcg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_mcg_size(void);
#define CONNECTX4LX_CMDIF_CTX_MCG_SIZE    (0x20)
void connectx4lx_cmdif_ctx_mcg_dump(const struct connectx4lx_cmdif_ctx_mcg *ptr_struct, FILE* file);
/* cmdif_ctx_sniffer */
void connectx4lx_cmdif_ctx_sniffer_pack(const struct connectx4lx_cmdif_ctx_sniffer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_sniffer_unpack(struct connectx4lx_cmdif_ctx_sniffer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_sniffer_print(const struct connectx4lx_cmdif_ctx_sniffer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_sniffer_size(void);
#define CONNECTX4LX_CMDIF_CTX_SNIFFER_SIZE    (0x20)
void connectx4lx_cmdif_ctx_sniffer_dump(const struct connectx4lx_cmdif_ctx_sniffer *ptr_struct, FILE* file);
/* cmdif_ctx_special_modify_rmp */
void connectx4lx_cmdif_ctx_special_modify_rmp_pack(const struct connectx4lx_cmdif_ctx_special_modify_rmp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_rmp_unpack(struct connectx4lx_cmdif_ctx_special_modify_rmp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_rmp_print(const struct connectx4lx_cmdif_ctx_special_modify_rmp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_modify_rmp_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_MODIFY_RMP_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_modify_rmp_dump(const struct connectx4lx_cmdif_ctx_special_modify_rmp *ptr_struct, FILE* file);
/* cmdif_ctx_special_arm_rq */
void connectx4lx_cmdif_ctx_special_arm_rq_pack(const struct connectx4lx_cmdif_ctx_special_arm_rq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_arm_rq_unpack(struct connectx4lx_cmdif_ctx_special_arm_rq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_arm_rq_print(const struct connectx4lx_cmdif_ctx_special_arm_rq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_arm_rq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_ARM_RQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_arm_rq_dump(const struct connectx4lx_cmdif_ctx_special_arm_rq *ptr_struct, FILE* file);
/* cmdif_ctx_special_mkey */
void connectx4lx_cmdif_ctx_special_mkey_pack(const struct connectx4lx_cmdif_ctx_special_mkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_mkey_unpack(struct connectx4lx_cmdif_ctx_special_mkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_mkey_print(const struct connectx4lx_cmdif_ctx_special_mkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_mkey_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_MKEY_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_mkey_dump(const struct connectx4lx_cmdif_ctx_special_mkey *ptr_struct, FILE* file);
/* cmdif_ctx_special_modify_cq */
void connectx4lx_cmdif_ctx_special_modify_cq_pack(const struct connectx4lx_cmdif_ctx_special_modify_cq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_cq_unpack(struct connectx4lx_cmdif_ctx_special_modify_cq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_cq_print(const struct connectx4lx_cmdif_ctx_special_modify_cq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_modify_cq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_MODIFY_CQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_modify_cq_dump(const struct connectx4lx_cmdif_ctx_special_modify_cq *ptr_struct, FILE* file);
/* cmdif_ctx_special_create_cq */
void connectx4lx_cmdif_ctx_special_create_cq_pack(const struct connectx4lx_cmdif_ctx_special_create_cq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_cq_unpack(struct connectx4lx_cmdif_ctx_special_create_cq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_cq_print(const struct connectx4lx_cmdif_ctx_special_create_cq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_cq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_CQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_cq_dump(const struct connectx4lx_cmdif_ctx_special_create_cq *ptr_struct, FILE* file);
/* cmdif_ctx_special_create_eq */
void connectx4lx_cmdif_ctx_special_create_eq_pack(const struct connectx4lx_cmdif_ctx_special_create_eq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_eq_unpack(struct connectx4lx_cmdif_ctx_special_create_eq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_eq_print(const struct connectx4lx_cmdif_ctx_special_create_eq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_eq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_EQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_eq_dump(const struct connectx4lx_cmdif_ctx_special_create_eq *ptr_struct, FILE* file);
/* cmdif_ctx_rqt */
void connectx4lx_cmdif_ctx_rqt_pack(const struct connectx4lx_cmdif_ctx_rqt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_rqt_unpack(struct connectx4lx_cmdif_ctx_rqt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_rqt_print(const struct connectx4lx_cmdif_ctx_rqt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_rqt_size(void);
#define CONNECTX4LX_CMDIF_CTX_RQT_SIZE    (0x20)
void connectx4lx_cmdif_ctx_rqt_dump(const struct connectx4lx_cmdif_ctx_rqt *ptr_struct, FILE* file);
/* cmdif_ctx_special_create_xrq */
void connectx4lx_cmdif_ctx_special_create_xrq_pack(const struct connectx4lx_cmdif_ctx_special_create_xrq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_xrq_unpack(struct connectx4lx_cmdif_ctx_special_create_xrq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_xrq_print(const struct connectx4lx_cmdif_ctx_special_create_xrq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_xrq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_XRQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_xrq_dump(const struct connectx4lx_cmdif_ctx_special_create_xrq *ptr_struct, FILE* file);
/* cmdif_ctx_special_create_srq */
void connectx4lx_cmdif_ctx_special_create_srq_pack(const struct connectx4lx_cmdif_ctx_special_create_srq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_srq_unpack(struct connectx4lx_cmdif_ctx_special_create_srq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_srq_print(const struct connectx4lx_cmdif_ctx_special_create_srq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_srq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_SRQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_srq_dump(const struct connectx4lx_cmdif_ctx_special_create_srq *ptr_struct, FILE* file);
/* cmdif_ctx_special_create_rq */
void connectx4lx_cmdif_ctx_special_create_rq_pack(const struct connectx4lx_cmdif_ctx_special_create_rq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_rq_unpack(struct connectx4lx_cmdif_ctx_special_create_rq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_rq_print(const struct connectx4lx_cmdif_ctx_special_create_rq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_rq_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_RQ_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_rq_dump(const struct connectx4lx_cmdif_ctx_special_create_rq *ptr_struct, FILE* file);
/* cmdif_ctx_special_qp_commands */
void connectx4lx_cmdif_ctx_special_qp_commands_pack(const struct connectx4lx_cmdif_ctx_special_qp_commands *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_unpack(struct connectx4lx_cmdif_ctx_special_qp_commands *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_qp_commands_print(const struct connectx4lx_cmdif_ctx_special_qp_commands *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_qp_commands_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_QP_COMMANDS_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_qp_commands_dump(const struct connectx4lx_cmdif_ctx_special_qp_commands *ptr_struct, FILE* file);
/* cmdif_ctx_special_modify_tis */
void connectx4lx_cmdif_ctx_special_modify_tis_pack(const struct connectx4lx_cmdif_ctx_special_modify_tis *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_tis_unpack(struct connectx4lx_cmdif_ctx_special_modify_tis *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_tis_print(const struct connectx4lx_cmdif_ctx_special_modify_tis *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_modify_tis_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_MODIFY_TIS_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_modify_tis_dump(const struct connectx4lx_cmdif_ctx_special_modify_tis *ptr_struct, FILE* file);
/* cmdif_ctx_special_modify_tir */
void connectx4lx_cmdif_ctx_special_modify_tir_pack(const struct connectx4lx_cmdif_ctx_special_modify_tir *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_tir_unpack(struct connectx4lx_cmdif_ctx_special_modify_tir *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_modify_tir_print(const struct connectx4lx_cmdif_ctx_special_modify_tir *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_modify_tir_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_MODIFY_TIR_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_modify_tir_dump(const struct connectx4lx_cmdif_ctx_special_modify_tir *ptr_struct, FILE* file);
/* cmdif_ctx_special_create */
void connectx4lx_cmdif_ctx_special_create_pack(const struct connectx4lx_cmdif_ctx_special_create *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_unpack(struct connectx4lx_cmdif_ctx_special_create *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_create_print(const struct connectx4lx_cmdif_ctx_special_create *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_create_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_CREATE_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_create_dump(const struct connectx4lx_cmdif_ctx_special_create *ptr_struct, FILE* file);
/* flush_type_bitmask */
void connectx4lx_flush_type_bitmask_pack(const struct connectx4lx_flush_type_bitmask *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flush_type_bitmask_unpack(struct connectx4lx_flush_type_bitmask *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flush_type_bitmask_print(const struct connectx4lx_flush_type_bitmask *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flush_type_bitmask_size(void);
#define CONNECTX4LX_FLUSH_TYPE_BITMASK_SIZE    (0x4)
void connectx4lx_flush_type_bitmask_dump(const struct connectx4lx_flush_type_bitmask *ptr_struct, FILE* file);
/* flush_type_bits */
void connectx4lx_flush_type_bits_pack(const struct connectx4lx_flush_type_bits *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flush_type_bits_unpack(struct connectx4lx_flush_type_bits *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flush_type_bits_print(const struct connectx4lx_flush_type_bits *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flush_type_bits_size(void);
#define CONNECTX4LX_FLUSH_TYPE_BITS_SIZE    (0x4)
void connectx4lx_flush_type_bits_dump(const struct connectx4lx_flush_type_bits *ptr_struct, FILE* file);
/* get_oem_ph_host_network_parameters_response */
void connectx4lx_get_oem_ph_host_network_parameters_response_pack(const struct connectx4lx_get_oem_ph_host_network_parameters_response *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_oem_ph_host_network_parameters_response_unpack(struct connectx4lx_get_oem_ph_host_network_parameters_response *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_oem_ph_host_network_parameters_response_print(const struct connectx4lx_get_oem_ph_host_network_parameters_response *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_oem_ph_host_network_parameters_response_size(void);
#define CONNECTX4LX_GET_OEM_PH_HOST_NETWORK_PARAMETERS_RESPONSE_SIZE    (0x60)
void connectx4lx_get_oem_ph_host_network_parameters_response_dump(const struct connectx4lx_get_oem_ph_host_network_parameters_response *ptr_struct, FILE* file);
/* lled_oem_hdr */
void connectx4lx_lled_oem_hdr_pack(const struct connectx4lx_lled_oem_hdr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_oem_hdr_unpack(struct connectx4lx_lled_oem_hdr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_oem_hdr_print(const struct connectx4lx_lled_oem_hdr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_oem_hdr_size(void);
#define CONNECTX4LX_LLED_OEM_HDR_SIZE    (0x8)
void connectx4lx_lled_oem_hdr_dump(const struct connectx4lx_lled_oem_hdr *ptr_struct, FILE* file);
/* lled_get_ext_cap_resp */
void connectx4lx_lled_get_ext_cap_resp_pack(const struct connectx4lx_lled_get_ext_cap_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_ext_cap_resp_unpack(struct connectx4lx_lled_get_ext_cap_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_ext_cap_resp_print(const struct connectx4lx_lled_get_ext_cap_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_ext_cap_resp_size(void);
#define CONNECTX4LX_LLED_GET_EXT_CAP_RESP_SIZE    (0x10)
void connectx4lx_lled_get_ext_cap_resp_dump(const struct connectx4lx_lled_get_ext_cap_resp *ptr_struct, FILE* file);
/* lled_get_part_info_resp */
void connectx4lx_lled_get_part_info_resp_pack(const struct connectx4lx_lled_get_part_info_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_part_info_resp_unpack(struct connectx4lx_lled_get_part_info_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_part_info_resp_print(const struct connectx4lx_lled_get_part_info_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_part_info_resp_size(void);
#define CONNECTX4LX_LLED_GET_PART_INFO_RESP_SIZE    (0x100)
void connectx4lx_lled_get_part_info_resp_dump(const struct connectx4lx_lled_get_part_info_resp *ptr_struct, FILE* file);
/* lled_set_iscsi_boot_tgt_config_resp */
void connectx4lx_lled_set_iscsi_boot_tgt_config_resp_pack(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_tgt_config_resp_unpack(struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_tgt_config_resp_print(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_iscsi_boot_tgt_config_resp_size(void);
#define CONNECTX4LX_LLED_SET_ISCSI_BOOT_TGT_CONFIG_RESP_SIZE    (0x14)
void connectx4lx_lled_set_iscsi_boot_tgt_config_resp_dump(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_resp *ptr_struct, FILE* file);
/* lled_get_iscsi_boot_tgt_config_resp */
void connectx4lx_lled_get_iscsi_boot_tgt_config_resp_pack(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_tgt_config_resp_unpack(struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_tgt_config_resp_print(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_iscsi_boot_tgt_config_resp_size(void);
#define CONNECTX4LX_LLED_GET_ISCSI_BOOT_TGT_CONFIG_RESP_SIZE    (0x24)
void connectx4lx_lled_get_iscsi_boot_tgt_config_resp_dump(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_resp *ptr_struct, FILE* file);
/* lled_set_iscsi_boot_init_config_resp */
void connectx4lx_lled_set_iscsi_boot_init_config_resp_pack(const struct connectx4lx_lled_set_iscsi_boot_init_config_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_init_config_resp_unpack(struct connectx4lx_lled_set_iscsi_boot_init_config_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_init_config_resp_print(const struct connectx4lx_lled_set_iscsi_boot_init_config_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_iscsi_boot_init_config_resp_size(void);
#define CONNECTX4LX_LLED_SET_ISCSI_BOOT_INIT_CONFIG_RESP_SIZE    (0x14)
void connectx4lx_lled_set_iscsi_boot_init_config_resp_dump(const struct connectx4lx_lled_set_iscsi_boot_init_config_resp *ptr_struct, FILE* file);
/* lled_get_iscsi_boot_init_config_resp */
void connectx4lx_lled_get_iscsi_boot_init_config_resp_pack(const struct connectx4lx_lled_get_iscsi_boot_init_config_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_init_config_resp_unpack(struct connectx4lx_lled_get_iscsi_boot_init_config_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_init_config_resp_print(const struct connectx4lx_lled_get_iscsi_boot_init_config_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_iscsi_boot_init_config_resp_size(void);
#define CONNECTX4LX_LLED_GET_ISCSI_BOOT_INIT_CONFIG_RESP_SIZE    (0x24)
void connectx4lx_lled_get_iscsi_boot_init_config_resp_dump(const struct connectx4lx_lled_get_iscsi_boot_init_config_resp *ptr_struct, FILE* file);
/* lled_pt_control_cmd_resp */
void connectx4lx_lled_pt_control_cmd_resp_pack(const struct connectx4lx_lled_pt_control_cmd_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_pt_control_cmd_resp_unpack(struct connectx4lx_lled_pt_control_cmd_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_pt_control_cmd_resp_print(const struct connectx4lx_lled_pt_control_cmd_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_pt_control_cmd_resp_size(void);
#define CONNECTX4LX_LLED_PT_CONTROL_CMD_RESP_SIZE    (0x8)
void connectx4lx_lled_pt_control_cmd_resp_dump(const struct connectx4lx_lled_pt_control_cmd_resp *ptr_struct, FILE* file);
/* lled_set_address_cmd */
void connectx4lx_lled_set_address_cmd_pack(const struct connectx4lx_lled_set_address_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_address_cmd_unpack(struct connectx4lx_lled_set_address_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_address_cmd_print(const struct connectx4lx_lled_set_address_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_address_cmd_size(void);
#define CONNECTX4LX_LLED_SET_ADDRESS_CMD_SIZE    (0x10)
void connectx4lx_lled_set_address_cmd_dump(const struct connectx4lx_lled_set_address_cmd *ptr_struct, FILE* file);
/* lled_set_address_resp */
void connectx4lx_lled_set_address_resp_pack(const struct connectx4lx_lled_set_address_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_address_resp_unpack(struct connectx4lx_lled_set_address_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_address_resp_print(const struct connectx4lx_lled_set_address_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_address_resp_size(void);
#define CONNECTX4LX_LLED_SET_ADDRESS_RESP_SIZE    (0x8)
void connectx4lx_lled_set_address_resp_dump(const struct connectx4lx_lled_set_address_resp *ptr_struct, FILE* file);
/* lled_get_sup_ver_resp */
void connectx4lx_lled_get_sup_ver_resp_pack(const struct connectx4lx_lled_get_sup_ver_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_sup_ver_resp_unpack(struct connectx4lx_lled_get_sup_ver_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_sup_ver_resp_print(const struct connectx4lx_lled_get_sup_ver_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_sup_ver_resp_size(void);
#define CONNECTX4LX_LLED_GET_SUP_VER_RESP_SIZE    (0xc)
void connectx4lx_lled_get_sup_ver_resp_dump(const struct connectx4lx_lled_get_sup_ver_resp *ptr_struct, FILE* file);
/* lled_get_rdma_stat_resp */
void connectx4lx_lled_get_rdma_stat_resp_pack(const struct connectx4lx_lled_get_rdma_stat_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_rdma_stat_resp_unpack(struct connectx4lx_lled_get_rdma_stat_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_rdma_stat_resp_print(const struct connectx4lx_lled_get_rdma_stat_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_rdma_stat_resp_size(void);
#define CONNECTX4LX_LLED_GET_RDMA_STAT_RESP_SIZE    (0x48)
void connectx4lx_lled_get_rdma_stat_resp_dump(const struct connectx4lx_lled_get_rdma_stat_resp *ptr_struct, FILE* file);
/* lled_get_os_driver_version_resp */
void connectx4lx_lled_get_os_driver_version_resp_pack(const struct connectx4lx_lled_get_os_driver_version_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_os_driver_version_resp_unpack(struct connectx4lx_lled_get_os_driver_version_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_os_driver_version_resp_print(const struct connectx4lx_lled_get_os_driver_version_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_os_driver_version_resp_size(void);
#define CONNECTX4LX_LLED_GET_OS_DRIVER_VERSION_RESP_SIZE    (0x30)
void connectx4lx_lled_get_os_driver_version_resp_dump(const struct connectx4lx_lled_get_os_driver_version_resp *ptr_struct, FILE* file);
/* lled_get_temperature_resp */
void connectx4lx_lled_get_temperature_resp_pack(const struct connectx4lx_lled_get_temperature_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_temperature_resp_unpack(struct connectx4lx_lled_get_temperature_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_temperature_resp_print(const struct connectx4lx_lled_get_temperature_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_temperature_resp_size(void);
#define CONNECTX4LX_LLED_GET_TEMPERATURE_RESP_SIZE    (0xc)
void connectx4lx_lled_get_temperature_resp_dump(const struct connectx4lx_lled_get_temperature_resp *ptr_struct, FILE* file);
/* lled_get_teaming_info_resp */
void connectx4lx_lled_get_teaming_info_resp_pack(const struct connectx4lx_lled_get_teaming_info_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_teaming_info_resp_unpack(struct connectx4lx_lled_get_teaming_info_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_teaming_info_resp_print(const struct connectx4lx_lled_get_teaming_info_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_teaming_info_resp_size(void);
#define CONNECTX4LX_LLED_GET_TEAMING_INFO_RESP_SIZE    (0x30)
void connectx4lx_lled_get_teaming_info_resp_dump(const struct connectx4lx_lled_get_teaming_info_resp *ptr_struct, FILE* file);
/* lled_get_inventory_resp */
void connectx4lx_lled_get_inventory_resp_pack(const struct connectx4lx_lled_get_inventory_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_inventory_resp_unpack(struct connectx4lx_lled_get_inventory_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_inventory_resp_print(const struct connectx4lx_lled_get_inventory_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_inventory_resp_size(void);
#define CONNECTX4LX_LLED_GET_INVENTORY_RESP_SIZE    (0x30)
void connectx4lx_lled_get_inventory_resp_dump(const struct connectx4lx_lled_get_inventory_resp *ptr_struct, FILE* file);
/* lled_get_lldp_resp */
void connectx4lx_lled_get_lldp_resp_pack(const struct connectx4lx_lled_get_lldp_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_lldp_resp_unpack(struct connectx4lx_lled_get_lldp_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_lldp_resp_print(const struct connectx4lx_lled_get_lldp_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_lldp_resp_size(void);
#define CONNECTX4LX_LLED_GET_LLDP_RESP_SIZE    (0x24)
void connectx4lx_lled_get_lldp_resp_dump(const struct connectx4lx_lled_get_lldp_resp *ptr_struct, FILE* file);
/* lled_get_interface_sensor_resp */
void connectx4lx_lled_get_interface_sensor_resp_pack(const union connectx4lx_lled_get_interface_sensor_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_unpack(union connectx4lx_lled_get_interface_sensor_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_sensor_resp_print(const union connectx4lx_lled_get_interface_sensor_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_interface_sensor_resp_size(void);
#define CONNECTX4LX_LLED_GET_INTERFACE_SENSOR_RESP_SIZE    (0x38)
void connectx4lx_lled_get_interface_sensor_resp_dump(const union connectx4lx_lled_get_interface_sensor_resp *ptr_struct, FILE* file);
/* lled_get_interface_info_resp */
void connectx4lx_lled_get_interface_info_resp_pack(const struct connectx4lx_lled_get_interface_info_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_info_resp_unpack(struct connectx4lx_lled_get_interface_info_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_interface_info_resp_print(const struct connectx4lx_lled_get_interface_info_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_interface_info_resp_size(void);
#define CONNECTX4LX_LLED_GET_INTERFACE_INFO_RESP_SIZE    (0x68)
void connectx4lx_lled_get_interface_info_resp_dump(const struct connectx4lx_lled_get_interface_info_resp *ptr_struct, FILE* file);
/* mellanox_aen_control */
void connectx4lx_mellanox_aen_control_pack(const struct connectx4lx_mellanox_aen_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mellanox_aen_control_unpack(struct connectx4lx_mellanox_aen_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mellanox_aen_control_print(const struct connectx4lx_mellanox_aen_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mellanox_aen_control_size(void);
#define CONNECTX4LX_MELLANOX_AEN_CONTROL_SIZE    (0x14)
void connectx4lx_mellanox_aen_control_dump(const struct connectx4lx_mellanox_aen_control *ptr_struct, FILE* file);
/* temperature_control_data */
void connectx4lx_temperature_control_data_pack(const struct connectx4lx_temperature_control_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_temperature_control_data_unpack(struct connectx4lx_temperature_control_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_temperature_control_data_print(const struct connectx4lx_temperature_control_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_temperature_control_data_size(void);
#define CONNECTX4LX_TEMPERATURE_CONTROL_DATA_SIZE    (0x10)
void connectx4lx_temperature_control_data_dump(const struct connectx4lx_temperature_control_data *ptr_struct, FILE* file);
/* get_flex_filter_data_resp */
void connectx4lx_get_flex_filter_data_resp_pack(const struct connectx4lx_get_flex_filter_data_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_data_resp_unpack(struct connectx4lx_get_flex_filter_data_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_data_resp_print(const struct connectx4lx_get_flex_filter_data_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_flex_filter_data_resp_size(void);
#define CONNECTX4LX_GET_FLEX_FILTER_DATA_RESP_SIZE    (0x88)
void connectx4lx_get_flex_filter_data_resp_dump(const struct connectx4lx_get_flex_filter_data_resp *ptr_struct, FILE* file);
/* get_flex_filter_mask_length_resp */
void connectx4lx_get_flex_filter_mask_length_resp_pack(const struct connectx4lx_get_flex_filter_mask_length_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_mask_length_resp_unpack(struct connectx4lx_get_flex_filter_mask_length_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_mask_length_resp_print(const struct connectx4lx_get_flex_filter_mask_length_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_flex_filter_mask_length_resp_size(void);
#define CONNECTX4LX_GET_FLEX_FILTER_MASK_LENGTH_RESP_SIZE    (0x1c)
void connectx4lx_get_flex_filter_mask_length_resp_dump(const struct connectx4lx_get_flex_filter_mask_length_resp *ptr_struct, FILE* file);
/* set_pf_mac_address_resp */
void connectx4lx_set_pf_mac_address_resp_pack(const struct connectx4lx_set_pf_mac_address_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_pf_mac_address_resp_unpack(struct connectx4lx_set_pf_mac_address_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_pf_mac_address_resp_print(const struct connectx4lx_set_pf_mac_address_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_pf_mac_address_resp_size(void);
#define CONNECTX4LX_SET_PF_MAC_ADDRESS_RESP_SIZE    (0x8)
void connectx4lx_set_pf_mac_address_resp_dump(const struct connectx4lx_set_pf_mac_address_resp *ptr_struct, FILE* file);
/* get_addresses_groups_count_resp */
void connectx4lx_get_addresses_groups_count_resp_pack(const struct connectx4lx_get_addresses_groups_count_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_addresses_groups_count_resp_unpack(struct connectx4lx_get_addresses_groups_count_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_addresses_groups_count_resp_print(const struct connectx4lx_get_addresses_groups_count_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_addresses_groups_count_resp_size(void);
#define CONNECTX4LX_GET_ADDRESSES_GROUPS_COUNT_RESP_SIZE    (0x8)
void connectx4lx_get_addresses_groups_count_resp_dump(const struct connectx4lx_get_addresses_groups_count_resp *ptr_struct, FILE* file);
/* set_port_led_control_resp */
void connectx4lx_set_port_led_control_resp_pack(const struct connectx4lx_set_port_led_control_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_port_led_control_resp_unpack(struct connectx4lx_set_port_led_control_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_port_led_control_resp_print(const struct connectx4lx_set_port_led_control_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_port_led_control_resp_size(void);
#define CONNECTX4LX_SET_PORT_LED_CONTROL_RESP_SIZE    (0xc)
void connectx4lx_set_port_led_control_resp_dump(const struct connectx4lx_set_port_led_control_resp *ptr_struct, FILE* file);
/* get_port_led_control_resp */
void connectx4lx_get_port_led_control_resp_pack(const struct connectx4lx_get_port_led_control_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_port_led_control_resp_unpack(struct connectx4lx_get_port_led_control_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_port_led_control_resp_print(const struct connectx4lx_get_port_led_control_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_port_led_control_resp_size(void);
#define CONNECTX4LX_GET_PORT_LED_CONTROL_RESP_SIZE    (0xc)
void connectx4lx_get_port_led_control_resp_dump(const struct connectx4lx_get_port_led_control_resp *ptr_struct, FILE* file);
/* mlnx_oem_resp_get_set_addresses */
void connectx4lx_mlnx_oem_resp_get_set_addresses_pack(const struct connectx4lx_mlnx_oem_resp_get_set_addresses *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_get_set_addresses_unpack(struct connectx4lx_mlnx_oem_resp_get_set_addresses *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_get_set_addresses_print(const struct connectx4lx_mlnx_oem_resp_get_set_addresses *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_resp_get_set_addresses_size(void);
#define CONNECTX4LX_MLNX_OEM_RESP_GET_SET_ADDRESSES_SIZE    (0x14)
void connectx4lx_mlnx_oem_resp_get_set_addresses_dump(const struct connectx4lx_mlnx_oem_resp_get_set_addresses *ptr_struct, FILE* file);
/* mlnx_oem_resp_get_temperature */
void connectx4lx_mlnx_oem_resp_get_temperature_pack(const struct connectx4lx_mlnx_oem_resp_get_temperature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_get_temperature_unpack(struct connectx4lx_mlnx_oem_resp_get_temperature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_get_temperature_print(const struct connectx4lx_mlnx_oem_resp_get_temperature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_resp_get_temperature_size(void);
#define CONNECTX4LX_MLNX_OEM_RESP_GET_TEMPERATURE_SIZE    (0x18)
void connectx4lx_mlnx_oem_resp_get_temperature_dump(const struct connectx4lx_mlnx_oem_resp_get_temperature *ptr_struct, FILE* file);
/* reset_nic */
void connectx4lx_reset_nic_pack(const struct connectx4lx_reset_nic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reset_nic_unpack(struct connectx4lx_reset_nic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reset_nic_print(const struct connectx4lx_reset_nic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reset_nic_size(void);
#define CONNECTX4LX_RESET_NIC_SIZE    (0x8)
void connectx4lx_reset_nic_dump(const struct connectx4lx_reset_nic *ptr_struct, FILE* file);
/* get_pf_mac_address_resp */
void connectx4lx_get_pf_mac_address_resp_pack(const struct connectx4lx_get_pf_mac_address_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_pf_mac_address_resp_unpack(struct connectx4lx_get_pf_mac_address_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_pf_mac_address_resp_print(const struct connectx4lx_get_pf_mac_address_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_pf_mac_address_resp_size(void);
#define CONNECTX4LX_GET_PF_MAC_ADDRESS_RESP_SIZE    (0x10)
void connectx4lx_get_pf_mac_address_resp_dump(const struct connectx4lx_get_pf_mac_address_resp *ptr_struct, FILE* file);
/* get_allocated_management_address_resp */
void connectx4lx_get_allocated_management_address_resp_pack(const struct connectx4lx_get_allocated_management_address_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_allocated_management_address_resp_unpack(struct connectx4lx_get_allocated_management_address_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_allocated_management_address_resp_print(const struct connectx4lx_get_allocated_management_address_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_allocated_management_address_resp_size(void);
#define CONNECTX4LX_GET_ALLOCATED_MANAGEMENT_ADDRESS_RESP_SIZE    (0x14)
void connectx4lx_get_allocated_management_address_resp_dump(const struct connectx4lx_get_allocated_management_address_resp *ptr_struct, FILE* file);
/* set_mc_affinity_resp */
void connectx4lx_set_mc_affinity_resp_pack(const struct connectx4lx_set_mc_affinity_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_mc_affinity_resp_unpack(struct connectx4lx_set_mc_affinity_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_mc_affinity_resp_print(const struct connectx4lx_set_mc_affinity_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_mc_affinity_resp_size(void);
#define CONNECTX4LX_SET_MC_AFFINITY_RESP_SIZE    (0x8)
void connectx4lx_set_mc_affinity_resp_dump(const struct connectx4lx_set_mc_affinity_resp *ptr_struct, FILE* file);
/* mlnx_oem_hdr */
void connectx4lx_mlnx_oem_hdr_pack(const struct connectx4lx_mlnx_oem_hdr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_hdr_unpack(struct connectx4lx_mlnx_oem_hdr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_hdr_print(const struct connectx4lx_mlnx_oem_hdr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_hdr_size(void);
#define CONNECTX4LX_MLNX_OEM_HDR_SIZE    (0x8)
void connectx4lx_mlnx_oem_hdr_dump(const struct connectx4lx_mlnx_oem_hdr *ptr_struct, FILE* file);
/* aen_control_support_field */
void connectx4lx_aen_control_support_field_pack(const struct connectx4lx_aen_control_support_field *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_aen_control_support_field_unpack(struct connectx4lx_aen_control_support_field *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_aen_control_support_field_print(const struct connectx4lx_aen_control_support_field *ptr_struct, FILE* file, int indent_level);
int connectx4lx_aen_control_support_field_size(void);
#define CONNECTX4LX_AEN_CONTROL_SUPPORT_FIELD_SIZE    (0x4)
void connectx4lx_aen_control_support_field_dump(const struct connectx4lx_aen_control_support_field *ptr_struct, FILE* file);
/* multicast_filter_settings */
void connectx4lx_multicast_filter_settings_pack(const struct connectx4lx_multicast_filter_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_multicast_filter_settings_unpack(struct connectx4lx_multicast_filter_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_multicast_filter_settings_print(const struct connectx4lx_multicast_filter_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_multicast_filter_settings_size(void);
#define CONNECTX4LX_MULTICAST_FILTER_SETTINGS_SIZE    (0x4)
void connectx4lx_multicast_filter_settings_dump(const struct connectx4lx_multicast_filter_settings *ptr_struct, FILE* file);
/* broadcast_filter_settings */
void connectx4lx_broadcast_filter_settings_pack(const struct connectx4lx_broadcast_filter_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_broadcast_filter_settings_unpack(struct connectx4lx_broadcast_filter_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_broadcast_filter_settings_print(const struct connectx4lx_broadcast_filter_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_broadcast_filter_settings_size(void);
#define CONNECTX4LX_BROADCAST_FILTER_SETTINGS_SIZE    (0x4)
void connectx4lx_broadcast_filter_settings_dump(const struct connectx4lx_broadcast_filter_settings *ptr_struct, FILE* file);
/* capability_flags */
void connectx4lx_capability_flags_pack(const struct connectx4lx_capability_flags *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_capability_flags_unpack(struct connectx4lx_capability_flags *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_capability_flags_print(const struct connectx4lx_capability_flags *ptr_struct, FILE* file, int indent_level);
int connectx4lx_capability_flags_size(void);
#define CONNECTX4LX_CAPABILITY_FLAGS_SIZE    (0x4)
void connectx4lx_capability_flags_dump(const struct connectx4lx_capability_flags *ptr_struct, FILE* file);
/* configuration_flags */
void connectx4lx_configuration_flags_pack(const struct connectx4lx_configuration_flags *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_configuration_flags_unpack(struct connectx4lx_configuration_flags *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_configuration_flags_print(const struct connectx4lx_configuration_flags *ptr_struct, FILE* file, int indent_level);
int connectx4lx_configuration_flags_size(void);
#define CONNECTX4LX_CONFIGURATION_FLAGS_SIZE    (0x4)
void connectx4lx_configuration_flags_dump(const struct connectx4lx_configuration_flags *ptr_struct, FILE* file);
/* link_settings */
void connectx4lx_link_settings_pack(const struct connectx4lx_link_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_link_settings_unpack(struct connectx4lx_link_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_link_settings_print(const struct connectx4lx_link_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_link_settings_size(void);
#define CONNECTX4LX_LINK_SETTINGS_SIZE    (0x4)
void connectx4lx_link_settings_dump(const struct connectx4lx_link_settings *ptr_struct, FILE* file);
/* link_status_field */
void connectx4lx_link_status_field_pack(const struct connectx4lx_link_status_field *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_link_status_field_unpack(struct connectx4lx_link_status_field *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_link_status_field_print(const struct connectx4lx_link_status_field *ptr_struct, FILE* file, int indent_level);
int connectx4lx_link_status_field_size(void);
#define CONNECTX4LX_LINK_STATUS_FIELD_SIZE    (0x4)
void connectx4lx_link_status_field_dump(const struct connectx4lx_link_status_field *ptr_struct, FILE* file);
/* get_oem_ph_host_network_parameters_request */
void connectx4lx_get_oem_ph_host_network_parameters_request_pack(const struct connectx4lx_get_oem_ph_host_network_parameters_request *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_oem_ph_host_network_parameters_request_unpack(struct connectx4lx_get_oem_ph_host_network_parameters_request *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_oem_ph_host_network_parameters_request_print(const struct connectx4lx_get_oem_ph_host_network_parameters_request *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_oem_ph_host_network_parameters_request_size(void);
#define CONNECTX4LX_GET_OEM_PH_HOST_NETWORK_PARAMETERS_REQUEST_SIZE    (0x8)
void connectx4lx_get_oem_ph_host_network_parameters_request_dump(const struct connectx4lx_get_oem_ph_host_network_parameters_request *ptr_struct, FILE* file);
/* lled_set_iscsi_boot_tgt_config_cmd */
void connectx4lx_lled_set_iscsi_boot_tgt_config_cmd_pack(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_tgt_config_cmd_unpack(struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_tgt_config_cmd_print(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_iscsi_boot_tgt_config_cmd_size(void);
#define CONNECTX4LX_LLED_SET_ISCSI_BOOT_TGT_CONFIG_CMD_SIZE    (0x24)
void connectx4lx_lled_set_iscsi_boot_tgt_config_cmd_dump(const struct connectx4lx_lled_set_iscsi_boot_tgt_config_cmd *ptr_struct, FILE* file);
/* lled_get_iscsi_boot_tgt_config_cmd */
void connectx4lx_lled_get_iscsi_boot_tgt_config_cmd_pack(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_tgt_config_cmd_unpack(struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_tgt_config_cmd_print(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_iscsi_boot_tgt_config_cmd_size(void);
#define CONNECTX4LX_LLED_GET_ISCSI_BOOT_TGT_CONFIG_CMD_SIZE    (0x14)
void connectx4lx_lled_get_iscsi_boot_tgt_config_cmd_dump(const struct connectx4lx_lled_get_iscsi_boot_tgt_config_cmd *ptr_struct, FILE* file);
/* lled_set_iscsi_boot_init_config_cmd */
void connectx4lx_lled_set_iscsi_boot_init_config_cmd_pack(const struct connectx4lx_lled_set_iscsi_boot_init_config_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_init_config_cmd_unpack(struct connectx4lx_lled_set_iscsi_boot_init_config_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_set_iscsi_boot_init_config_cmd_print(const struct connectx4lx_lled_set_iscsi_boot_init_config_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_set_iscsi_boot_init_config_cmd_size(void);
#define CONNECTX4LX_LLED_SET_ISCSI_BOOT_INIT_CONFIG_CMD_SIZE    (0x24)
void connectx4lx_lled_set_iscsi_boot_init_config_cmd_dump(const struct connectx4lx_lled_set_iscsi_boot_init_config_cmd *ptr_struct, FILE* file);
/* lled_get_iscsi_boot_init_config_cmd */
void connectx4lx_lled_get_iscsi_boot_init_config_cmd_pack(const struct connectx4lx_lled_get_iscsi_boot_init_config_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_init_config_cmd_unpack(struct connectx4lx_lled_get_iscsi_boot_init_config_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_iscsi_boot_init_config_cmd_print(const struct connectx4lx_lled_get_iscsi_boot_init_config_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_iscsi_boot_init_config_cmd_size(void);
#define CONNECTX4LX_LLED_GET_ISCSI_BOOT_INIT_CONFIG_CMD_SIZE    (0x14)
void connectx4lx_lled_get_iscsi_boot_init_config_cmd_dump(const struct connectx4lx_lled_get_iscsi_boot_init_config_cmd *ptr_struct, FILE* file);
/* lled_get_teaming_info_cmd */
void connectx4lx_lled_get_teaming_info_cmd_pack(const struct connectx4lx_lled_get_teaming_info_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_teaming_info_cmd_unpack(struct connectx4lx_lled_get_teaming_info_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_teaming_info_cmd_print(const struct connectx4lx_lled_get_teaming_info_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_teaming_info_cmd_size(void);
#define CONNECTX4LX_LLED_GET_TEAMING_INFO_CMD_SIZE    (0x10)
void connectx4lx_lled_get_teaming_info_cmd_dump(const struct connectx4lx_lled_get_teaming_info_cmd *ptr_struct, FILE* file);
/* lled_get_address_cmd */
void connectx4lx_lled_get_address_cmd_pack(const struct connectx4lx_lled_get_address_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_address_cmd_unpack(struct connectx4lx_lled_get_address_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_address_cmd_print(const struct connectx4lx_lled_get_address_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_address_cmd_size(void);
#define CONNECTX4LX_LLED_GET_ADDRESS_CMD_SIZE    (0x8)
void connectx4lx_lled_get_address_cmd_dump(const struct connectx4lx_lled_get_address_cmd *ptr_struct, FILE* file);
/* lled_get_rdma_stat_cmd */
void connectx4lx_lled_get_rdma_stat_cmd_pack(const struct connectx4lx_lled_get_rdma_stat_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_rdma_stat_cmd_unpack(struct connectx4lx_lled_get_rdma_stat_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_rdma_stat_cmd_print(const struct connectx4lx_lled_get_rdma_stat_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_rdma_stat_cmd_size(void);
#define CONNECTX4LX_LLED_GET_RDMA_STAT_CMD_SIZE    (0x8)
void connectx4lx_lled_get_rdma_stat_cmd_dump(const struct connectx4lx_lled_get_rdma_stat_cmd *ptr_struct, FILE* file);
/* lled_get_os_driver_version_cmd */
void connectx4lx_lled_get_os_driver_version_cmd_pack(const struct connectx4lx_lled_get_os_driver_version_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_get_os_driver_version_cmd_unpack(struct connectx4lx_lled_get_os_driver_version_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_get_os_driver_version_cmd_print(const struct connectx4lx_lled_get_os_driver_version_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_get_os_driver_version_cmd_size(void);
#define CONNECTX4LX_LLED_GET_OS_DRIVER_VERSION_CMD_SIZE    (0x10)
void connectx4lx_lled_get_os_driver_version_cmd_dump(const struct connectx4lx_lled_get_os_driver_version_cmd *ptr_struct, FILE* file);
/* get_mellanox_aen_control */
void connectx4lx_get_mellanox_aen_control_pack(const struct connectx4lx_get_mellanox_aen_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_mellanox_aen_control_unpack(struct connectx4lx_get_mellanox_aen_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_mellanox_aen_control_print(const struct connectx4lx_get_mellanox_aen_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_mellanox_aen_control_size(void);
#define CONNECTX4LX_GET_MELLANOX_AEN_CONTROL_SIZE    (0x10)
void connectx4lx_get_mellanox_aen_control_dump(const struct connectx4lx_get_mellanox_aen_control *ptr_struct, FILE* file);
/* get_flex_filter_data */
void connectx4lx_get_flex_filter_data_pack(const struct connectx4lx_get_flex_filter_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_data_unpack(struct connectx4lx_get_flex_filter_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_data_print(const struct connectx4lx_get_flex_filter_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_flex_filter_data_size(void);
#define CONNECTX4LX_GET_FLEX_FILTER_DATA_SIZE    (0x10)
void connectx4lx_get_flex_filter_data_dump(const struct connectx4lx_get_flex_filter_data *ptr_struct, FILE* file);
/* get_flex_filter_mask_length */
void connectx4lx_get_flex_filter_mask_length_pack(const struct connectx4lx_get_flex_filter_mask_length *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_mask_length_unpack(struct connectx4lx_get_flex_filter_mask_length *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_flex_filter_mask_length_print(const struct connectx4lx_get_flex_filter_mask_length *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_flex_filter_mask_length_size(void);
#define CONNECTX4LX_GET_FLEX_FILTER_MASK_LENGTH_SIZE    (0x10)
void connectx4lx_get_flex_filter_mask_length_dump(const struct connectx4lx_get_flex_filter_mask_length *ptr_struct, FILE* file);
/* set_pf_mac_address */
void connectx4lx_set_pf_mac_address_pack(const struct connectx4lx_set_pf_mac_address *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_pf_mac_address_unpack(struct connectx4lx_set_pf_mac_address *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_pf_mac_address_print(const struct connectx4lx_set_pf_mac_address *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_pf_mac_address_size(void);
#define CONNECTX4LX_SET_PF_MAC_ADDRESS_SIZE    (0x14)
void connectx4lx_set_pf_mac_address_dump(const struct connectx4lx_set_pf_mac_address *ptr_struct, FILE* file);
/* set_port_led_control */
void connectx4lx_set_port_led_control_pack(const struct connectx4lx_set_port_led_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_port_led_control_unpack(struct connectx4lx_set_port_led_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_port_led_control_print(const struct connectx4lx_set_port_led_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_port_led_control_size(void);
#define CONNECTX4LX_SET_PORT_LED_CONTROL_SIZE    (0x10)
void connectx4lx_set_port_led_control_dump(const struct connectx4lx_set_port_led_control *ptr_struct, FILE* file);
/* get_port_led_control */
void connectx4lx_get_port_led_control_pack(const struct connectx4lx_get_port_led_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_port_led_control_unpack(struct connectx4lx_get_port_led_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_port_led_control_print(const struct connectx4lx_get_port_led_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_port_led_control_size(void);
#define CONNECTX4LX_GET_PORT_LED_CONTROL_SIZE    (0x10)
void connectx4lx_get_port_led_control_dump(const struct connectx4lx_get_port_led_control *ptr_struct, FILE* file);
/* mlnx_oem_cmd_set_addresses */
void connectx4lx_mlnx_oem_cmd_set_addresses_pack(const struct connectx4lx_mlnx_oem_cmd_set_addresses *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_set_addresses_unpack(struct connectx4lx_mlnx_oem_cmd_set_addresses *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_set_addresses_print(const struct connectx4lx_mlnx_oem_cmd_set_addresses *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_cmd_set_addresses_size(void);
#define CONNECTX4LX_MLNX_OEM_CMD_SET_ADDRESSES_SIZE    (0x10)
void connectx4lx_mlnx_oem_cmd_set_addresses_dump(const struct connectx4lx_mlnx_oem_cmd_set_addresses *ptr_struct, FILE* file);
/* mlnx_oem_cmd_get_addresses */
void connectx4lx_mlnx_oem_cmd_get_addresses_pack(const struct connectx4lx_mlnx_oem_cmd_get_addresses *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_get_addresses_unpack(struct connectx4lx_mlnx_oem_cmd_get_addresses *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_get_addresses_print(const struct connectx4lx_mlnx_oem_cmd_get_addresses *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_cmd_get_addresses_size(void);
#define CONNECTX4LX_MLNX_OEM_CMD_GET_ADDRESSES_SIZE    (0x10)
void connectx4lx_mlnx_oem_cmd_get_addresses_dump(const struct connectx4lx_mlnx_oem_cmd_get_addresses *ptr_struct, FILE* file);
/* mlnx_oem_cmd_get_temperature */
void connectx4lx_mlnx_oem_cmd_get_temperature_pack(const struct connectx4lx_mlnx_oem_cmd_get_temperature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_get_temperature_unpack(struct connectx4lx_mlnx_oem_cmd_get_temperature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_get_temperature_print(const struct connectx4lx_mlnx_oem_cmd_get_temperature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_cmd_get_temperature_size(void);
#define CONNECTX4LX_MLNX_OEM_CMD_GET_TEMPERATURE_SIZE    (0x10)
void connectx4lx_mlnx_oem_cmd_get_temperature_dump(const struct connectx4lx_mlnx_oem_cmd_get_temperature *ptr_struct, FILE* file);
/* get_pf_mac_address */
void connectx4lx_get_pf_mac_address_pack(const struct connectx4lx_get_pf_mac_address *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_pf_mac_address_unpack(struct connectx4lx_get_pf_mac_address *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_pf_mac_address_print(const struct connectx4lx_get_pf_mac_address *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_pf_mac_address_size(void);
#define CONNECTX4LX_GET_PF_MAC_ADDRESS_SIZE    (0x8)
void connectx4lx_get_pf_mac_address_dump(const struct connectx4lx_get_pf_mac_address *ptr_struct, FILE* file);
/* get_allocated_management_address */
void connectx4lx_get_allocated_management_address_pack(const struct connectx4lx_get_allocated_management_address *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_allocated_management_address_unpack(struct connectx4lx_get_allocated_management_address *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_allocated_management_address_print(const struct connectx4lx_get_allocated_management_address *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_allocated_management_address_size(void);
#define CONNECTX4LX_GET_ALLOCATED_MANAGEMENT_ADDRESS_SIZE    (0x8)
void connectx4lx_get_allocated_management_address_dump(const struct connectx4lx_get_allocated_management_address *ptr_struct, FILE* file);
/* set_mc_affinity */
void connectx4lx_set_mc_affinity_pack(const struct connectx4lx_set_mc_affinity *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_mc_affinity_unpack(struct connectx4lx_set_mc_affinity *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_mc_affinity_print(const struct connectx4lx_set_mc_affinity *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_mc_affinity_size(void);
#define CONNECTX4LX_SET_MC_AFFINITY_SIZE    (0x3c)
void connectx4lx_set_mc_affinity_dump(const struct connectx4lx_set_mc_affinity *ptr_struct, FILE* file);
/* reg_access_reg_tlv_data */
void connectx4lx_reg_access_reg_tlv_data_pack(const union connectx4lx_reg_access_reg_tlv_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reg_access_reg_tlv_data_unpack(union connectx4lx_reg_access_reg_tlv_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reg_access_reg_tlv_data_print(const union connectx4lx_reg_access_reg_tlv_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reg_access_reg_tlv_data_size(void);
#define CONNECTX4LX_REG_ACCESS_REG_TLV_DATA_SIZE    (0x2c)
void connectx4lx_reg_access_reg_tlv_data_dump(const union connectx4lx_reg_access_reg_tlv_data *ptr_struct, FILE* file);
/* pmaos_reg */
void connectx4lx_pmaos_reg_pack(const struct connectx4lx_pmaos_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmaos_reg_unpack(struct connectx4lx_pmaos_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmaos_reg_print(const struct connectx4lx_pmaos_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmaos_reg_size(void);
#define CONNECTX4LX_PMAOS_REG_SIZE    (0x10)
void connectx4lx_pmaos_reg_dump(const struct connectx4lx_pmaos_reg *ptr_struct, FILE* file);
/* mtppse_reg */
void connectx4lx_mtppse_reg_pack(const struct connectx4lx_mtppse_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mtppse_reg_unpack(struct connectx4lx_mtppse_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mtppse_reg_print(const struct connectx4lx_mtppse_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mtppse_reg_size(void);
#define CONNECTX4LX_MTPPSE_REG_SIZE    (0x10)
void connectx4lx_mtppse_reg_dump(const struct connectx4lx_mtppse_reg *ptr_struct, FILE* file);
/* mtpps_reg */
void connectx4lx_mtpps_reg_pack(const struct connectx4lx_mtpps_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mtpps_reg_unpack(struct connectx4lx_mtpps_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mtpps_reg_print(const struct connectx4lx_mtpps_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mtpps_reg_size(void);
#define CONNECTX4LX_MTPPS_REG_SIZE    (0x40)
void connectx4lx_mtpps_reg_dump(const struct connectx4lx_mtpps_reg *ptr_struct, FILE* file);
/* fpga_ctrl */
void connectx4lx_fpga_ctrl_pack(const struct connectx4lx_fpga_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_ctrl_unpack(struct connectx4lx_fpga_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_ctrl_print(const struct connectx4lx_fpga_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_ctrl_size(void);
#define CONNECTX4LX_FPGA_CTRL_SIZE    (0x10)
void connectx4lx_fpga_ctrl_dump(const struct connectx4lx_fpga_ctrl *ptr_struct, FILE* file);
/* fpga_cap */
void connectx4lx_fpga_cap_pack(const struct connectx4lx_fpga_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_cap_unpack(struct connectx4lx_fpga_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_cap_print(const struct connectx4lx_fpga_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_cap_size(void);
#define CONNECTX4LX_FPGA_CAP_SIZE    (0x100)
void connectx4lx_fpga_cap_dump(const struct connectx4lx_fpga_cap *ptr_struct, FILE* file);
/* fpga_access_reg */
void connectx4lx_fpga_access_reg_pack(const struct connectx4lx_fpga_access_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_access_reg_unpack(struct connectx4lx_fpga_access_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_access_reg_print(const struct connectx4lx_fpga_access_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_access_reg_size(void);
#define CONNECTX4LX_FPGA_ACCESS_REG_SIZE    (0x14)
void connectx4lx_fpga_access_reg_dump(const struct connectx4lx_fpga_access_reg *ptr_struct, FILE* file);
/* pmmp_reg */
void connectx4lx_pmmp_reg_pack(const struct connectx4lx_pmmp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmmp_reg_unpack(struct connectx4lx_pmmp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmmp_reg_print(const struct connectx4lx_pmmp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmmp_reg_size(void);
#define CONNECTX4LX_PMMP_REG_SIZE    (0x2c)
void connectx4lx_pmmp_reg_dump(const struct connectx4lx_pmmp_reg *ptr_struct, FILE* file);
/* pcmr_reg */
void connectx4lx_pcmr_reg_pack(const struct connectx4lx_pcmr_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcmr_reg_unpack(struct connectx4lx_pcmr_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcmr_reg_print(const struct connectx4lx_pcmr_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcmr_reg_size(void);
#define CONNECTX4LX_PCMR_REG_SIZE    (0xc)
void connectx4lx_pcmr_reg_dump(const struct connectx4lx_pcmr_reg *ptr_struct, FILE* file);
/* mcion_reg */
void connectx4lx_mcion_reg_pack(const struct connectx4lx_mcion_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcion_reg_unpack(struct connectx4lx_mcion_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcion_reg_print(const struct connectx4lx_mcion_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcion_reg_size(void);
#define CONNECTX4LX_MCION_REG_SIZE    (0x18)
void connectx4lx_mcion_reg_dump(const struct connectx4lx_mcion_reg *ptr_struct, FILE* file);
/* pddr_reg */
void connectx4lx_pddr_reg_pack(const struct connectx4lx_pddr_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pddr_reg_unpack(struct connectx4lx_pddr_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pddr_reg_print(const struct connectx4lx_pddr_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pddr_reg_size(void);
#define CONNECTX4LX_PDDR_REG_SIZE    (0x100)
void connectx4lx_pddr_reg_dump(const struct connectx4lx_pddr_reg *ptr_struct, FILE* file);
/* mpcnt_reg */
void connectx4lx_mpcnt_reg_pack(const struct connectx4lx_mpcnt_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mpcnt_reg_unpack(struct connectx4lx_mpcnt_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mpcnt_reg_print(const struct connectx4lx_mpcnt_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mpcnt_reg_size(void);
#define CONNECTX4LX_MPCNT_REG_SIZE    (0x100)
void connectx4lx_mpcnt_reg_dump(const struct connectx4lx_mpcnt_reg *ptr_struct, FILE* file);
/* mcia_reg */
void connectx4lx_mcia_reg_pack(const struct connectx4lx_mcia_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcia_reg_unpack(struct connectx4lx_mcia_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcia_reg_print(const struct connectx4lx_mcia_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcia_reg_size(void);
#define CONNECTX4LX_MCIA_REG_SIZE    (0x40)
void connectx4lx_mcia_reg_dump(const struct connectx4lx_mcia_reg *ptr_struct, FILE* file);
/* ppad_reg */
void connectx4lx_ppad_reg_pack(const struct connectx4lx_ppad_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ppad_reg_unpack(struct connectx4lx_ppad_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ppad_reg_print(const struct connectx4lx_ppad_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ppad_reg_size(void);
#define CONNECTX4LX_PPAD_REG_SIZE    (0x10)
void connectx4lx_ppad_reg_dump(const struct connectx4lx_ppad_reg *ptr_struct, FILE* file);
/* pvlc_reg */
void connectx4lx_pvlc_reg_pack(const struct connectx4lx_pvlc_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pvlc_reg_unpack(struct connectx4lx_pvlc_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pvlc_reg_print(const struct connectx4lx_pvlc_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pvlc_reg_size(void);
#define CONNECTX4LX_PVLC_REG_SIZE    (0x10)
void connectx4lx_pvlc_reg_dump(const struct connectx4lx_pvlc_reg *ptr_struct, FILE* file);
/* ppcnt_reg */
void connectx4lx_ppcnt_reg_pack(const struct connectx4lx_ppcnt_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ppcnt_reg_unpack(struct connectx4lx_ppcnt_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ppcnt_reg_print(const struct connectx4lx_ppcnt_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ppcnt_reg_size(void);
#define CONNECTX4LX_PPCNT_REG_SIZE    (0x100)
void connectx4lx_ppcnt_reg_dump(const struct connectx4lx_ppcnt_reg *ptr_struct, FILE* file);
/* ptys_reg */
void connectx4lx_ptys_reg_pack(const struct connectx4lx_ptys_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ptys_reg_unpack(struct connectx4lx_ptys_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ptys_reg_print(const struct connectx4lx_ptys_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ptys_reg_size(void);
#define CONNECTX4LX_PTYS_REG_SIZE    (0x40)
void connectx4lx_ptys_reg_dump(const struct connectx4lx_ptys_reg *ptr_struct, FILE* file);
/* pmlp_reg */
void connectx4lx_pmlp_reg_pack(const struct connectx4lx_pmlp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pmlp_reg_unpack(struct connectx4lx_pmlp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pmlp_reg_print(const struct connectx4lx_pmlp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pmlp_reg_size(void);
#define CONNECTX4LX_PMLP_REG_SIZE    (0x40)
void connectx4lx_pmlp_reg_dump(const struct connectx4lx_pmlp_reg *ptr_struct, FILE* file);
/* register_mfbe */
void connectx4lx_register_mfbe_pack(const struct connectx4lx_register_mfbe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_mfbe_unpack(struct connectx4lx_register_mfbe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_mfbe_print(const struct connectx4lx_register_mfbe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_mfbe_size(void);
#define CONNECTX4LX_REGISTER_MFBE_SIZE    (0xc)
void connectx4lx_register_mfbe_dump(const struct connectx4lx_register_mfbe *ptr_struct, FILE* file);
/* register_mfba */
void connectx4lx_register_mfba_pack(const struct connectx4lx_register_mfba *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_mfba_unpack(struct connectx4lx_register_mfba *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_mfba_print(const struct connectx4lx_register_mfba *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_mfba_size(void);
#define CONNECTX4LX_REGISTER_MFBA_SIZE    (0x2c)
void connectx4lx_register_mfba_dump(const struct connectx4lx_register_mfba *ptr_struct, FILE* file);
/* register_mfpa */
void connectx4lx_register_mfpa_pack(const struct connectx4lx_register_mfpa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_mfpa_unpack(struct connectx4lx_register_mfpa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_mfpa_print(const struct connectx4lx_register_mfpa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_mfpa_size(void);
#define CONNECTX4LX_REGISTER_MFPA_SIZE    (0x20)
void connectx4lx_register_mfpa_dump(const struct connectx4lx_register_mfpa *ptr_struct, FILE* file);
/* db_threshold_register_layout */
void connectx4lx_db_threshold_register_layout_pack(const struct connectx4lx_db_threshold_register_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_db_threshold_register_layout_unpack(struct connectx4lx_db_threshold_register_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_db_threshold_register_layout_print(const struct connectx4lx_db_threshold_register_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_db_threshold_register_layout_size(void);
#define CONNECTX4LX_DB_THRESHOLD_REGISTER_LAYOUT_SIZE    (0x10)
void connectx4lx_db_threshold_register_layout_dump(const struct connectx4lx_db_threshold_register_layout *ptr_struct, FILE* file);
/* register_pplr */
void connectx4lx_register_pplr_pack(const struct connectx4lx_register_pplr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_pplr_unpack(struct connectx4lx_register_pplr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_pplr_print(const struct connectx4lx_register_pplr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_pplr_size(void);
#define CONNECTX4LX_REGISTER_PPLR_SIZE    (0x10)
void connectx4lx_register_pplr_dump(const struct connectx4lx_register_pplr *ptr_struct, FILE* file);
/* register_host_endianness */
void connectx4lx_register_host_endianness_pack(const struct connectx4lx_register_host_endianness *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_host_endianness_unpack(struct connectx4lx_register_host_endianness *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_host_endianness_print(const struct connectx4lx_register_host_endianness *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_host_endianness_size(void);
#define CONNECTX4LX_REGISTER_HOST_ENDIANNESS_SIZE    (0x10)
void connectx4lx_register_host_endianness_dump(const struct connectx4lx_register_host_endianness *ptr_struct, FILE* file);
/* register_fp_sl_map */
void connectx4lx_register_fp_sl_map_pack(const struct connectx4lx_register_fp_sl_map *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_fp_sl_map_unpack(struct connectx4lx_register_fp_sl_map *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_fp_sl_map_print(const struct connectx4lx_register_fp_sl_map *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_fp_sl_map_size(void);
#define CONNECTX4LX_REGISTER_FP_SL_MAP_SIZE    (0x10)
void connectx4lx_register_fp_sl_map_dump(const struct connectx4lx_register_fp_sl_map *ptr_struct, FILE* file);
/* register_power_settings */
void connectx4lx_register_power_settings_pack(const struct connectx4lx_register_power_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_power_settings_unpack(struct connectx4lx_register_power_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_power_settings_print(const struct connectx4lx_register_power_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_power_settings_size(void);
#define CONNECTX4LX_REGISTER_POWER_SETTINGS_SIZE    (0x10)
void connectx4lx_register_power_settings_dump(const struct connectx4lx_register_power_settings *ptr_struct, FILE* file);
/* register_loopback_control */
void connectx4lx_register_loopback_control_pack(const struct connectx4lx_register_loopback_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_loopback_control_unpack(struct connectx4lx_register_loopback_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_loopback_control_print(const struct connectx4lx_register_loopback_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_loopback_control_size(void);
#define CONNECTX4LX_REGISTER_LOOPBACK_CONTROL_SIZE    (0x10)
void connectx4lx_register_loopback_control_dump(const struct connectx4lx_register_loopback_control *ptr_struct, FILE* file);
/* pfcc_reg */
void connectx4lx_pfcc_reg_pack(const struct connectx4lx_pfcc_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pfcc_reg_unpack(struct connectx4lx_pfcc_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pfcc_reg_print(const struct connectx4lx_pfcc_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pfcc_reg_size(void);
#define CONNECTX4LX_PFCC_REG_SIZE    (0x20)
void connectx4lx_pfcc_reg_dump(const struct connectx4lx_pfcc_reg *ptr_struct, FILE* file);
/* access_register_unit_port_capabilities */
void connectx4lx_access_register_unit_port_capabilities_pack(const struct connectx4lx_access_register_unit_port_capabilities *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_port_capabilities_unpack(struct connectx4lx_access_register_unit_port_capabilities *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_port_capabilities_print(const struct connectx4lx_access_register_unit_port_capabilities *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_unit_port_capabilities_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_UNIT_PORT_CAPABILITIES_SIZE    (0x14)
void connectx4lx_access_register_unit_port_capabilities_dump(const struct connectx4lx_access_register_unit_port_capabilities *ptr_struct, FILE* file);
/* register_unit_perf_counters_global_ctrl */
void connectx4lx_register_unit_perf_counters_global_ctrl_pack(const struct connectx4lx_register_unit_perf_counters_global_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_unit_perf_counters_global_ctrl_unpack(struct connectx4lx_register_unit_perf_counters_global_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_unit_perf_counters_global_ctrl_print(const struct connectx4lx_register_unit_perf_counters_global_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_unit_perf_counters_global_ctrl_size(void);
#define CONNECTX4LX_REGISTER_UNIT_PERF_COUNTERS_GLOBAL_CTRL_SIZE    (0x10)
void connectx4lx_register_unit_perf_counters_global_ctrl_dump(const struct connectx4lx_register_unit_perf_counters_global_ctrl *ptr_struct, FILE* file);
/* access_register_unit_perf_counters_data */
void connectx4lx_access_register_unit_perf_counters_data_pack(const struct connectx4lx_access_register_unit_perf_counters_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_data_unpack(struct connectx4lx_access_register_unit_perf_counters_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_data_print(const struct connectx4lx_access_register_unit_perf_counters_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_unit_perf_counters_data_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_UNIT_PERF_COUNTERS_DATA_SIZE    (0x20)
void connectx4lx_access_register_unit_perf_counters_data_dump(const struct connectx4lx_access_register_unit_perf_counters_data *ptr_struct, FILE* file);
/* access_register_unit_perf_counters_cfg */
void connectx4lx_access_register_unit_perf_counters_cfg_pack(const struct connectx4lx_access_register_unit_perf_counters_cfg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_cfg_unpack(struct connectx4lx_access_register_unit_perf_counters_cfg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_unit_perf_counters_cfg_print(const struct connectx4lx_access_register_unit_perf_counters_cfg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_unit_perf_counters_cfg_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_UNIT_PERF_COUNTERS_CFG_SIZE    (0x20)
void connectx4lx_access_register_unit_perf_counters_cfg_dump(const struct connectx4lx_access_register_unit_perf_counters_cfg *ptr_struct, FILE* file);
/* register_set_node */
void connectx4lx_register_set_node_pack(const struct connectx4lx_register_set_node *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_register_set_node_unpack(struct connectx4lx_register_set_node *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_register_set_node_print(const struct connectx4lx_register_set_node *ptr_struct, FILE* file, int indent_level);
int connectx4lx_register_set_node_size(void);
#define CONNECTX4LX_REGISTER_SET_NODE_SIZE    (0x40)
void connectx4lx_register_set_node_dump(const struct connectx4lx_register_set_node *ptr_struct, FILE* file);
/* dcbx_app_reg */
void connectx4lx_dcbx_app_reg_pack(const struct connectx4lx_dcbx_app_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_app_reg_unpack(struct connectx4lx_dcbx_app_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_app_reg_print(const struct connectx4lx_dcbx_app_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_app_reg_size(void);
#define CONNECTX4LX_DCBX_APP_REG_SIZE    (0x14)
void connectx4lx_dcbx_app_reg_dump(const struct connectx4lx_dcbx_app_reg *ptr_struct, FILE* file);
/* dcbx_param_reg */
void connectx4lx_dcbx_param_reg_pack(const struct connectx4lx_dcbx_param_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_param_reg_unpack(struct connectx4lx_dcbx_param_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_param_reg_print(const struct connectx4lx_dcbx_param_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_param_reg_size(void);
#define CONNECTX4LX_DCBX_PARAM_REG_SIZE    (0x40)
void connectx4lx_dcbx_param_reg_dump(const struct connectx4lx_dcbx_param_reg *ptr_struct, FILE* file);
/* mlcr */
void connectx4lx_mlcr_pack(const struct connectx4lx_mlcr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlcr_unpack(struct connectx4lx_mlcr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlcr_print(const struct connectx4lx_mlcr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlcr_size(void);
#define CONNECTX4LX_MLCR_SIZE    (0xc)
void connectx4lx_mlcr_dump(const struct connectx4lx_mlcr *ptr_struct, FILE* file);
/* qhll */
void connectx4lx_qhll_pack(const struct connectx4lx_qhll *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qhll_unpack(struct connectx4lx_qhll *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qhll_print(const struct connectx4lx_qhll *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qhll_size(void);
#define CONNECTX4LX_QHLL_SIZE    (0xc)
void connectx4lx_qhll_dump(const struct connectx4lx_qhll *ptr_struct, FILE* file);
/* qtct_reg */
void connectx4lx_qtct_reg_pack(const struct connectx4lx_qtct_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qtct_reg_unpack(struct connectx4lx_qtct_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qtct_reg_print(const struct connectx4lx_qtct_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qtct_reg_size(void);
#define CONNECTX4LX_QTCT_REG_SIZE    (0x8)
void connectx4lx_qtct_reg_dump(const struct connectx4lx_qtct_reg *ptr_struct, FILE* file);
/* qpdp_reg */
void connectx4lx_qpdp_reg_pack(const struct connectx4lx_qpdp_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qpdp_reg_unpack(struct connectx4lx_qpdp_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qpdp_reg_print(const struct connectx4lx_qpdp_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qpdp_reg_size(void);
#define CONNECTX4LX_QPDP_REG_SIZE    (0x8)
void connectx4lx_qpdp_reg_dump(const struct connectx4lx_qpdp_reg *ptr_struct, FILE* file);
/* qetcr_reg */
void connectx4lx_qetcr_reg_pack(const struct connectx4lx_qetcr_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qetcr_reg_unpack(struct connectx4lx_qetcr_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qetcr_reg_print(const struct connectx4lx_qetcr_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qetcr_reg_size(void);
#define CONNECTX4LX_QETCR_REG_SIZE    (0x50)
void connectx4lx_qetcr_reg_dump(const struct connectx4lx_qetcr_reg *ptr_struct, FILE* file);
/* pcam_reg */
void connectx4lx_pcam_reg_pack(const struct connectx4lx_pcam_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcam_reg_unpack(struct connectx4lx_pcam_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcam_reg_print(const struct connectx4lx_pcam_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcam_reg_size(void);
#define CONNECTX4LX_PCAM_REG_SIZE    (0x50)
void connectx4lx_pcam_reg_dump(const struct connectx4lx_pcam_reg *ptr_struct, FILE* file);
/* mcam_reg */
void connectx4lx_mcam_reg_pack(const struct connectx4lx_mcam_reg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mcam_reg_unpack(struct connectx4lx_mcam_reg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mcam_reg_print(const struct connectx4lx_mcam_reg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mcam_reg_size(void);
#define CONNECTX4LX_MCAM_REG_SIZE    (0x48)
void connectx4lx_mcam_reg_dump(const struct connectx4lx_mcam_reg *ptr_struct, FILE* file);
/* ib_gid */
void connectx4lx_ib_gid_pack(const struct connectx4lx_ib_gid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ib_gid_unpack(struct connectx4lx_ib_gid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ib_gid_print(const struct connectx4lx_ib_gid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ib_gid_size(void);
#define CONNECTX4LX_IB_GID_SIZE    (0x10)
void connectx4lx_ib_gid_dump(const struct connectx4lx_ib_gid *ptr_struct, FILE* file);
/* dmfs_encap_meta */
void connectx4lx_dmfs_encap_meta_pack(const struct connectx4lx_dmfs_encap_meta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_encap_meta_unpack(struct connectx4lx_dmfs_encap_meta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_encap_meta_print(const struct connectx4lx_dmfs_encap_meta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_encap_meta_size(void);
#define CONNECTX4LX_DMFS_ENCAP_META_SIZE    (0x8)
void connectx4lx_dmfs_encap_meta_dump(const struct connectx4lx_dmfs_encap_meta *ptr_struct, FILE* file);
/* flow_counter_fw_ctx */
void connectx4lx_flow_counter_fw_ctx_pack(const struct connectx4lx_flow_counter_fw_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flow_counter_fw_ctx_unpack(struct connectx4lx_flow_counter_fw_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flow_counter_fw_ctx_print(const struct connectx4lx_flow_counter_fw_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flow_counter_fw_ctx_size(void);
#define CONNECTX4LX_FLOW_COUNTER_FW_CTX_SIZE    (0x20)
void connectx4lx_flow_counter_fw_ctx_dump(const struct connectx4lx_flow_counter_fw_ctx *ptr_struct, FILE* file);
/* l2_table_entry_fw_ctx */
void connectx4lx_l2_table_entry_fw_ctx_pack(const struct connectx4lx_l2_table_entry_fw_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_l2_table_entry_fw_ctx_unpack(struct connectx4lx_l2_table_entry_fw_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_l2_table_entry_fw_ctx_print(const struct connectx4lx_l2_table_entry_fw_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_l2_table_entry_fw_ctx_size(void);
#define CONNECTX4LX_L2_TABLE_ENTRY_FW_CTX_SIZE    (0x20)
void connectx4lx_l2_table_entry_fw_ctx_dump(const struct connectx4lx_l2_table_entry_fw_ctx *ptr_struct, FILE* file);
/* dmfs_fte_meta */
void connectx4lx_dmfs_fte_meta_pack(const struct connectx4lx_dmfs_fte_meta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_fte_meta_unpack(struct connectx4lx_dmfs_fte_meta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_fte_meta_print(const struct connectx4lx_dmfs_fte_meta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_fte_meta_size(void);
#define CONNECTX4LX_DMFS_FTE_META_SIZE    (0x40)
void connectx4lx_dmfs_fte_meta_dump(const struct connectx4lx_dmfs_fte_meta *ptr_struct, FILE* file);
/* dmfs_ft_meta */
void connectx4lx_dmfs_ft_meta_pack(const struct connectx4lx_dmfs_ft_meta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_ft_meta_unpack(struct connectx4lx_dmfs_ft_meta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_ft_meta_print(const struct connectx4lx_dmfs_ft_meta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_ft_meta_size(void);
#define CONNECTX4LX_DMFS_FT_META_SIZE    (0x40)
void connectx4lx_dmfs_ft_meta_dump(const struct connectx4lx_dmfs_ft_meta *ptr_struct, FILE* file);
/* dmfs_fg_meta */
void connectx4lx_dmfs_fg_meta_pack(const struct connectx4lx_dmfs_fg_meta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_fg_meta_unpack(struct connectx4lx_dmfs_fg_meta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_fg_meta_print(const struct connectx4lx_dmfs_fg_meta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_fg_meta_size(void);
#define CONNECTX4LX_DMFS_FG_META_SIZE    (0x40)
void connectx4lx_dmfs_fg_meta_dump(const struct connectx4lx_dmfs_fg_meta *ptr_struct, FILE* file);
/* mkey_dump */
void connectx4lx_mkey_dump_pack(const struct connectx4lx_mkey_dump *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mkey_dump_unpack(struct connectx4lx_mkey_dump *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mkey_dump_print(const struct connectx4lx_mkey_dump *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mkey_dump_size(void);
#define CONNECTX4LX_MKEY_DUMP_SIZE    (0x4)
void connectx4lx_mkey_dump_dump(const struct connectx4lx_mkey_dump *ptr_struct, FILE* file);
/* fw_tis */
void connectx4lx_fw_tis_pack(const struct connectx4lx_fw_tis *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_tis_unpack(struct connectx4lx_fw_tis *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_tis_print(const struct connectx4lx_fw_tis *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_tis_size(void);
#define CONNECTX4LX_FW_TIS_SIZE    (0x40)
void connectx4lx_fw_tis_dump(const struct connectx4lx_fw_tis *ptr_struct, FILE* file);
/* fw_tir */
void connectx4lx_fw_tir_pack(const struct connectx4lx_fw_tir *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_tir_unpack(struct connectx4lx_fw_tir *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_tir_print(const struct connectx4lx_fw_tir *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_tir_size(void);
#define CONNECTX4LX_FW_TIR_SIZE    (0x40)
void connectx4lx_fw_tir_dump(const struct connectx4lx_fw_tir *ptr_struct, FILE* file);
/* fw_qpc */
void connectx4lx_fw_qpc_pack(const struct connectx4lx_fw_qpc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_unpack(struct connectx4lx_fw_qpc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_qpc_print(const struct connectx4lx_fw_qpc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_qpc_size(void);
#define CONNECTX4LX_FW_QPC_SIZE    (0x40)
void connectx4lx_fw_qpc_dump(const struct connectx4lx_fw_qpc *ptr_struct, FILE* file);
/* fw_srqc */
void connectx4lx_fw_srqc_pack(const struct connectx4lx_fw_srqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_srqc_unpack(struct connectx4lx_fw_srqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_srqc_print(const struct connectx4lx_fw_srqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_srqc_size(void);
#define CONNECTX4LX_FW_SRQC_SIZE    (0x40)
void connectx4lx_fw_srqc_dump(const struct connectx4lx_fw_srqc *ptr_struct, FILE* file);
/* sw_ads */
void connectx4lx_sw_ads_pack(const struct connectx4lx_sw_ads *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_ads_unpack(struct connectx4lx_sw_ads *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_ads_print(const struct connectx4lx_sw_ads *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_ads_size(void);
#define CONNECTX4LX_SW_ADS_SIZE    (0x2c)
void connectx4lx_sw_ads_dump(const struct connectx4lx_sw_ads *ptr_struct, FILE* file);
/* gid_mac_l2_entry */
void connectx4lx_gid_mac_l2_entry_pack(const struct connectx4lx_gid_mac_l2_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gid_mac_l2_entry_unpack(struct connectx4lx_gid_mac_l2_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gid_mac_l2_entry_print(const struct connectx4lx_gid_mac_l2_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gid_mac_l2_entry_size(void);
#define CONNECTX4LX_GID_MAC_L2_ENTRY_SIZE    (0xc)
void connectx4lx_gid_mac_l2_entry_dump(const struct connectx4lx_gid_mac_l2_entry *ptr_struct, FILE* file);
/* hw_msix_ext_context */
void connectx4lx_hw_msix_ext_context_pack(const struct connectx4lx_hw_msix_ext_context *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_ext_context_unpack(struct connectx4lx_hw_msix_ext_context *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_ext_context_print(const struct connectx4lx_hw_msix_ext_context *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_ext_context_size(void);
#define CONNECTX4LX_HW_MSIX_EXT_CONTEXT_SIZE    (0x10)
void connectx4lx_hw_msix_ext_context_dump(const struct connectx4lx_hw_msix_ext_context *ptr_struct, FILE* file);
/* hw_msix_context */
void connectx4lx_hw_msix_context_pack(const struct connectx4lx_hw_msix_context *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_unpack(struct connectx4lx_hw_msix_context *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_context_print(const struct connectx4lx_hw_msix_context *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_context_size(void);
#define CONNECTX4LX_HW_MSIX_CONTEXT_SIZE    (0x10)
void connectx4lx_hw_msix_context_dump(const struct connectx4lx_hw_msix_context *ptr_struct, FILE* file);
/* hw_rdb_atomic_data */
void connectx4lx_hw_rdb_atomic_data_pack(const struct connectx4lx_hw_rdb_atomic_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_rdb_atomic_data_unpack(struct connectx4lx_hw_rdb_atomic_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_rdb_atomic_data_print(const struct connectx4lx_hw_rdb_atomic_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_rdb_atomic_data_size(void);
#define CONNECTX4LX_HW_RDB_ATOMIC_DATA_SIZE    (0x20)
void connectx4lx_hw_rdb_atomic_data_dump(const struct connectx4lx_hw_rdb_atomic_data *ptr_struct, FILE* file);
/* hw_mtt2 */
void connectx4lx_hw_mtt2_pack(const struct connectx4lx_hw_mtt2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_mtt2_unpack(struct connectx4lx_hw_mtt2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_mtt2_print(const struct connectx4lx_hw_mtt2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_mtt2_size(void);
#define CONNECTX4LX_HW_MTT2_SIZE    (0x8)
void connectx4lx_hw_mtt2_dump(const struct connectx4lx_hw_mtt2 *ptr_struct, FILE* file);
/* hw_mtt */
void connectx4lx_hw_mtt_pack(const struct connectx4lx_hw_mtt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_mtt_unpack(struct connectx4lx_hw_mtt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_mtt_print(const struct connectx4lx_hw_mtt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_mtt_size(void);
#define CONNECTX4LX_HW_MTT_SIZE    (0x8)
void connectx4lx_hw_mtt_dump(const struct connectx4lx_hw_mtt *ptr_struct, FILE* file);
/* steering_qp_list */
void connectx4lx_steering_qp_list_pack(const struct connectx4lx_steering_qp_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_steering_qp_list_unpack(struct connectx4lx_steering_qp_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_steering_qp_list_print(const struct connectx4lx_steering_qp_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_steering_qp_list_size(void);
#define CONNECTX4LX_STEERING_QP_LIST_SIZE    (0x40)
void connectx4lx_steering_qp_list_dump(const struct connectx4lx_steering_qp_list *ptr_struct, FILE* file);
/* hw_ste */
void connectx4lx_hw_ste_pack(const struct connectx4lx_hw_ste *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_ste_unpack(struct connectx4lx_hw_ste *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_ste_print(const struct connectx4lx_hw_ste *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_ste_size(void);
#define CONNECTX4LX_HW_STE_SIZE    (0x40)
void connectx4lx_hw_ste_dump(const struct connectx4lx_hw_ste *ptr_struct, FILE* file);
/* hw_timer */
void connectx4lx_hw_timer_pack(const struct connectx4lx_hw_timer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_timer_unpack(struct connectx4lx_hw_timer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_timer_print(const struct connectx4lx_hw_timer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_timer_size(void);
#define CONNECTX4LX_HW_TIMER_SIZE    (0x1)
void connectx4lx_hw_timer_dump(const struct connectx4lx_hw_timer *ptr_struct, FILE* file);
/* sxdc_requestor_in_sq */
void connectx4lx_sxdc_requestor_in_sq_pack(const struct connectx4lx_sxdc_requestor_in_sq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_requestor_in_sq_unpack(struct connectx4lx_sxdc_requestor_in_sq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_requestor_in_sq_print(const struct connectx4lx_sxdc_requestor_in_sq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_requestor_in_sq_size(void);
#define CONNECTX4LX_SXDC_REQUESTOR_IN_SQ_SIZE    (0x8)
void connectx4lx_sxdc_requestor_in_sq_dump(const struct connectx4lx_sxdc_requestor_in_sq *ptr_struct, FILE* file);
/* sxdc_responder_in_sq */
void connectx4lx_sxdc_responder_in_sq_pack(const struct connectx4lx_sxdc_responder_in_sq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_responder_in_sq_unpack(struct connectx4lx_sxdc_responder_in_sq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_responder_in_sq_print(const struct connectx4lx_sxdc_responder_in_sq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_responder_in_sq_size(void);
#define CONNECTX4LX_SXDC_RESPONDER_IN_SQ_SIZE    (0x8)
void connectx4lx_sxdc_responder_in_sq_dump(const struct connectx4lx_sxdc_responder_in_sq *ptr_struct, FILE* file);
/* sxdc_scheduling_interrupt_requestor */
void connectx4lx_sxdc_scheduling_interrupt_requestor_pack(const struct connectx4lx_sxdc_scheduling_interrupt_requestor *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_scheduling_interrupt_requestor_unpack(struct connectx4lx_sxdc_scheduling_interrupt_requestor *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_scheduling_interrupt_requestor_print(const struct connectx4lx_sxdc_scheduling_interrupt_requestor *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_scheduling_interrupt_requestor_size(void);
#define CONNECTX4LX_SXDC_SCHEDULING_INTERRUPT_REQUESTOR_SIZE    (0x8)
void connectx4lx_sxdc_scheduling_interrupt_requestor_dump(const struct connectx4lx_sxdc_scheduling_interrupt_requestor *ptr_struct, FILE* file);
/* sxdc_scheduling_interrupt_responder */
void connectx4lx_sxdc_scheduling_interrupt_responder_pack(const struct connectx4lx_sxdc_scheduling_interrupt_responder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_scheduling_interrupt_responder_unpack(struct connectx4lx_sxdc_scheduling_interrupt_responder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_scheduling_interrupt_responder_print(const struct connectx4lx_sxdc_scheduling_interrupt_responder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_scheduling_interrupt_responder_size(void);
#define CONNECTX4LX_SXDC_SCHEDULING_INTERRUPT_RESPONDER_SIZE    (0x8)
void connectx4lx_sxdc_scheduling_interrupt_responder_dump(const struct connectx4lx_sxdc_scheduling_interrupt_responder *ptr_struct, FILE* file);
/* sxdc_doorbell_int */
void connectx4lx_sxdc_doorbell_int_pack(const struct connectx4lx_sxdc_doorbell_int *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_doorbell_int_unpack(struct connectx4lx_sxdc_doorbell_int *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_doorbell_int_print(const struct connectx4lx_sxdc_doorbell_int *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_doorbell_int_size(void);
#define CONNECTX4LX_SXDC_DOORBELL_INT_SIZE    (0x8)
void connectx4lx_sxdc_doorbell_int_dump(const struct connectx4lx_sxdc_doorbell_int *ptr_struct, FILE* file);
/* sxdc_fast_path */
void connectx4lx_sxdc_fast_path_pack(const struct connectx4lx_sxdc_fast_path *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_fast_path_unpack(struct connectx4lx_sxdc_fast_path *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_fast_path_print(const struct connectx4lx_sxdc_fast_path *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_fast_path_size(void);
#define CONNECTX4LX_SXDC_FAST_PATH_SIZE    (0x8)
void connectx4lx_sxdc_fast_path_dump(const struct connectx4lx_sxdc_fast_path *ptr_struct, FILE* file);
/* sxdc_external_db_en */
void connectx4lx_sxdc_external_db_en_pack(const struct connectx4lx_sxdc_external_db_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_external_db_en_unpack(struct connectx4lx_sxdc_external_db_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_external_db_en_print(const struct connectx4lx_sxdc_external_db_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_external_db_en_size(void);
#define CONNECTX4LX_SXDC_EXTERNAL_DB_EN_SIZE    (0x8)
void connectx4lx_sxdc_external_db_en_dump(const struct connectx4lx_sxdc_external_db_en *ptr_struct, FILE* file);
/* sxdc_valid */
void connectx4lx_sxdc_valid_pack(const struct connectx4lx_sxdc_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_valid_unpack(struct connectx4lx_sxdc_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_valid_print(const struct connectx4lx_sxdc_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_valid_size(void);
#define CONNECTX4LX_SXDC_VALID_SIZE    (0x8)
void connectx4lx_sxdc_valid_dump(const struct connectx4lx_sxdc_valid *ptr_struct, FILE* file);
/* sxdc_sq */
void connectx4lx_sxdc_sq_pack(const struct connectx4lx_sxdc_sq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_sq_unpack(struct connectx4lx_sxdc_sq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_sq_print(const struct connectx4lx_sxdc_sq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_sq_size(void);
#define CONNECTX4LX_SXDC_SQ_SIZE    (0x8)
void connectx4lx_sxdc_sq_dump(const struct connectx4lx_sxdc_sq *ptr_struct, FILE* file);
/* sxdc_swqe_producer_index */
void connectx4lx_sxdc_swqe_producer_index_pack(const struct connectx4lx_sxdc_swqe_producer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_swqe_producer_index_unpack(struct connectx4lx_sxdc_swqe_producer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_swqe_producer_index_print(const struct connectx4lx_sxdc_swqe_producer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_swqe_producer_index_size(void);
#define CONNECTX4LX_SXDC_SWQE_PRODUCER_INDEX_SIZE    (0x8)
void connectx4lx_sxdc_swqe_producer_index_dump(const struct connectx4lx_sxdc_swqe_producer_index *ptr_struct, FILE* file);
/* sxdc_uar */
void connectx4lx_sxdc_uar_pack(const struct connectx4lx_sxdc_uar *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sxdc_uar_unpack(struct connectx4lx_sxdc_uar *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sxdc_uar_print(const struct connectx4lx_sxdc_uar *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sxdc_uar_size(void);
#define CONNECTX4LX_SXDC_UAR_SIZE    (0x8)
void connectx4lx_sxdc_uar_dump(const struct connectx4lx_sxdc_uar *ptr_struct, FILE* file);
/* hw_dct */
void connectx4lx_hw_dct_pack(const union connectx4lx_hw_dct *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_dct_unpack(union connectx4lx_hw_dct *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_dct_print(const union connectx4lx_hw_dct *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_dct_size(void);
#define CONNECTX4LX_HW_DCT_SIZE    (0x40)
void connectx4lx_hw_dct_dump(const union connectx4lx_hw_dct *ptr_struct, FILE* file);
/* hw_r_qpc */
void connectx4lx_hw_r_qpc_pack(const union connectx4lx_hw_r_qpc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_unpack(union connectx4lx_hw_r_qpc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_r_qpc_print(const union connectx4lx_hw_r_qpc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_r_qpc_size(void);
#define CONNECTX4LX_HW_R_QPC_SIZE    (0x40)
void connectx4lx_hw_r_qpc_dump(const union connectx4lx_hw_r_qpc *ptr_struct, FILE* file);
/* hw_s_qpc_responder_session_id_23_16 */
void connectx4lx_hw_s_qpc_responder_session_id_23_16_pack(const struct connectx4lx_hw_s_qpc_responder_session_id_23_16 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_responder_session_id_23_16_unpack(struct connectx4lx_hw_s_qpc_responder_session_id_23_16 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_responder_session_id_23_16_print(const struct connectx4lx_hw_s_qpc_responder_session_id_23_16 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_responder_session_id_23_16_size(void);
#define CONNECTX4LX_HW_S_QPC_RESPONDER_SESSION_ID_23_16_SIZE    (0x40)
void connectx4lx_hw_s_qpc_responder_session_id_23_16_dump(const struct connectx4lx_hw_s_qpc_responder_session_id_23_16 *ptr_struct, FILE* file);
/* hw_s_qpc_responder_session_id_15_0 */
void connectx4lx_hw_s_qpc_responder_session_id_15_0_pack(const struct connectx4lx_hw_s_qpc_responder_session_id_15_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_responder_session_id_15_0_unpack(struct connectx4lx_hw_s_qpc_responder_session_id_15_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_responder_session_id_15_0_print(const struct connectx4lx_hw_s_qpc_responder_session_id_15_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_responder_session_id_15_0_size(void);
#define CONNECTX4LX_HW_S_QPC_RESPONDER_SESSION_ID_15_0_SIZE    (0x40)
void connectx4lx_hw_s_qpc_responder_session_id_15_0_dump(const struct connectx4lx_hw_s_qpc_responder_session_id_15_0 *ptr_struct, FILE* file);
/* hw_s_qpc_no_direct_access */
void connectx4lx_hw_s_qpc_no_direct_access_pack(const struct connectx4lx_hw_s_qpc_no_direct_access *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_no_direct_access_unpack(struct connectx4lx_hw_s_qpc_no_direct_access *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_no_direct_access_print(const struct connectx4lx_hw_s_qpc_no_direct_access *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_no_direct_access_size(void);
#define CONNECTX4LX_HW_S_QPC_NO_DIRECT_ACCESS_SIZE    (0x40)
void connectx4lx_hw_s_qpc_no_direct_access_dump(const struct connectx4lx_hw_s_qpc_no_direct_access *ptr_struct, FILE* file);
/* hw_s_qpc_ignore_pkey_check */
void connectx4lx_hw_s_qpc_ignore_pkey_check_pack(const struct connectx4lx_hw_s_qpc_ignore_pkey_check *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ignore_pkey_check_unpack(struct connectx4lx_hw_s_qpc_ignore_pkey_check *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ignore_pkey_check_print(const struct connectx4lx_hw_s_qpc_ignore_pkey_check *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ignore_pkey_check_size(void);
#define CONNECTX4LX_HW_S_QPC_IGNORE_PKEY_CHECK_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ignore_pkey_check_dump(const struct connectx4lx_hw_s_qpc_ignore_pkey_check *ptr_struct, FILE* file);
/* hw_s_qpc_rx_heartbeat */
void connectx4lx_hw_s_qpc_rx_heartbeat_pack(const struct connectx4lx_hw_s_qpc_rx_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_rx_heartbeat_unpack(struct connectx4lx_hw_s_qpc_rx_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_rx_heartbeat_print(const struct connectx4lx_hw_s_qpc_rx_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_rx_heartbeat_size(void);
#define CONNECTX4LX_HW_S_QPC_RX_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_rx_heartbeat_dump(const struct connectx4lx_hw_s_qpc_rx_heartbeat *ptr_struct, FILE* file);
/* hw_s_qpc_tcu_drop */
void connectx4lx_hw_s_qpc_tcu_drop_pack(const struct connectx4lx_hw_s_qpc_tcu_drop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_tcu_drop_unpack(struct connectx4lx_hw_s_qpc_tcu_drop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_tcu_drop_print(const struct connectx4lx_hw_s_qpc_tcu_drop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_tcu_drop_size(void);
#define CONNECTX4LX_HW_S_QPC_TCU_DROP_SIZE    (0x40)
void connectx4lx_hw_s_qpc_tcu_drop_dump(const struct connectx4lx_hw_s_qpc_tcu_drop *ptr_struct, FILE* file);
/* hw_s_qpc_tcu_trap */
void connectx4lx_hw_s_qpc_tcu_trap_pack(const struct connectx4lx_hw_s_qpc_tcu_trap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_tcu_trap_unpack(struct connectx4lx_hw_s_qpc_tcu_trap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_tcu_trap_print(const struct connectx4lx_hw_s_qpc_tcu_trap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_tcu_trap_size(void);
#define CONNECTX4LX_HW_S_QPC_TCU_TRAP_SIZE    (0x40)
void connectx4lx_hw_s_qpc_tcu_trap_dump(const struct connectx4lx_hw_s_qpc_tcu_trap *ptr_struct, FILE* file);
/* hw_s_qpc_qp_valid */
void connectx4lx_hw_s_qpc_qp_valid_pack(const struct connectx4lx_hw_s_qpc_qp_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_qp_valid_unpack(struct connectx4lx_hw_s_qpc_qp_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_qp_valid_print(const struct connectx4lx_hw_s_qpc_qp_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_qp_valid_size(void);
#define CONNECTX4LX_HW_S_QPC_QP_VALID_SIZE    (0x40)
void connectx4lx_hw_s_qpc_qp_valid_dump(const struct connectx4lx_hw_s_qpc_qp_valid *ptr_struct, FILE* file);
/* hw_s_qpc_fast_path */
void connectx4lx_hw_s_qpc_fast_path_pack(const struct connectx4lx_hw_s_qpc_fast_path *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_fast_path_unpack(struct connectx4lx_hw_s_qpc_fast_path *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_fast_path_print(const struct connectx4lx_hw_s_qpc_fast_path *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_fast_path_size(void);
#define CONNECTX4LX_HW_S_QPC_FAST_PATH_SIZE    (0x40)
void connectx4lx_hw_s_qpc_fast_path_dump(const struct connectx4lx_hw_s_qpc_fast_path *ptr_struct, FILE* file);
/* hw_s_qpc_can_use_reserved_lkey */
void connectx4lx_hw_s_qpc_can_use_reserved_lkey_pack(const struct connectx4lx_hw_s_qpc_can_use_reserved_lkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_can_use_reserved_lkey_unpack(struct connectx4lx_hw_s_qpc_can_use_reserved_lkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_can_use_reserved_lkey_print(const struct connectx4lx_hw_s_qpc_can_use_reserved_lkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_can_use_reserved_lkey_size(void);
#define CONNECTX4LX_HW_S_QPC_CAN_USE_RESERVED_LKEY_SIZE    (0x40)
void connectx4lx_hw_s_qpc_can_use_reserved_lkey_dump(const struct connectx4lx_hw_s_qpc_can_use_reserved_lkey *ptr_struct, FILE* file);
/* hw_s_qpc_e2e_credits_enabled */
void connectx4lx_hw_s_qpc_e2e_credits_enabled_pack(const struct connectx4lx_hw_s_qpc_e2e_credits_enabled *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_e2e_credits_enabled_unpack(struct connectx4lx_hw_s_qpc_e2e_credits_enabled *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_e2e_credits_enabled_print(const struct connectx4lx_hw_s_qpc_e2e_credits_enabled *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_e2e_credits_enabled_size(void);
#define CONNECTX4LX_HW_S_QPC_E2E_CREDITS_ENABLED_SIZE    (0x40)
void connectx4lx_hw_s_qpc_e2e_credits_enabled_dump(const struct connectx4lx_hw_s_qpc_e2e_credits_enabled *ptr_struct, FILE* file);
/* hw_s_qpc_sx_heartbeat */
void connectx4lx_hw_s_qpc_sx_heartbeat_pack(const struct connectx4lx_hw_s_qpc_sx_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_heartbeat_unpack(struct connectx4lx_hw_s_qpc_sx_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_heartbeat_print(const struct connectx4lx_hw_s_qpc_sx_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_sx_heartbeat_size(void);
#define CONNECTX4LX_HW_S_QPC_SX_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_sx_heartbeat_dump(const struct connectx4lx_hw_s_qpc_sx_heartbeat *ptr_struct, FILE* file);
/* hw_s_qpc_max_read_atomic */
void connectx4lx_hw_s_qpc_max_read_atomic_pack(const struct connectx4lx_hw_s_qpc_max_read_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_max_read_atomic_unpack(struct connectx4lx_hw_s_qpc_max_read_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_max_read_atomic_print(const struct connectx4lx_hw_s_qpc_max_read_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_max_read_atomic_size(void);
#define CONNECTX4LX_HW_S_QPC_MAX_READ_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_s_qpc_max_read_atomic_dump(const struct connectx4lx_hw_s_qpc_max_read_atomic *ptr_struct, FILE* file);
/* hw_s_qpc_psn_wraparound */
void connectx4lx_hw_s_qpc_psn_wraparound_pack(const struct connectx4lx_hw_s_qpc_psn_wraparound *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_psn_wraparound_unpack(struct connectx4lx_hw_s_qpc_psn_wraparound *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_psn_wraparound_print(const struct connectx4lx_hw_s_qpc_psn_wraparound *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_psn_wraparound_size(void);
#define CONNECTX4LX_HW_S_QPC_PSN_WRAPAROUND_SIZE    (0x40)
void connectx4lx_hw_s_qpc_psn_wraparound_dump(const struct connectx4lx_hw_s_qpc_psn_wraparound *ptr_struct, FILE* file);
/* hw_s_qpc_uncompleted_non_wire_wqe */
void connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe_pack(const struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe_unpack(struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe_print(const struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe_size(void);
#define CONNECTX4LX_HW_S_QPC_UNCOMPLETED_NON_WIRE_WQE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe_dump(const struct connectx4lx_hw_s_qpc_uncompleted_non_wire_wqe *ptr_struct, FILE* file);
/* hw_s_qpc_dc_full_handshake */
void connectx4lx_hw_s_qpc_dc_full_handshake_pack(const struct connectx4lx_hw_s_qpc_dc_full_handshake *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_full_handshake_unpack(struct connectx4lx_hw_s_qpc_dc_full_handshake *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_full_handshake_print(const struct connectx4lx_hw_s_qpc_dc_full_handshake *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_dc_full_handshake_size(void);
#define CONNECTX4LX_HW_S_QPC_DC_FULL_HANDSHAKE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dc_full_handshake_dump(const struct connectx4lx_hw_s_qpc_dc_full_handshake *ptr_struct, FILE* file);
/* hw_s_qpc_ldb_prefetch_size */
void connectx4lx_hw_s_qpc_ldb_prefetch_size_pack(const struct connectx4lx_hw_s_qpc_ldb_prefetch_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ldb_prefetch_size_unpack(struct connectx4lx_hw_s_qpc_ldb_prefetch_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ldb_prefetch_size_print(const struct connectx4lx_hw_s_qpc_ldb_prefetch_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ldb_prefetch_size_size(void);
#define CONNECTX4LX_HW_S_QPC_LDB_PREFETCH_SIZE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ldb_prefetch_size_dump(const struct connectx4lx_hw_s_qpc_ldb_prefetch_size *ptr_struct, FILE* file);
/* hw_s_qpc_timer_enable */
void connectx4lx_hw_s_qpc_timer_enable_pack(const struct connectx4lx_hw_s_qpc_timer_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_timer_enable_unpack(struct connectx4lx_hw_s_qpc_timer_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_timer_enable_print(const struct connectx4lx_hw_s_qpc_timer_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_timer_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_TIMER_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_timer_enable_dump(const struct connectx4lx_hw_s_qpc_timer_enable *ptr_struct, FILE* file);
/* hw_s_qpc_frwr_enable */
void connectx4lx_hw_s_qpc_frwr_enable_pack(const struct connectx4lx_hw_s_qpc_frwr_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_frwr_enable_unpack(struct connectx4lx_hw_s_qpc_frwr_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_frwr_enable_print(const struct connectx4lx_hw_s_qpc_frwr_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_frwr_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_FRWR_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_frwr_enable_dump(const struct connectx4lx_hw_s_qpc_frwr_enable *ptr_struct, FILE* file);
/* hw_s_qpc_wqe_index_check_enable */
void connectx4lx_hw_s_qpc_wqe_index_check_enable_pack(const struct connectx4lx_hw_s_qpc_wqe_index_check_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_wqe_index_check_enable_unpack(struct connectx4lx_hw_s_qpc_wqe_index_check_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_wqe_index_check_enable_print(const struct connectx4lx_hw_s_qpc_wqe_index_check_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_wqe_index_check_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_WQE_INDEX_CHECK_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_wqe_index_check_enable_dump(const struct connectx4lx_hw_s_qpc_wqe_index_check_enable *ptr_struct, FILE* file);
/* hw_s_qpc_sx_steering_root */
void connectx4lx_hw_s_qpc_sx_steering_root_pack(const struct connectx4lx_hw_s_qpc_sx_steering_root *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_steering_root_unpack(struct connectx4lx_hw_s_qpc_sx_steering_root *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_steering_root_print(const struct connectx4lx_hw_s_qpc_sx_steering_root *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_sx_steering_root_size(void);
#define CONNECTX4LX_HW_S_QPC_SX_STEERING_ROOT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_sx_steering_root_dump(const struct connectx4lx_hw_s_qpc_sx_steering_root *ptr_struct, FILE* file);
/* hw_s_qpc_dc_state */
void connectx4lx_hw_s_qpc_dc_state_pack(const struct connectx4lx_hw_s_qpc_dc_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_state_unpack(struct connectx4lx_hw_s_qpc_dc_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_state_print(const struct connectx4lx_hw_s_qpc_dc_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_dc_state_size(void);
#define CONNECTX4LX_HW_S_QPC_DC_STATE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dc_state_dump(const struct connectx4lx_hw_s_qpc_dc_state *ptr_struct, FILE* file);
/* hw_s_qpc_limited_qp */
void connectx4lx_hw_s_qpc_limited_qp_pack(const struct connectx4lx_hw_s_qpc_limited_qp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_limited_qp_unpack(struct connectx4lx_hw_s_qpc_limited_qp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_limited_qp_print(const struct connectx4lx_hw_s_qpc_limited_qp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_limited_qp_size(void);
#define CONNECTX4LX_HW_S_QPC_LIMITED_QP_SIZE    (0x40)
void connectx4lx_hw_s_qpc_limited_qp_dump(const struct connectx4lx_hw_s_qpc_limited_qp *ptr_struct, FILE* file);
/* hw_s_qpc_umr_enable */
void connectx4lx_hw_s_qpc_umr_enable_pack(const struct connectx4lx_hw_s_qpc_umr_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_umr_enable_unpack(struct connectx4lx_hw_s_qpc_umr_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_umr_enable_print(const struct connectx4lx_hw_s_qpc_umr_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_umr_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_UMR_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_umr_enable_dump(const struct connectx4lx_hw_s_qpc_umr_enable *ptr_struct, FILE* file);
/* hw_s_qpc_sx_wq_fetch_limit */
void connectx4lx_hw_s_qpc_sx_wq_fetch_limit_pack(const struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_wq_fetch_limit_unpack(struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_wq_fetch_limit_print(const struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_sx_wq_fetch_limit_size(void);
#define CONNECTX4LX_HW_S_QPC_SX_WQ_FETCH_LIMIT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_sx_wq_fetch_limit_dump(const struct connectx4lx_hw_s_qpc_sx_wq_fetch_limit *ptr_struct, FILE* file);
/* hw_s_qpc_allow_grh_type */
void connectx4lx_hw_s_qpc_allow_grh_type_pack(const struct connectx4lx_hw_s_qpc_allow_grh_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_allow_grh_type_unpack(struct connectx4lx_hw_s_qpc_allow_grh_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_allow_grh_type_print(const struct connectx4lx_hw_s_qpc_allow_grh_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_allow_grh_type_size(void);
#define CONNECTX4LX_HW_S_QPC_ALLOW_GRH_TYPE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_allow_grh_type_dump(const struct connectx4lx_hw_s_qpc_allow_grh_type *ptr_struct, FILE* file);
/* hw_s_qpc_allow_roce_type */
void connectx4lx_hw_s_qpc_allow_roce_type_pack(const struct connectx4lx_hw_s_qpc_allow_roce_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_allow_roce_type_unpack(struct connectx4lx_hw_s_qpc_allow_roce_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_allow_roce_type_print(const struct connectx4lx_hw_s_qpc_allow_roce_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_allow_roce_type_size(void);
#define CONNECTX4LX_HW_S_QPC_ALLOW_ROCE_TYPE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_allow_roce_type_dump(const struct connectx4lx_hw_s_qpc_allow_roce_type *ptr_struct, FILE* file);
/* hw_s_qpc_oldest_non_acked_psn */
void connectx4lx_hw_s_qpc_oldest_non_acked_psn_pack(const struct connectx4lx_hw_s_qpc_oldest_non_acked_psn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_oldest_non_acked_psn_unpack(struct connectx4lx_hw_s_qpc_oldest_non_acked_psn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_oldest_non_acked_psn_print(const struct connectx4lx_hw_s_qpc_oldest_non_acked_psn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_oldest_non_acked_psn_size(void);
#define CONNECTX4LX_HW_S_QPC_OLDEST_NON_ACKED_PSN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_oldest_non_acked_psn_dump(const struct connectx4lx_hw_s_qpc_oldest_non_acked_psn *ptr_struct, FILE* file);
/* hw_s_qpc_inline_scatter */
void connectx4lx_hw_s_qpc_inline_scatter_pack(const struct connectx4lx_hw_s_qpc_inline_scatter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_inline_scatter_unpack(struct connectx4lx_hw_s_qpc_inline_scatter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_inline_scatter_print(const struct connectx4lx_hw_s_qpc_inline_scatter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_inline_scatter_size(void);
#define CONNECTX4LX_HW_S_QPC_INLINE_SCATTER_SIZE    (0x40)
void connectx4lx_hw_s_qpc_inline_scatter_dump(const struct connectx4lx_hw_s_qpc_inline_scatter *ptr_struct, FILE* file);
/* hw_s_qpc_connection_state */
void connectx4lx_hw_s_qpc_connection_state_pack(const struct connectx4lx_hw_s_qpc_connection_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_connection_state_unpack(struct connectx4lx_hw_s_qpc_connection_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_connection_state_print(const struct connectx4lx_hw_s_qpc_connection_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_connection_state_size(void);
#define CONNECTX4LX_HW_S_QPC_CONNECTION_STATE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_connection_state_dump(const struct connectx4lx_hw_s_qpc_connection_state *ptr_struct, FILE* file);
/* hw_s_qpc_ack_req_frequency */
void connectx4lx_hw_s_qpc_ack_req_frequency_pack(const struct connectx4lx_hw_s_qpc_ack_req_frequency *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ack_req_frequency_unpack(struct connectx4lx_hw_s_qpc_ack_req_frequency *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ack_req_frequency_print(const struct connectx4lx_hw_s_qpc_ack_req_frequency *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ack_req_frequency_size(void);
#define CONNECTX4LX_HW_S_QPC_ACK_REQ_FREQUENCY_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ack_req_frequency_dump(const struct connectx4lx_hw_s_qpc_ack_req_frequency *ptr_struct, FILE* file);
/* hw_s_qpc_mtu_byte */
void connectx4lx_hw_s_qpc_mtu_byte_pack(const struct connectx4lx_hw_s_qpc_mtu_byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_mtu_byte_unpack(struct connectx4lx_hw_s_qpc_mtu_byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_mtu_byte_print(const struct connectx4lx_hw_s_qpc_mtu_byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_mtu_byte_size(void);
#define CONNECTX4LX_HW_S_QPC_MTU_BYTE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_mtu_byte_dump(const struct connectx4lx_hw_s_qpc_mtu_byte *ptr_struct, FILE* file);
/* hw_s_qpc_ssn */
void connectx4lx_hw_s_qpc_ssn_pack(const struct connectx4lx_hw_s_qpc_ssn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ssn_unpack(struct connectx4lx_hw_s_qpc_ssn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ssn_print(const struct connectx4lx_hw_s_qpc_ssn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ssn_size(void);
#define CONNECTX4LX_HW_S_QPC_SSN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ssn_dump(const struct connectx4lx_hw_s_qpc_ssn *ptr_struct, FILE* file);
/* hw_s_qpc_force_grh_tclass */
void connectx4lx_hw_s_qpc_force_grh_tclass_pack(const struct connectx4lx_hw_s_qpc_force_grh_tclass *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_grh_tclass_unpack(struct connectx4lx_hw_s_qpc_force_grh_tclass *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_grh_tclass_print(const struct connectx4lx_hw_s_qpc_force_grh_tclass *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_grh_tclass_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_GRH_TCLASS_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_grh_tclass_dump(const struct connectx4lx_hw_s_qpc_force_grh_tclass *ptr_struct, FILE* file);
/* hw_s_qpc_force_sl */
void connectx4lx_hw_s_qpc_force_sl_pack(const struct connectx4lx_hw_s_qpc_force_sl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_sl_unpack(struct connectx4lx_hw_s_qpc_force_sl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_sl_print(const struct connectx4lx_hw_s_qpc_force_sl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_sl_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_SL_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_sl_dump(const struct connectx4lx_hw_s_qpc_force_sl *ptr_struct, FILE* file);
/* hw_s_qpc_currently_completing_ds */
void connectx4lx_hw_s_qpc_currently_completing_ds_pack(const struct connectx4lx_hw_s_qpc_currently_completing_ds *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_currently_completing_ds_unpack(struct connectx4lx_hw_s_qpc_currently_completing_ds *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_currently_completing_ds_print(const struct connectx4lx_hw_s_qpc_currently_completing_ds *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_currently_completing_ds_size(void);
#define CONNECTX4LX_HW_S_QPC_CURRENTLY_COMPLETING_DS_SIZE    (0x40)
void connectx4lx_hw_s_qpc_currently_completing_ds_dump(const struct connectx4lx_hw_s_qpc_currently_completing_ds *ptr_struct, FILE* file);
/* hw_s_qpc_requestor_session_id */
void connectx4lx_hw_s_qpc_requestor_session_id_pack(const struct connectx4lx_hw_s_qpc_requestor_session_id *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_requestor_session_id_unpack(struct connectx4lx_hw_s_qpc_requestor_session_id *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_requestor_session_id_print(const struct connectx4lx_hw_s_qpc_requestor_session_id *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_requestor_session_id_size(void);
#define CONNECTX4LX_HW_S_QPC_REQUESTOR_SESSION_ID_SIZE    (0x40)
void connectx4lx_hw_s_qpc_requestor_session_id_dump(const struct connectx4lx_hw_s_qpc_requestor_session_id *ptr_struct, FILE* file);
/* hw_s_qpc_psn_since_ackreq */
void connectx4lx_hw_s_qpc_psn_since_ackreq_pack(const struct connectx4lx_hw_s_qpc_psn_since_ackreq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_psn_since_ackreq_unpack(struct connectx4lx_hw_s_qpc_psn_since_ackreq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_psn_since_ackreq_print(const struct connectx4lx_hw_s_qpc_psn_since_ackreq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_psn_since_ackreq_size(void);
#define CONNECTX4LX_HW_S_QPC_PSN_SINCE_ACKREQ_SIZE    (0x40)
void connectx4lx_hw_s_qpc_psn_since_ackreq_dump(const struct connectx4lx_hw_s_qpc_psn_since_ackreq *ptr_struct, FILE* file);
/* hw_s_qpc_first_psn_of_message_currently_completing */
void connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing_pack(const struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing_unpack(struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing_print(const struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing_size(void);
#define CONNECTX4LX_HW_S_QPC_FIRST_PSN_OF_MESSAGE_CURRENTLY_COMPLETING_SIZE    (0x40)
void connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing_dump(const struct connectx4lx_hw_s_qpc_first_psn_of_message_currently_completing *ptr_struct, FILE* file);
/* hw_s_qpc_currently_completing_wqe_index */
void connectx4lx_hw_s_qpc_currently_completing_wqe_index_pack(const struct connectx4lx_hw_s_qpc_currently_completing_wqe_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_currently_completing_wqe_index_unpack(struct connectx4lx_hw_s_qpc_currently_completing_wqe_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_currently_completing_wqe_index_print(const struct connectx4lx_hw_s_qpc_currently_completing_wqe_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_currently_completing_wqe_index_size(void);
#define CONNECTX4LX_HW_S_QPC_CURRENTLY_COMPLETING_WQE_INDEX_SIZE    (0x40)
void connectx4lx_hw_s_qpc_currently_completing_wqe_index_dump(const struct connectx4lx_hw_s_qpc_currently_completing_wqe_index *ptr_struct, FILE* file);
/* hw_s_qpc_swqe_consumer_index */
void connectx4lx_hw_s_qpc_swqe_consumer_index_pack(const struct connectx4lx_hw_s_qpc_swqe_consumer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_swqe_consumer_index_unpack(struct connectx4lx_hw_s_qpc_swqe_consumer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_swqe_consumer_index_print(const struct connectx4lx_hw_s_qpc_swqe_consumer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_swqe_consumer_index_size(void);
#define CONNECTX4LX_HW_S_QPC_SWQE_CONSUMER_INDEX_SIZE    (0x40)
void connectx4lx_hw_s_qpc_swqe_consumer_index_dump(const struct connectx4lx_hw_s_qpc_swqe_consumer_index *ptr_struct, FILE* file);
/* hw_s_qpc_number_outstanding_reads */
void connectx4lx_hw_s_qpc_number_outstanding_reads_pack(const struct connectx4lx_hw_s_qpc_number_outstanding_reads *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_number_outstanding_reads_unpack(struct connectx4lx_hw_s_qpc_number_outstanding_reads *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_number_outstanding_reads_print(const struct connectx4lx_hw_s_qpc_number_outstanding_reads *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_number_outstanding_reads_size(void);
#define CONNECTX4LX_HW_S_QPC_NUMBER_OUTSTANDING_READS_SIZE    (0x40)
void connectx4lx_hw_s_qpc_number_outstanding_reads_dump(const struct connectx4lx_hw_s_qpc_number_outstanding_reads *ptr_struct, FILE* file);
/* hw_s_qpc_force_my_gid_mac_index */
void connectx4lx_hw_s_qpc_force_my_gid_mac_index_pack(const struct connectx4lx_hw_s_qpc_force_my_gid_mac_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_my_gid_mac_index_unpack(struct connectx4lx_hw_s_qpc_force_my_gid_mac_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_my_gid_mac_index_print(const struct connectx4lx_hw_s_qpc_force_my_gid_mac_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_my_gid_mac_index_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_MY_GID_MAC_INDEX_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_my_gid_mac_index_dump(const struct connectx4lx_hw_s_qpc_force_my_gid_mac_index *ptr_struct, FILE* file);
/* hw_s_qpc_sx_gather_commit */
void connectx4lx_hw_s_qpc_sx_gather_commit_pack(const struct connectx4lx_hw_s_qpc_sx_gather_commit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_gather_commit_unpack(struct connectx4lx_hw_s_qpc_sx_gather_commit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_gather_commit_print(const struct connectx4lx_hw_s_qpc_sx_gather_commit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_sx_gather_commit_size(void);
#define CONNECTX4LX_HW_S_QPC_SX_GATHER_COMMIT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_sx_gather_commit_dump(const struct connectx4lx_hw_s_qpc_sx_gather_commit *ptr_struct, FILE* file);
/* hw_s_qpc_ts */
void connectx4lx_hw_s_qpc_ts_pack(const struct connectx4lx_hw_s_qpc_ts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ts_unpack(struct connectx4lx_hw_s_qpc_ts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ts_print(const struct connectx4lx_hw_s_qpc_ts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ts_size(void);
#define CONNECTX4LX_HW_S_QPC_TS_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ts_dump(const struct connectx4lx_hw_s_qpc_ts *ptr_struct, FILE* file);
/* hw_s_qpc_extended_atomic */
void connectx4lx_hw_s_qpc_extended_atomic_pack(const struct connectx4lx_hw_s_qpc_extended_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_extended_atomic_unpack(struct connectx4lx_hw_s_qpc_extended_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_extended_atomic_print(const struct connectx4lx_hw_s_qpc_extended_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_extended_atomic_size(void);
#define CONNECTX4LX_HW_S_QPC_EXTENDED_ATOMIC_SIZE    (0x40)
void connectx4lx_hw_s_qpc_extended_atomic_dump(const struct connectx4lx_hw_s_qpc_extended_atomic *ptr_struct, FILE* file);
/* hw_s_qpc_cntag_enable */
void connectx4lx_hw_s_qpc_cntag_enable_pack(const struct connectx4lx_hw_s_qpc_cntag_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cntag_enable_unpack(struct connectx4lx_hw_s_qpc_cntag_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cntag_enable_print(const struct connectx4lx_hw_s_qpc_cntag_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_cntag_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_CNTAG_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_cntag_enable_dump(const struct connectx4lx_hw_s_qpc_cntag_enable *ptr_struct, FILE* file);
/* hw_s_qpc_cntag_flowid */
void connectx4lx_hw_s_qpc_cntag_flowid_pack(const struct connectx4lx_hw_s_qpc_cntag_flowid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cntag_flowid_unpack(struct connectx4lx_hw_s_qpc_cntag_flowid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cntag_flowid_print(const struct connectx4lx_hw_s_qpc_cntag_flowid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_cntag_flowid_size(void);
#define CONNECTX4LX_HW_S_QPC_CNTAG_FLOWID_SIZE    (0x40)
void connectx4lx_hw_s_qpc_cntag_flowid_dump(const struct connectx4lx_hw_s_qpc_cntag_flowid *ptr_struct, FILE* file);
/* hw_s_qpc_umr_permission_select */
void connectx4lx_hw_s_qpc_umr_permission_select_pack(const struct connectx4lx_hw_s_qpc_umr_permission_select *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_umr_permission_select_unpack(struct connectx4lx_hw_s_qpc_umr_permission_select *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_umr_permission_select_print(const struct connectx4lx_hw_s_qpc_umr_permission_select *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_umr_permission_select_size(void);
#define CONNECTX4LX_HW_S_QPC_UMR_PERMISSION_SELECT_SIZE    (0x40)
void connectx4lx_hw_s_qpc_umr_permission_select_dump(const struct connectx4lx_hw_s_qpc_umr_permission_select *ptr_struct, FILE* file);
/* hw_s_qpc_ecn */
void connectx4lx_hw_s_qpc_ecn_pack(const struct connectx4lx_hw_s_qpc_ecn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ecn_unpack(struct connectx4lx_hw_s_qpc_ecn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_ecn_print(const struct connectx4lx_hw_s_qpc_ecn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_ecn_size(void);
#define CONNECTX4LX_HW_S_QPC_ECN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_ecn_dump(const struct connectx4lx_hw_s_qpc_ecn *ptr_struct, FILE* file);
/* hw_s_qpc_force_ecn */
void connectx4lx_hw_s_qpc_force_ecn_pack(const struct connectx4lx_hw_s_qpc_force_ecn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_ecn_unpack(struct connectx4lx_hw_s_qpc_force_ecn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_ecn_print(const struct connectx4lx_hw_s_qpc_force_ecn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_ecn_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_ECN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_ecn_dump(const struct connectx4lx_hw_s_qpc_force_ecn *ptr_struct, FILE* file);
/* hw_s_qpc_force_dscp */
void connectx4lx_hw_s_qpc_force_dscp_pack(const struct connectx4lx_hw_s_qpc_force_dscp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_dscp_unpack(struct connectx4lx_hw_s_qpc_force_dscp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_dscp_print(const struct connectx4lx_hw_s_qpc_force_dscp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_dscp_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_DSCP_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_dscp_dump(const struct connectx4lx_hw_s_qpc_force_dscp *ptr_struct, FILE* file);
/* hw_s_qpc_next_to_send_psn */
void connectx4lx_hw_s_qpc_next_to_send_psn_pack(const struct connectx4lx_hw_s_qpc_next_to_send_psn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_next_to_send_psn_unpack(struct connectx4lx_hw_s_qpc_next_to_send_psn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_next_to_send_psn_print(const struct connectx4lx_hw_s_qpc_next_to_send_psn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_next_to_send_psn_size(void);
#define CONNECTX4LX_HW_S_QPC_NEXT_TO_SEND_PSN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_next_to_send_psn_dump(const struct connectx4lx_hw_s_qpc_next_to_send_psn *ptr_struct, FILE* file);
/* hw_s_qpc_counter_index */
void connectx4lx_hw_s_qpc_counter_index_pack(const struct connectx4lx_hw_s_qpc_counter_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_counter_index_unpack(struct connectx4lx_hw_s_qpc_counter_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_counter_index_print(const struct connectx4lx_hw_s_qpc_counter_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_counter_index_size(void);
#define CONNECTX4LX_HW_S_QPC_COUNTER_INDEX_SIZE    (0x40)
void connectx4lx_hw_s_qpc_counter_index_dump(const struct connectx4lx_hw_s_qpc_counter_index *ptr_struct, FILE* file);
/* hw_s_qpc_cq_number */
void connectx4lx_hw_s_qpc_cq_number_pack(const struct connectx4lx_hw_s_qpc_cq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cq_number_unpack(struct connectx4lx_hw_s_qpc_cq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_cq_number_print(const struct connectx4lx_hw_s_qpc_cq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_cq_number_size(void);
#define CONNECTX4LX_HW_S_QPC_CQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_s_qpc_cq_number_dump(const struct connectx4lx_hw_s_qpc_cq_number *ptr_struct, FILE* file);
/* hw_s_qpc_dscp */
void connectx4lx_hw_s_qpc_dscp_pack(const struct connectx4lx_hw_s_qpc_dscp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dscp_unpack(struct connectx4lx_hw_s_qpc_dscp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dscp_print(const struct connectx4lx_hw_s_qpc_dscp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_dscp_size(void);
#define CONNECTX4LX_HW_S_QPC_DSCP_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dscp_dump(const struct connectx4lx_hw_s_qpc_dscp *ptr_struct, FILE* file);
/* hw_s_qpc_packet_count_in_message */
void connectx4lx_hw_s_qpc_packet_count_in_message_pack(const struct connectx4lx_hw_s_qpc_packet_count_in_message *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_packet_count_in_message_unpack(struct connectx4lx_hw_s_qpc_packet_count_in_message *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_packet_count_in_message_print(const struct connectx4lx_hw_s_qpc_packet_count_in_message *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_packet_count_in_message_size(void);
#define CONNECTX4LX_HW_S_QPC_PACKET_COUNT_IN_MESSAGE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_packet_count_in_message_dump(const struct connectx4lx_hw_s_qpc_packet_count_in_message *ptr_struct, FILE* file);
/* hw_s_qpc_sx_ethertype_check_enable */
void connectx4lx_hw_s_qpc_sx_ethertype_check_enable_pack(const struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_ethertype_check_enable_unpack(struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_sx_ethertype_check_enable_print(const struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_sx_ethertype_check_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_SX_ETHERTYPE_CHECK_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_sx_ethertype_check_enable_dump(const struct connectx4lx_hw_s_qpc_sx_ethertype_check_enable *ptr_struct, FILE* file);
/* hw_s_qpc_packet_allowed */
void connectx4lx_hw_s_qpc_packet_allowed_pack(const struct connectx4lx_hw_s_qpc_packet_allowed *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_packet_allowed_unpack(struct connectx4lx_hw_s_qpc_packet_allowed *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_packet_allowed_print(const struct connectx4lx_hw_s_qpc_packet_allowed *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_packet_allowed_size(void);
#define CONNECTX4LX_HW_S_QPC_PACKET_ALLOWED_SIZE    (0x40)
void connectx4lx_hw_s_qpc_packet_allowed_dump(const struct connectx4lx_hw_s_qpc_packet_allowed *ptr_struct, FILE* file);
/* hw_s_qpc_force_cvlan */
void connectx4lx_hw_s_qpc_force_cvlan_pack(const struct connectx4lx_hw_s_qpc_force_cvlan *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_cvlan_unpack(struct connectx4lx_hw_s_qpc_force_cvlan *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_cvlan_print(const struct connectx4lx_hw_s_qpc_force_cvlan *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_cvlan_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_CVLAN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_cvlan_dump(const struct connectx4lx_hw_s_qpc_force_cvlan *ptr_struct, FILE* file);
/* hw_s_qpc_force_my_mac */
void connectx4lx_hw_s_qpc_force_my_mac_pack(const struct connectx4lx_hw_s_qpc_force_my_mac *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_my_mac_unpack(struct connectx4lx_hw_s_qpc_force_my_mac *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_force_my_mac_print(const struct connectx4lx_hw_s_qpc_force_my_mac *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_force_my_mac_size(void);
#define CONNECTX4LX_HW_S_QPC_FORCE_MY_MAC_SIZE    (0x40)
void connectx4lx_hw_s_qpc_force_my_mac_dump(const struct connectx4lx_hw_s_qpc_force_my_mac *ptr_struct, FILE* file);
/* hw_s_qpc_software_parse_enable */
void connectx4lx_hw_s_qpc_software_parse_enable_pack(const struct connectx4lx_hw_s_qpc_software_parse_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_software_parse_enable_unpack(struct connectx4lx_hw_s_qpc_software_parse_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_software_parse_enable_print(const struct connectx4lx_hw_s_qpc_software_parse_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_software_parse_enable_size(void);
#define CONNECTX4LX_HW_S_QPC_SOFTWARE_PARSE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_s_qpc_software_parse_enable_dump(const struct connectx4lx_hw_s_qpc_software_parse_enable *ptr_struct, FILE* file);
/* hw_s_qpc_wqe_mandatory_header */
void connectx4lx_hw_s_qpc_wqe_mandatory_header_pack(const struct connectx4lx_hw_s_qpc_wqe_mandatory_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_wqe_mandatory_header_unpack(struct connectx4lx_hw_s_qpc_wqe_mandatory_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_wqe_mandatory_header_print(const struct connectx4lx_hw_s_qpc_wqe_mandatory_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_wqe_mandatory_header_size(void);
#define CONNECTX4LX_HW_S_QPC_WQE_MANDATORY_HEADER_SIZE    (0x40)
void connectx4lx_hw_s_qpc_wqe_mandatory_header_dump(const struct connectx4lx_hw_s_qpc_wqe_mandatory_header *ptr_struct, FILE* file);
/* hw_s_qpc_vl15 */
void connectx4lx_hw_s_qpc_vl15_pack(const struct connectx4lx_hw_s_qpc_vl15 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_vl15_unpack(struct connectx4lx_hw_s_qpc_vl15 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_vl15_print(const struct connectx4lx_hw_s_qpc_vl15 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_vl15_size(void);
#define CONNECTX4LX_HW_S_QPC_VL15_SIZE    (0x40)
void connectx4lx_hw_s_qpc_vl15_dump(const struct connectx4lx_hw_s_qpc_vl15 *ptr_struct, FILE* file);
/* hw_s_qpc_deth_sqpn */
void connectx4lx_hw_s_qpc_deth_sqpn_pack(const struct connectx4lx_hw_s_qpc_deth_sqpn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_deth_sqpn_unpack(struct connectx4lx_hw_s_qpc_deth_sqpn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_deth_sqpn_print(const struct connectx4lx_hw_s_qpc_deth_sqpn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_deth_sqpn_size(void);
#define CONNECTX4LX_HW_S_QPC_DETH_SQPN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_deth_sqpn_dump(const struct connectx4lx_hw_s_qpc_deth_sqpn *ptr_struct, FILE* file);
/* hw_s_qpc_lsn */
void connectx4lx_hw_s_qpc_lsn_pack(const struct connectx4lx_hw_s_qpc_lsn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_lsn_unpack(struct connectx4lx_hw_s_qpc_lsn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_lsn_print(const struct connectx4lx_hw_s_qpc_lsn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_lsn_size(void);
#define CONNECTX4LX_HW_S_QPC_LSN_SIZE    (0x40)
void connectx4lx_hw_s_qpc_lsn_dump(const struct connectx4lx_hw_s_qpc_lsn *ptr_struct, FILE* file);
/* hw_s_qpc_dc_access_key_63_32 */
void connectx4lx_hw_s_qpc_dc_access_key_63_32_pack(const struct connectx4lx_hw_s_qpc_dc_access_key_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_access_key_63_32_unpack(struct connectx4lx_hw_s_qpc_dc_access_key_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_access_key_63_32_print(const struct connectx4lx_hw_s_qpc_dc_access_key_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_dc_access_key_63_32_size(void);
#define CONNECTX4LX_HW_S_QPC_DC_ACCESS_KEY_63_32_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dc_access_key_63_32_dump(const struct connectx4lx_hw_s_qpc_dc_access_key_63_32 *ptr_struct, FILE* file);
/* hw_s_qpc_dc_access_key_31_0 */
void connectx4lx_hw_s_qpc_dc_access_key_31_0_pack(const struct connectx4lx_hw_s_qpc_dc_access_key_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_access_key_31_0_unpack(struct connectx4lx_hw_s_qpc_dc_access_key_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_dc_access_key_31_0_print(const struct connectx4lx_hw_s_qpc_dc_access_key_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_dc_access_key_31_0_size(void);
#define CONNECTX4LX_HW_S_QPC_DC_ACCESS_KEY_31_0_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dc_access_key_31_0_dump(const struct connectx4lx_hw_s_qpc_dc_access_key_31_0 *ptr_struct, FILE* file);
/* hw_c_qpc_common_valid */
void connectx4lx_hw_c_qpc_common_valid_pack(const struct connectx4lx_hw_c_qpc_common_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_common_valid_unpack(struct connectx4lx_hw_c_qpc_common_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_common_valid_print(const struct connectx4lx_hw_c_qpc_common_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_common_valid_size(void);
#define CONNECTX4LX_HW_C_QPC_COMMON_VALID_SIZE    (0x40)
void connectx4lx_hw_c_qpc_common_valid_dump(const struct connectx4lx_hw_c_qpc_common_valid *ptr_struct, FILE* file);
/* hw_c_qpc_udp_source_port */
void connectx4lx_hw_c_qpc_udp_source_port_pack(const struct connectx4lx_hw_c_qpc_udp_source_port *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_udp_source_port_unpack(struct connectx4lx_hw_c_qpc_udp_source_port *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_udp_source_port_print(const struct connectx4lx_hw_c_qpc_udp_source_port *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_udp_source_port_size(void);
#define CONNECTX4LX_HW_C_QPC_UDP_SOURCE_PORT_SIZE    (0x40)
void connectx4lx_hw_c_qpc_udp_source_port_dump(const struct connectx4lx_hw_c_qpc_udp_source_port *ptr_struct, FILE* file);
/* hw_c_qpc_cqe_tip_source */
void connectx4lx_hw_c_qpc_cqe_tip_source_pack(const struct connectx4lx_hw_c_qpc_cqe_tip_source *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_cqe_tip_source_unpack(struct connectx4lx_hw_c_qpc_cqe_tip_source *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_cqe_tip_source_print(const struct connectx4lx_hw_c_qpc_cqe_tip_source *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_cqe_tip_source_size(void);
#define CONNECTX4LX_HW_C_QPC_CQE_TIP_SOURCE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_cqe_tip_source_dump(const struct connectx4lx_hw_c_qpc_cqe_tip_source *ptr_struct, FILE* file);
/* hw_c_qpc_dual_write */
void connectx4lx_hw_c_qpc_dual_write_pack(const struct connectx4lx_hw_c_qpc_dual_write *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_dual_write_unpack(struct connectx4lx_hw_c_qpc_dual_write *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_dual_write_print(const struct connectx4lx_hw_c_qpc_dual_write *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_dual_write_size(void);
#define CONNECTX4LX_HW_C_QPC_DUAL_WRITE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_dual_write_dump(const struct connectx4lx_hw_c_qpc_dual_write *ptr_struct, FILE* file);
/* hw_c_qpc_force_loopback */
void connectx4lx_hw_c_qpc_force_loopback_pack(const struct connectx4lx_hw_c_qpc_force_loopback *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_loopback_unpack(struct connectx4lx_hw_c_qpc_force_loopback *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_loopback_print(const struct connectx4lx_hw_c_qpc_force_loopback *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_force_loopback_size(void);
#define CONNECTX4LX_HW_C_QPC_FORCE_LOOPBACK_SIZE    (0x40)
void connectx4lx_hw_c_qpc_force_loopback_dump(const struct connectx4lx_hw_c_qpc_force_loopback *ptr_struct, FILE* file);
/* hw_c_qpc_rx_migreq */
void connectx4lx_hw_c_qpc_rx_migreq_pack(const struct connectx4lx_hw_c_qpc_rx_migreq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rx_migreq_unpack(struct connectx4lx_hw_c_qpc_rx_migreq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rx_migreq_print(const struct connectx4lx_hw_c_qpc_rx_migreq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_rx_migreq_size(void);
#define CONNECTX4LX_HW_C_QPC_RX_MIGREQ_SIZE    (0x40)
void connectx4lx_hw_c_qpc_rx_migreq_dump(const struct connectx4lx_hw_c_qpc_rx_migreq *ptr_struct, FILE* file);
/* hw_c_qpc_sx_migreq */
void connectx4lx_hw_c_qpc_sx_migreq_pack(const struct connectx4lx_hw_c_qpc_sx_migreq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_sx_migreq_unpack(struct connectx4lx_hw_c_qpc_sx_migreq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_sx_migreq_print(const struct connectx4lx_hw_c_qpc_sx_migreq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_sx_migreq_size(void);
#define CONNECTX4LX_HW_C_QPC_SX_MIGREQ_SIZE    (0x40)
void connectx4lx_hw_c_qpc_sx_migreq_dump(const struct connectx4lx_hw_c_qpc_sx_migreq *ptr_struct, FILE* file);
/* hw_c_qpc_max_message_size */
void connectx4lx_hw_c_qpc_max_message_size_pack(const struct connectx4lx_hw_c_qpc_max_message_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_max_message_size_unpack(struct connectx4lx_hw_c_qpc_max_message_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_max_message_size_print(const struct connectx4lx_hw_c_qpc_max_message_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_max_message_size_size(void);
#define CONNECTX4LX_HW_C_QPC_MAX_MESSAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_max_message_size_dump(const struct connectx4lx_hw_c_qpc_max_message_size *ptr_struct, FILE* file);
/* hw_c_qpc_mtu */
void connectx4lx_hw_c_qpc_mtu_pack(const struct connectx4lx_hw_c_qpc_mtu *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtu_unpack(struct connectx4lx_hw_c_qpc_mtu *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtu_print(const struct connectx4lx_hw_c_qpc_mtu *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_mtu_size(void);
#define CONNECTX4LX_HW_C_QPC_MTU_SIZE    (0x40)
void connectx4lx_hw_c_qpc_mtu_dump(const struct connectx4lx_hw_c_qpc_mtu *ptr_struct, FILE* file);
/* hw_c_qpc_link_type_mac */
void connectx4lx_hw_c_qpc_link_type_mac_pack(const struct connectx4lx_hw_c_qpc_link_type_mac *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_link_type_mac_unpack(struct connectx4lx_hw_c_qpc_link_type_mac *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_link_type_mac_print(const struct connectx4lx_hw_c_qpc_link_type_mac *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_link_type_mac_size(void);
#define CONNECTX4LX_HW_C_QPC_LINK_TYPE_MAC_SIZE    (0x40)
void connectx4lx_hw_c_qpc_link_type_mac_dump(const struct connectx4lx_hw_c_qpc_link_type_mac *ptr_struct, FILE* file);
/* hw_c_qpc_rwq_type */
void connectx4lx_hw_c_qpc_rwq_type_pack(const struct connectx4lx_hw_c_qpc_rwq_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwq_type_unpack(struct connectx4lx_hw_c_qpc_rwq_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwq_type_print(const struct connectx4lx_hw_c_qpc_rwq_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_rwq_type_size(void);
#define CONNECTX4LX_HW_C_QPC_RWQ_TYPE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_rwq_type_dump(const struct connectx4lx_hw_c_qpc_rwq_type *ptr_struct, FILE* file);
/* hw_c_qpc_ipd */
void connectx4lx_hw_c_qpc_ipd_pack(const struct connectx4lx_hw_c_qpc_ipd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_ipd_unpack(struct connectx4lx_hw_c_qpc_ipd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_ipd_print(const struct connectx4lx_hw_c_qpc_ipd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_ipd_size(void);
#define CONNECTX4LX_HW_C_QPC_IPD_SIZE    (0x40)
void connectx4lx_hw_c_qpc_ipd_dump(const struct connectx4lx_hw_c_qpc_ipd *ptr_struct, FILE* file);
/* hw_c_qpc_flow_label */
void connectx4lx_hw_c_qpc_flow_label_pack(const struct connectx4lx_hw_c_qpc_flow_label *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_flow_label_unpack(struct connectx4lx_hw_c_qpc_flow_label *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_flow_label_print(const struct connectx4lx_hw_c_qpc_flow_label *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_flow_label_size(void);
#define CONNECTX4LX_HW_C_QPC_FLOW_LABEL_SIZE    (0x40)
void connectx4lx_hw_c_qpc_flow_label_dump(const struct connectx4lx_hw_c_qpc_flow_label *ptr_struct, FILE* file);
/* hw_c_qpc_hop_limit */
void connectx4lx_hw_c_qpc_hop_limit_pack(const struct connectx4lx_hw_c_qpc_hop_limit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_hop_limit_unpack(struct connectx4lx_hw_c_qpc_hop_limit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_hop_limit_print(const struct connectx4lx_hw_c_qpc_hop_limit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_hop_limit_size(void);
#define CONNECTX4LX_HW_C_QPC_HOP_LIMIT_SIZE    (0x40)
void connectx4lx_hw_c_qpc_hop_limit_dump(const struct connectx4lx_hw_c_qpc_hop_limit *ptr_struct, FILE* file);
/* hw_c_qpc_wq_signature */
void connectx4lx_hw_c_qpc_wq_signature_pack(const struct connectx4lx_hw_c_qpc_wq_signature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_wq_signature_unpack(struct connectx4lx_hw_c_qpc_wq_signature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_wq_signature_print(const struct connectx4lx_hw_c_qpc_wq_signature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_wq_signature_size(void);
#define CONNECTX4LX_HW_C_QPC_WQ_SIGNATURE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_wq_signature_dump(const struct connectx4lx_hw_c_qpc_wq_signature *ptr_struct, FILE* file);
/* hw_c_qpc_log_page_size */
void connectx4lx_hw_c_qpc_log_page_size_pack(const struct connectx4lx_hw_c_qpc_log_page_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_log_page_size_unpack(struct connectx4lx_hw_c_qpc_log_page_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_log_page_size_print(const struct connectx4lx_hw_c_qpc_log_page_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_log_page_size_size(void);
#define CONNECTX4LX_HW_C_QPC_LOG_PAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_log_page_size_dump(const struct connectx4lx_hw_c_qpc_log_page_size *ptr_struct, FILE* file);
/* hw_c_qpc_swqe_buffer_size */
void connectx4lx_hw_c_qpc_swqe_buffer_size_pack(const struct connectx4lx_hw_c_qpc_swqe_buffer_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_swqe_buffer_size_unpack(struct connectx4lx_hw_c_qpc_swqe_buffer_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_swqe_buffer_size_print(const struct connectx4lx_hw_c_qpc_swqe_buffer_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_swqe_buffer_size_size(void);
#define CONNECTX4LX_HW_C_QPC_SWQE_BUFFER_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_swqe_buffer_size_dump(const struct connectx4lx_hw_c_qpc_swqe_buffer_size *ptr_struct, FILE* file);
/* hw_c_qpc_force_ipd */
void connectx4lx_hw_c_qpc_force_ipd_pack(const struct connectx4lx_hw_c_qpc_force_ipd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_ipd_unpack(struct connectx4lx_hw_c_qpc_force_ipd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_ipd_print(const struct connectx4lx_hw_c_qpc_force_ipd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_force_ipd_size(void);
#define CONNECTX4LX_HW_C_QPC_FORCE_IPD_SIZE    (0x40)
void connectx4lx_hw_c_qpc_force_ipd_dump(const struct connectx4lx_hw_c_qpc_force_ipd *ptr_struct, FILE* file);
/* hw_c_qpc_adaptive_routing */
void connectx4lx_hw_c_qpc_adaptive_routing_pack(const struct connectx4lx_hw_c_qpc_adaptive_routing *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_adaptive_routing_unpack(struct connectx4lx_hw_c_qpc_adaptive_routing *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_adaptive_routing_print(const struct connectx4lx_hw_c_qpc_adaptive_routing *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_adaptive_routing_size(void);
#define CONNECTX4LX_HW_C_QPC_ADAPTIVE_ROUTING_SIZE    (0x40)
void connectx4lx_hw_c_qpc_adaptive_routing_dump(const struct connectx4lx_hw_c_qpc_adaptive_routing *ptr_struct, FILE* file);
/* hw_c_qpc_rwqe_stride */
void connectx4lx_hw_c_qpc_rwqe_stride_pack(const struct connectx4lx_hw_c_qpc_rwqe_stride *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwqe_stride_unpack(struct connectx4lx_hw_c_qpc_rwqe_stride *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwqe_stride_print(const struct connectx4lx_hw_c_qpc_rwqe_stride *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_rwqe_stride_size(void);
#define CONNECTX4LX_HW_C_QPC_RWQE_STRIDE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_rwqe_stride_dump(const struct connectx4lx_hw_c_qpc_rwqe_stride *ptr_struct, FILE* file);
/* hw_c_qpc_rcyclic_size */
void connectx4lx_hw_c_qpc_rcyclic_size_pack(const struct connectx4lx_hw_c_qpc_rcyclic_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rcyclic_size_unpack(struct connectx4lx_hw_c_qpc_rcyclic_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rcyclic_size_print(const struct connectx4lx_hw_c_qpc_rcyclic_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_rcyclic_size_size(void);
#define CONNECTX4LX_HW_C_QPC_RCYCLIC_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_rcyclic_size_dump(const struct connectx4lx_hw_c_qpc_rcyclic_size *ptr_struct, FILE* file);
/* hw_c_qpc_rwqe_buffer_size */
void connectx4lx_hw_c_qpc_rwqe_buffer_size_pack(const struct connectx4lx_hw_c_qpc_rwqe_buffer_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwqe_buffer_size_unpack(struct connectx4lx_hw_c_qpc_rwqe_buffer_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_rwqe_buffer_size_print(const struct connectx4lx_hw_c_qpc_rwqe_buffer_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_rwqe_buffer_size_size(void);
#define CONNECTX4LX_HW_C_QPC_RWQE_BUFFER_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_rwqe_buffer_size_dump(const struct connectx4lx_hw_c_qpc_rwqe_buffer_size *ptr_struct, FILE* file);
/* hw_c_qpc_peer_qp */
void connectx4lx_hw_c_qpc_peer_qp_pack(const struct connectx4lx_hw_c_qpc_peer_qp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_qp_unpack(struct connectx4lx_hw_c_qpc_peer_qp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_qp_print(const struct connectx4lx_hw_c_qpc_peer_qp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_qp_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_QP_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_qp_dump(const struct connectx4lx_hw_c_qpc_peer_qp *ptr_struct, FILE* file);
/* hw_c_qpc_max_encapsulation_size */
void connectx4lx_hw_c_qpc_max_encapsulation_size_pack(const struct connectx4lx_hw_c_qpc_max_encapsulation_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_max_encapsulation_size_unpack(struct connectx4lx_hw_c_qpc_max_encapsulation_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_max_encapsulation_size_print(const struct connectx4lx_hw_c_qpc_max_encapsulation_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_max_encapsulation_size_size(void);
#define CONNECTX4LX_HW_C_QPC_MAX_ENCAPSULATION_SIZE_SIZE    (0x40)
void connectx4lx_hw_c_qpc_max_encapsulation_size_dump(const struct connectx4lx_hw_c_qpc_max_encapsulation_size *ptr_struct, FILE* file);
/* hw_c_qpc_wqe_page_offset */
void connectx4lx_hw_c_qpc_wqe_page_offset_pack(const struct connectx4lx_hw_c_qpc_wqe_page_offset *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_wqe_page_offset_unpack(struct connectx4lx_hw_c_qpc_wqe_page_offset *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_wqe_page_offset_print(const struct connectx4lx_hw_c_qpc_wqe_page_offset *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_wqe_page_offset_size(void);
#define CONNECTX4LX_HW_C_QPC_WQE_PAGE_OFFSET_SIZE    (0x40)
void connectx4lx_hw_c_qpc_wqe_page_offset_dump(const struct connectx4lx_hw_c_qpc_wqe_page_offset *ptr_struct, FILE* file);
/* hw_c_qpc_cqe_qpn */
void connectx4lx_hw_c_qpc_cqe_qpn_pack(const struct connectx4lx_hw_c_qpc_cqe_qpn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_cqe_qpn_unpack(struct connectx4lx_hw_c_qpc_cqe_qpn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_cqe_qpn_print(const struct connectx4lx_hw_c_qpc_cqe_qpn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_cqe_qpn_size(void);
#define CONNECTX4LX_HW_C_QPC_CQE_QPN_SIZE    (0x40)
void connectx4lx_hw_c_qpc_cqe_qpn_dump(const struct connectx4lx_hw_c_qpc_cqe_qpn *ptr_struct, FILE* file);
/* hw_c_qpc_sl */
void connectx4lx_hw_c_qpc_sl_pack(const struct connectx4lx_hw_c_qpc_sl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_sl_unpack(struct connectx4lx_hw_c_qpc_sl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_sl_print(const struct connectx4lx_hw_c_qpc_sl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_sl_size(void);
#define CONNECTX4LX_HW_C_QPC_SL_SIZE    (0x40)
void connectx4lx_hw_c_qpc_sl_dump(const struct connectx4lx_hw_c_qpc_sl *ptr_struct, FILE* file);
/* hw_c_qpc_pkey_table_index */
void connectx4lx_hw_c_qpc_pkey_table_index_pack(const struct connectx4lx_hw_c_qpc_pkey_table_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_pkey_table_index_unpack(struct connectx4lx_hw_c_qpc_pkey_table_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_pkey_table_index_print(const struct connectx4lx_hw_c_qpc_pkey_table_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_pkey_table_index_size(void);
#define CONNECTX4LX_HW_C_QPC_PKEY_TABLE_INDEX_SIZE    (0x40)
void connectx4lx_hw_c_qpc_pkey_table_index_dump(const struct connectx4lx_hw_c_qpc_pkey_table_index *ptr_struct, FILE* file);
/* hw_c_qpc_grh_bit */
void connectx4lx_hw_c_qpc_grh_bit_pack(const struct connectx4lx_hw_c_qpc_grh_bit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_grh_bit_unpack(struct connectx4lx_hw_c_qpc_grh_bit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_grh_bit_print(const struct connectx4lx_hw_c_qpc_grh_bit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_grh_bit_size(void);
#define CONNECTX4LX_HW_C_QPC_GRH_BIT_SIZE    (0x40)
void connectx4lx_hw_c_qpc_grh_bit_dump(const struct connectx4lx_hw_c_qpc_grh_bit *ptr_struct, FILE* file);
/* hw_c_qpc_force_my_lid */
void connectx4lx_hw_c_qpc_force_my_lid_pack(const struct connectx4lx_hw_c_qpc_force_my_lid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_my_lid_unpack(struct connectx4lx_hw_c_qpc_force_my_lid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_force_my_lid_print(const struct connectx4lx_hw_c_qpc_force_my_lid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_force_my_lid_size(void);
#define CONNECTX4LX_HW_C_QPC_FORCE_MY_LID_SIZE    (0x40)
void connectx4lx_hw_c_qpc_force_my_lid_dump(const struct connectx4lx_hw_c_qpc_force_my_lid *ptr_struct, FILE* file);
/* hw_c_qpc_my_lid */
void connectx4lx_hw_c_qpc_my_lid_pack(const struct connectx4lx_hw_c_qpc_my_lid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_my_lid_unpack(struct connectx4lx_hw_c_qpc_my_lid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_my_lid_print(const struct connectx4lx_hw_c_qpc_my_lid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_my_lid_size(void);
#define CONNECTX4LX_HW_C_QPC_MY_LID_SIZE    (0x40)
void connectx4lx_hw_c_qpc_my_lid_dump(const struct connectx4lx_hw_c_qpc_my_lid *ptr_struct, FILE* file);
/* hw_c_qpc_peer_mac_47_32 */
void connectx4lx_hw_c_qpc_peer_mac_47_32_pack(const struct connectx4lx_hw_c_qpc_peer_mac_47_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_mac_47_32_unpack(struct connectx4lx_hw_c_qpc_peer_mac_47_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_mac_47_32_print(const struct connectx4lx_hw_c_qpc_peer_mac_47_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_mac_47_32_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_MAC_47_32_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_mac_47_32_dump(const struct connectx4lx_hw_c_qpc_peer_mac_47_32 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_mac_31_0 */
void connectx4lx_hw_c_qpc_peer_mac_31_0_pack(const struct connectx4lx_hw_c_qpc_peer_mac_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_mac_31_0_unpack(struct connectx4lx_hw_c_qpc_peer_mac_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_mac_31_0_print(const struct connectx4lx_hw_c_qpc_peer_mac_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_mac_31_0_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_MAC_31_0_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_mac_31_0_dump(const struct connectx4lx_hw_c_qpc_peer_mac_31_0 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_lid */
void connectx4lx_hw_c_qpc_peer_lid_pack(const struct connectx4lx_hw_c_qpc_peer_lid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_lid_unpack(struct connectx4lx_hw_c_qpc_peer_lid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_lid_print(const struct connectx4lx_hw_c_qpc_peer_lid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_lid_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_LID_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_lid_dump(const struct connectx4lx_hw_c_qpc_peer_lid *ptr_struct, FILE* file);
/* hw_c_qpc_port_number */
void connectx4lx_hw_c_qpc_port_number_pack(const struct connectx4lx_hw_c_qpc_port_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_port_number_unpack(struct connectx4lx_hw_c_qpc_port_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_port_number_print(const struct connectx4lx_hw_c_qpc_port_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_port_number_size(void);
#define CONNECTX4LX_HW_C_QPC_PORT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_c_qpc_port_number_dump(const struct connectx4lx_hw_c_qpc_port_number *ptr_struct, FILE* file);
/* hw_c_qpc_vlan_prio */
void connectx4lx_hw_c_qpc_vlan_prio_pack(const struct connectx4lx_hw_c_qpc_vlan_prio *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_vlan_prio_unpack(struct connectx4lx_hw_c_qpc_vlan_prio *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_vlan_prio_print(const struct connectx4lx_hw_c_qpc_vlan_prio *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_vlan_prio_size(void);
#define CONNECTX4LX_HW_C_QPC_VLAN_PRIO_SIZE    (0x40)
void connectx4lx_hw_c_qpc_vlan_prio_dump(const struct connectx4lx_hw_c_qpc_vlan_prio *ptr_struct, FILE* file);
/* hw_c_qpc_context_number */
void connectx4lx_hw_c_qpc_context_number_pack(const struct connectx4lx_hw_c_qpc_context_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_context_number_unpack(struct connectx4lx_hw_c_qpc_context_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_context_number_print(const struct connectx4lx_hw_c_qpc_context_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_context_number_size(void);
#define CONNECTX4LX_HW_C_QPC_CONTEXT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_c_qpc_context_number_dump(const struct connectx4lx_hw_c_qpc_context_number *ptr_struct, FILE* file);
/* hw_c_qpc_tclass */
void connectx4lx_hw_c_qpc_tclass_pack(const struct connectx4lx_hw_c_qpc_tclass *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_tclass_unpack(struct connectx4lx_hw_c_qpc_tclass *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_tclass_print(const struct connectx4lx_hw_c_qpc_tclass *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_tclass_size(void);
#define CONNECTX4LX_HW_C_QPC_TCLASS_SIZE    (0x40)
void connectx4lx_hw_c_qpc_tclass_dump(const struct connectx4lx_hw_c_qpc_tclass *ptr_struct, FILE* file);
/* hw_c_qpc_pd */
void connectx4lx_hw_c_qpc_pd_pack(const struct connectx4lx_hw_c_qpc_pd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_pd_unpack(struct connectx4lx_hw_c_qpc_pd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_pd_print(const struct connectx4lx_hw_c_qpc_pd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_pd_size(void);
#define CONNECTX4LX_HW_C_QPC_PD_SIZE    (0x40)
void connectx4lx_hw_c_qpc_pd_dump(const struct connectx4lx_hw_c_qpc_pd *ptr_struct, FILE* file);
/* hw_c_qpc_translation_process_index */
void connectx4lx_hw_c_qpc_translation_process_index_pack(const struct connectx4lx_hw_c_qpc_translation_process_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_translation_process_index_unpack(struct connectx4lx_hw_c_qpc_translation_process_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_translation_process_index_print(const struct connectx4lx_hw_c_qpc_translation_process_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_translation_process_index_size(void);
#define CONNECTX4LX_HW_C_QPC_TRANSLATION_PROCESS_INDEX_SIZE    (0x40)
void connectx4lx_hw_c_qpc_translation_process_index_dump(const struct connectx4lx_hw_c_qpc_translation_process_index *ptr_struct, FILE* file);
/* hw_c_qpc_my_gid_mac_index */
void connectx4lx_hw_c_qpc_my_gid_mac_index_pack(const struct connectx4lx_hw_c_qpc_my_gid_mac_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_my_gid_mac_index_unpack(struct connectx4lx_hw_c_qpc_my_gid_mac_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_my_gid_mac_index_print(const struct connectx4lx_hw_c_qpc_my_gid_mac_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_my_gid_mac_index_size(void);
#define CONNECTX4LX_HW_C_QPC_MY_GID_MAC_INDEX_SIZE    (0x40)
void connectx4lx_hw_c_qpc_my_gid_mac_index_dump(const struct connectx4lx_hw_c_qpc_my_gid_mac_index *ptr_struct, FILE* file);
/* hw_c_qpc_mtt_pointer_39_32 */
void connectx4lx_hw_c_qpc_mtt_pointer_39_32_pack(const struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtt_pointer_39_32_unpack(struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtt_pointer_39_32_print(const struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_mtt_pointer_39_32_size(void);
#define CONNECTX4LX_HW_C_QPC_MTT_POINTER_39_32_SIZE    (0x40)
void connectx4lx_hw_c_qpc_mtt_pointer_39_32_dump(const struct connectx4lx_hw_c_qpc_mtt_pointer_39_32 *ptr_struct, FILE* file);
/* hw_c_qpc_mtt_pointer_31_0 */
void connectx4lx_hw_c_qpc_mtt_pointer_31_0_pack(const struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtt_pointer_31_0_unpack(struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_mtt_pointer_31_0_print(const struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_mtt_pointer_31_0_size(void);
#define CONNECTX4LX_HW_C_QPC_MTT_POINTER_31_0_SIZE    (0x40)
void connectx4lx_hw_c_qpc_mtt_pointer_31_0_dump(const struct connectx4lx_hw_c_qpc_mtt_pointer_31_0 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_lid2 */
void connectx4lx_hw_c_qpc_peer_lid2_pack(const struct connectx4lx_hw_c_qpc_peer_lid2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_lid2_unpack(struct connectx4lx_hw_c_qpc_peer_lid2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_lid2_print(const struct connectx4lx_hw_c_qpc_peer_lid2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_lid2_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_LID2_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_lid2_dump(const struct connectx4lx_hw_c_qpc_peer_lid2 *ptr_struct, FILE* file);
/* hw_c_qpc_qkey */
void connectx4lx_hw_c_qpc_qkey_pack(const struct connectx4lx_hw_c_qpc_qkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_qkey_unpack(struct connectx4lx_hw_c_qpc_qkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_qkey_print(const struct connectx4lx_hw_c_qpc_qkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_qkey_size(void);
#define CONNECTX4LX_HW_C_QPC_QKEY_SIZE    (0x40)
void connectx4lx_hw_c_qpc_qkey_dump(const struct connectx4lx_hw_c_qpc_qkey *ptr_struct, FILE* file);
/* hw_c_qpc_peer_qp2 */
void connectx4lx_hw_c_qpc_peer_qp2_pack(const struct connectx4lx_hw_c_qpc_peer_qp2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_qp2_unpack(struct connectx4lx_hw_c_qpc_peer_qp2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_qp2_print(const struct connectx4lx_hw_c_qpc_peer_qp2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_qp2_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_QP2_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_qp2_dump(const struct connectx4lx_hw_c_qpc_peer_qp2 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_gid_127_96 */
void connectx4lx_hw_c_qpc_peer_gid_127_96_pack(const struct connectx4lx_hw_c_qpc_peer_gid_127_96 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_127_96_unpack(struct connectx4lx_hw_c_qpc_peer_gid_127_96 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_127_96_print(const struct connectx4lx_hw_c_qpc_peer_gid_127_96 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_gid_127_96_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_GID_127_96_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_gid_127_96_dump(const struct connectx4lx_hw_c_qpc_peer_gid_127_96 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_gid_95_64 */
void connectx4lx_hw_c_qpc_peer_gid_95_64_pack(const struct connectx4lx_hw_c_qpc_peer_gid_95_64 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_95_64_unpack(struct connectx4lx_hw_c_qpc_peer_gid_95_64 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_95_64_print(const struct connectx4lx_hw_c_qpc_peer_gid_95_64 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_gid_95_64_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_GID_95_64_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_gid_95_64_dump(const struct connectx4lx_hw_c_qpc_peer_gid_95_64 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_gid_63_32 */
void connectx4lx_hw_c_qpc_peer_gid_63_32_pack(const struct connectx4lx_hw_c_qpc_peer_gid_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_63_32_unpack(struct connectx4lx_hw_c_qpc_peer_gid_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_63_32_print(const struct connectx4lx_hw_c_qpc_peer_gid_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_gid_63_32_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_GID_63_32_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_gid_63_32_dump(const struct connectx4lx_hw_c_qpc_peer_gid_63_32 *ptr_struct, FILE* file);
/* hw_c_qpc_peer_gid_31_0 */
void connectx4lx_hw_c_qpc_peer_gid_31_0_pack(const struct connectx4lx_hw_c_qpc_peer_gid_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_31_0_unpack(struct connectx4lx_hw_c_qpc_peer_gid_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_peer_gid_31_0_print(const struct connectx4lx_hw_c_qpc_peer_gid_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_peer_gid_31_0_size(void);
#define CONNECTX4LX_HW_C_QPC_PEER_GID_31_0_SIZE    (0x40)
void connectx4lx_hw_c_qpc_peer_gid_31_0_dump(const struct connectx4lx_hw_c_qpc_peer_gid_31_0 *ptr_struct, FILE* file);
/* hw_srq_srq_valid */
void connectx4lx_hw_srq_srq_valid_pack(const struct connectx4lx_hw_srq_srq_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_srq_valid_unpack(struct connectx4lx_hw_srq_srq_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_srq_valid_print(const struct connectx4lx_hw_srq_srq_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_srq_valid_size(void);
#define CONNECTX4LX_HW_SRQ_SRQ_VALID_SIZE    (0x40)
void connectx4lx_hw_srq_srq_valid_dump(const struct connectx4lx_hw_srq_srq_valid *ptr_struct, FILE* file);
/* hw_srq_rwqe_consumer_stride_index */
void connectx4lx_hw_srq_rwqe_consumer_stride_index_pack(const struct connectx4lx_hw_srq_rwqe_consumer_stride_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_consumer_stride_index_unpack(struct connectx4lx_hw_srq_rwqe_consumer_stride_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_consumer_stride_index_print(const struct connectx4lx_hw_srq_rwqe_consumer_stride_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwqe_consumer_stride_index_size(void);
#define CONNECTX4LX_HW_SRQ_RWQE_CONSUMER_STRIDE_INDEX_SIZE    (0x40)
void connectx4lx_hw_srq_rwqe_consumer_stride_index_dump(const struct connectx4lx_hw_srq_rwqe_consumer_stride_index *ptr_struct, FILE* file);
/* hw_srq_log2_wqe_left_lro_allow */
void connectx4lx_hw_srq_log2_wqe_left_lro_allow_pack(const struct connectx4lx_hw_srq_log2_wqe_left_lro_allow *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_wqe_left_lro_allow_unpack(struct connectx4lx_hw_srq_log2_wqe_left_lro_allow *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_wqe_left_lro_allow_print(const struct connectx4lx_hw_srq_log2_wqe_left_lro_allow *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_log2_wqe_left_lro_allow_size(void);
#define CONNECTX4LX_HW_SRQ_LOG2_WQE_LEFT_LRO_ALLOW_SIZE    (0x40)
void connectx4lx_hw_srq_log2_wqe_left_lro_allow_dump(const struct connectx4lx_hw_srq_log2_wqe_left_lro_allow *ptr_struct, FILE* file);
/* hw_srq_cqe_rq_source */
void connectx4lx_hw_srq_cqe_rq_source_pack(const struct connectx4lx_hw_srq_cqe_rq_source *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cqe_rq_source_unpack(struct connectx4lx_hw_srq_cqe_rq_source *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cqe_rq_source_print(const struct connectx4lx_hw_srq_cqe_rq_source *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_cqe_rq_source_size(void);
#define CONNECTX4LX_HW_SRQ_CQE_RQ_SOURCE_SIZE    (0x40)
void connectx4lx_hw_srq_cqe_rq_source_dump(const struct connectx4lx_hw_srq_cqe_rq_source *ptr_struct, FILE* file);
/* hw_srq_translation_process_index */
void connectx4lx_hw_srq_translation_process_index_pack(const struct connectx4lx_hw_srq_translation_process_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_translation_process_index_unpack(struct connectx4lx_hw_srq_translation_process_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_translation_process_index_print(const struct connectx4lx_hw_srq_translation_process_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_translation_process_index_size(void);
#define CONNECTX4LX_HW_SRQ_TRANSLATION_PROCESS_INDEX_SIZE    (0x40)
void connectx4lx_hw_srq_translation_process_index_dump(const struct connectx4lx_hw_srq_translation_process_index *ptr_struct, FILE* file);
/* hw_srq_log2_stride_size */
void connectx4lx_hw_srq_log2_stride_size_pack(const struct connectx4lx_hw_srq_log2_stride_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_stride_size_unpack(struct connectx4lx_hw_srq_log2_stride_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_stride_size_print(const struct connectx4lx_hw_srq_log2_stride_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_log2_stride_size_size(void);
#define CONNECTX4LX_HW_SRQ_LOG2_STRIDE_SIZE_SIZE    (0x40)
void connectx4lx_hw_srq_log2_stride_size_dump(const struct connectx4lx_hw_srq_log2_stride_size *ptr_struct, FILE* file);
/* hw_srq_two_bytes_shift_en */
void connectx4lx_hw_srq_two_bytes_shift_en_pack(const struct connectx4lx_hw_srq_two_bytes_shift_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_two_bytes_shift_en_unpack(struct connectx4lx_hw_srq_two_bytes_shift_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_two_bytes_shift_en_print(const struct connectx4lx_hw_srq_two_bytes_shift_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_two_bytes_shift_en_size(void);
#define CONNECTX4LX_HW_SRQ_TWO_BYTES_SHIFT_EN_SIZE    (0x40)
void connectx4lx_hw_srq_two_bytes_shift_en_dump(const struct connectx4lx_hw_srq_two_bytes_shift_en *ptr_struct, FILE* file);
/* hw_srq_log2_num_of_strides */
void connectx4lx_hw_srq_log2_num_of_strides_pack(const struct connectx4lx_hw_srq_log2_num_of_strides *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_num_of_strides_unpack(struct connectx4lx_hw_srq_log2_num_of_strides *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log2_num_of_strides_print(const struct connectx4lx_hw_srq_log2_num_of_strides *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_log2_num_of_strides_size(void);
#define CONNECTX4LX_HW_SRQ_LOG2_NUM_OF_STRIDES_SIZE    (0x40)
void connectx4lx_hw_srq_log2_num_of_strides_dump(const struct connectx4lx_hw_srq_log2_num_of_strides *ptr_struct, FILE* file);
/* hw_srq_cqe_srqn */
void connectx4lx_hw_srq_cqe_srqn_pack(const struct connectx4lx_hw_srq_cqe_srqn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cqe_srqn_unpack(struct connectx4lx_hw_srq_cqe_srqn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cqe_srqn_print(const struct connectx4lx_hw_srq_cqe_srqn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_cqe_srqn_size(void);
#define CONNECTX4LX_HW_SRQ_CQE_SRQN_SIZE    (0x40)
void connectx4lx_hw_srq_cqe_srqn_dump(const struct connectx4lx_hw_srq_cqe_srqn *ptr_struct, FILE* file);
/* hw_srq_rwq_type_srq */
void connectx4lx_hw_srq_rwq_type_srq_pack(const struct connectx4lx_hw_srq_rwq_type_srq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwq_type_srq_unpack(struct connectx4lx_hw_srq_rwq_type_srq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwq_type_srq_print(const struct connectx4lx_hw_srq_rwq_type_srq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwq_type_srq_size(void);
#define CONNECTX4LX_HW_SRQ_RWQ_TYPE_SRQ_SIZE    (0x40)
void connectx4lx_hw_srq_rwq_type_srq_dump(const struct connectx4lx_hw_srq_rwq_type_srq *ptr_struct, FILE* file);
/* hw_srq_rcyclic_size */
void connectx4lx_hw_srq_rcyclic_size_pack(const struct connectx4lx_hw_srq_rcyclic_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_size_unpack(struct connectx4lx_hw_srq_rcyclic_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_size_print(const struct connectx4lx_hw_srq_rcyclic_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rcyclic_size_size(void);
#define CONNECTX4LX_HW_SRQ_RCYCLIC_SIZE_SIZE    (0x40)
void connectx4lx_hw_srq_rcyclic_size_dump(const struct connectx4lx_hw_srq_rcyclic_size *ptr_struct, FILE* file);
/* hw_srq_rcyclic_producer */
void connectx4lx_hw_srq_rcyclic_producer_pack(const struct connectx4lx_hw_srq_rcyclic_producer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_producer_unpack(struct connectx4lx_hw_srq_rcyclic_producer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_producer_print(const struct connectx4lx_hw_srq_rcyclic_producer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rcyclic_producer_size(void);
#define CONNECTX4LX_HW_SRQ_RCYCLIC_PRODUCER_SIZE    (0x40)
void connectx4lx_hw_srq_rcyclic_producer_dump(const struct connectx4lx_hw_srq_rcyclic_producer *ptr_struct, FILE* file);
/* hw_srq_rcyclic_consumer */
void connectx4lx_hw_srq_rcyclic_consumer_pack(const struct connectx4lx_hw_srq_rcyclic_consumer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_consumer_unpack(struct connectx4lx_hw_srq_rcyclic_consumer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rcyclic_consumer_print(const struct connectx4lx_hw_srq_rcyclic_consumer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rcyclic_consumer_size(void);
#define CONNECTX4LX_HW_SRQ_RCYCLIC_CONSUMER_SIZE    (0x40)
void connectx4lx_hw_srq_rcyclic_consumer_dump(const struct connectx4lx_hw_srq_rcyclic_consumer *ptr_struct, FILE* file);
/* hw_srq_srq_fw */
void connectx4lx_hw_srq_srq_fw_pack(const struct connectx4lx_hw_srq_srq_fw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_srq_fw_unpack(struct connectx4lx_hw_srq_srq_fw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_srq_fw_print(const struct connectx4lx_hw_srq_srq_fw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_srq_fw_size(void);
#define CONNECTX4LX_HW_SRQ_SRQ_FW_SIZE    (0x40)
void connectx4lx_hw_srq_srq_fw_dump(const struct connectx4lx_hw_srq_srq_fw *ptr_struct, FILE* file);
/* hw_srq_e2e_consumer_index */
void connectx4lx_hw_srq_e2e_consumer_index_pack(const struct connectx4lx_hw_srq_e2e_consumer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_consumer_index_unpack(struct connectx4lx_hw_srq_e2e_consumer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_consumer_index_print(const struct connectx4lx_hw_srq_e2e_consumer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_consumer_index_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_CONSUMER_INDEX_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_consumer_index_dump(const struct connectx4lx_hw_srq_e2e_consumer_index *ptr_struct, FILE* file);
/* hw_srq_e2e_producer_index */
void connectx4lx_hw_srq_e2e_producer_index_pack(const struct connectx4lx_hw_srq_e2e_producer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_producer_index_unpack(struct connectx4lx_hw_srq_e2e_producer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_producer_index_print(const struct connectx4lx_hw_srq_e2e_producer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_producer_index_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_PRODUCER_INDEX_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_producer_index_dump(const struct connectx4lx_hw_srq_e2e_producer_index *ptr_struct, FILE* file);
/* hw_srq_rwqe_consumer_index */
void connectx4lx_hw_srq_rwqe_consumer_index_pack(const struct connectx4lx_hw_srq_rwqe_consumer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_consumer_index_unpack(struct connectx4lx_hw_srq_rwqe_consumer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_consumer_index_print(const struct connectx4lx_hw_srq_rwqe_consumer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwqe_consumer_index_size(void);
#define CONNECTX4LX_HW_SRQ_RWQE_CONSUMER_INDEX_SIZE    (0x40)
void connectx4lx_hw_srq_rwqe_consumer_index_dump(const struct connectx4lx_hw_srq_rwqe_consumer_index *ptr_struct, FILE* file);
/* hw_srq_xrc_domain */
void connectx4lx_hw_srq_xrc_domain_pack(const struct connectx4lx_hw_srq_xrc_domain *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_xrc_domain_unpack(struct connectx4lx_hw_srq_xrc_domain *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_xrc_domain_print(const struct connectx4lx_hw_srq_xrc_domain *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_xrc_domain_size(void);
#define CONNECTX4LX_HW_SRQ_XRC_DOMAIN_SIZE    (0x40)
void connectx4lx_hw_srq_xrc_domain_dump(const struct connectx4lx_hw_srq_xrc_domain *ptr_struct, FILE* file);
/* hw_srq_e2e_credits_prefetch_threshold */
void connectx4lx_hw_srq_e2e_credits_prefetch_threshold_pack(const struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_credits_prefetch_threshold_unpack(struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_credits_prefetch_threshold_print(const struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_credits_prefetch_threshold_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_CREDITS_PREFETCH_THRESHOLD_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_credits_prefetch_threshold_dump(const struct connectx4lx_hw_srq_e2e_credits_prefetch_threshold *ptr_struct, FILE* file);
/* hw_srq_pd */
void connectx4lx_hw_srq_pd_pack(const struct connectx4lx_hw_srq_pd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_pd_unpack(struct connectx4lx_hw_srq_pd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_pd_print(const struct connectx4lx_hw_srq_pd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_pd_size(void);
#define CONNECTX4LX_HW_SRQ_PD_SIZE    (0x40)
void connectx4lx_hw_srq_pd_dump(const struct connectx4lx_hw_srq_pd *ptr_struct, FILE* file);
/* hw_srq_rwqe_stride */
void connectx4lx_hw_srq_rwqe_stride_pack(const struct connectx4lx_hw_srq_rwqe_stride *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_stride_unpack(struct connectx4lx_hw_srq_rwqe_stride *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_stride_print(const struct connectx4lx_hw_srq_rwqe_stride *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwqe_stride_size(void);
#define CONNECTX4LX_HW_SRQ_RWQE_STRIDE_SIZE    (0x40)
void connectx4lx_hw_srq_rwqe_stride_dump(const struct connectx4lx_hw_srq_rwqe_stride *ptr_struct, FILE* file);
/* hw_srq_rwqe_buffer_size */
void connectx4lx_hw_srq_rwqe_buffer_size_pack(const struct connectx4lx_hw_srq_rwqe_buffer_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_buffer_size_unpack(struct connectx4lx_hw_srq_rwqe_buffer_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_buffer_size_print(const struct connectx4lx_hw_srq_rwqe_buffer_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwqe_buffer_size_size(void);
#define CONNECTX4LX_HW_SRQ_RWQE_BUFFER_SIZE_SIZE    (0x40)
void connectx4lx_hw_srq_rwqe_buffer_size_dump(const struct connectx4lx_hw_srq_rwqe_buffer_size *ptr_struct, FILE* file);
/* hw_srq_cq_number */
void connectx4lx_hw_srq_cq_number_pack(const struct connectx4lx_hw_srq_cq_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cq_number_unpack(struct connectx4lx_hw_srq_cq_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_cq_number_print(const struct connectx4lx_hw_srq_cq_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_cq_number_size(void);
#define CONNECTX4LX_HW_SRQ_CQ_NUMBER_SIZE    (0x40)
void connectx4lx_hw_srq_cq_number_dump(const struct connectx4lx_hw_srq_cq_number *ptr_struct, FILE* file);
/* hw_srq_tcu_trap */
void connectx4lx_hw_srq_tcu_trap_pack(const struct connectx4lx_hw_srq_tcu_trap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_tcu_trap_unpack(struct connectx4lx_hw_srq_tcu_trap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_tcu_trap_print(const struct connectx4lx_hw_srq_tcu_trap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_tcu_trap_size(void);
#define CONNECTX4LX_HW_SRQ_TCU_TRAP_SIZE    (0x40)
void connectx4lx_hw_srq_tcu_trap_dump(const struct connectx4lx_hw_srq_tcu_trap *ptr_struct, FILE* file);
/* hw_srq_can_use_reserved_lkey */
void connectx4lx_hw_srq_can_use_reserved_lkey_pack(const struct connectx4lx_hw_srq_can_use_reserved_lkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_can_use_reserved_lkey_unpack(struct connectx4lx_hw_srq_can_use_reserved_lkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_can_use_reserved_lkey_print(const struct connectx4lx_hw_srq_can_use_reserved_lkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_can_use_reserved_lkey_size(void);
#define CONNECTX4LX_HW_SRQ_CAN_USE_RESERVED_LKEY_SIZE    (0x40)
void connectx4lx_hw_srq_can_use_reserved_lkey_dump(const struct connectx4lx_hw_srq_can_use_reserved_lkey *ptr_struct, FILE* file);
/* hw_srq_tcu_drop */
void connectx4lx_hw_srq_tcu_drop_pack(const struct connectx4lx_hw_srq_tcu_drop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_tcu_drop_unpack(struct connectx4lx_hw_srq_tcu_drop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_tcu_drop_print(const struct connectx4lx_hw_srq_tcu_drop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_tcu_drop_size(void);
#define CONNECTX4LX_HW_SRQ_TCU_DROP_SIZE    (0x40)
void connectx4lx_hw_srq_tcu_drop_dump(const struct connectx4lx_hw_srq_tcu_drop *ptr_struct, FILE* file);
/* hw_srq_log_page_size */
void connectx4lx_hw_srq_log_page_size_pack(const struct connectx4lx_hw_srq_log_page_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log_page_size_unpack(struct connectx4lx_hw_srq_log_page_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_log_page_size_print(const struct connectx4lx_hw_srq_log_page_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_log_page_size_size(void);
#define CONNECTX4LX_HW_SRQ_LOG_PAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_srq_log_page_size_dump(const struct connectx4lx_hw_srq_log_page_size *ptr_struct, FILE* file);
/* hw_srq_context_number */
void connectx4lx_hw_srq_context_number_pack(const struct connectx4lx_hw_srq_context_number *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_context_number_unpack(struct connectx4lx_hw_srq_context_number *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_context_number_print(const struct connectx4lx_hw_srq_context_number *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_context_number_size(void);
#define CONNECTX4LX_HW_SRQ_CONTEXT_NUMBER_SIZE    (0x40)
void connectx4lx_hw_srq_context_number_dump(const struct connectx4lx_hw_srq_context_number *ptr_struct, FILE* file);
/* hw_srq_rwqe_limit_event */
void connectx4lx_hw_srq_rwqe_limit_event_pack(const struct connectx4lx_hw_srq_rwqe_limit_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_limit_event_unpack(struct connectx4lx_hw_srq_rwqe_limit_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rwqe_limit_event_print(const struct connectx4lx_hw_srq_rwqe_limit_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rwqe_limit_event_size(void);
#define CONNECTX4LX_HW_SRQ_RWQE_LIMIT_EVENT_SIZE    (0x40)
void connectx4lx_hw_srq_rwqe_limit_event_dump(const struct connectx4lx_hw_srq_rwqe_limit_event *ptr_struct, FILE* file);
/* hw_srq_e2e_fetch_enable */
void connectx4lx_hw_srq_e2e_fetch_enable_pack(const struct connectx4lx_hw_srq_e2e_fetch_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_fetch_enable_unpack(struct connectx4lx_hw_srq_e2e_fetch_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_fetch_enable_print(const struct connectx4lx_hw_srq_e2e_fetch_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_fetch_enable_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_FETCH_ENABLE_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_fetch_enable_dump(const struct connectx4lx_hw_srq_e2e_fetch_enable *ptr_struct, FILE* file);
/* hw_srq_rx_heartbeat */
void connectx4lx_hw_srq_rx_heartbeat_pack(const struct connectx4lx_hw_srq_rx_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rx_heartbeat_unpack(struct connectx4lx_hw_srq_rx_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_rx_heartbeat_print(const struct connectx4lx_hw_srq_rx_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_rx_heartbeat_size(void);
#define CONNECTX4LX_HW_SRQ_RX_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_srq_rx_heartbeat_dump(const struct connectx4lx_hw_srq_rx_heartbeat *ptr_struct, FILE* file);
/* hw_srq_wqe_page_offset */
void connectx4lx_hw_srq_wqe_page_offset_pack(const struct connectx4lx_hw_srq_wqe_page_offset *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_wqe_page_offset_unpack(struct connectx4lx_hw_srq_wqe_page_offset *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_wqe_page_offset_print(const struct connectx4lx_hw_srq_wqe_page_offset *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_wqe_page_offset_size(void);
#define CONNECTX4LX_HW_SRQ_WQE_PAGE_OFFSET_SIZE    (0x40)
void connectx4lx_hw_srq_wqe_page_offset_dump(const struct connectx4lx_hw_srq_wqe_page_offset *ptr_struct, FILE* file);
/* hw_srq_mtt_pointer_39_32 */
void connectx4lx_hw_srq_mtt_pointer_39_32_pack(const struct connectx4lx_hw_srq_mtt_pointer_39_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_mtt_pointer_39_32_unpack(struct connectx4lx_hw_srq_mtt_pointer_39_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_mtt_pointer_39_32_print(const struct connectx4lx_hw_srq_mtt_pointer_39_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_mtt_pointer_39_32_size(void);
#define CONNECTX4LX_HW_SRQ_MTT_POINTER_39_32_SIZE    (0x40)
void connectx4lx_hw_srq_mtt_pointer_39_32_dump(const struct connectx4lx_hw_srq_mtt_pointer_39_32 *ptr_struct, FILE* file);
/* hw_srq_mtt_pointer_31_0 */
void connectx4lx_hw_srq_mtt_pointer_31_0_pack(const struct connectx4lx_hw_srq_mtt_pointer_31_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_mtt_pointer_31_0_unpack(struct connectx4lx_hw_srq_mtt_pointer_31_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_mtt_pointer_31_0_print(const struct connectx4lx_hw_srq_mtt_pointer_31_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_mtt_pointer_31_0_size(void);
#define CONNECTX4LX_HW_SRQ_MTT_POINTER_31_0_SIZE    (0x40)
void connectx4lx_hw_srq_mtt_pointer_31_0_dump(const struct connectx4lx_hw_srq_mtt_pointer_31_0 *ptr_struct, FILE* file);
/* hw_srq_wq_signature */
void connectx4lx_hw_srq_wq_signature_pack(const struct connectx4lx_hw_srq_wq_signature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_wq_signature_unpack(struct connectx4lx_hw_srq_wq_signature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_wq_signature_print(const struct connectx4lx_hw_srq_wq_signature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_wq_signature_size(void);
#define CONNECTX4LX_HW_SRQ_WQ_SIGNATURE_SIZE    (0x40)
void connectx4lx_hw_srq_wq_signature_dump(const struct connectx4lx_hw_srq_wq_signature *ptr_struct, FILE* file);
/* hw_srq_e2e_pa_63_34 */
void connectx4lx_hw_srq_e2e_pa_63_34_pack(const struct connectx4lx_hw_srq_e2e_pa_63_34 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_pa_63_34_unpack(struct connectx4lx_hw_srq_e2e_pa_63_34 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_pa_63_34_print(const struct connectx4lx_hw_srq_e2e_pa_63_34 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_pa_63_34_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_PA_63_34_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_pa_63_34_dump(const struct connectx4lx_hw_srq_e2e_pa_63_34 *ptr_struct, FILE* file);
/* hw_srq_e2e_pa_33_2 */
void connectx4lx_hw_srq_e2e_pa_33_2_pack(const struct connectx4lx_hw_srq_e2e_pa_33_2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_pa_33_2_unpack(struct connectx4lx_hw_srq_e2e_pa_33_2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_srq_e2e_pa_33_2_print(const struct connectx4lx_hw_srq_e2e_pa_33_2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_srq_e2e_pa_33_2_size(void);
#define CONNECTX4LX_HW_SRQ_E2E_PA_33_2_SIZE    (0x40)
void connectx4lx_hw_srq_e2e_pa_33_2_dump(const struct connectx4lx_hw_srq_e2e_pa_33_2 *ptr_struct, FILE* file);
/* pf_vf_cfg_space */
void connectx4lx_pf_vf_cfg_space_pack(const struct connectx4lx_pf_vf_cfg_space *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pf_vf_cfg_space_unpack(struct connectx4lx_pf_vf_cfg_space *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pf_vf_cfg_space_print(const struct connectx4lx_pf_vf_cfg_space *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pf_vf_cfg_space_size(void);
#define CONNECTX4LX_PF_VF_CFG_SPACE_SIZE    (0x1c)
void connectx4lx_pf_vf_cfg_space_dump(const struct connectx4lx_pf_vf_cfg_space *ptr_struct, FILE* file);
/* hw_init_info */
void connectx4lx_hw_init_info_pack(const struct connectx4lx_hw_init_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_init_info_unpack(struct connectx4lx_hw_init_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_init_info_print(const struct connectx4lx_hw_init_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_init_info_size(void);
#define CONNECTX4LX_HW_INIT_INFO_SIZE    (0x4)
void connectx4lx_hw_init_info_dump(const struct connectx4lx_hw_init_info *ptr_struct, FILE* file);
/* hw_cqc_cqc_valid */
void connectx4lx_hw_cqc_cqc_valid_pack(const struct connectx4lx_hw_cqc_cqc_valid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqc_valid_unpack(struct connectx4lx_hw_cqc_cqc_valid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqc_valid_print(const struct connectx4lx_hw_cqc_cqc_valid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cqc_valid_size(void);
#define CONNECTX4LX_HW_CQC_CQC_VALID_SIZE    (0x40)
void connectx4lx_hw_cqc_cqc_valid_dump(const struct connectx4lx_hw_cqc_cqc_valid *ptr_struct, FILE* file);
/* hw_cqc_poll_cq_queue_in_error_state */
void connectx4lx_hw_cqc_poll_cq_queue_in_error_state_pack(const struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_poll_cq_queue_in_error_state_unpack(struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_poll_cq_queue_in_error_state_print(const struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_poll_cq_queue_in_error_state_size(void);
#define CONNECTX4LX_HW_CQC_POLL_CQ_QUEUE_IN_ERROR_STATE_SIZE    (0x40)
void connectx4lx_hw_cqc_poll_cq_queue_in_error_state_dump(const struct connectx4lx_hw_cqc_poll_cq_queue_in_error_state *ptr_struct, FILE* file);
/* hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue */
void connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue_pack(const struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue_unpack(struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue_print(const struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue_size(void);
#define CONNECTX4LX_HW_CQC_POLL_CQ_CQE_WITH_ERROR_GENERATED_ON_THIS_QUEUE_SIZE    (0x40)
void connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue_dump(const struct connectx4lx_hw_cqc_poll_cq_cqe_with_error_generated_on_this_queue *ptr_struct, FILE* file);
/* hw_cqc_log_page_size */
void connectx4lx_hw_cqc_log_page_size_pack(const struct connectx4lx_hw_cqc_log_page_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_log_page_size_unpack(struct connectx4lx_hw_cqc_log_page_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_log_page_size_print(const struct connectx4lx_hw_cqc_log_page_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_log_page_size_size(void);
#define CONNECTX4LX_HW_CQC_LOG_PAGE_SIZE_SIZE    (0x40)
void connectx4lx_hw_cqc_log_page_size_dump(const struct connectx4lx_hw_cqc_log_page_size *ptr_struct, FILE* file);
/* hw_cqc_pa_error */
void connectx4lx_hw_cqc_pa_error_pack(const struct connectx4lx_hw_cqc_pa_error *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa_error_unpack(struct connectx4lx_hw_cqc_pa_error *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa_error_print(const struct connectx4lx_hw_cqc_pa_error *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa_error_size(void);
#define CONNECTX4LX_HW_CQC_PA_ERROR_SIZE    (0x40)
void connectx4lx_hw_cqc_pa_error_dump(const struct connectx4lx_hw_cqc_pa_error *ptr_struct, FILE* file);
/* hw_cqc_small_message_as_solicited */
void connectx4lx_hw_cqc_small_message_as_solicited_pack(const struct connectx4lx_hw_cqc_small_message_as_solicited *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_small_message_as_solicited_unpack(struct connectx4lx_hw_cqc_small_message_as_solicited *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_small_message_as_solicited_print(const struct connectx4lx_hw_cqc_small_message_as_solicited *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_small_message_as_solicited_size(void);
#define CONNECTX4LX_HW_CQC_SMALL_MESSAGE_AS_SOLICITED_SIZE    (0x40)
void connectx4lx_hw_cqc_small_message_as_solicited_dump(const struct connectx4lx_hw_cqc_small_message_as_solicited *ptr_struct, FILE* file);
/* hw_cqc_moderation_time_from_cqe */
void connectx4lx_hw_cqc_moderation_time_from_cqe_pack(const struct connectx4lx_hw_cqc_moderation_time_from_cqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_time_from_cqe_unpack(struct connectx4lx_hw_cqc_moderation_time_from_cqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_time_from_cqe_print(const struct connectx4lx_hw_cqc_moderation_time_from_cqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_time_from_cqe_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_TIME_FROM_CQE_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_time_from_cqe_dump(const struct connectx4lx_hw_cqc_moderation_time_from_cqe *ptr_struct, FILE* file);
/* hw_cqc_cqe_coalesce_enable */
void connectx4lx_hw_cqc_cqe_coalesce_enable_pack(const struct connectx4lx_hw_cqc_cqe_coalesce_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_coalesce_enable_unpack(struct connectx4lx_hw_cqc_cqe_coalesce_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_coalesce_enable_print(const struct connectx4lx_hw_cqc_cqe_coalesce_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cqe_coalesce_enable_size(void);
#define CONNECTX4LX_HW_CQC_CQE_COALESCE_ENABLE_SIZE    (0x40)
void connectx4lx_hw_cqc_cqe_coalesce_enable_dump(const struct connectx4lx_hw_cqc_cqe_coalesce_enable *ptr_struct, FILE* file);
/* hw_cqc_cqe_coalesce_checksum_msix */
void connectx4lx_hw_cqc_cqe_coalesce_checksum_msix_pack(const struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_coalesce_checksum_msix_unpack(struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_coalesce_checksum_msix_print(const struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cqe_coalesce_checksum_msix_size(void);
#define CONNECTX4LX_HW_CQC_CQE_COALESCE_CHECKSUM_MSIX_SIZE    (0x40)
void connectx4lx_hw_cqc_cqe_coalesce_checksum_msix_dump(const struct connectx4lx_hw_cqc_cqe_coalesce_checksum_msix *ptr_struct, FILE* file);
/* hw_cqc_msix */
void connectx4lx_hw_cqc_msix_pack(const struct connectx4lx_hw_cqc_msix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_msix_unpack(struct connectx4lx_hw_cqc_msix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_msix_print(const struct connectx4lx_hw_cqc_msix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_msix_size(void);
#define CONNECTX4LX_HW_CQC_MSIX_SIZE    (0x40)
void connectx4lx_hw_cqc_msix_dump(const struct connectx4lx_hw_cqc_msix *ptr_struct, FILE* file);
/* hw_cqc_cqe_128b_size */
void connectx4lx_hw_cqc_cqe_128b_size_pack(const struct connectx4lx_hw_cqc_cqe_128b_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_128b_size_unpack(struct connectx4lx_hw_cqc_cqe_128b_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_128b_size_print(const struct connectx4lx_hw_cqc_cqe_128b_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cqe_128b_size_size(void);
#define CONNECTX4LX_HW_CQC_CQE_128B_SIZE_SIZE    (0x40)
void connectx4lx_hw_cqc_cqe_128b_size_dump(const struct connectx4lx_hw_cqc_cqe_128b_size *ptr_struct, FILE* file);
/* hw_cqc_last_notified_check_for_arm_en */
void connectx4lx_hw_cqc_last_notified_check_for_arm_en_pack(const struct connectx4lx_hw_cqc_last_notified_check_for_arm_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_notified_check_for_arm_en_unpack(struct connectx4lx_hw_cqc_last_notified_check_for_arm_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_notified_check_for_arm_en_print(const struct connectx4lx_hw_cqc_last_notified_check_for_arm_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_last_notified_check_for_arm_en_size(void);
#define CONNECTX4LX_HW_CQC_LAST_NOTIFIED_CHECK_FOR_ARM_EN_SIZE    (0x40)
void connectx4lx_hw_cqc_last_notified_check_for_arm_en_dump(const struct connectx4lx_hw_cqc_last_notified_check_for_arm_en *ptr_struct, FILE* file);
/* hw_cqc_moderation_break_by_solicited */
void connectx4lx_hw_cqc_moderation_break_by_solicited_pack(const struct connectx4lx_hw_cqc_moderation_break_by_solicited *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_break_by_solicited_unpack(struct connectx4lx_hw_cqc_moderation_break_by_solicited *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_break_by_solicited_print(const struct connectx4lx_hw_cqc_moderation_break_by_solicited *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_break_by_solicited_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_BREAK_BY_SOLICITED_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_break_by_solicited_dump(const struct connectx4lx_hw_cqc_moderation_break_by_solicited *ptr_struct, FILE* file);
/* hw_cqc_lookahead_log_size */
void connectx4lx_hw_cqc_lookahead_log_size_pack(const struct connectx4lx_hw_cqc_lookahead_log_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_lookahead_log_size_unpack(struct connectx4lx_hw_cqc_lookahead_log_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_lookahead_log_size_print(const struct connectx4lx_hw_cqc_lookahead_log_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_lookahead_log_size_size(void);
#define CONNECTX4LX_HW_CQC_LOOKAHEAD_LOG_SIZE_SIZE    (0x40)
void connectx4lx_hw_cqc_lookahead_log_size_dump(const struct connectx4lx_hw_cqc_lookahead_log_size *ptr_struct, FILE* file);
/* hw_cqc_last_solicited_index */
void connectx4lx_hw_cqc_last_solicited_index_pack(const struct connectx4lx_hw_cqc_last_solicited_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_solicited_index_unpack(struct connectx4lx_hw_cqc_last_solicited_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_solicited_index_print(const struct connectx4lx_hw_cqc_last_solicited_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_last_solicited_index_size(void);
#define CONNECTX4LX_HW_CQC_LAST_SOLICITED_INDEX_SIZE    (0x40)
void connectx4lx_hw_cqc_last_solicited_index_dump(const struct connectx4lx_hw_cqc_last_solicited_index *ptr_struct, FILE* file);
/* hw_cqc_pa0_63_32 */
void connectx4lx_hw_cqc_pa0_63_32_pack(const struct connectx4lx_hw_cqc_pa0_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa0_63_32_unpack(struct connectx4lx_hw_cqc_pa0_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa0_63_32_print(const struct connectx4lx_hw_cqc_pa0_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa0_63_32_size(void);
#define CONNECTX4LX_HW_CQC_PA0_63_32_SIZE    (0x40)
void connectx4lx_hw_cqc_pa0_63_32_dump(const struct connectx4lx_hw_cqc_pa0_63_32 *ptr_struct, FILE* file);
/* hw_cqc_pa0_31_12 */
void connectx4lx_hw_cqc_pa0_31_12_pack(const struct connectx4lx_hw_cqc_pa0_31_12 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa0_31_12_unpack(struct connectx4lx_hw_cqc_pa0_31_12 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa0_31_12_print(const struct connectx4lx_hw_cqc_pa0_31_12 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa0_31_12_size(void);
#define CONNECTX4LX_HW_CQC_PA0_31_12_SIZE    (0x40)
void connectx4lx_hw_cqc_pa0_31_12_dump(const struct connectx4lx_hw_cqc_pa0_31_12 *ptr_struct, FILE* file);
/* hw_cqc_cq_trap */
void connectx4lx_hw_cqc_cq_trap_pack(const struct connectx4lx_hw_cqc_cq_trap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_trap_unpack(struct connectx4lx_hw_cqc_cq_trap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_trap_print(const struct connectx4lx_hw_cqc_cq_trap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cq_trap_size(void);
#define CONNECTX4LX_HW_CQC_CQ_TRAP_SIZE    (0x40)
void connectx4lx_hw_cqc_cq_trap_dump(const struct connectx4lx_hw_cqc_cq_trap *ptr_struct, FILE* file);
/* hw_cqc_shrink */
void connectx4lx_hw_cqc_shrink_pack(const struct connectx4lx_hw_cqc_shrink *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_shrink_unpack(struct connectx4lx_hw_cqc_shrink *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_shrink_print(const struct connectx4lx_hw_cqc_shrink *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_shrink_size(void);
#define CONNECTX4LX_HW_CQC_SHRINK_SIZE    (0x40)
void connectx4lx_hw_cqc_shrink_dump(const struct connectx4lx_hw_cqc_shrink *ptr_struct, FILE* file);
/* hw_cqc_pa_mode */
void connectx4lx_hw_cqc_pa_mode_pack(const struct connectx4lx_hw_cqc_pa_mode *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa_mode_unpack(struct connectx4lx_hw_cqc_pa_mode *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa_mode_print(const struct connectx4lx_hw_cqc_pa_mode *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa_mode_size(void);
#define CONNECTX4LX_HW_CQC_PA_MODE_SIZE    (0x40)
void connectx4lx_hw_cqc_pa_mode_dump(const struct connectx4lx_hw_cqc_pa_mode *ptr_struct, FILE* file);
/* hw_cqc_cqe_heartbeat */
void connectx4lx_hw_cqc_cqe_heartbeat_pack(const struct connectx4lx_hw_cqc_cqe_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_heartbeat_unpack(struct connectx4lx_hw_cqc_cqe_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cqe_heartbeat_print(const struct connectx4lx_hw_cqc_cqe_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cqe_heartbeat_size(void);
#define CONNECTX4LX_HW_CQC_CQE_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_cqc_cqe_heartbeat_dump(const struct connectx4lx_hw_cqc_cqe_heartbeat *ptr_struct, FILE* file);
/* hw_cqc_db_recovery_enable */
void connectx4lx_hw_cqc_db_recovery_enable_pack(const struct connectx4lx_hw_cqc_db_recovery_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_recovery_enable_unpack(struct connectx4lx_hw_cqc_db_recovery_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_recovery_enable_print(const struct connectx4lx_hw_cqc_db_recovery_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_db_recovery_enable_size(void);
#define CONNECTX4LX_HW_CQC_DB_RECOVERY_ENABLE_SIZE    (0x40)
void connectx4lx_hw_cqc_db_recovery_enable_dump(const struct connectx4lx_hw_cqc_db_recovery_enable *ptr_struct, FILE* file);
/* hw_cqc_cq_page_offset */
void connectx4lx_hw_cqc_cq_page_offset_pack(const struct connectx4lx_hw_cqc_cq_page_offset *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_page_offset_unpack(struct connectx4lx_hw_cqc_cq_page_offset *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_page_offset_print(const struct connectx4lx_hw_cqc_cq_page_offset *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cq_page_offset_size(void);
#define CONNECTX4LX_HW_CQC_CQ_PAGE_OFFSET_SIZE    (0x40)
void connectx4lx_hw_cqc_cq_page_offset_dump(const struct connectx4lx_hw_cqc_cq_page_offset *ptr_struct, FILE* file);
/* hw_cqc_last_notified_index */
void connectx4lx_hw_cqc_last_notified_index_pack(const struct connectx4lx_hw_cqc_last_notified_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_notified_index_unpack(struct connectx4lx_hw_cqc_last_notified_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_last_notified_index_print(const struct connectx4lx_hw_cqc_last_notified_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_last_notified_index_size(void);
#define CONNECTX4LX_HW_CQC_LAST_NOTIFIED_INDEX_SIZE    (0x40)
void connectx4lx_hw_cqc_last_notified_index_dump(const struct connectx4lx_hw_cqc_last_notified_index *ptr_struct, FILE* file);
/* hw_cqc_moderation_cnt_limit_15_8 */
void connectx4lx_hw_cqc_moderation_cnt_limit_15_8_pack(const struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_cnt_limit_15_8_unpack(struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_cnt_limit_15_8_print(const struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_cnt_limit_15_8_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_CNT_LIMIT_15_8_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_cnt_limit_15_8_dump(const struct connectx4lx_hw_cqc_moderation_cnt_limit_15_8 *ptr_struct, FILE* file);
/* hw_cqc_moderation_cnt_limit_7_0 */
void connectx4lx_hw_cqc_moderation_cnt_limit_7_0_pack(const struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_cnt_limit_7_0_unpack(struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_cnt_limit_7_0_print(const struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_cnt_limit_7_0_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_CNT_LIMIT_7_0_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_cnt_limit_7_0_dump(const struct connectx4lx_hw_cqc_moderation_cnt_limit_7_0 *ptr_struct, FILE* file);
/* hw_cqc_producer_index */
void connectx4lx_hw_cqc_producer_index_pack(const struct connectx4lx_hw_cqc_producer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_producer_index_unpack(struct connectx4lx_hw_cqc_producer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_producer_index_print(const struct connectx4lx_hw_cqc_producer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_producer_index_size(void);
#define CONNECTX4LX_HW_CQC_PRODUCER_INDEX_SIZE    (0x40)
void connectx4lx_hw_cqc_producer_index_dump(const struct connectx4lx_hw_cqc_producer_index *ptr_struct, FILE* file);
/* hw_cqc_moderation_min_wait_time */
void connectx4lx_hw_cqc_moderation_min_wait_time_pack(const struct connectx4lx_hw_cqc_moderation_min_wait_time *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_min_wait_time_unpack(struct connectx4lx_hw_cqc_moderation_min_wait_time *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_min_wait_time_print(const struct connectx4lx_hw_cqc_moderation_min_wait_time *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_min_wait_time_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_MIN_WAIT_TIME_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_min_wait_time_dump(const struct connectx4lx_hw_cqc_moderation_min_wait_time *ptr_struct, FILE* file);
/* hw_cqc_eqn */
void connectx4lx_hw_cqc_eqn_pack(const struct connectx4lx_hw_cqc_eqn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_eqn_unpack(struct connectx4lx_hw_cqc_eqn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_eqn_print(const struct connectx4lx_hw_cqc_eqn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_eqn_size(void);
#define CONNECTX4LX_HW_CQC_EQN_SIZE    (0x40)
void connectx4lx_hw_cqc_eqn_dump(const struct connectx4lx_hw_cqc_eqn *ptr_struct, FILE* file);
/* hw_cqc_number_of_events_generated */
void connectx4lx_hw_cqc_number_of_events_generated_pack(const struct connectx4lx_hw_cqc_number_of_events_generated *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_number_of_events_generated_unpack(struct connectx4lx_hw_cqc_number_of_events_generated *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_number_of_events_generated_print(const struct connectx4lx_hw_cqc_number_of_events_generated *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_number_of_events_generated_size(void);
#define CONNECTX4LX_HW_CQC_NUMBER_OF_EVENTS_GENERATED_SIZE    (0x40)
void connectx4lx_hw_cqc_number_of_events_generated_dump(const struct connectx4lx_hw_cqc_number_of_events_generated *ptr_struct, FILE* file);
/* hw_cqc_db_heartbeat */
void connectx4lx_hw_cqc_db_heartbeat_pack(const struct connectx4lx_hw_cqc_db_heartbeat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_heartbeat_unpack(struct connectx4lx_hw_cqc_db_heartbeat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_heartbeat_print(const struct connectx4lx_hw_cqc_db_heartbeat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_db_heartbeat_size(void);
#define CONNECTX4LX_HW_CQC_DB_HEARTBEAT_SIZE    (0x40)
void connectx4lx_hw_cqc_db_heartbeat_dump(const struct connectx4lx_hw_cqc_db_heartbeat *ptr_struct, FILE* file);
/* hw_cqc_log2_size */
void connectx4lx_hw_cqc_log2_size_pack(const struct connectx4lx_hw_cqc_log2_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_log2_size_unpack(struct connectx4lx_hw_cqc_log2_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_log2_size_print(const struct connectx4lx_hw_cqc_log2_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_log2_size_size(void);
#define CONNECTX4LX_HW_CQC_LOG2_SIZE_SIZE    (0x40)
void connectx4lx_hw_cqc_log2_size_dump(const struct connectx4lx_hw_cqc_log2_size *ptr_struct, FILE* file);
/* hw_cqc_db_ci */
void connectx4lx_hw_cqc_db_ci_pack(const struct connectx4lx_hw_cqc_db_ci *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_ci_unpack(struct connectx4lx_hw_cqc_db_ci *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_db_ci_print(const struct connectx4lx_hw_cqc_db_ci *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_db_ci_size(void);
#define CONNECTX4LX_HW_CQC_DB_CI_SIZE    (0x40)
void connectx4lx_hw_cqc_db_ci_dump(const struct connectx4lx_hw_cqc_db_ci *ptr_struct, FILE* file);
/* hw_cqc_cipa_63_32 */
void connectx4lx_hw_cqc_cipa_63_32_pack(const struct connectx4lx_hw_cqc_cipa_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cipa_63_32_unpack(struct connectx4lx_hw_cqc_cipa_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cipa_63_32_print(const struct connectx4lx_hw_cqc_cipa_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cipa_63_32_size(void);
#define CONNECTX4LX_HW_CQC_CIPA_63_32_SIZE    (0x40)
void connectx4lx_hw_cqc_cipa_63_32_dump(const struct connectx4lx_hw_cqc_cipa_63_32 *ptr_struct, FILE* file);
/* hw_cqc_cipa_31_3 */
void connectx4lx_hw_cqc_cipa_31_3_pack(const struct connectx4lx_hw_cqc_cipa_31_3 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cipa_31_3_unpack(struct connectx4lx_hw_cqc_cipa_31_3 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cipa_31_3_print(const struct connectx4lx_hw_cqc_cipa_31_3 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cipa_31_3_size(void);
#define CONNECTX4LX_HW_CQC_CIPA_31_3_SIZE    (0x40)
void connectx4lx_hw_cqc_cipa_31_3_dump(const struct connectx4lx_hw_cqc_cipa_31_3 *ptr_struct, FILE* file);
/* hw_cqc_mtt_pointer_39_37 */
void connectx4lx_hw_cqc_mtt_pointer_39_37_pack(const struct connectx4lx_hw_cqc_mtt_pointer_39_37 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_39_37_unpack(struct connectx4lx_hw_cqc_mtt_pointer_39_37 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_39_37_print(const struct connectx4lx_hw_cqc_mtt_pointer_39_37 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_mtt_pointer_39_37_size(void);
#define CONNECTX4LX_HW_CQC_MTT_POINTER_39_37_SIZE    (0x40)
void connectx4lx_hw_cqc_mtt_pointer_39_37_dump(const struct connectx4lx_hw_cqc_mtt_pointer_39_37 *ptr_struct, FILE* file);
/* hw_cqc_mtt_pointer_36_5 */
void connectx4lx_hw_cqc_mtt_pointer_36_5_pack(const struct connectx4lx_hw_cqc_mtt_pointer_36_5 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_36_5_unpack(struct connectx4lx_hw_cqc_mtt_pointer_36_5 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_36_5_print(const struct connectx4lx_hw_cqc_mtt_pointer_36_5 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_mtt_pointer_36_5_size(void);
#define CONNECTX4LX_HW_CQC_MTT_POINTER_36_5_SIZE    (0x40)
void connectx4lx_hw_cqc_mtt_pointer_36_5_dump(const struct connectx4lx_hw_cqc_mtt_pointer_36_5 *ptr_struct, FILE* file);
/* hw_cqc_mtt_pointer_4_0 */
void connectx4lx_hw_cqc_mtt_pointer_4_0_pack(const struct connectx4lx_hw_cqc_mtt_pointer_4_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_4_0_unpack(struct connectx4lx_hw_cqc_mtt_pointer_4_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_mtt_pointer_4_0_print(const struct connectx4lx_hw_cqc_mtt_pointer_4_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_mtt_pointer_4_0_size(void);
#define CONNECTX4LX_HW_CQC_MTT_POINTER_4_0_SIZE    (0x40)
void connectx4lx_hw_cqc_mtt_pointer_4_0_dump(const struct connectx4lx_hw_cqc_mtt_pointer_4_0 *ptr_struct, FILE* file);
/* hw_cqc_overrun_ignore */
void connectx4lx_hw_cqc_overrun_ignore_pack(const struct connectx4lx_hw_cqc_overrun_ignore *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_overrun_ignore_unpack(struct connectx4lx_hw_cqc_overrun_ignore *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_overrun_ignore_print(const struct connectx4lx_hw_cqc_overrun_ignore *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_overrun_ignore_size(void);
#define CONNECTX4LX_HW_CQC_OVERRUN_IGNORE_SIZE    (0x40)
void connectx4lx_hw_cqc_overrun_ignore_dump(const struct connectx4lx_hw_cqc_overrun_ignore *ptr_struct, FILE* file);
/* hw_cqc_cq_state */
void connectx4lx_hw_cqc_cq_state_pack(const struct connectx4lx_hw_cqc_cq_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_state_unpack(struct connectx4lx_hw_cqc_cq_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_cq_state_print(const struct connectx4lx_hw_cqc_cq_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_cq_state_size(void);
#define CONNECTX4LX_HW_CQC_CQ_STATE_SIZE    (0x40)
void connectx4lx_hw_cqc_cq_state_dump(const struct connectx4lx_hw_cqc_cq_state *ptr_struct, FILE* file);
/* hw_cqc_consumer_index */
void connectx4lx_hw_cqc_consumer_index_pack(const struct connectx4lx_hw_cqc_consumer_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_consumer_index_unpack(struct connectx4lx_hw_cqc_consumer_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_consumer_index_print(const struct connectx4lx_hw_cqc_consumer_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_consumer_index_size(void);
#define CONNECTX4LX_HW_CQC_CONSUMER_INDEX_SIZE    (0x40)
void connectx4lx_hw_cqc_consumer_index_dump(const struct connectx4lx_hw_cqc_consumer_index *ptr_struct, FILE* file);
/* hw_cqc_pa1_63_32 */
void connectx4lx_hw_cqc_pa1_63_32_pack(const struct connectx4lx_hw_cqc_pa1_63_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa1_63_32_unpack(struct connectx4lx_hw_cqc_pa1_63_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa1_63_32_print(const struct connectx4lx_hw_cqc_pa1_63_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa1_63_32_size(void);
#define CONNECTX4LX_HW_CQC_PA1_63_32_SIZE    (0x40)
void connectx4lx_hw_cqc_pa1_63_32_dump(const struct connectx4lx_hw_cqc_pa1_63_32 *ptr_struct, FILE* file);
/* hw_cqc_pa1_31_12 */
void connectx4lx_hw_cqc_pa1_31_12_pack(const struct connectx4lx_hw_cqc_pa1_31_12 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa1_31_12_unpack(struct connectx4lx_hw_cqc_pa1_31_12 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_pa1_31_12_print(const struct connectx4lx_hw_cqc_pa1_31_12 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_pa1_31_12_size(void);
#define CONNECTX4LX_HW_CQC_PA1_31_12_SIZE    (0x40)
void connectx4lx_hw_cqc_pa1_31_12_dump(const struct connectx4lx_hw_cqc_pa1_31_12 *ptr_struct, FILE* file);
/* hw_cqc_moderation_timestamp_51_40 */
void connectx4lx_hw_cqc_moderation_timestamp_51_40_pack(const struct connectx4lx_hw_cqc_moderation_timestamp_51_40 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_51_40_unpack(struct connectx4lx_hw_cqc_moderation_timestamp_51_40 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_51_40_print(const struct connectx4lx_hw_cqc_moderation_timestamp_51_40 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_timestamp_51_40_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_TIMESTAMP_51_40_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_timestamp_51_40_dump(const struct connectx4lx_hw_cqc_moderation_timestamp_51_40 *ptr_struct, FILE* file);
/* hw_cqc_moderation_timestamp_39_8 */
void connectx4lx_hw_cqc_moderation_timestamp_39_8_pack(const struct connectx4lx_hw_cqc_moderation_timestamp_39_8 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_39_8_unpack(struct connectx4lx_hw_cqc_moderation_timestamp_39_8 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_39_8_print(const struct connectx4lx_hw_cqc_moderation_timestamp_39_8 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_timestamp_39_8_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_TIMESTAMP_39_8_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_timestamp_39_8_dump(const struct connectx4lx_hw_cqc_moderation_timestamp_39_8 *ptr_struct, FILE* file);
/* hw_cqc_moderation_timestamp_7_0 */
void connectx4lx_hw_cqc_moderation_timestamp_7_0_pack(const struct connectx4lx_hw_cqc_moderation_timestamp_7_0 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_7_0_unpack(struct connectx4lx_hw_cqc_moderation_timestamp_7_0 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_moderation_timestamp_7_0_print(const struct connectx4lx_hw_cqc_moderation_timestamp_7_0 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_moderation_timestamp_7_0_size(void);
#define CONNECTX4LX_HW_CQC_MODERATION_TIMESTAMP_7_0_SIZE    (0x40)
void connectx4lx_hw_cqc_moderation_timestamp_7_0_dump(const struct connectx4lx_hw_cqc_moderation_timestamp_7_0 *ptr_struct, FILE* file);
/* hw_cqc_uar */
void connectx4lx_hw_cqc_uar_pack(const struct connectx4lx_hw_cqc_uar *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_uar_unpack(struct connectx4lx_hw_cqc_uar *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_cqc_uar_print(const struct connectx4lx_hw_cqc_uar *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_cqc_uar_size(void);
#define CONNECTX4LX_HW_CQC_UAR_SIZE    (0x40)
void connectx4lx_hw_cqc_uar_dump(const struct connectx4lx_hw_cqc_uar *ptr_struct, FILE* file);
/* calibration_values */
void connectx4lx_calibration_values_pack(const struct connectx4lx_calibration_values *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_calibration_values_unpack(struct connectx4lx_calibration_values *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_calibration_values_print(const struct connectx4lx_calibration_values *ptr_struct, FILE* file, int indent_level);
int connectx4lx_calibration_values_size(void);
#define CONNECTX4LX_CALIBRATION_VALUES_SIZE    (0xc)
void connectx4lx_calibration_values_dump(const struct connectx4lx_calibration_values *ptr_struct, FILE* file);
/* lane_const_sd_params_tx_preset */
void connectx4lx_lane_const_sd_params_tx_preset_pack(const struct connectx4lx_lane_const_sd_params_tx_preset *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_tx_preset_unpack(struct connectx4lx_lane_const_sd_params_tx_preset *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_tx_preset_print(const struct connectx4lx_lane_const_sd_params_tx_preset *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_const_sd_params_tx_preset_size(void);
#define CONNECTX4LX_LANE_CONST_SD_PARAMS_TX_PRESET_SIZE    (0x1f0)
void connectx4lx_lane_const_sd_params_tx_preset_dump(const struct connectx4lx_lane_const_sd_params_tx_preset *ptr_struct, FILE* file);
/* sd_params_rx_aba */
void connectx4lx_sd_params_rx_aba_pack(const struct connectx4lx_sd_params_rx_aba *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_rx_aba_unpack(struct connectx4lx_sd_params_rx_aba *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_rx_aba_print(const struct connectx4lx_sd_params_rx_aba *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_rx_aba_size(void);
#define CONNECTX4LX_SD_PARAMS_RX_ABA_SIZE    (0x280)
void connectx4lx_sd_params_rx_aba_dump(const struct connectx4lx_sd_params_rx_aba *ptr_struct, FILE* file);
/* shared_const_sd_params_rx_force */
void connectx4lx_shared_const_sd_params_rx_force_pack(const struct connectx4lx_shared_const_sd_params_rx_force *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_rx_force_unpack(struct connectx4lx_shared_const_sd_params_rx_force *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_rx_force_print(const struct connectx4lx_shared_const_sd_params_rx_force *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_const_sd_params_rx_force_size(void);
#define CONNECTX4LX_SHARED_CONST_SD_PARAMS_RX_FORCE_SIZE    (0xa0)
void connectx4lx_shared_const_sd_params_rx_force_dump(const struct connectx4lx_shared_const_sd_params_rx_force *ptr_struct, FILE* file);
/* sd_params_tx_vendor_id */
void connectx4lx_sd_params_tx_vendor_id_pack(const struct connectx4lx_sd_params_tx_vendor_id *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_vendor_id_unpack(struct connectx4lx_sd_params_tx_vendor_id *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_vendor_id_print(const struct connectx4lx_sd_params_tx_vendor_id *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_vendor_id_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_VENDOR_ID_SIZE    (0xc0)
void connectx4lx_sd_params_tx_vendor_id_dump(const struct connectx4lx_sd_params_tx_vendor_id *ptr_struct, FILE* file);
/* sd_params_tx_active */
void connectx4lx_sd_params_tx_active_pack(const struct connectx4lx_sd_params_tx_active *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_active_unpack(struct connectx4lx_sd_params_tx_active *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_active_print(const struct connectx4lx_sd_params_tx_active *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_active_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_ACTIVE_SIZE    (0x30)
void connectx4lx_sd_params_tx_active_dump(const struct connectx4lx_sd_params_tx_active *ptr_struct, FILE* file);
/* sd_params_tx_aba */
void connectx4lx_sd_params_tx_aba_pack(const struct connectx4lx_sd_params_tx_aba *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_aba_unpack(struct connectx4lx_sd_params_tx_aba *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sd_params_tx_aba_print(const struct connectx4lx_sd_params_tx_aba *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sd_params_tx_aba_size(void);
#define CONNECTX4LX_SD_PARAMS_TX_ABA_SIZE    (0x400)
void connectx4lx_sd_params_tx_aba_dump(const struct connectx4lx_sd_params_tx_aba *ptr_struct, FILE* file);
/* shared_const_sd_params_tx_force */
void connectx4lx_shared_const_sd_params_tx_force_pack(const struct connectx4lx_shared_const_sd_params_tx_force *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_tx_force_unpack(struct connectx4lx_shared_const_sd_params_tx_force *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_tx_force_print(const struct connectx4lx_shared_const_sd_params_tx_force *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_const_sd_params_tx_force_size(void);
#define CONNECTX4LX_SHARED_CONST_SD_PARAMS_TX_FORCE_SIZE    (0x50)
void connectx4lx_shared_const_sd_params_tx_force_dump(const struct connectx4lx_shared_const_sd_params_tx_force *ptr_struct, FILE* file);
/* module_reset_data_db */
void connectx4lx_module_reset_data_db_pack(const struct connectx4lx_module_reset_data_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_reset_data_db_unpack(struct connectx4lx_module_reset_data_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_reset_data_db_print(const struct connectx4lx_module_reset_data_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_reset_data_db_size(void);
#define CONNECTX4LX_MODULE_RESET_DATA_DB_SIZE    (0x1)
void connectx4lx_module_reset_data_db_dump(const struct connectx4lx_module_reset_data_db *ptr_struct, FILE* file);
/* module_select_data_db */
void connectx4lx_module_select_data_db_pack(const struct connectx4lx_module_select_data_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_select_data_db_unpack(struct connectx4lx_module_select_data_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_select_data_db_print(const struct connectx4lx_module_select_data_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_select_data_db_size(void);
#define CONNECTX4LX_MODULE_SELECT_DATA_DB_SIZE    (0x1)
void connectx4lx_module_select_data_db_dump(const struct connectx4lx_module_select_data_db *ptr_struct, FILE* file);
/* module_prsnt_data_db */
void connectx4lx_module_prsnt_data_db_pack(const struct connectx4lx_module_prsnt_data_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_prsnt_data_db_unpack(struct connectx4lx_module_prsnt_data_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_prsnt_data_db_print(const struct connectx4lx_module_prsnt_data_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_prsnt_data_db_size(void);
#define CONNECTX4LX_MODULE_PRSNT_DATA_DB_SIZE    (0x1)
void connectx4lx_module_prsnt_data_db_dump(const struct connectx4lx_module_prsnt_data_db *ptr_struct, FILE* file);
/* module2locallane */
void connectx4lx_module2locallane_pack(const struct connectx4lx_module2locallane *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module2locallane_unpack(struct connectx4lx_module2locallane *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module2locallane_print(const struct connectx4lx_module2locallane *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module2locallane_size(void);
#define CONNECTX4LX_MODULE2LOCALLANE_SIZE    (0x10)
void connectx4lx_module2locallane_dump(const struct connectx4lx_module2locallane *ptr_struct, FILE* file);
/* mlnx_enhanced_equal_info_ini */
void connectx4lx_mlnx_enhanced_equal_info_ini_pack(const struct connectx4lx_mlnx_enhanced_equal_info_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_enhanced_equal_info_ini_unpack(struct connectx4lx_mlnx_enhanced_equal_info_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_enhanced_equal_info_ini_print(const struct connectx4lx_mlnx_enhanced_equal_info_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_enhanced_equal_info_ini_size(void);
#define CONNECTX4LX_MLNX_ENHANCED_EQUAL_INFO_INI_SIZE    (0x4)
void connectx4lx_mlnx_enhanced_equal_info_ini_dump(const struct connectx4lx_mlnx_enhanced_equal_info_ini *ptr_struct, FILE* file);
/* mlpn_database_all_protocol_bits_ini */
void connectx4lx_mlpn_database_all_protocol_bits_ini_pack(const struct connectx4lx_mlpn_database_all_protocol_bits_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlpn_database_all_protocol_bits_ini_unpack(struct connectx4lx_mlpn_database_all_protocol_bits_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlpn_database_all_protocol_bits_ini_print(const struct connectx4lx_mlpn_database_all_protocol_bits_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlpn_database_all_protocol_bits_ini_size(void);
#define CONNECTX4LX_MLPN_DATABASE_ALL_PROTOCOL_BITS_INI_SIZE    (0x4)
void connectx4lx_mlpn_database_all_protocol_bits_ini_dump(const struct connectx4lx_mlpn_database_all_protocol_bits_ini *ptr_struct, FILE* file);
/* nv_tlv_data_tpt_capabilities */
void connectx4lx_nv_tlv_data_tpt_capabilities_pack(const struct connectx4lx_nv_tlv_data_tpt_capabilities *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_tpt_capabilities_unpack(struct connectx4lx_nv_tlv_data_tpt_capabilities *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_tpt_capabilities_print(const struct connectx4lx_nv_tlv_data_tpt_capabilities *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_data_tpt_capabilities_size(void);
#define CONNECTX4LX_NV_TLV_DATA_TPT_CAPABILITIES_SIZE    (0x4)
void connectx4lx_nv_tlv_data_tpt_capabilities_dump(const struct connectx4lx_nv_tlv_data_tpt_capabilities *ptr_struct, FILE* file);
/* nv_tpt_conf */
void connectx4lx_nv_tpt_conf_pack(const struct connectx4lx_nv_tpt_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tpt_conf_unpack(struct connectx4lx_nv_tpt_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tpt_conf_print(const struct connectx4lx_nv_tpt_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tpt_conf_size(void);
#define CONNECTX4LX_NV_TPT_CONF_SIZE    (0x4)
void connectx4lx_nv_tpt_conf_dump(const struct connectx4lx_nv_tpt_conf *ptr_struct, FILE* file);
/* nv_global_pci_cap */
void connectx4lx_nv_global_pci_cap_pack(const struct connectx4lx_nv_global_pci_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_global_pci_cap_unpack(struct connectx4lx_nv_global_pci_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_global_pci_cap_print(const struct connectx4lx_nv_global_pci_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_global_pci_cap_size(void);
#define CONNECTX4LX_NV_GLOBAL_PCI_CAP_SIZE    (0x14)
void connectx4lx_nv_global_pci_cap_dump(const struct connectx4lx_nv_global_pci_cap *ptr_struct, FILE* file);
/* nv_global_pci_conf */
void connectx4lx_nv_global_pci_conf_pack(const struct connectx4lx_nv_global_pci_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_global_pci_conf_unpack(struct connectx4lx_nv_global_pci_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_global_pci_conf_print(const struct connectx4lx_nv_global_pci_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_global_pci_conf_size(void);
#define CONNECTX4LX_NV_GLOBAL_PCI_CONF_SIZE    (0xc)
void connectx4lx_nv_global_pci_conf_dump(const struct connectx4lx_nv_global_pci_conf *ptr_struct, FILE* file);
/* link_caps2 */
void connectx4lx_link_caps2_pack(const struct connectx4lx_link_caps2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_link_caps2_unpack(struct connectx4lx_link_caps2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_link_caps2_print(const struct connectx4lx_link_caps2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_link_caps2_size(void);
#define CONNECTX4LX_LINK_CAPS2_SIZE    (0x4)
void connectx4lx_link_caps2_dump(const struct connectx4lx_link_caps2 *ptr_struct, FILE* file);
/* device_caps2 */
void connectx4lx_device_caps2_pack(const struct connectx4lx_device_caps2 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_device_caps2_unpack(struct connectx4lx_device_caps2 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_device_caps2_print(const struct connectx4lx_device_caps2 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_device_caps2_size(void);
#define CONNECTX4LX_DEVICE_CAPS2_SIZE    (0x4)
void connectx4lx_device_caps2_dump(const struct connectx4lx_device_caps2 *ptr_struct, FILE* file);
/* link_caps */
void connectx4lx_link_caps_pack(const struct connectx4lx_link_caps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_link_caps_unpack(struct connectx4lx_link_caps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_link_caps_print(const struct connectx4lx_link_caps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_link_caps_size(void);
#define CONNECTX4LX_LINK_CAPS_SIZE    (0x4)
void connectx4lx_link_caps_dump(const struct connectx4lx_link_caps *ptr_struct, FILE* file);
/* device_caps */
void connectx4lx_device_caps_pack(const struct connectx4lx_device_caps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_device_caps_unpack(struct connectx4lx_device_caps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_device_caps_print(const struct connectx4lx_device_caps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_device_caps_size(void);
#define CONNECTX4LX_DEVICE_CAPS_SIZE    (0x4)
void connectx4lx_device_caps_dump(const struct connectx4lx_device_caps *ptr_struct, FILE* file);
/* external_port_pf_array */
void connectx4lx_external_port_pf_array_pack(const struct connectx4lx_external_port_pf_array *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_external_port_pf_array_unpack(struct connectx4lx_external_port_pf_array *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_external_port_pf_array_print(const struct connectx4lx_external_port_pf_array *ptr_struct, FILE* file, int indent_level);
int connectx4lx_external_port_pf_array_size(void);
#define CONNECTX4LX_EXTERNAL_PORT_PF_ARRAY_SIZE    (0x18)
void connectx4lx_external_port_pf_array_dump(const struct connectx4lx_external_port_pf_array *ptr_struct, FILE* file);
/* nv_config_host_port_main */
void connectx4lx_nv_config_host_port_main_pack(const struct connectx4lx_nv_config_host_port_main *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_port_main_unpack(struct connectx4lx_nv_config_host_port_main *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_port_main_print(const struct connectx4lx_nv_config_host_port_main *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_host_port_main_size(void);
#define CONNECTX4LX_NV_CONFIG_HOST_PORT_MAIN_SIZE    (0x8)
void connectx4lx_nv_config_host_port_main_dump(const struct connectx4lx_nv_config_host_port_main *ptr_struct, FILE* file);
/* nv_tlv_data_curr_config */
void connectx4lx_nv_tlv_data_curr_config_pack(const struct connectx4lx_nv_tlv_data_curr_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_curr_config_unpack(struct connectx4lx_nv_tlv_data_curr_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_curr_config_print(const struct connectx4lx_nv_tlv_data_curr_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_data_curr_config_size(void);
#define CONNECTX4LX_NV_TLV_DATA_CURR_CONFIG_SIZE    (0x4)
void connectx4lx_nv_tlv_data_curr_config_dump(const struct connectx4lx_nv_tlv_data_curr_config *ptr_struct, FILE* file);
/* nv_config_flex_nic */
void connectx4lx_nv_config_flex_nic_pack(const struct connectx4lx_nv_config_flex_nic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_flex_nic_unpack(struct connectx4lx_nv_config_flex_nic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_flex_nic_print(const struct connectx4lx_nv_config_flex_nic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_flex_nic_size(void);
#define CONNECTX4LX_NV_CONFIG_FLEX_NIC_SIZE    (0x4)
void connectx4lx_nv_config_flex_nic_dump(const struct connectx4lx_nv_config_flex_nic *ptr_struct, FILE* file);
/* nv_config_host_2_bmc */
void connectx4lx_nv_config_host_2_bmc_pack(const struct connectx4lx_nv_config_host_2_bmc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_2_bmc_unpack(struct connectx4lx_nv_config_host_2_bmc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_2_bmc_print(const struct connectx4lx_nv_config_host_2_bmc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_host_2_bmc_size(void);
#define CONNECTX4LX_NV_CONFIG_HOST_2_BMC_SIZE    (0x4)
void connectx4lx_nv_config_host_2_bmc_dump(const struct connectx4lx_nv_config_host_2_bmc *ptr_struct, FILE* file);
/* nv_tlv_tweaks */
void connectx4lx_nv_tlv_tweaks_pack(const struct connectx4lx_nv_tlv_tweaks *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_tweaks_unpack(struct connectx4lx_nv_tlv_tweaks *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_tweaks_print(const struct connectx4lx_nv_tlv_tweaks *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_tweaks_size(void);
#define CONNECTX4LX_NV_TLV_TWEAKS_SIZE    (0x4)
void connectx4lx_nv_tlv_tweaks_dump(const struct connectx4lx_nv_tlv_tweaks *ptr_struct, FILE* file);
/* nv_sw_offload_conf */
void connectx4lx_nv_sw_offload_conf_pack(const struct connectx4lx_nv_sw_offload_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_sw_offload_conf_unpack(struct connectx4lx_nv_sw_offload_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_sw_offload_conf_print(const struct connectx4lx_nv_sw_offload_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_sw_offload_conf_size(void);
#define CONNECTX4LX_NV_SW_OFFLOAD_CONF_SIZE    (0x8)
void connectx4lx_nv_sw_offload_conf_dump(const struct connectx4lx_nv_sw_offload_conf *ptr_struct, FILE* file);
/* nv_roce_1_5_conf */
void connectx4lx_nv_roce_1_5_conf_pack(const struct connectx4lx_nv_roce_1_5_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_roce_1_5_conf_unpack(struct connectx4lx_nv_roce_1_5_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_roce_1_5_conf_print(const struct connectx4lx_nv_roce_1_5_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_roce_1_5_conf_size(void);
#define CONNECTX4LX_NV_ROCE_1_5_CONF_SIZE    (0x4)
void connectx4lx_nv_roce_1_5_conf_dump(const struct connectx4lx_nv_roce_1_5_conf *ptr_struct, FILE* file);
/* nv_mpfs_conf */
void connectx4lx_nv_mpfs_conf_pack(const struct connectx4lx_nv_mpfs_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_mpfs_conf_unpack(struct connectx4lx_nv_mpfs_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_mpfs_conf_print(const struct connectx4lx_nv_mpfs_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_mpfs_conf_size(void);
#define CONNECTX4LX_NV_MPFS_CONF_SIZE    (0x4)
void connectx4lx_nv_mpfs_conf_dump(const struct connectx4lx_nv_mpfs_conf *ptr_struct, FILE* file);
/* nv_qos_ets_tc_conf */
void connectx4lx_nv_qos_ets_tc_conf_pack(const struct connectx4lx_nv_qos_ets_tc_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_qos_ets_tc_conf_unpack(struct connectx4lx_nv_qos_ets_tc_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_qos_ets_tc_conf_print(const struct connectx4lx_nv_qos_ets_tc_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_qos_ets_tc_conf_size(void);
#define CONNECTX4LX_NV_QOS_ETS_TC_CONF_SIZE    (0x48)
void connectx4lx_nv_qos_ets_tc_conf_dump(const struct connectx4lx_nv_qos_ets_tc_conf *ptr_struct, FILE* file);
/* nv_qos_cap */
void connectx4lx_nv_qos_cap_pack(const struct connectx4lx_nv_qos_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_qos_cap_unpack(struct connectx4lx_nv_qos_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_qos_cap_print(const struct connectx4lx_nv_qos_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_qos_cap_size(void);
#define CONNECTX4LX_NV_QOS_CAP_SIZE    (0x4)
void connectx4lx_nv_qos_cap_dump(const struct connectx4lx_nv_qos_cap *ptr_struct, FILE* file);
/* nv_qos_conf */
void connectx4lx_nv_qos_conf_pack(const struct connectx4lx_nv_qos_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_qos_conf_unpack(struct connectx4lx_nv_qos_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_qos_conf_print(const struct connectx4lx_nv_qos_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_qos_conf_size(void);
#define CONNECTX4LX_NV_QOS_CONF_SIZE    (0xc)
void connectx4lx_nv_qos_conf_dump(const struct connectx4lx_nv_qos_conf *ptr_struct, FILE* file);
/* nv_lldp_nb_dcbx */
void connectx4lx_nv_lldp_nb_dcbx_pack(const struct connectx4lx_nv_lldp_nb_dcbx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_dcbx_unpack(struct connectx4lx_nv_lldp_nb_dcbx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_dcbx_print(const struct connectx4lx_nv_lldp_nb_dcbx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_lldp_nb_dcbx_size(void);
#define CONNECTX4LX_NV_LLDP_NB_DCBX_SIZE    (0x4)
void connectx4lx_nv_lldp_nb_dcbx_dump(const struct connectx4lx_nv_lldp_nb_dcbx *ptr_struct, FILE* file);
/* nv_lldp_nb_conf */
void connectx4lx_nv_lldp_nb_conf_pack(const struct connectx4lx_nv_lldp_nb_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_conf_unpack(struct connectx4lx_nv_lldp_nb_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_conf_print(const struct connectx4lx_nv_lldp_nb_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_lldp_nb_conf_size(void);
#define CONNECTX4LX_NV_LLDP_NB_CONF_SIZE    (0xc)
void connectx4lx_nv_lldp_nb_conf_dump(const struct connectx4lx_nv_lldp_nb_conf *ptr_struct, FILE* file);
/* nv_lldp_nb_cap */
void connectx4lx_nv_lldp_nb_cap_pack(const struct connectx4lx_nv_lldp_nb_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_cap_unpack(struct connectx4lx_nv_lldp_nb_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_lldp_nb_cap_print(const struct connectx4lx_nv_lldp_nb_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_lldp_nb_cap_size(void);
#define CONNECTX4LX_NV_LLDP_NB_CAP_SIZE    (0xc)
void connectx4lx_nv_lldp_nb_cap_dump(const struct connectx4lx_nv_lldp_nb_cap *ptr_struct, FILE* file);
/* nv_keep_link_up */
void connectx4lx_nv_keep_link_up_pack(const struct connectx4lx_nv_keep_link_up *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_keep_link_up_unpack(struct connectx4lx_nv_keep_link_up *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_keep_link_up_print(const struct connectx4lx_nv_keep_link_up *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_keep_link_up_size(void);
#define CONNECTX4LX_NV_KEEP_LINK_UP_SIZE    (0x4)
void connectx4lx_nv_keep_link_up_dump(const struct connectx4lx_nv_keep_link_up *ptr_struct, FILE* file);
/* nv_roce_cc_ecn */
void connectx4lx_nv_roce_cc_ecn_pack(const struct connectx4lx_nv_roce_cc_ecn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_roce_cc_ecn_unpack(struct connectx4lx_nv_roce_cc_ecn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_roce_cc_ecn_print(const struct connectx4lx_nv_roce_cc_ecn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_roce_cc_ecn_size(void);
#define CONNECTX4LX_NV_ROCE_CC_ECN_SIZE    (0x44)
void connectx4lx_nv_roce_cc_ecn_dump(const struct connectx4lx_nv_roce_cc_ecn *ptr_struct, FILE* file);
/* nv_roce_cc */
void connectx4lx_nv_roce_cc_pack(const struct connectx4lx_nv_roce_cc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_roce_cc_unpack(struct connectx4lx_nv_roce_cc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_roce_cc_print(const struct connectx4lx_nv_roce_cc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_roce_cc_size(void);
#define CONNECTX4LX_NV_ROCE_CC_SIZE    (0x4)
void connectx4lx_nv_roce_cc_dump(const struct connectx4lx_nv_roce_cc *ptr_struct, FILE* file);
/* pll_prj_ini_db */
void connectx4lx_pll_prj_ini_db_pack(const struct connectx4lx_pll_prj_ini_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pll_prj_ini_db_unpack(struct connectx4lx_pll_prj_ini_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pll_prj_ini_db_print(const struct connectx4lx_pll_prj_ini_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pll_prj_ini_db_size(void);
#define CONNECTX4LX_PLL_PRJ_INI_DB_SIZE    (0x4)
void connectx4lx_pll_prj_ini_db_dump(const struct connectx4lx_pll_prj_ini_db *ptr_struct, FILE* file);
/* itoc_param */
void connectx4lx_itoc_param_pack(const struct connectx4lx_itoc_param *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itoc_param_unpack(struct connectx4lx_itoc_param *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itoc_param_print(const struct connectx4lx_itoc_param *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itoc_param_size(void);
#define CONNECTX4LX_ITOC_PARAM_SIZE    (0x8)
void connectx4lx_itoc_param_dump(const struct connectx4lx_itoc_param *ptr_struct, FILE* file);
/* subroutines_db */
void connectx4lx_subroutines_db_pack(const union connectx4lx_subroutines_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_unpack(union connectx4lx_subroutines_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_subroutines_db_print(const union connectx4lx_subroutines_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_subroutines_db_size(void);
#define CONNECTX4LX_SUBROUTINES_DB_SIZE    (0x100)
void connectx4lx_subroutines_db_dump(const union connectx4lx_subroutines_db *ptr_struct, FILE* file);
/* sm_admin_ini */
void connectx4lx_sm_admin_ini_pack(const struct connectx4lx_sm_admin_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sm_admin_ini_unpack(struct connectx4lx_sm_admin_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sm_admin_ini_print(const struct connectx4lx_sm_admin_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sm_admin_ini_size(void);
#define CONNECTX4LX_SM_ADMIN_INI_SIZE    (0xd8)
void connectx4lx_sm_admin_ini_dump(const struct connectx4lx_sm_admin_ini *ptr_struct, FILE* file);
/* err_correction_cap */
void connectx4lx_err_correction_cap_pack(const struct connectx4lx_err_correction_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_err_correction_cap_unpack(struct connectx4lx_err_correction_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_err_correction_cap_print(const struct connectx4lx_err_correction_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_err_correction_cap_size(void);
#define CONNECTX4LX_ERR_CORRECTION_CAP_SIZE    (0x4)
void connectx4lx_err_correction_cap_dump(const struct connectx4lx_err_correction_cap *ptr_struct, FILE* file);
/* eth_speeds_supported */
void connectx4lx_eth_speeds_supported_pack(const struct connectx4lx_eth_speeds_supported *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_speeds_supported_unpack(struct connectx4lx_eth_speeds_supported *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_speeds_supported_print(const struct connectx4lx_eth_speeds_supported *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_speeds_supported_size(void);
#define CONNECTX4LX_ETH_SPEEDS_SUPPORTED_SIZE    (0x1)
void connectx4lx_eth_speeds_supported_dump(const struct connectx4lx_eth_speeds_supported *ptr_struct, FILE* file);
/* dword_val */
void connectx4lx_dword_val_pack(const struct connectx4lx_dword_val *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dword_val_unpack(struct connectx4lx_dword_val *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dword_val_print(const struct connectx4lx_dword_val *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dword_val_size(void);
#define CONNECTX4LX_DWORD_VAL_SIZE    (0x4)
void connectx4lx_dword_val_dump(const struct connectx4lx_dword_val *ptr_struct, FILE* file);
/* port_cap_mask1_fields */
void connectx4lx_port_cap_mask1_fields_pack(const struct connectx4lx_port_cap_mask1_fields *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_cap_mask1_fields_unpack(struct connectx4lx_port_cap_mask1_fields *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_cap_mask1_fields_print(const struct connectx4lx_port_cap_mask1_fields *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_cap_mask1_fields_size(void);
#define CONNECTX4LX_PORT_CAP_MASK1_FIELDS_SIZE    (0x4)
void connectx4lx_port_cap_mask1_fields_dump(const struct connectx4lx_port_cap_mask1_fields *ptr_struct, FILE* file);
/* dcr_odp_event_entry */
void connectx4lx_dcr_odp_event_entry_pack(const struct connectx4lx_dcr_odp_event_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcr_odp_event_entry_unpack(struct connectx4lx_dcr_odp_event_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcr_odp_event_entry_print(const struct connectx4lx_dcr_odp_event_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcr_odp_event_entry_size(void);
#define CONNECTX4LX_DCR_ODP_EVENT_ENTRY_SIZE    (0x4)
void connectx4lx_dcr_odp_event_entry_dump(const struct connectx4lx_dcr_odp_event_entry *ptr_struct, FILE* file);
/* flow_counter_list */
void connectx4lx_flow_counter_list_pack(const struct connectx4lx_flow_counter_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flow_counter_list_unpack(struct connectx4lx_flow_counter_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flow_counter_list_print(const struct connectx4lx_flow_counter_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flow_counter_list_size(void);
#define CONNECTX4LX_FLOW_COUNTER_LIST_SIZE    (0x8)
void connectx4lx_flow_counter_list_dump(const struct connectx4lx_flow_counter_list *ptr_struct, FILE* file);
/* dest_format_struct */
void connectx4lx_dest_format_struct_pack(const struct connectx4lx_dest_format_struct *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dest_format_struct_unpack(struct connectx4lx_dest_format_struct *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dest_format_struct_print(const struct connectx4lx_dest_format_struct *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dest_format_struct_size(void);
#define CONNECTX4LX_DEST_FORMAT_STRUCT_SIZE    (0x8)
void connectx4lx_dest_format_struct_dump(const struct connectx4lx_dest_format_struct *ptr_struct, FILE* file);
/* error_flow_trigger_tag_rxt */
void connectx4lx_error_flow_trigger_tag_rxt_pack(const struct connectx4lx_error_flow_trigger_tag_rxt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxt_unpack(struct connectx4lx_error_flow_trigger_tag_rxt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxt_print(const struct connectx4lx_error_flow_trigger_tag_rxt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_rxt_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_RXT_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_rxt_dump(const struct connectx4lx_error_flow_trigger_tag_rxt *ptr_struct, FILE* file);
/* error_flow_trigger_tag_sxw */
void connectx4lx_error_flow_trigger_tag_sxw_pack(const struct connectx4lx_error_flow_trigger_tag_sxw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_sxw_unpack(struct connectx4lx_error_flow_trigger_tag_sxw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_sxw_print(const struct connectx4lx_error_flow_trigger_tag_sxw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_sxw_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_SXW_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_sxw_dump(const struct connectx4lx_error_flow_trigger_tag_sxw *ptr_struct, FILE* file);
/* error_flow_trigger_tag_tpt */
void connectx4lx_error_flow_trigger_tag_tpt_pack(const struct connectx4lx_error_flow_trigger_tag_tpt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_tpt_unpack(struct connectx4lx_error_flow_trigger_tag_tpt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_tpt_print(const struct connectx4lx_error_flow_trigger_tag_tpt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_tpt_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_TPT_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_tpt_dump(const struct connectx4lx_error_flow_trigger_tag_tpt *ptr_struct, FILE* file);
/* error_flow_trigger_tag_tpt_memop */
void connectx4lx_error_flow_trigger_tag_tpt_memop_pack(const struct connectx4lx_error_flow_trigger_tag_tpt_memop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_tpt_memop_unpack(struct connectx4lx_error_flow_trigger_tag_tpt_memop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_tpt_memop_print(const struct connectx4lx_error_flow_trigger_tag_tpt_memop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_tpt_memop_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_TPT_MEMOP_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_tpt_memop_dump(const struct connectx4lx_error_flow_trigger_tag_tpt_memop *ptr_struct, FILE* file);
/* error_flow_trigger_tag_rxc */
void connectx4lx_error_flow_trigger_tag_rxc_pack(const struct connectx4lx_error_flow_trigger_tag_rxc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxc_unpack(struct connectx4lx_error_flow_trigger_tag_rxc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxc_print(const struct connectx4lx_error_flow_trigger_tag_rxc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_rxc_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_RXC_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_rxc_dump(const struct connectx4lx_error_flow_trigger_tag_rxc *ptr_struct, FILE* file);
/* error_flow_trigger_tag_rxw_fte */
void connectx4lx_error_flow_trigger_tag_rxw_fte_pack(const struct connectx4lx_error_flow_trigger_tag_rxw_fte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxw_fte_unpack(struct connectx4lx_error_flow_trigger_tag_rxw_fte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxw_fte_print(const struct connectx4lx_error_flow_trigger_tag_rxw_fte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_rxw_fte_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_RXW_FTE_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_rxw_fte_dump(const struct connectx4lx_error_flow_trigger_tag_rxw_fte *ptr_struct, FILE* file);
/* error_flow_trigger_tag_rxw_ldb */
void connectx4lx_error_flow_trigger_tag_rxw_ldb_pack(const struct connectx4lx_error_flow_trigger_tag_rxw_ldb *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxw_ldb_unpack(struct connectx4lx_error_flow_trigger_tag_rxw_ldb *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_rxw_ldb_print(const struct connectx4lx_error_flow_trigger_tag_rxw_ldb *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_rxw_ldb_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_RXW_LDB_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_rxw_ldb_dump(const struct connectx4lx_error_flow_trigger_tag_rxw_ldb *ptr_struct, FILE* file);
/* odp_hca_params */
void connectx4lx_odp_hca_params_pack(const struct connectx4lx_odp_hca_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_odp_hca_params_unpack(struct connectx4lx_odp_hca_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_odp_hca_params_print(const struct connectx4lx_odp_hca_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_odp_hca_params_size(void);
#define CONNECTX4LX_ODP_HCA_PARAMS_SIZE    (0x4)
void connectx4lx_odp_hca_params_dump(const struct connectx4lx_odp_hca_params *ptr_struct, FILE* file);
/* cmdif_ctx_special */
void connectx4lx_cmdif_ctx_special_pack(const union connectx4lx_cmdif_ctx_special *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_unpack(union connectx4lx_cmdif_ctx_special *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_special_print(const union connectx4lx_cmdif_ctx_special *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_special_size(void);
#define CONNECTX4LX_CMDIF_CTX_SPECIAL_SIZE    (0x20)
void connectx4lx_cmdif_ctx_special_dump(const union connectx4lx_cmdif_ctx_special *ptr_struct, FILE* file);
/* flush_type */
void connectx4lx_flush_type_pack(const union connectx4lx_flush_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flush_type_unpack(union connectx4lx_flush_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flush_type_print(const union connectx4lx_flush_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flush_type_size(void);
#define CONNECTX4LX_FLUSH_TYPE_SIZE    (0x4)
void connectx4lx_flush_type_dump(const union connectx4lx_flush_type *ptr_struct, FILE* file);
/* general_notification_delay_drop_event */
void connectx4lx_general_notification_delay_drop_event_pack(const struct connectx4lx_general_notification_delay_drop_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_general_notification_delay_drop_event_unpack(struct connectx4lx_general_notification_delay_drop_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_general_notification_delay_drop_event_print(const struct connectx4lx_general_notification_delay_drop_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_general_notification_delay_drop_event_size(void);
#define CONNECTX4LX_GENERAL_NOTIFICATION_DELAY_DROP_EVENT_SIZE    (0x1c)
void connectx4lx_general_notification_delay_drop_event_dump(const struct connectx4lx_general_notification_delay_drop_event *ptr_struct, FILE* file);
/* pps_event */
void connectx4lx_pps_event_pack(const struct connectx4lx_pps_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pps_event_unpack(struct connectx4lx_pps_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pps_event_print(const struct connectx4lx_pps_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pps_event_size(void);
#define CONNECTX4LX_PPS_EVENT_SIZE    (0x1c)
void connectx4lx_pps_event_dump(const struct connectx4lx_pps_event *ptr_struct, FILE* file);
/* fpga_qp_error_event */
void connectx4lx_fpga_qp_error_event_pack(const struct connectx4lx_fpga_qp_error_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_qp_error_event_unpack(struct connectx4lx_fpga_qp_error_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_qp_error_event_print(const struct connectx4lx_fpga_qp_error_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_qp_error_event_size(void);
#define CONNECTX4LX_FPGA_QP_ERROR_EVENT_SIZE    (0x1c)
void connectx4lx_fpga_qp_error_event_dump(const struct connectx4lx_fpga_qp_error_event *ptr_struct, FILE* file);
/* fpga_error_event */
void connectx4lx_fpga_error_event_pack(const struct connectx4lx_fpga_error_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_error_event_unpack(struct connectx4lx_fpga_error_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_error_event_print(const struct connectx4lx_fpga_error_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_error_event_size(void);
#define CONNECTX4LX_FPGA_ERROR_EVENT_SIZE    (0x1c)
void connectx4lx_fpga_error_event_dump(const struct connectx4lx_fpga_error_event *ptr_struct, FILE* file);
/* nic_vport_change_event */
void connectx4lx_nic_vport_change_event_pack(const struct connectx4lx_nic_vport_change_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nic_vport_change_event_unpack(struct connectx4lx_nic_vport_change_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nic_vport_change_event_print(const struct connectx4lx_nic_vport_change_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nic_vport_change_event_size(void);
#define CONNECTX4LX_NIC_VPORT_CHANGE_EVENT_SIZE    (0x1c)
void connectx4lx_nic_vport_change_event_dump(const struct connectx4lx_nic_vport_change_event *ptr_struct, FILE* file);
/* pages_req_event */
void connectx4lx_pages_req_event_pack(const struct connectx4lx_pages_req_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pages_req_event_unpack(struct connectx4lx_pages_req_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pages_req_event_print(const struct connectx4lx_pages_req_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pages_req_event_size(void);
#define CONNECTX4LX_PAGES_REQ_EVENT_SIZE    (0x1c)
void connectx4lx_pages_req_event_dump(const struct connectx4lx_pages_req_event *ptr_struct, FILE* file);
/* cmd_inter_comp_event */
void connectx4lx_cmd_inter_comp_event_pack(const struct connectx4lx_cmd_inter_comp_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmd_inter_comp_event_unpack(struct connectx4lx_cmd_inter_comp_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmd_inter_comp_event_print(const struct connectx4lx_cmd_inter_comp_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmd_inter_comp_event_size(void);
#define CONNECTX4LX_CMD_INTER_COMP_EVENT_SIZE    (0x1c)
void connectx4lx_cmd_inter_comp_event_dump(const struct connectx4lx_cmd_inter_comp_event *ptr_struct, FILE* file);
/* stall_vl_event */
void connectx4lx_stall_vl_event_pack(const struct connectx4lx_stall_vl_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_stall_vl_event_unpack(struct connectx4lx_stall_vl_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_stall_vl_event_print(const struct connectx4lx_stall_vl_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_stall_vl_event_size(void);
#define CONNECTX4LX_STALL_VL_EVENT_SIZE    (0x18)
void connectx4lx_stall_vl_event_dump(const struct connectx4lx_stall_vl_event *ptr_struct, FILE* file);
/* db_bf_congestion_event */
void connectx4lx_db_bf_congestion_event_pack(const struct connectx4lx_db_bf_congestion_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_db_bf_congestion_event_unpack(struct connectx4lx_db_bf_congestion_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_db_bf_congestion_event_print(const struct connectx4lx_db_bf_congestion_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_db_bf_congestion_event_size(void);
#define CONNECTX4LX_DB_BF_CONGESTION_EVENT_SIZE    (0x18)
void connectx4lx_db_bf_congestion_event_dump(const struct connectx4lx_db_bf_congestion_event *ptr_struct, FILE* file);
/* temp_warning_event */
void connectx4lx_temp_warning_event_pack(const struct connectx4lx_temp_warning_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_temp_warning_event_unpack(struct connectx4lx_temp_warning_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_temp_warning_event_print(const struct connectx4lx_temp_warning_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_temp_warning_event_size(void);
#define CONNECTX4LX_TEMP_WARNING_EVENT_SIZE    (0x10)
void connectx4lx_temp_warning_event_dump(const struct connectx4lx_temp_warning_event *ptr_struct, FILE* file);
/* dcbx_change_event */
void connectx4lx_dcbx_change_event_pack(const struct connectx4lx_dcbx_change_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_change_event_unpack(struct connectx4lx_dcbx_change_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_change_event_print(const struct connectx4lx_dcbx_change_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_change_event_size(void);
#define CONNECTX4LX_DCBX_CHANGE_EVENT_SIZE    (0x1c)
void connectx4lx_dcbx_change_event_dump(const struct connectx4lx_dcbx_change_event *ptr_struct, FILE* file);
/* port_module_event */
void connectx4lx_port_module_event_pack(const struct connectx4lx_port_module_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_module_event_unpack(struct connectx4lx_port_module_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_module_event_print(const struct connectx4lx_port_module_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_module_event_size(void);
#define CONNECTX4LX_PORT_MODULE_EVENT_SIZE    (0x1c)
void connectx4lx_port_module_event_dump(const struct connectx4lx_port_module_event *ptr_struct, FILE* file);
/* gpio_event */
void connectx4lx_gpio_event_pack(const struct connectx4lx_gpio_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gpio_event_unpack(struct connectx4lx_gpio_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gpio_event_print(const struct connectx4lx_gpio_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gpio_event_size(void);
#define CONNECTX4LX_GPIO_EVENT_SIZE    (0x1c)
void connectx4lx_gpio_event_dump(const struct connectx4lx_gpio_event *ptr_struct, FILE* file);
/* port_state_change_event */
void connectx4lx_port_state_change_event_pack(const struct connectx4lx_port_state_change_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_state_change_event_unpack(struct connectx4lx_port_state_change_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_state_change_event_print(const struct connectx4lx_port_state_change_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_state_change_event_size(void);
#define CONNECTX4LX_PORT_STATE_CHANGE_EVENT_SIZE    (0x1c)
void connectx4lx_port_state_change_event_dump(const struct connectx4lx_port_state_change_event *ptr_struct, FILE* file);
/* dropped_packet_logged */
void connectx4lx_dropped_packet_logged_pack(const struct connectx4lx_dropped_packet_logged *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dropped_packet_logged_unpack(struct connectx4lx_dropped_packet_logged *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dropped_packet_logged_print(const struct connectx4lx_dropped_packet_logged *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dropped_packet_logged_size(void);
#define CONNECTX4LX_DROPPED_PACKET_LOGGED_SIZE    (0x1c)
void connectx4lx_dropped_packet_logged_dump(const struct connectx4lx_dropped_packet_logged *ptr_struct, FILE* file);
/* cq_error */
void connectx4lx_cq_error_pack(const struct connectx4lx_cq_error *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cq_error_unpack(struct connectx4lx_cq_error *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cq_error_print(const struct connectx4lx_cq_error *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cq_error_size(void);
#define CONNECTX4LX_CQ_ERROR_SIZE    (0x1c)
void connectx4lx_cq_error_dump(const struct connectx4lx_cq_error *ptr_struct, FILE* file);
/* rdma_page_fault_event */
void connectx4lx_rdma_page_fault_event_pack(const struct connectx4lx_rdma_page_fault_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rdma_page_fault_event_unpack(struct connectx4lx_rdma_page_fault_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rdma_page_fault_event_print(const struct connectx4lx_rdma_page_fault_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rdma_page_fault_event_size(void);
#define CONNECTX4LX_RDMA_PAGE_FAULT_EVENT_SIZE    (0x1c)
void connectx4lx_rdma_page_fault_event_dump(const struct connectx4lx_rdma_page_fault_event *ptr_struct, FILE* file);
/* wqe_associated_page_fault_event */
void connectx4lx_wqe_associated_page_fault_event_pack(const struct connectx4lx_wqe_associated_page_fault_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_associated_page_fault_event_unpack(struct connectx4lx_wqe_associated_page_fault_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_associated_page_fault_event_print(const struct connectx4lx_wqe_associated_page_fault_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_associated_page_fault_event_size(void);
#define CONNECTX4LX_WQE_ASSOCIATED_PAGE_FAULT_EVENT_SIZE    (0x1c)
void connectx4lx_wqe_associated_page_fault_event_dump(const struct connectx4lx_wqe_associated_page_fault_event *ptr_struct, FILE* file);
/* qp_events */
void connectx4lx_qp_events_pack(const struct connectx4lx_qp_events *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qp_events_unpack(struct connectx4lx_qp_events *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qp_events_print(const struct connectx4lx_qp_events *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qp_events_size(void);
#define CONNECTX4LX_QP_EVENTS_SIZE    (0x1c)
void connectx4lx_qp_events_dump(const struct connectx4lx_qp_events *ptr_struct, FILE* file);
/* dct_events */
void connectx4lx_dct_events_pack(const struct connectx4lx_dct_events *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dct_events_unpack(struct connectx4lx_dct_events *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dct_events_print(const struct connectx4lx_dct_events *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dct_events_size(void);
#define CONNECTX4LX_DCT_EVENTS_SIZE    (0x1c)
void connectx4lx_dct_events_dump(const struct connectx4lx_dct_events *ptr_struct, FILE* file);
/* comp_event */
void connectx4lx_comp_event_pack(const struct connectx4lx_comp_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_comp_event_unpack(struct connectx4lx_comp_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_comp_event_print(const struct connectx4lx_comp_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_comp_event_size(void);
#define CONNECTX4LX_COMP_EVENT_SIZE    (0x1c)
void connectx4lx_comp_event_dump(const struct connectx4lx_comp_event *ptr_struct, FILE* file);
/* sw_eqe_flat_data */
void connectx4lx_sw_eqe_flat_data_pack(const struct connectx4lx_sw_eqe_flat_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_eqe_flat_data_unpack(struct connectx4lx_sw_eqe_flat_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_eqe_flat_data_print(const struct connectx4lx_sw_eqe_flat_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_eqe_flat_data_size(void);
#define CONNECTX4LX_SW_EQE_FLAT_DATA_SIZE    (0x1c)
void connectx4lx_sw_eqe_flat_data_dump(const struct connectx4lx_sw_eqe_flat_data *ptr_struct, FILE* file);
/* ph_oem_resp */
void connectx4lx_ph_oem_resp_pack(const union connectx4lx_ph_oem_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ph_oem_resp_unpack(union connectx4lx_ph_oem_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ph_oem_resp_print(const union connectx4lx_ph_oem_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ph_oem_resp_size(void);
#define CONNECTX4LX_PH_OEM_RESP_SIZE    (0x100)
void connectx4lx_ph_oem_resp_dump(const union connectx4lx_ph_oem_resp *ptr_struct, FILE* file);
/* lled_oem_resp */
void connectx4lx_lled_oem_resp_pack(const union connectx4lx_lled_oem_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_oem_resp_unpack(union connectx4lx_lled_oem_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_oem_resp_print(const union connectx4lx_lled_oem_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_oem_resp_size(void);
#define CONNECTX4LX_LLED_OEM_RESP_SIZE    (0x100)
void connectx4lx_lled_oem_resp_dump(const union connectx4lx_lled_oem_resp *ptr_struct, FILE* file);
/* mlnx_oem_resp */
void connectx4lx_mlnx_oem_resp_pack(const union connectx4lx_mlnx_oem_resp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_unpack(union connectx4lx_mlnx_oem_resp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_resp_print(const union connectx4lx_mlnx_oem_resp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_resp_size(void);
#define CONNECTX4LX_MLNX_OEM_RESP_SIZE    (0x100)
void connectx4lx_mlnx_oem_resp_dump(const union connectx4lx_mlnx_oem_resp *ptr_struct, FILE* file);
/* get_pt_stat */
void connectx4lx_get_pt_stat_pack(const struct connectx4lx_get_pt_stat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_pt_stat_unpack(struct connectx4lx_get_pt_stat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_pt_stat_print(const struct connectx4lx_get_pt_stat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_pt_stat_size(void);
#define CONNECTX4LX_GET_PT_STAT_SIZE    (0x2c)
void connectx4lx_get_pt_stat_dump(const struct connectx4lx_get_pt_stat *ptr_struct, FILE* file);
/* get_control_stat */
void connectx4lx_get_control_stat_pack(const struct connectx4lx_get_control_stat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_control_stat_unpack(struct connectx4lx_get_control_stat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_control_stat_print(const struct connectx4lx_get_control_stat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_control_stat_size(void);
#define CONNECTX4LX_GET_CONTROL_STAT_SIZE    (0x1c)
void connectx4lx_get_control_stat_dump(const struct connectx4lx_get_control_stat *ptr_struct, FILE* file);
/* get_port_stat */
void connectx4lx_get_port_stat_pack(const struct connectx4lx_get_port_stat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_port_stat_unpack(struct connectx4lx_get_port_stat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_port_stat_print(const struct connectx4lx_get_port_stat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_port_stat_size(void);
#define CONNECTX4LX_GET_PORT_STAT_SIZE    (0xc8)
void connectx4lx_get_port_stat_dump(const struct connectx4lx_get_port_stat *ptr_struct, FILE* file);
/* get_capabilities */
void connectx4lx_get_capabilities_pack(const struct connectx4lx_get_capabilities *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_capabilities_unpack(struct connectx4lx_get_capabilities *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_capabilities_print(const struct connectx4lx_get_capabilities *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_capabilities_size(void);
#define CONNECTX4LX_GET_CAPABILITIES_SIZE    (0x1c)
void connectx4lx_get_capabilities_dump(const struct connectx4lx_get_capabilities *ptr_struct, FILE* file);
/* get_version_id */
void connectx4lx_get_version_id_pack(const struct connectx4lx_get_version_id *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_version_id_unpack(struct connectx4lx_get_version_id *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_version_id_print(const struct connectx4lx_get_version_id *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_version_id_size(void);
#define CONNECTX4LX_GET_VERSION_ID_SIZE    (0x24)
void connectx4lx_get_version_id_dump(const struct connectx4lx_get_version_id *ptr_struct, FILE* file);
/* get_params_response */
void connectx4lx_get_params_response_pack(const struct connectx4lx_get_params_response *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_params_response_unpack(struct connectx4lx_get_params_response *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_params_response_print(const struct connectx4lx_get_params_response *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_params_response_size(void);
#define CONNECTX4LX_GET_PARAMS_RESPONSE_SIZE    (0x80)
void connectx4lx_get_params_response_dump(const struct connectx4lx_get_params_response *ptr_struct, FILE* file);
/* get_link_status_response */
void connectx4lx_get_link_status_response_pack(const struct connectx4lx_get_link_status_response *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_get_link_status_response_unpack(struct connectx4lx_get_link_status_response *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_get_link_status_response_print(const struct connectx4lx_get_link_status_response *ptr_struct, FILE* file, int indent_level);
int connectx4lx_get_link_status_response_size(void);
#define CONNECTX4LX_GET_LINK_STATUS_RESPONSE_SIZE    (0xc)
void connectx4lx_get_link_status_response_dump(const struct connectx4lx_get_link_status_response *ptr_struct, FILE* file);
/* ph_oem_cmd */
void connectx4lx_ph_oem_cmd_pack(const union connectx4lx_ph_oem_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ph_oem_cmd_unpack(union connectx4lx_ph_oem_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ph_oem_cmd_print(const union connectx4lx_ph_oem_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ph_oem_cmd_size(void);
#define CONNECTX4LX_PH_OEM_CMD_SIZE    (0x100)
void connectx4lx_ph_oem_cmd_dump(const union connectx4lx_ph_oem_cmd *ptr_struct, FILE* file);
/* lled_oem_cmd */
void connectx4lx_lled_oem_cmd_pack(const union connectx4lx_lled_oem_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lled_oem_cmd_unpack(union connectx4lx_lled_oem_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lled_oem_cmd_print(const union connectx4lx_lled_oem_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lled_oem_cmd_size(void);
#define CONNECTX4LX_LLED_OEM_CMD_SIZE    (0x100)
void connectx4lx_lled_oem_cmd_dump(const union connectx4lx_lled_oem_cmd *ptr_struct, FILE* file);
/* mlnx_oem_cmd */
void connectx4lx_mlnx_oem_cmd_pack(const union connectx4lx_mlnx_oem_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_unpack(union connectx4lx_mlnx_oem_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlnx_oem_cmd_print(const union connectx4lx_mlnx_oem_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlnx_oem_cmd_size(void);
#define CONNECTX4LX_MLNX_OEM_CMD_SIZE    (0x100)
void connectx4lx_mlnx_oem_cmd_dump(const union connectx4lx_mlnx_oem_cmd *ptr_struct, FILE* file);
/* set_ncsi_flow_control */
void connectx4lx_set_ncsi_flow_control_pack(const struct connectx4lx_set_ncsi_flow_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_ncsi_flow_control_unpack(struct connectx4lx_set_ncsi_flow_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_ncsi_flow_control_print(const struct connectx4lx_set_ncsi_flow_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_ncsi_flow_control_size(void);
#define CONNECTX4LX_SET_NCSI_FLOW_CONTROL_SIZE    (0x4)
void connectx4lx_set_ncsi_flow_control_dump(const struct connectx4lx_set_ncsi_flow_control *ptr_struct, FILE* file);
/* disable_channel */
void connectx4lx_disable_channel_pack(const struct connectx4lx_disable_channel *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_disable_channel_unpack(struct connectx4lx_disable_channel *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_disable_channel_print(const struct connectx4lx_disable_channel *ptr_struct, FILE* file, int indent_level);
int connectx4lx_disable_channel_size(void);
#define CONNECTX4LX_DISABLE_CHANNEL_SIZE    (0x4)
void connectx4lx_disable_channel_dump(const struct connectx4lx_disable_channel *ptr_struct, FILE* file);
/* aen_enable */
void connectx4lx_aen_enable_pack(const struct connectx4lx_aen_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_aen_enable_unpack(struct connectx4lx_aen_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_aen_enable_print(const struct connectx4lx_aen_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_aen_enable_size(void);
#define CONNECTX4LX_AEN_ENABLE_SIZE    (0x8)
void connectx4lx_aen_enable_dump(const struct connectx4lx_aen_enable *ptr_struct, FILE* file);
/* set_link_cmd_payload */
void connectx4lx_set_link_cmd_payload_pack(const struct connectx4lx_set_link_cmd_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_link_cmd_payload_unpack(struct connectx4lx_set_link_cmd_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_link_cmd_payload_print(const struct connectx4lx_set_link_cmd_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_link_cmd_payload_size(void);
#define CONNECTX4LX_SET_LINK_CMD_PAYLOAD_SIZE    (0x8)
void connectx4lx_set_link_cmd_payload_dump(const struct connectx4lx_set_link_cmd_payload *ptr_struct, FILE* file);
/* enable_vlan_cmd_payload */
void connectx4lx_enable_vlan_cmd_payload_pack(const struct connectx4lx_enable_vlan_cmd_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_enable_vlan_cmd_payload_unpack(struct connectx4lx_enable_vlan_cmd_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_enable_vlan_cmd_payload_print(const struct connectx4lx_enable_vlan_cmd_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_enable_vlan_cmd_payload_size(void);
#define CONNECTX4LX_ENABLE_VLAN_CMD_PAYLOAD_SIZE    (0x4)
void connectx4lx_enable_vlan_cmd_payload_dump(const struct connectx4lx_enable_vlan_cmd_payload *ptr_struct, FILE* file);
/* set_vlan_cmd_payload */
void connectx4lx_set_vlan_cmd_payload_pack(const struct connectx4lx_set_vlan_cmd_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_vlan_cmd_payload_unpack(struct connectx4lx_set_vlan_cmd_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_vlan_cmd_payload_print(const struct connectx4lx_set_vlan_cmd_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_vlan_cmd_payload_size(void);
#define CONNECTX4LX_SET_VLAN_CMD_PAYLOAD_SIZE    (0x8)
void connectx4lx_set_vlan_cmd_payload_dump(const struct connectx4lx_set_vlan_cmd_payload *ptr_struct, FILE* file);
/* set_mac_cmd_payload */
void connectx4lx_set_mac_cmd_payload_pack(const struct connectx4lx_set_mac_cmd_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_set_mac_cmd_payload_unpack(struct connectx4lx_set_mac_cmd_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_set_mac_cmd_payload_print(const struct connectx4lx_set_mac_cmd_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_set_mac_cmd_payload_size(void);
#define CONNECTX4LX_SET_MAC_CMD_PAYLOAD_SIZE    (0x8)
void connectx4lx_set_mac_cmd_payload_dump(const struct connectx4lx_set_mac_cmd_payload *ptr_struct, FILE* file);
/* generic_flash_reg_access_data */
void connectx4lx_generic_flash_reg_access_data_pack(const struct connectx4lx_generic_flash_reg_access_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_generic_flash_reg_access_data_unpack(struct connectx4lx_generic_flash_reg_access_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_generic_flash_reg_access_data_print(const struct connectx4lx_generic_flash_reg_access_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_generic_flash_reg_access_data_size(void);
#define CONNECTX4LX_GENERIC_FLASH_REG_ACCESS_DATA_SIZE    (0x10c)
void connectx4lx_generic_flash_reg_access_data_dump(const struct connectx4lx_generic_flash_reg_access_data *ptr_struct, FILE* file);
/* access_register_data_layout */
void connectx4lx_access_register_data_layout_pack(const union connectx4lx_access_register_data_layout *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_access_register_data_layout_unpack(union connectx4lx_access_register_data_layout *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_access_register_data_layout_print(const union connectx4lx_access_register_data_layout *ptr_struct, FILE* file, int indent_level);
int connectx4lx_access_register_data_layout_size(void);
#define CONNECTX4LX_ACCESS_REGISTER_DATA_LAYOUT_SIZE    (0x108)
void connectx4lx_access_register_data_layout_dump(const union connectx4lx_access_register_data_layout *ptr_struct, FILE* file);
/* scheduling_context */
void connectx4lx_scheduling_context_pack(const struct connectx4lx_scheduling_context *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_scheduling_context_unpack(struct connectx4lx_scheduling_context *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_scheduling_context_print(const struct connectx4lx_scheduling_context *ptr_struct, FILE* file, int indent_level);
int connectx4lx_scheduling_context_size(void);
#define CONNECTX4LX_SCHEDULING_CONTEXT_SIZE    (0x40)
void connectx4lx_scheduling_context_dump(const struct connectx4lx_scheduling_context *ptr_struct, FILE* file);
/* fw_ipoib_meta */
void connectx4lx_fw_ipoib_meta_pack(const struct connectx4lx_fw_ipoib_meta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_ipoib_meta_unpack(struct connectx4lx_fw_ipoib_meta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_ipoib_meta_print(const struct connectx4lx_fw_ipoib_meta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_ipoib_meta_size(void);
#define CONNECTX4LX_FW_IPOIB_META_SIZE    (0x10)
void connectx4lx_fw_ipoib_meta_dump(const struct connectx4lx_fw_ipoib_meta *ptr_struct, FILE* file);
/* fw_q_counters */
void connectx4lx_fw_q_counters_pack(const struct connectx4lx_fw_q_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_q_counters_unpack(struct connectx4lx_fw_q_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_q_counters_print(const struct connectx4lx_fw_q_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_q_counters_size(void);
#define CONNECTX4LX_FW_Q_COUNTERS_SIZE    (0x40)
void connectx4lx_fw_q_counters_dump(const struct connectx4lx_fw_q_counters *ptr_struct, FILE* file);
/* fw_transport_domain */
void connectx4lx_fw_transport_domain_pack(const struct connectx4lx_fw_transport_domain *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_transport_domain_unpack(struct connectx4lx_fw_transport_domain *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_transport_domain_print(const struct connectx4lx_fw_transport_domain *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_transport_domain_size(void);
#define CONNECTX4LX_FW_TRANSPORT_DOMAIN_SIZE    (0x8)
void connectx4lx_fw_transport_domain_dump(const struct connectx4lx_fw_transport_domain *ptr_struct, FILE* file);
/* vqos_arb_ctx */
void connectx4lx_vqos_arb_ctx_pack(const struct connectx4lx_vqos_arb_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vqos_arb_ctx_unpack(struct connectx4lx_vqos_arb_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vqos_arb_ctx_print(const struct connectx4lx_vqos_arb_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vqos_arb_ctx_size(void);
#define CONNECTX4LX_VQOS_ARB_CTX_SIZE    (0x20)
void connectx4lx_vqos_arb_ctx_dump(const struct connectx4lx_vqos_arb_ctx *ptr_struct, FILE* file);
/* dc_control_packet_desc */
void connectx4lx_dc_control_packet_desc_pack(const struct connectx4lx_dc_control_packet_desc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dc_control_packet_desc_unpack(struct connectx4lx_dc_control_packet_desc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dc_control_packet_desc_print(const struct connectx4lx_dc_control_packet_desc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dc_control_packet_desc_size(void);
#define CONNECTX4LX_DC_CONTROL_PACKET_DESC_SIZE    (0x40)
void connectx4lx_dc_control_packet_desc_dump(const struct connectx4lx_dc_control_packet_desc *ptr_struct, FILE* file);
/* dmfs_resources */
void connectx4lx_dmfs_resources_pack(const union connectx4lx_dmfs_resources *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_resources_unpack(union connectx4lx_dmfs_resources *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_resources_print(const union connectx4lx_dmfs_resources *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_resources_size(void);
#define CONNECTX4LX_DMFS_RESOURCES_SIZE    (0x40)
void connectx4lx_dmfs_resources_dump(const union connectx4lx_dmfs_resources *ptr_struct, FILE* file);
/* list_element */
void connectx4lx_list_element_pack(const struct connectx4lx_list_element *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_list_element_unpack(struct connectx4lx_list_element *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_list_element_print(const struct connectx4lx_list_element *ptr_struct, FILE* file, int indent_level);
int connectx4lx_list_element_size(void);
#define CONNECTX4LX_LIST_ELEMENT_SIZE    (0x8)
void connectx4lx_list_element_dump(const struct connectx4lx_list_element *ptr_struct, FILE* file);
/* fw_rqt */
void connectx4lx_fw_rqt_pack(const struct connectx4lx_fw_rqt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_rqt_unpack(struct connectx4lx_fw_rqt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_rqt_print(const struct connectx4lx_fw_rqt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_rqt_size(void);
#define CONNECTX4LX_FW_RQT_SIZE    (0x20)
void connectx4lx_fw_rqt_dump(const struct connectx4lx_fw_rqt *ptr_struct, FILE* file);
/* fw_cqc */
void connectx4lx_fw_cqc_pack(const struct connectx4lx_fw_cqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_cqc_unpack(struct connectx4lx_fw_cqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_cqc_print(const struct connectx4lx_fw_cqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_cqc_size(void);
#define CONNECTX4LX_FW_CQC_SIZE    (0x10)
void connectx4lx_fw_cqc_dump(const struct connectx4lx_fw_cqc *ptr_struct, FILE* file);
/* fw_psv */
void connectx4lx_fw_psv_pack(const struct connectx4lx_fw_psv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_psv_unpack(struct connectx4lx_fw_psv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_psv_print(const struct connectx4lx_fw_psv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_psv_size(void);
#define CONNECTX4LX_FW_PSV_SIZE    (0x4)
void connectx4lx_fw_psv_dump(const struct connectx4lx_fw_psv *ptr_struct, FILE* file);
/* fw_mkc */
void connectx4lx_fw_mkc_pack(const struct connectx4lx_fw_mkc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_mkc_unpack(struct connectx4lx_fw_mkc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_mkc_print(const struct connectx4lx_fw_mkc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_mkc_size(void);
#define CONNECTX4LX_FW_MKC_SIZE    (0x10)
void connectx4lx_fw_mkc_dump(const struct connectx4lx_fw_mkc *ptr_struct, FILE* file);
/* fw_cre */
void connectx4lx_fw_cre_pack(const union connectx4lx_fw_cre *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_cre_unpack(union connectx4lx_fw_cre *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_cre_print(const union connectx4lx_fw_cre *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_cre_size(void);
#define CONNECTX4LX_FW_CRE_SIZE    (0x40)
void connectx4lx_fw_cre_dump(const union connectx4lx_fw_cre *ptr_struct, FILE* file);
/* fw_basic_res_ctx */
void connectx4lx_fw_basic_res_ctx_pack(const struct connectx4lx_fw_basic_res_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_basic_res_ctx_unpack(struct connectx4lx_fw_basic_res_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_basic_res_ctx_print(const struct connectx4lx_fw_basic_res_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_basic_res_ctx_size(void);
#define CONNECTX4LX_FW_BASIC_RES_CTX_SIZE    (0x4)
void connectx4lx_fw_basic_res_ctx_dump(const struct connectx4lx_fw_basic_res_ctx *ptr_struct, FILE* file);
/* fw_alt_path */
void connectx4lx_fw_alt_path_pack(const struct connectx4lx_fw_alt_path *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_alt_path_unpack(struct connectx4lx_fw_alt_path *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_alt_path_print(const struct connectx4lx_fw_alt_path *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_alt_path_size(void);
#define CONNECTX4LX_FW_ALT_PATH_SIZE    (0x30)
void connectx4lx_fw_alt_path_dump(const struct connectx4lx_fw_alt_path *ptr_struct, FILE* file);
/* fw_eqc */
void connectx4lx_fw_eqc_pack(const struct connectx4lx_fw_eqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_eqc_unpack(struct connectx4lx_fw_eqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_eqc_print(const struct connectx4lx_fw_eqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_eqc_size(void);
#define CONNECTX4LX_FW_EQC_SIZE    (0x10)
void connectx4lx_fw_eqc_dump(const struct connectx4lx_fw_eqc *ptr_struct, FILE* file);
/* hw_gvmi_counter */
void connectx4lx_hw_gvmi_counter_pack(const struct connectx4lx_hw_gvmi_counter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_gvmi_counter_unpack(struct connectx4lx_hw_gvmi_counter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_gvmi_counter_print(const struct connectx4lx_hw_gvmi_counter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_gvmi_counter_size(void);
#define CONNECTX4LX_HW_GVMI_COUNTER_SIZE    (0x10)
void connectx4lx_hw_gvmi_counter_dump(const struct connectx4lx_hw_gvmi_counter *ptr_struct, FILE* file);
/* hw_qp_counter */
void connectx4lx_hw_qp_counter_pack(const struct connectx4lx_hw_qp_counter *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_qp_counter_unpack(struct connectx4lx_hw_qp_counter *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_qp_counter_print(const struct connectx4lx_hw_qp_counter *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_qp_counter_size(void);
#define CONNECTX4LX_HW_QP_COUNTER_SIZE    (0x20)
void connectx4lx_hw_qp_counter_dump(const struct connectx4lx_hw_qp_counter *ptr_struct, FILE* file);
/* gid_mac_table_entry */
void connectx4lx_gid_mac_table_entry_pack(const struct connectx4lx_gid_mac_table_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gid_mac_table_entry_unpack(struct connectx4lx_gid_mac_table_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gid_mac_table_entry_print(const struct connectx4lx_gid_mac_table_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gid_mac_table_entry_size(void);
#define CONNECTX4LX_GID_MAC_TABLE_ENTRY_SIZE    (0x20)
void connectx4lx_gid_mac_table_entry_dump(const struct connectx4lx_gid_mac_table_entry *ptr_struct, FILE* file);
/* hw_msix */
void connectx4lx_hw_msix_pack(const struct connectx4lx_hw_msix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_msix_unpack(struct connectx4lx_hw_msix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_msix_print(const struct connectx4lx_hw_msix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_msix_size(void);
#define CONNECTX4LX_HW_MSIX_SIZE    (0x20)
void connectx4lx_hw_msix_dump(const struct connectx4lx_hw_msix *ptr_struct, FILE* file);
/* hw_rdb */
void connectx4lx_hw_rdb_pack(const struct connectx4lx_hw_rdb *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_rdb_unpack(struct connectx4lx_hw_rdb *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_rdb_print(const struct connectx4lx_hw_rdb *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_rdb_size(void);
#define CONNECTX4LX_HW_RDB_SIZE    (0x40)
void connectx4lx_hw_rdb_dump(const struct connectx4lx_hw_rdb *ptr_struct, FILE* file);
/* icm_mtt */
void connectx4lx_icm_mtt_pack(const union connectx4lx_icm_mtt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icm_mtt_unpack(union connectx4lx_icm_mtt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icm_mtt_print(const union connectx4lx_icm_mtt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icm_mtt_size(void);
#define CONNECTX4LX_ICM_MTT_SIZE    (0x8)
void connectx4lx_icm_mtt_dump(const union connectx4lx_icm_mtt *ptr_struct, FILE* file);
/* steering_entry_icmc */
void connectx4lx_steering_entry_icmc_pack(const union connectx4lx_steering_entry_icmc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_steering_entry_icmc_unpack(union connectx4lx_steering_entry_icmc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_steering_entry_icmc_print(const union connectx4lx_steering_entry_icmc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_steering_entry_icmc_size(void);
#define CONNECTX4LX_STEERING_ENTRY_ICMC_SIZE    (0x40)
void connectx4lx_steering_entry_icmc_dump(const union connectx4lx_steering_entry_icmc *ptr_struct, FILE* file);
/* hw_pkey */
void connectx4lx_hw_pkey_pack(const struct connectx4lx_hw_pkey *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_pkey_unpack(struct connectx4lx_hw_pkey *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_pkey_print(const struct connectx4lx_hw_pkey *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_pkey_size(void);
#define CONNECTX4LX_HW_PKEY_SIZE    (0x4)
void connectx4lx_hw_pkey_dump(const struct connectx4lx_hw_pkey *ptr_struct, FILE* file);
/* hw_timer_32 */
void connectx4lx_hw_timer_32_pack(const struct connectx4lx_hw_timer_32 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_timer_32_unpack(struct connectx4lx_hw_timer_32 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_timer_32_print(const struct connectx4lx_hw_timer_32 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_timer_32_size(void);
#define CONNECTX4LX_HW_TIMER_32_SIZE    (0x4)
void connectx4lx_hw_timer_32_dump(const struct connectx4lx_hw_timer_32 *ptr_struct, FILE* file);
/* hw_sq_qp_list */
void connectx4lx_hw_sq_qp_list_pack(const struct connectx4lx_hw_sq_qp_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_sq_qp_list_unpack(struct connectx4lx_hw_sq_qp_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_sq_qp_list_print(const struct connectx4lx_hw_sq_qp_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_sq_qp_list_size(void);
#define CONNECTX4LX_HW_SQ_QP_LIST_SIZE    (0x4)
void connectx4lx_hw_sq_qp_list_dump(const struct connectx4lx_hw_sq_qp_list *ptr_struct, FILE* file);
/* hw_pipa */
void connectx4lx_hw_pipa_pack(const struct connectx4lx_hw_pipa *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_pipa_unpack(struct connectx4lx_hw_pipa *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_pipa_print(const struct connectx4lx_hw_pipa *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_pipa_size(void);
#define CONNECTX4LX_HW_PIPA_SIZE    (0x8)
void connectx4lx_hw_pipa_dump(const struct connectx4lx_hw_pipa *ptr_struct, FILE* file);
/* hw_sxdc */
void connectx4lx_hw_sxdc_pack(const union connectx4lx_hw_sxdc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_sxdc_unpack(union connectx4lx_hw_sxdc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_sxdc_print(const union connectx4lx_hw_sxdc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_sxdc_size(void);
#define CONNECTX4LX_HW_SXDC_SIZE    (0x8)
void connectx4lx_hw_sxdc_dump(const union connectx4lx_hw_sxdc *ptr_struct, FILE* file);
/* hw_klm_entry */
void connectx4lx_hw_klm_entry_pack(const struct connectx4lx_hw_klm_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_klm_entry_unpack(struct connectx4lx_hw_klm_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_klm_entry_print(const struct connectx4lx_hw_klm_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_klm_entry_size(void);
#define CONNECTX4LX_HW_KLM_ENTRY_SIZE    (0x10)
void connectx4lx_hw_klm_entry_dump(const struct connectx4lx_hw_klm_entry *ptr_struct, FILE* file);
/* hw_sq_tokens */
void connectx4lx_hw_sq_tokens_pack(const struct connectx4lx_hw_sq_tokens *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_sq_tokens_unpack(struct connectx4lx_hw_sq_tokens *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_sq_tokens_print(const struct connectx4lx_hw_sq_tokens *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_sq_tokens_size(void);
#define CONNECTX4LX_HW_SQ_TOKENS_SIZE    (0x20)
void connectx4lx_hw_sq_tokens_dump(const struct connectx4lx_hw_sq_tokens *ptr_struct, FILE* file);
/* hw_gvmi_tokens */
void connectx4lx_hw_gvmi_tokens_pack(const struct connectx4lx_hw_gvmi_tokens *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_gvmi_tokens_unpack(struct connectx4lx_hw_gvmi_tokens *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_gvmi_tokens_print(const struct connectx4lx_hw_gvmi_tokens *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_gvmi_tokens_size(void);
#define CONNECTX4LX_HW_GVMI_TOKENS_SIZE    (0x20)
void connectx4lx_hw_gvmi_tokens_dump(const struct connectx4lx_hw_gvmi_tokens *ptr_struct, FILE* file);
/* hw_sq_pointers */
void connectx4lx_hw_sq_pointers_pack(const struct connectx4lx_hw_sq_pointers *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_sq_pointers_unpack(struct connectx4lx_hw_sq_pointers *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_sq_pointers_print(const struct connectx4lx_hw_sq_pointers *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_sq_pointers_size(void);
#define CONNECTX4LX_HW_SQ_POINTERS_SIZE    (0x20)
void connectx4lx_hw_sq_pointers_dump(const struct connectx4lx_hw_sq_pointers *ptr_struct, FILE* file);
/* hw_trasta */
void connectx4lx_hw_trasta_pack(const struct connectx4lx_hw_trasta *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_trasta_unpack(struct connectx4lx_hw_trasta *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_trasta_print(const struct connectx4lx_hw_trasta *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_trasta_size(void);
#define CONNECTX4LX_HW_TRASTA_SIZE    (0x10)
void connectx4lx_hw_trasta_dump(const struct connectx4lx_hw_trasta *ptr_struct, FILE* file);
/* hw_port_info */
void connectx4lx_hw_port_info_pack(const struct connectx4lx_hw_port_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_port_info_unpack(struct connectx4lx_hw_port_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_port_info_print(const struct connectx4lx_hw_port_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_port_info_size(void);
#define CONNECTX4LX_HW_PORT_INFO_SIZE    (0x40)
void connectx4lx_hw_port_info_dump(const struct connectx4lx_hw_port_info *ptr_struct, FILE* file);
/* hw_qpc_r_dct */
void connectx4lx_hw_qpc_r_dct_pack(const union connectx4lx_hw_qpc_r_dct *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_qpc_r_dct_unpack(union connectx4lx_hw_qpc_r_dct *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_qpc_r_dct_print(const union connectx4lx_hw_qpc_r_dct *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_qpc_r_dct_size(void);
#define CONNECTX4LX_HW_QPC_R_DCT_SIZE    (0x40)
void connectx4lx_hw_qpc_r_dct_dump(const union connectx4lx_hw_qpc_r_dct *ptr_struct, FILE* file);
/* hw_s_qpc */
void connectx4lx_hw_s_qpc_pack(const union connectx4lx_hw_s_qpc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_unpack(union connectx4lx_hw_s_qpc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_s_qpc_print(const union connectx4lx_hw_s_qpc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_s_qpc_size(void);
#define CONNECTX4LX_HW_S_QPC_SIZE    (0x40)
void connectx4lx_hw_s_qpc_dump(const union connectx4lx_hw_s_qpc *ptr_struct, FILE* file);
/* hw_c_qpc */
void connectx4lx_hw_c_qpc_pack(const union connectx4lx_hw_c_qpc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_unpack(union connectx4lx_hw_c_qpc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_qpc_print(const union connectx4lx_hw_c_qpc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_qpc_size(void);
#define CONNECTX4LX_HW_C_QPC_SIZE    (0x40)
void connectx4lx_hw_c_qpc_dump(const union connectx4lx_hw_c_qpc *ptr_struct, FILE* file);
/* hw_c_srq */
void connectx4lx_hw_c_srq_pack(const union connectx4lx_hw_c_srq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_srq_unpack(union connectx4lx_hw_c_srq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_srq_print(const union connectx4lx_hw_c_srq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_srq_size(void);
#define CONNECTX4LX_HW_C_SRQ_SIZE    (0x40)
void connectx4lx_hw_c_srq_dump(const union connectx4lx_hw_c_srq *ptr_struct, FILE* file);
/* hw_toc */
void connectx4lx_hw_toc_pack(const struct connectx4lx_hw_toc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_toc_unpack(struct connectx4lx_hw_toc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_toc_print(const struct connectx4lx_hw_toc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_toc_size(void);
#define CONNECTX4LX_HW_TOC_SIZE    (0x40)
void connectx4lx_hw_toc_dump(const struct connectx4lx_hw_toc *ptr_struct, FILE* file);
/* hw_mkc */
void connectx4lx_hw_mkc_pack(const struct connectx4lx_hw_mkc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_mkc_unpack(struct connectx4lx_hw_mkc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_mkc_print(const struct connectx4lx_hw_mkc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_mkc_size(void);
#define CONNECTX4LX_HW_MKC_SIZE    (0x40)
void connectx4lx_hw_mkc_dump(const struct connectx4lx_hw_mkc *ptr_struct, FILE* file);
/* hw_c_eqc */
void connectx4lx_hw_c_eqc_pack(const union connectx4lx_hw_c_eqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_eqc_unpack(union connectx4lx_hw_c_eqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_eqc_print(const union connectx4lx_hw_c_eqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_eqc_size(void);
#define CONNECTX4LX_HW_C_EQC_SIZE    (0x40)
void connectx4lx_hw_c_eqc_dump(const union connectx4lx_hw_c_eqc *ptr_struct, FILE* file);
/* hw_c_cqc */
void connectx4lx_hw_c_cqc_pack(const union connectx4lx_hw_c_cqc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_c_cqc_unpack(union connectx4lx_hw_c_cqc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_c_cqc_print(const union connectx4lx_hw_c_cqc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_c_cqc_size(void);
#define CONNECTX4LX_HW_C_CQC_SIZE    (0x40)
void connectx4lx_hw_c_cqc_dump(const union connectx4lx_hw_c_cqc *ptr_struct, FILE* file);
/* lane_const_frame_lock */
void connectx4lx_lane_const_frame_lock_pack(const struct connectx4lx_lane_const_frame_lock *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_const_frame_lock_unpack(struct connectx4lx_lane_const_frame_lock *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_const_frame_lock_print(const struct connectx4lx_lane_const_frame_lock *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_const_frame_lock_size(void);
#define CONNECTX4LX_LANE_CONST_FRAME_LOCK_SIZE    (0x24)
void connectx4lx_lane_const_frame_lock_dump(const struct connectx4lx_lane_const_frame_lock *ptr_struct, FILE* file);
/* lane_const_calib_params */
void connectx4lx_lane_const_calib_params_pack(const struct connectx4lx_lane_const_calib_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_const_calib_params_unpack(struct connectx4lx_lane_const_calib_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_const_calib_params_print(const struct connectx4lx_lane_const_calib_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_const_calib_params_size(void);
#define CONNECTX4LX_LANE_CONST_CALIB_PARAMS_SIZE    (0x28)
void connectx4lx_lane_const_calib_params_dump(const struct connectx4lx_lane_const_calib_params *ptr_struct, FILE* file);
/* lane_const_sd_params */
void connectx4lx_lane_const_sd_params_pack(const struct connectx4lx_lane_const_sd_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_unpack(struct connectx4lx_lane_const_sd_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_const_sd_params_print(const struct connectx4lx_lane_const_sd_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_const_sd_params_size(void);
#define CONNECTX4LX_LANE_CONST_SD_PARAMS_SIZE    (0x1f0)
void connectx4lx_lane_const_sd_params_dump(const struct connectx4lx_lane_const_sd_params *ptr_struct, FILE* file);
/* shared_const_sd_params_rx */
void connectx4lx_shared_const_sd_params_rx_pack(const struct connectx4lx_shared_const_sd_params_rx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_rx_unpack(struct connectx4lx_shared_const_sd_params_rx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_rx_print(const struct connectx4lx_shared_const_sd_params_rx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_const_sd_params_rx_size(void);
#define CONNECTX4LX_SHARED_CONST_SD_PARAMS_RX_SIZE    (0x320)
void connectx4lx_shared_const_sd_params_rx_dump(const struct connectx4lx_shared_const_sd_params_rx *ptr_struct, FILE* file);
/* shared_const_sd_params_tx */
void connectx4lx_shared_const_sd_params_tx_pack(const struct connectx4lx_shared_const_sd_params_tx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_tx_unpack(struct connectx4lx_shared_const_sd_params_tx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_const_sd_params_tx_print(const struct connectx4lx_shared_const_sd_params_tx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_const_sd_params_tx_size(void);
#define CONNECTX4LX_SHARED_CONST_SD_PARAMS_TX_SIZE    (0x540)
void connectx4lx_shared_const_sd_params_tx_dump(const struct connectx4lx_shared_const_sd_params_tx *ptr_struct, FILE* file);
/* pcie_subroutines_db_index */
void connectx4lx_pcie_subroutines_db_index_pack(const struct connectx4lx_pcie_subroutines_db_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_index_unpack(struct connectx4lx_pcie_subroutines_db_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_index_print(const struct connectx4lx_pcie_subroutines_db_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_subroutines_db_index_size(void);
#define CONNECTX4LX_PCIE_SUBROUTINES_DB_INDEX_SIZE    (0x20)
void connectx4lx_pcie_subroutines_db_index_dump(const struct connectx4lx_pcie_subroutines_db_index *ptr_struct, FILE* file);
/* pcie_subroutines_db_name */
void connectx4lx_pcie_subroutines_db_name_pack(const struct connectx4lx_pcie_subroutines_db_name *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_name_unpack(struct connectx4lx_pcie_subroutines_db_name *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_name_print(const struct connectx4lx_pcie_subroutines_db_name *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_subroutines_db_name_size(void);
#define CONNECTX4LX_PCIE_SUBROUTINES_DB_NAME_SIZE    (0x20)
void connectx4lx_pcie_subroutines_db_name_dump(const struct connectx4lx_pcie_subroutines_db_name *ptr_struct, FILE* file);
/* eqlz_tx_adaptation */
void connectx4lx_eqlz_tx_adaptation_pack(const struct connectx4lx_eqlz_tx_adaptation *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eqlz_tx_adaptation_unpack(struct connectx4lx_eqlz_tx_adaptation *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eqlz_tx_adaptation_print(const struct connectx4lx_eqlz_tx_adaptation *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eqlz_tx_adaptation_size(void);
#define CONNECTX4LX_EQLZ_TX_ADAPTATION_SIZE    (0x4)
void connectx4lx_eqlz_tx_adaptation_dump(const struct connectx4lx_eqlz_tx_adaptation *ptr_struct, FILE* file);
/* ffe_tap_set_9_taps */
void connectx4lx_ffe_tap_set_9_taps_pack(const struct connectx4lx_ffe_tap_set_9_taps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ffe_tap_set_9_taps_unpack(struct connectx4lx_ffe_tap_set_9_taps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ffe_tap_set_9_taps_print(const struct connectx4lx_ffe_tap_set_9_taps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ffe_tap_set_9_taps_size(void);
#define CONNECTX4LX_FFE_TAP_SET_9_TAPS_SIZE    (0xc)
void connectx4lx_ffe_tap_set_9_taps_dump(const struct connectx4lx_ffe_tap_set_9_taps *ptr_struct, FILE* file);
/* tx_sets_shomron */
void connectx4lx_tx_sets_shomron_pack(const struct connectx4lx_tx_sets_shomron *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tx_sets_shomron_unpack(struct connectx4lx_tx_sets_shomron *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tx_sets_shomron_print(const struct connectx4lx_tx_sets_shomron *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tx_sets_shomron_size(void);
#define CONNECTX4LX_TX_SETS_SHOMRON_SIZE    (0x4)
void connectx4lx_tx_sets_shomron_dump(const struct connectx4lx_tx_sets_shomron *ptr_struct, FILE* file);
/* pn_st */
void connectx4lx_pn_st_pack(const struct connectx4lx_pn_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pn_st_unpack(struct connectx4lx_pn_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pn_st_print(const struct connectx4lx_pn_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pn_st_size(void);
#define CONNECTX4LX_PN_ST_SIZE    (0x2)
void connectx4lx_pn_st_dump(const struct connectx4lx_pn_st *ptr_struct, FILE* file);
/* bit_type_st */
void connectx4lx_bit_type_st_pack(const struct connectx4lx_bit_type_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_bit_type_st_unpack(struct connectx4lx_bit_type_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_bit_type_st_print(const struct connectx4lx_bit_type_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_bit_type_st_size(void);
#define CONNECTX4LX_BIT_TYPE_ST_SIZE    (0x0)
void connectx4lx_bit_type_st_dump(const struct connectx4lx_bit_type_st *ptr_struct, FILE* file);
/* gpio_group_config */
void connectx4lx_gpio_group_config_pack(const struct connectx4lx_gpio_group_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gpio_group_config_unpack(struct connectx4lx_gpio_group_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gpio_group_config_print(const struct connectx4lx_gpio_group_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gpio_group_config_size(void);
#define CONNECTX4LX_GPIO_GROUP_CONFIG_SIZE    (0x1)
void connectx4lx_gpio_group_config_dump(const struct connectx4lx_gpio_group_config *ptr_struct, FILE* file);
/* gpio_function */
void connectx4lx_gpio_function_pack(const struct connectx4lx_gpio_function *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gpio_function_unpack(struct connectx4lx_gpio_function *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gpio_function_print(const struct connectx4lx_gpio_function *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gpio_function_size(void);
#define CONNECTX4LX_GPIO_FUNCTION_SIZE    (0x2)
void connectx4lx_gpio_function_dump(const struct connectx4lx_gpio_function *ptr_struct, FILE* file);
/* pca_mapping_database */
void connectx4lx_pca_mapping_database_pack(const struct connectx4lx_pca_mapping_database *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pca_mapping_database_unpack(struct connectx4lx_pca_mapping_database *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pca_mapping_database_print(const struct connectx4lx_pca_mapping_database *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pca_mapping_database_size(void);
#define CONNECTX4LX_PCA_MAPPING_DATABASE_SIZE    (0x4)
void connectx4lx_pca_mapping_database_dump(const struct connectx4lx_pca_mapping_database *ptr_struct, FILE* file);
/* module2local */
void connectx4lx_module2local_pack(const struct connectx4lx_module2local *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module2local_unpack(struct connectx4lx_module2local *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module2local_print(const struct connectx4lx_module2local *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module2local_size(void);
#define CONNECTX4LX_MODULE2LOCAL_SIZE    (0x20)
void connectx4lx_module2local_dump(const struct connectx4lx_module2local *ptr_struct, FILE* file);
/* led_mapping */
void connectx4lx_led_mapping_pack(const struct connectx4lx_led_mapping *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_led_mapping_unpack(struct connectx4lx_led_mapping *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_led_mapping_print(const struct connectx4lx_led_mapping *ptr_struct, FILE* file, int indent_level);
int connectx4lx_led_mapping_size(void);
#define CONNECTX4LX_LED_MAPPING_SIZE    (0x2)
void connectx4lx_led_mapping_dump(const struct connectx4lx_led_mapping *ptr_struct, FILE* file);
/* mlpn_enhanced_database_ini */
void connectx4lx_mlpn_enhanced_database_ini_pack(const struct connectx4lx_mlpn_enhanced_database_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlpn_enhanced_database_ini_unpack(struct connectx4lx_mlpn_enhanced_database_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlpn_enhanced_database_ini_print(const struct connectx4lx_mlpn_enhanced_database_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlpn_enhanced_database_ini_size(void);
#define CONNECTX4LX_MLPN_ENHANCED_DATABASE_INI_SIZE    (0x4)
void connectx4lx_mlpn_enhanced_database_ini_dump(const struct connectx4lx_mlpn_enhanced_database_ini *ptr_struct, FILE* file);
/* mlpn_database_all_protocol_ini */
void connectx4lx_mlpn_database_all_protocol_ini_pack(const struct connectx4lx_mlpn_database_all_protocol_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mlpn_database_all_protocol_ini_unpack(struct connectx4lx_mlpn_database_all_protocol_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mlpn_database_all_protocol_ini_print(const struct connectx4lx_mlpn_database_all_protocol_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mlpn_database_all_protocol_ini_size(void);
#define CONNECTX4LX_MLPN_DATABASE_ALL_PROTOCOL_INI_SIZE    (0x4)
void connectx4lx_mlpn_database_all_protocol_ini_dump(const struct connectx4lx_mlpn_database_all_protocol_ini *ptr_struct, FILE* file);
/* tx_rx_logic_serdes_mapping_node_ini */
void connectx4lx_tx_rx_logic_serdes_mapping_node_ini_pack(const struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tx_rx_logic_serdes_mapping_node_ini_unpack(struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tx_rx_logic_serdes_mapping_node_ini_print(const struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tx_rx_logic_serdes_mapping_node_ini_size(void);
#define CONNECTX4LX_TX_RX_LOGIC_SERDES_MAPPING_NODE_INI_SIZE    (0x20)
void connectx4lx_tx_rx_logic_serdes_mapping_node_ini_dump(const struct connectx4lx_tx_rx_logic_serdes_mapping_node_ini *ptr_struct, FILE* file);
/* ib_an_hw_main_ini */
void connectx4lx_ib_an_hw_main_ini_pack(const struct connectx4lx_ib_an_hw_main_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ib_an_hw_main_ini_unpack(struct connectx4lx_ib_an_hw_main_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ib_an_hw_main_ini_print(const struct connectx4lx_ib_an_hw_main_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ib_an_hw_main_ini_size(void);
#define CONNECTX4LX_IB_AN_HW_MAIN_INI_SIZE    (0x5c)
void connectx4lx_ib_an_hw_main_ini_dump(const struct connectx4lx_ib_an_hw_main_ini *ptr_struct, FILE* file);
/* nv_tlv_data_vpi_settings */
void connectx4lx_nv_tlv_data_vpi_settings_pack(const struct connectx4lx_nv_tlv_data_vpi_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_vpi_settings_unpack(struct connectx4lx_nv_tlv_data_vpi_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_tlv_data_vpi_settings_print(const struct connectx4lx_nv_tlv_data_vpi_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_tlv_data_vpi_settings_size(void);
#define CONNECTX4LX_NV_TLV_DATA_VPI_SETTINGS_SIZE    (0x4)
void connectx4lx_nv_tlv_data_vpi_settings_dump(const struct connectx4lx_nv_tlv_data_vpi_settings *ptr_struct, FILE* file);
/* nv_config_kdnet_data */
void connectx4lx_nv_config_kdnet_data_pack(const struct connectx4lx_nv_config_kdnet_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_kdnet_data_unpack(struct connectx4lx_nv_config_kdnet_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_kdnet_data_print(const struct connectx4lx_nv_config_kdnet_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_kdnet_data_size(void);
#define CONNECTX4LX_NV_CONFIG_KDNET_DATA_SIZE    (0x4)
void connectx4lx_nv_config_kdnet_data_dump(const struct connectx4lx_nv_config_kdnet_data *ptr_struct, FILE* file);
/* nv_config_tpt */
void connectx4lx_nv_config_tpt_pack(const struct connectx4lx_nv_config_tpt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_tpt_unpack(struct connectx4lx_nv_config_tpt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_tpt_print(const struct connectx4lx_nv_config_tpt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_tpt_size(void);
#define CONNECTX4LX_NV_CONFIG_TPT_SIZE    (0x8)
void connectx4lx_nv_config_tpt_dump(const struct connectx4lx_nv_config_tpt *ptr_struct, FILE* file);
/* nv_config_pci */
void connectx4lx_nv_config_pci_pack(const struct connectx4lx_nv_config_pci *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_pci_unpack(struct connectx4lx_nv_config_pci *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_pci_print(const struct connectx4lx_nv_config_pci *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_pci_size(void);
#define CONNECTX4LX_NV_CONFIG_PCI_SIZE    (0x20)
void connectx4lx_nv_config_pci_dump(const struct connectx4lx_nv_config_pci *ptr_struct, FILE* file);
/* aer_ini */
void connectx4lx_aer_ini_pack(const struct connectx4lx_aer_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_aer_ini_unpack(struct connectx4lx_aer_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_aer_ini_print(const struct connectx4lx_aer_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_aer_ini_size(void);
#define CONNECTX4LX_AER_INI_SIZE    (0x4)
void connectx4lx_aer_ini_dump(const struct connectx4lx_aer_ini *ptr_struct, FILE* file);
/* msix_ini */
void connectx4lx_msix_ini_pack(const struct connectx4lx_msix_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_msix_ini_unpack(struct connectx4lx_msix_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_msix_ini_print(const struct connectx4lx_msix_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_msix_ini_size(void);
#define CONNECTX4LX_MSIX_INI_SIZE    (0x8)
void connectx4lx_msix_ini_dump(const struct connectx4lx_msix_ini *ptr_struct, FILE* file);
/* pciex_ini */
void connectx4lx_pciex_ini_pack(const struct connectx4lx_pciex_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pciex_ini_unpack(struct connectx4lx_pciex_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pciex_ini_print(const struct connectx4lx_pciex_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pciex_ini_size(void);
#define CONNECTX4LX_PCIEX_INI_SIZE    (0x18)
void connectx4lx_pciex_ini_dump(const struct connectx4lx_pciex_ini *ptr_struct, FILE* file);
/* sriov_ini */
void connectx4lx_sriov_ini_pack(const struct connectx4lx_sriov_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sriov_ini_unpack(struct connectx4lx_sriov_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sriov_ini_print(const struct connectx4lx_sriov_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sriov_ini_size(void);
#define CONNECTX4LX_SRIOV_INI_SIZE    (0x8)
void connectx4lx_sriov_ini_dump(const struct connectx4lx_sriov_ini *ptr_struct, FILE* file);
/* pci_cfg_hdr_ini */
void connectx4lx_pci_cfg_hdr_ini_pack(const struct connectx4lx_pci_cfg_hdr_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_hdr_ini_unpack(struct connectx4lx_pci_cfg_hdr_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_hdr_ini_print(const struct connectx4lx_pci_cfg_hdr_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pci_cfg_hdr_ini_size(void);
#define CONNECTX4LX_PCI_CFG_HDR_INI_SIZE    (0x10)
void connectx4lx_pci_cfg_hdr_ini_dump(const struct connectx4lx_pci_cfg_hdr_ini *ptr_struct, FILE* file);
/* fw_block_behavior_fields */
void connectx4lx_fw_block_behavior_fields_pack(const struct connectx4lx_fw_block_behavior_fields *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_fields_unpack(struct connectx4lx_fw_block_behavior_fields *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_fields_print(const struct connectx4lx_fw_block_behavior_fields *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_block_behavior_fields_size(void);
#define CONNECTX4LX_FW_BLOCK_BEHAVIOR_FIELDS_SIZE    (0x4)
void connectx4lx_fw_block_behavior_fields_dump(const struct connectx4lx_fw_block_behavior_fields *ptr_struct, FILE* file);
/* fw_block_behavior_dw */
void connectx4lx_fw_block_behavior_dw_pack(const struct connectx4lx_fw_block_behavior_dw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_dw_unpack(struct connectx4lx_fw_block_behavior_dw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_dw_print(const struct connectx4lx_fw_block_behavior_dw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_block_behavior_dw_size(void);
#define CONNECTX4LX_FW_BLOCK_BEHAVIOR_DW_SIZE    (0x4)
void connectx4lx_fw_block_behavior_dw_dump(const struct connectx4lx_fw_block_behavior_dw *ptr_struct, FILE* file);
/* nv_config_host_func_main */
void connectx4lx_nv_config_host_func_main_pack(const struct connectx4lx_nv_config_host_func_main *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_func_main_unpack(struct connectx4lx_nv_config_host_func_main *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_func_main_print(const struct connectx4lx_nv_config_host_func_main *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_host_func_main_size(void);
#define CONNECTX4LX_NV_CONFIG_HOST_FUNC_MAIN_SIZE    (0x18)
void connectx4lx_nv_config_host_func_main_dump(const struct connectx4lx_nv_config_host_func_main *ptr_struct, FILE* file);
/* nv_config_host_main */
void connectx4lx_nv_config_host_main_pack(const struct connectx4lx_nv_config_host_main *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_main_unpack(struct connectx4lx_nv_config_host_main *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_host_main_print(const struct connectx4lx_nv_config_host_main *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_host_main_size(void);
#define CONNECTX4LX_NV_CONFIG_HOST_MAIN_SIZE    (0x10)
void connectx4lx_nv_config_host_main_dump(const struct connectx4lx_nv_config_host_main *ptr_struct, FILE* file);
/* nv_config_global_main */
void connectx4lx_nv_config_global_main_pack(const struct connectx4lx_nv_config_global_main *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_global_main_unpack(struct connectx4lx_nv_config_global_main *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_global_main_print(const struct connectx4lx_nv_config_global_main *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_global_main_size(void);
#define CONNECTX4LX_NV_CONFIG_GLOBAL_MAIN_SIZE    (0x40)
void connectx4lx_nv_config_global_main_dump(const struct connectx4lx_nv_config_global_main *ptr_struct, FILE* file);
/* port_settings */
void connectx4lx_port_settings_pack(const struct connectx4lx_port_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_settings_unpack(struct connectx4lx_port_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_settings_print(const struct connectx4lx_port_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_settings_size(void);
#define CONNECTX4LX_PORT_SETTINGS_SIZE    (0x100)
void connectx4lx_port_settings_dump(const struct connectx4lx_port_settings *ptr_struct, FILE* file);
/* ini_fff_mode_db */
void connectx4lx_ini_fff_mode_db_pack(const struct connectx4lx_ini_fff_mode_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ini_fff_mode_db_unpack(struct connectx4lx_ini_fff_mode_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ini_fff_mode_db_print(const struct connectx4lx_ini_fff_mode_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ini_fff_mode_db_size(void);
#define CONNECTX4LX_INI_FFF_MODE_DB_SIZE    (0x10)
void connectx4lx_ini_fff_mode_db_dump(const struct connectx4lx_ini_fff_mode_db *ptr_struct, FILE* file);
/* centerpll_prj_ini_db */
void connectx4lx_centerpll_prj_ini_db_pack(const struct connectx4lx_centerpll_prj_ini_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_centerpll_prj_ini_db_unpack(struct connectx4lx_centerpll_prj_ini_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_centerpll_prj_ini_db_print(const struct connectx4lx_centerpll_prj_ini_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_centerpll_prj_ini_db_size(void);
#define CONNECTX4LX_CENTERPLL_PRJ_INI_DB_SIZE    (0x10)
void connectx4lx_centerpll_prj_ini_db_dump(const struct connectx4lx_centerpll_prj_ini_db *ptr_struct, FILE* file);
/* power_management_ini */
void connectx4lx_power_management_ini_pack(const struct connectx4lx_power_management_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_power_management_ini_unpack(struct connectx4lx_power_management_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_power_management_ini_print(const struct connectx4lx_power_management_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_power_management_ini_size(void);
#define CONNECTX4LX_POWER_MANAGEMENT_INI_SIZE    (0x8)
void connectx4lx_power_management_ini_dump(const struct connectx4lx_power_management_ini *ptr_struct, FILE* file);
/* tx_tuning_2_vars */
void connectx4lx_tx_tuning_2_vars_pack(const struct connectx4lx_tx_tuning_2_vars *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tx_tuning_2_vars_unpack(struct connectx4lx_tx_tuning_2_vars *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tx_tuning_2_vars_print(const struct connectx4lx_tx_tuning_2_vars *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tx_tuning_2_vars_size(void);
#define CONNECTX4LX_TX_TUNING_2_VARS_SIZE    (0x8)
void connectx4lx_tx_tuning_2_vars_dump(const struct connectx4lx_tx_tuning_2_vars *ptr_struct, FILE* file);
/* tx_tuning_vars */
void connectx4lx_tx_tuning_vars_pack(const struct connectx4lx_tx_tuning_vars *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tx_tuning_vars_unpack(struct connectx4lx_tx_tuning_vars *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tx_tuning_vars_print(const struct connectx4lx_tx_tuning_vars *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tx_tuning_vars_size(void);
#define CONNECTX4LX_TX_TUNING_VARS_SIZE    (0x4)
void connectx4lx_tx_tuning_vars_dump(const struct connectx4lx_tx_tuning_vars *ptr_struct, FILE* file);
/* error_correction_thresholds */
void connectx4lx_error_correction_thresholds_pack(const struct connectx4lx_error_correction_thresholds *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_correction_thresholds_unpack(struct connectx4lx_error_correction_thresholds *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_correction_thresholds_print(const struct connectx4lx_error_correction_thresholds *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_correction_thresholds_size(void);
#define CONNECTX4LX_ERROR_CORRECTION_THRESHOLDS_SIZE    (0x28)
void connectx4lx_error_correction_thresholds_dump(const struct connectx4lx_error_correction_thresholds *ptr_struct, FILE* file);
/* phy_uc_config */
void connectx4lx_phy_uc_config_pack(const struct connectx4lx_phy_uc_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_uc_config_unpack(struct connectx4lx_phy_uc_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_uc_config_print(const struct connectx4lx_phy_uc_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_uc_config_size(void);
#define CONNECTX4LX_PHY_UC_CONFIG_SIZE    (0x118)
void connectx4lx_phy_uc_config_dump(const struct connectx4lx_phy_uc_config *ptr_struct, FILE* file);
/* err_correction_ini */
void connectx4lx_err_correction_ini_pack(const struct connectx4lx_err_correction_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_err_correction_ini_unpack(struct connectx4lx_err_correction_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_err_correction_ini_print(const struct connectx4lx_err_correction_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_err_correction_ini_size(void);
#define CONNECTX4LX_ERR_CORRECTION_INI_SIZE    (0xdc)
void connectx4lx_err_correction_ini_dump(const struct connectx4lx_err_correction_ini *ptr_struct, FILE* file);
/* phy_temp_cfg */
void connectx4lx_phy_temp_cfg_pack(const struct connectx4lx_phy_temp_cfg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_temp_cfg_unpack(struct connectx4lx_phy_temp_cfg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_temp_cfg_print(const struct connectx4lx_phy_temp_cfg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_temp_cfg_size(void);
#define CONNECTX4LX_PHY_TEMP_CFG_SIZE    (0x4)
void connectx4lx_phy_temp_cfg_dump(const struct connectx4lx_phy_temp_cfg *ptr_struct, FILE* file);
/* phy_lcl_ini */
void connectx4lx_phy_lcl_ini_pack(const struct connectx4lx_phy_lcl_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_lcl_ini_unpack(struct connectx4lx_phy_lcl_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_lcl_ini_print(const struct connectx4lx_phy_lcl_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_lcl_ini_size(void);
#define CONNECTX4LX_PHY_LCL_INI_SIZE    (0xc)
void connectx4lx_phy_lcl_ini_dump(const struct connectx4lx_phy_lcl_ini *ptr_struct, FILE* file);
/* pldm_supported_features */
void connectx4lx_pldm_supported_features_pack(const struct connectx4lx_pldm_supported_features *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pldm_supported_features_unpack(struct connectx4lx_pldm_supported_features *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pldm_supported_features_print(const struct connectx4lx_pldm_supported_features *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pldm_supported_features_size(void);
#define CONNECTX4LX_PLDM_SUPPORTED_FEATURES_SIZE    (0x4)
void connectx4lx_pldm_supported_features_dump(const struct connectx4lx_pldm_supported_features *ptr_struct, FILE* file);
/* pldm_sensor_rec_handle_en */
void connectx4lx_pldm_sensor_rec_handle_en_pack(const struct connectx4lx_pldm_sensor_rec_handle_en *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pldm_sensor_rec_handle_en_unpack(struct connectx4lx_pldm_sensor_rec_handle_en *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pldm_sensor_rec_handle_en_print(const struct connectx4lx_pldm_sensor_rec_handle_en *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pldm_sensor_rec_handle_en_size(void);
#define CONNECTX4LX_PLDM_SENSOR_REC_HANDLE_EN_SIZE    (0x4)
void connectx4lx_pldm_sensor_rec_handle_en_dump(const struct connectx4lx_pldm_sensor_rec_handle_en *ptr_struct, FILE* file);
/* oem_enable */
void connectx4lx_oem_enable_pack(const struct connectx4lx_oem_enable *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_oem_enable_unpack(struct connectx4lx_oem_enable *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_oem_enable_print(const struct connectx4lx_oem_enable *ptr_struct, FILE* file, int indent_level);
int connectx4lx_oem_enable_size(void);
#define CONNECTX4LX_OEM_ENABLE_SIZE    (0x4)
void connectx4lx_oem_enable_dump(const struct connectx4lx_oem_enable *ptr_struct, FILE* file);
/* pca9536_config */
void connectx4lx_pca9536_config_pack(const struct connectx4lx_pca9536_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pca9536_config_unpack(struct connectx4lx_pca9536_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pca9536_config_print(const struct connectx4lx_pca9536_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pca9536_config_size(void);
#define CONNECTX4LX_PCA9536_CONFIG_SIZE    (0x2)
void connectx4lx_pca9536_config_dump(const struct connectx4lx_pca9536_config *ptr_struct, FILE* file);
/* pca9555_config */
void connectx4lx_pca9555_config_pack(const struct connectx4lx_pca9555_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pca9555_config_unpack(struct connectx4lx_pca9555_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pca9555_config_print(const struct connectx4lx_pca9555_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pca9555_config_size(void);
#define CONNECTX4LX_PCA9555_CONFIG_SIZE    (0x4)
void connectx4lx_pca9555_config_dump(const struct connectx4lx_pca9555_config *ptr_struct, FILE* file);
/* port_cap_mask1 */
void connectx4lx_port_cap_mask1_pack(const union connectx4lx_port_cap_mask1 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_cap_mask1_unpack(union connectx4lx_port_cap_mask1 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_cap_mask1_print(const union connectx4lx_port_cap_mask1 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_cap_mask1_size(void);
#define CONNECTX4LX_PORT_CAP_MASK1_SIZE    (0x4)
void connectx4lx_port_cap_mask1_dump(const union connectx4lx_port_cap_mask1 *ptr_struct, FILE* file);
/* status2pattern */
void connectx4lx_status2pattern_pack(const struct connectx4lx_status2pattern *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_status2pattern_unpack(struct connectx4lx_status2pattern *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_status2pattern_print(const struct connectx4lx_status2pattern *ptr_struct, FILE* file, int indent_level);
int connectx4lx_status2pattern_size(void);
#define CONNECTX4LX_STATUS2PATTERN_SIZE    (0x20)
void connectx4lx_status2pattern_dump(const struct connectx4lx_status2pattern *ptr_struct, FILE* file);
/* pattern_length_data */
void connectx4lx_pattern_length_data_pack(const struct connectx4lx_pattern_length_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pattern_length_data_unpack(struct connectx4lx_pattern_length_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pattern_length_data_print(const struct connectx4lx_pattern_length_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pattern_length_data_size(void);
#define CONNECTX4LX_PATTERN_LENGTH_DATA_SIZE    (0x0)
void connectx4lx_pattern_length_data_dump(const struct connectx4lx_pattern_length_data *ptr_struct, FILE* file);
/* pattern_data */
void connectx4lx_pattern_data_pack(const struct connectx4lx_pattern_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pattern_data_unpack(struct connectx4lx_pattern_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pattern_data_print(const struct connectx4lx_pattern_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pattern_data_size(void);
#define CONNECTX4LX_PATTERN_DATA_SIZE    (0x2)
void connectx4lx_pattern_data_dump(const struct connectx4lx_pattern_data *ptr_struct, FILE* file);
/* reset_version */
void connectx4lx_reset_version_pack(const struct connectx4lx_reset_version *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reset_version_unpack(struct connectx4lx_reset_version *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reset_version_print(const struct connectx4lx_reset_version *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reset_version_size(void);
#define CONNECTX4LX_RESET_VERSION_SIZE    (0x4)
void connectx4lx_reset_version_dump(const struct connectx4lx_reset_version *ptr_struct, FILE* file);
/* dcr_odp_events */
void connectx4lx_dcr_odp_events_pack(const struct connectx4lx_dcr_odp_events *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcr_odp_events_unpack(struct connectx4lx_dcr_odp_events *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcr_odp_events_print(const struct connectx4lx_dcr_odp_events *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcr_odp_events_size(void);
#define CONNECTX4LX_DCR_ODP_EVENTS_SIZE    (0x40)
void connectx4lx_dcr_odp_events_dump(const struct connectx4lx_dcr_odp_events *ptr_struct, FILE* file);
/* disable_mask_value */
void connectx4lx_disable_mask_value_pack(const struct connectx4lx_disable_mask_value *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_disable_mask_value_unpack(struct connectx4lx_disable_mask_value *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_disable_mask_value_print(const struct connectx4lx_disable_mask_value *ptr_struct, FILE* file, int indent_level);
int connectx4lx_disable_mask_value_size(void);
#define CONNECTX4LX_DISABLE_MASK_VALUE_SIZE    (0x4)
void connectx4lx_disable_mask_value_dump(const struct connectx4lx_disable_mask_value *ptr_struct, FILE* file);
/* disable_mask_bits */
void connectx4lx_disable_mask_bits_pack(const struct connectx4lx_disable_mask_bits *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_disable_mask_bits_unpack(struct connectx4lx_disable_mask_bits *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_disable_mask_bits_print(const struct connectx4lx_disable_mask_bits *ptr_struct, FILE* file, int indent_level);
int connectx4lx_disable_mask_bits_size(void);
#define CONNECTX4LX_DISABLE_MASK_BITS_SIZE    (0x4)
void connectx4lx_disable_mask_bits_dump(const struct connectx4lx_disable_mask_bits *ptr_struct, FILE* file);
/* mctp_oem_message_header */
void connectx4lx_mctp_oem_message_header_pack(const struct connectx4lx_mctp_oem_message_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mctp_oem_message_header_unpack(struct connectx4lx_mctp_oem_message_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mctp_oem_message_header_print(const struct connectx4lx_mctp_oem_message_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mctp_oem_message_header_size(void);
#define CONNECTX4LX_MCTP_OEM_MESSAGE_HEADER_SIZE    (0x8)
void connectx4lx_mctp_oem_message_header_dump(const struct connectx4lx_mctp_oem_message_header *ptr_struct, FILE* file);
/* icmd_mctp_vnd_pci_debug_words */
void connectx4lx_icmd_mctp_vnd_pci_debug_words_pack(const struct connectx4lx_icmd_mctp_vnd_pci_debug_words *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_words_unpack(struct connectx4lx_icmd_mctp_vnd_pci_debug_words *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_words_print(const struct connectx4lx_icmd_mctp_vnd_pci_debug_words *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mctp_vnd_pci_debug_words_size(void);
#define CONNECTX4LX_ICMD_MCTP_VND_PCI_DEBUG_WORDS_SIZE    (0x100)
void connectx4lx_icmd_mctp_vnd_pci_debug_words_dump(const struct connectx4lx_icmd_mctp_vnd_pci_debug_words *ptr_struct, FILE* file);
/* tlv_words */
void connectx4lx_tlv_words_pack(const struct connectx4lx_tlv_words *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tlv_words_unpack(struct connectx4lx_tlv_words *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tlv_words_print(const struct connectx4lx_tlv_words *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tlv_words_size(void);
#define CONNECTX4LX_TLV_WORDS_SIZE    (0x80)
void connectx4lx_tlv_words_dump(const struct connectx4lx_tlv_words *ptr_struct, FILE* file);
/* dcbx_cee_tlv */
void connectx4lx_dcbx_cee_tlv_pack(const struct connectx4lx_dcbx_cee_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_cee_tlv_unpack(struct connectx4lx_dcbx_cee_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_cee_tlv_print(const struct connectx4lx_dcbx_cee_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_cee_tlv_size(void);
#define CONNECTX4LX_DCBX_CEE_TLV_SIZE    (0x3c)
void connectx4lx_dcbx_cee_tlv_dump(const struct connectx4lx_dcbx_cee_tlv *ptr_struct, FILE* file);
/* dcbx_app */
void connectx4lx_dcbx_app_pack(const struct connectx4lx_dcbx_app *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_app_unpack(struct connectx4lx_dcbx_app *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_app_print(const struct connectx4lx_dcbx_app *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_app_size(void);
#define CONNECTX4LX_DCBX_APP_SIZE    (0xc)
void connectx4lx_dcbx_app_dump(const struct connectx4lx_dcbx_app *ptr_struct, FILE* file);
/* dcbx_pfc */
void connectx4lx_dcbx_pfc_pack(const struct connectx4lx_dcbx_pfc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_pfc_unpack(struct connectx4lx_dcbx_pfc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_pfc_print(const struct connectx4lx_dcbx_pfc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_pfc_size(void);
#define CONNECTX4LX_DCBX_PFC_SIZE    (0x8)
void connectx4lx_dcbx_pfc_dump(const struct connectx4lx_dcbx_pfc *ptr_struct, FILE* file);
/* dcbx_ets_reco */
void connectx4lx_dcbx_ets_reco_pack(const struct connectx4lx_dcbx_ets_reco *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_ets_reco_unpack(struct connectx4lx_dcbx_ets_reco *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_ets_reco_print(const struct connectx4lx_dcbx_ets_reco *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_ets_reco_size(void);
#define CONNECTX4LX_DCBX_ETS_RECO_SIZE    (0x1c)
void connectx4lx_dcbx_ets_reco_dump(const struct connectx4lx_dcbx_ets_reco *ptr_struct, FILE* file);
/* dcbx_ets_conf */
void connectx4lx_dcbx_ets_conf_pack(const struct connectx4lx_dcbx_ets_conf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcbx_ets_conf_unpack(struct connectx4lx_dcbx_ets_conf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcbx_ets_conf_print(const struct connectx4lx_dcbx_ets_conf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcbx_ets_conf_size(void);
#define CONNECTX4LX_DCBX_ETS_CONF_SIZE    (0x1c)
void connectx4lx_dcbx_ets_conf_dump(const struct connectx4lx_dcbx_ets_conf *ptr_struct, FILE* file);
/* uint64_wa_678118 */
void connectx4lx_uint64_wa_678118_pack(const struct connectx4lx_uint64_wa_678118 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_uint64_wa_678118_unpack(struct connectx4lx_uint64_wa_678118 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_uint64_wa_678118_print(const struct connectx4lx_uint64_wa_678118 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_uint64_wa_678118_size(void);
#define CONNECTX4LX_UINT64_WA_678118_SIZE    (0x8)
void connectx4lx_uint64_wa_678118_dump(const struct connectx4lx_uint64_wa_678118 *ptr_struct, FILE* file);
/* lldp_tlv_extended_type_dwords */
void connectx4lx_lldp_tlv_extended_type_dwords_pack(const struct connectx4lx_lldp_tlv_extended_type_dwords *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_dwords_unpack(struct connectx4lx_lldp_tlv_extended_type_dwords *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_dwords_print(const struct connectx4lx_lldp_tlv_extended_type_dwords *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lldp_tlv_extended_type_dwords_size(void);
#define CONNECTX4LX_LLDP_TLV_EXTENDED_TYPE_DWORDS_SIZE    (0x8)
void connectx4lx_lldp_tlv_extended_type_dwords_dump(const struct connectx4lx_lldp_tlv_extended_type_dwords *ptr_struct, FILE* file);
/* lldp_tlv_extended_type_fields */
void connectx4lx_lldp_tlv_extended_type_fields_pack(const struct connectx4lx_lldp_tlv_extended_type_fields *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_fields_unpack(struct connectx4lx_lldp_tlv_extended_type_fields *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_fields_print(const struct connectx4lx_lldp_tlv_extended_type_fields *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lldp_tlv_extended_type_fields_size(void);
#define CONNECTX4LX_LLDP_TLV_EXTENDED_TYPE_FIELDS_SIZE    (0x8)
void connectx4lx_lldp_tlv_extended_type_fields_dump(const struct connectx4lx_lldp_tlv_extended_type_fields *ptr_struct, FILE* file);
/* dmfs_ft_type_info */
void connectx4lx_dmfs_ft_type_info_pack(const struct connectx4lx_dmfs_ft_type_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_ft_type_info_unpack(struct connectx4lx_dmfs_ft_type_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_ft_type_info_print(const struct connectx4lx_dmfs_ft_type_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_ft_type_info_size(void);
#define CONNECTX4LX_DMFS_FT_TYPE_INFO_SIZE    (0x4)
void connectx4lx_dmfs_ft_type_info_dump(const struct connectx4lx_dmfs_ft_type_info *ptr_struct, FILE* file);
/* ocbb_fields_from_vpd */
void connectx4lx_ocbb_fields_from_vpd_pack(const struct connectx4lx_ocbb_fields_from_vpd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ocbb_fields_from_vpd_unpack(struct connectx4lx_ocbb_fields_from_vpd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ocbb_fields_from_vpd_print(const struct connectx4lx_ocbb_fields_from_vpd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ocbb_fields_from_vpd_size(void);
#define CONNECTX4LX_OCBB_FIELDS_FROM_VPD_SIZE    (0x44)
void connectx4lx_ocbb_fields_from_vpd_dump(const struct connectx4lx_ocbb_fields_from_vpd *ptr_struct, FILE* file);
/* fw_banner */
void connectx4lx_fw_banner_pack(const struct connectx4lx_fw_banner *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_banner_unpack(struct connectx4lx_fw_banner *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_banner_print(const struct connectx4lx_fw_banner *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_banner_size(void);
#define CONNECTX4LX_FW_BANNER_SIZE    (0xc)
void connectx4lx_fw_banner_dump(const struct connectx4lx_fw_banner *ptr_struct, FILE* file);
/* sfp_st */
void connectx4lx_sfp_st_pack(const struct connectx4lx_sfp_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sfp_st_unpack(struct connectx4lx_sfp_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sfp_st_print(const struct connectx4lx_sfp_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sfp_st_size(void);
#define CONNECTX4LX_SFP_ST_SIZE    (0xc)
void connectx4lx_sfp_st_dump(const struct connectx4lx_sfp_st *ptr_struct, FILE* file);
/* qsfp_st */
void connectx4lx_qsfp_st_pack(const struct connectx4lx_qsfp_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qsfp_st_unpack(struct connectx4lx_qsfp_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qsfp_st_print(const struct connectx4lx_qsfp_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qsfp_st_size(void);
#define CONNECTX4LX_QSFP_ST_SIZE    (0x24)
void connectx4lx_qsfp_st_dump(const struct connectx4lx_qsfp_st *ptr_struct, FILE* file);
/* general_st */
void connectx4lx_general_st_pack(const struct connectx4lx_general_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_general_st_unpack(struct connectx4lx_general_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_general_st_print(const struct connectx4lx_general_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_general_st_size(void);
#define CONNECTX4LX_GENERAL_ST_SIZE    (0x8)
void connectx4lx_general_st_dump(const struct connectx4lx_general_st *ptr_struct, FILE* file);
/* resource_type_entry */
void connectx4lx_resource_type_entry_pack(const struct connectx4lx_resource_type_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_resource_type_entry_unpack(struct connectx4lx_resource_type_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_resource_type_entry_print(const struct connectx4lx_resource_type_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_resource_type_entry_size(void);
#define CONNECTX4LX_RESOURCE_TYPE_ENTRY_SIZE    (0x4)
void connectx4lx_resource_type_entry_dump(const struct connectx4lx_resource_type_entry *ptr_struct, FILE* file);
/* index_and_length */
void connectx4lx_index_and_length_pack(const struct connectx4lx_index_and_length *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_index_and_length_unpack(struct connectx4lx_index_and_length *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_index_and_length_print(const struct connectx4lx_index_and_length *ptr_struct, FILE* file, int indent_level);
int connectx4lx_index_and_length_size(void);
#define CONNECTX4LX_INDEX_AND_LENGTH_SIZE    (0x10)
void connectx4lx_index_and_length_dump(const struct connectx4lx_index_and_length *ptr_struct, FILE* file);
/* flow_list */
void connectx4lx_flow_list_pack(const union connectx4lx_flow_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flow_list_unpack(union connectx4lx_flow_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flow_list_print(const union connectx4lx_flow_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flow_list_size(void);
#define CONNECTX4LX_FLOW_LIST_SIZE    (0x8)
void connectx4lx_flow_list_dump(const union connectx4lx_flow_list *ptr_struct, FILE* file);
/* flow_table_entry_match_set_lyr_2_4 */
void connectx4lx_flow_table_entry_match_set_lyr_2_4_pack(const struct connectx4lx_flow_table_entry_match_set_lyr_2_4 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flow_table_entry_match_set_lyr_2_4_unpack(struct connectx4lx_flow_table_entry_match_set_lyr_2_4 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flow_table_entry_match_set_lyr_2_4_print(const struct connectx4lx_flow_table_entry_match_set_lyr_2_4 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flow_table_entry_match_set_lyr_2_4_size(void);
#define CONNECTX4LX_FLOW_TABLE_ENTRY_MATCH_SET_LYR_2_4_SIZE    (0x40)
void connectx4lx_flow_table_entry_match_set_lyr_2_4_dump(const struct connectx4lx_flow_table_entry_match_set_lyr_2_4 *ptr_struct, FILE* file);
/* flow_table_entry_match_set_misc */
void connectx4lx_flow_table_entry_match_set_misc_pack(const struct connectx4lx_flow_table_entry_match_set_misc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flow_table_entry_match_set_misc_unpack(struct connectx4lx_flow_table_entry_match_set_misc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flow_table_entry_match_set_misc_print(const struct connectx4lx_flow_table_entry_match_set_misc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flow_table_entry_match_set_misc_size(void);
#define CONNECTX4LX_FLOW_TABLE_ENTRY_MATCH_SET_MISC_SIZE    (0x40)
void connectx4lx_flow_table_entry_match_set_misc_dump(const struct connectx4lx_flow_table_entry_match_set_misc *ptr_struct, FILE* file);
/* qsfp */
void connectx4lx_qsfp_pack(const struct connectx4lx_qsfp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_qsfp_unpack(struct connectx4lx_qsfp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_qsfp_print(const struct connectx4lx_qsfp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_qsfp_size(void);
#define CONNECTX4LX_QSFP_SIZE    (0x8)
void connectx4lx_qsfp_dump(const struct connectx4lx_qsfp *ptr_struct, FILE* file);
/* sfp */
void connectx4lx_sfp_pack(const struct connectx4lx_sfp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sfp_unpack(struct connectx4lx_sfp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sfp_print(const struct connectx4lx_sfp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sfp_size(void);
#define CONNECTX4LX_SFP_SIZE    (0x8)
void connectx4lx_sfp_dump(const struct connectx4lx_sfp *ptr_struct, FILE* file);
/* grade_params */
void connectx4lx_grade_params_pack(const struct connectx4lx_grade_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_grade_params_unpack(struct connectx4lx_grade_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_grade_params_print(const struct connectx4lx_grade_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_grade_params_size(void);
#define CONNECTX4LX_GRADE_PARAMS_SIZE    (0x20)
void connectx4lx_grade_params_dump(const struct connectx4lx_grade_params *ptr_struct, FILE* file);
/* as_dw */
void connectx4lx_as_dw_pack(const struct connectx4lx_as_dw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_as_dw_unpack(struct connectx4lx_as_dw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_as_dw_print(const struct connectx4lx_as_dw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_as_dw_size(void);
#define CONNECTX4LX_AS_DW_SIZE    (0x4)
void connectx4lx_as_dw_dump(const struct connectx4lx_as_dw *ptr_struct, FILE* file);
/* eth_protocols_as_bits */
void connectx4lx_eth_protocols_as_bits_pack(const struct connectx4lx_eth_protocols_as_bits *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eth_protocols_as_bits_unpack(struct connectx4lx_eth_protocols_as_bits *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eth_protocols_as_bits_print(const struct connectx4lx_eth_protocols_as_bits *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eth_protocols_as_bits_size(void);
#define CONNECTX4LX_ETH_PROTOCOLS_AS_BITS_SIZE    (0x4)
void connectx4lx_eth_protocols_as_bits_dump(const struct connectx4lx_eth_protocols_as_bits *ptr_struct, FILE* file);
/* icmd_ver_data_one_qp_per_recovery */
void connectx4lx_icmd_ver_data_one_qp_per_recovery_pack(const struct connectx4lx_icmd_ver_data_one_qp_per_recovery *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_one_qp_per_recovery_unpack(struct connectx4lx_icmd_ver_data_one_qp_per_recovery *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_one_qp_per_recovery_print(const struct connectx4lx_icmd_ver_data_one_qp_per_recovery *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ver_data_one_qp_per_recovery_size(void);
#define CONNECTX4LX_ICMD_VER_DATA_ONE_QP_PER_RECOVERY_SIZE    (0x4)
void connectx4lx_icmd_ver_data_one_qp_per_recovery_dump(const struct connectx4lx_icmd_ver_data_one_qp_per_recovery *ptr_struct, FILE* file);
/* icmd_ver_data_max_atomic */
void connectx4lx_icmd_ver_data_max_atomic_pack(const struct connectx4lx_icmd_ver_data_max_atomic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_max_atomic_unpack(struct connectx4lx_icmd_ver_data_max_atomic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_max_atomic_print(const struct connectx4lx_icmd_ver_data_max_atomic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ver_data_max_atomic_size(void);
#define CONNECTX4LX_ICMD_VER_DATA_MAX_ATOMIC_SIZE    (0x4)
void connectx4lx_icmd_ver_data_max_atomic_dump(const struct connectx4lx_icmd_ver_data_max_atomic *ptr_struct, FILE* file);
/* error_flow_trigger_tag */
void connectx4lx_error_flow_trigger_tag_pack(const union connectx4lx_error_flow_trigger_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_unpack(union connectx4lx_error_flow_trigger_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_tag_print(const union connectx4lx_error_flow_trigger_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_tag_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_TAG_SIZE    (0x10)
void connectx4lx_error_flow_trigger_tag_dump(const union connectx4lx_error_flow_trigger_tag *ptr_struct, FILE* file);
/* fw_vport_ctx */
void connectx4lx_fw_vport_ctx_pack(const struct connectx4lx_fw_vport_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_vport_ctx_unpack(struct connectx4lx_fw_vport_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_vport_ctx_print(const struct connectx4lx_fw_vport_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_vport_ctx_size(void);
#define CONNECTX4LX_FW_VPORT_CTX_SIZE    (0x2)
void connectx4lx_fw_vport_ctx_dump(const struct connectx4lx_fw_vport_ctx *ptr_struct, FILE* file);
/* vf_pages_list */
void connectx4lx_vf_pages_list_pack(const struct connectx4lx_vf_pages_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vf_pages_list_unpack(struct connectx4lx_vf_pages_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vf_pages_list_print(const struct connectx4lx_vf_pages_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vf_pages_list_size(void);
#define CONNECTX4LX_VF_PAGES_LIST_SIZE    (0x40)
void connectx4lx_vf_pages_list_dump(const struct connectx4lx_vf_pages_list *ptr_struct, FILE* file);
/* icm_page_manager */
void connectx4lx_icm_page_manager_pack(const struct connectx4lx_icm_page_manager *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icm_page_manager_unpack(struct connectx4lx_icm_page_manager *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icm_page_manager_print(const struct connectx4lx_icm_page_manager *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icm_page_manager_size(void);
#define CONNECTX4LX_ICM_PAGE_MANAGER_SIZE    (0x20)
void connectx4lx_icm_page_manager_dump(const struct connectx4lx_icm_page_manager *ptr_struct, FILE* file);
/* hca_params */
void connectx4lx_hca_params_pack(const struct connectx4lx_hca_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hca_params_unpack(struct connectx4lx_hca_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hca_params_print(const struct connectx4lx_hca_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hca_params_size(void);
#define CONNECTX4LX_HCA_PARAMS_SIZE    (0x20)
void connectx4lx_hca_params_dump(const struct connectx4lx_hca_params *ptr_struct, FILE* file);
/* dummy_addresses_one_cache_line */
void connectx4lx_dummy_addresses_one_cache_line_pack(const struct connectx4lx_dummy_addresses_one_cache_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dummy_addresses_one_cache_line_unpack(struct connectx4lx_dummy_addresses_one_cache_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dummy_addresses_one_cache_line_print(const struct connectx4lx_dummy_addresses_one_cache_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dummy_addresses_one_cache_line_size(void);
#define CONNECTX4LX_DUMMY_ADDRESSES_ONE_CACHE_LINE_SIZE    (0x40)
void connectx4lx_dummy_addresses_one_cache_line_dump(const struct connectx4lx_dummy_addresses_one_cache_line *ptr_struct, FILE* file);
/* cmdif_ctx */
void connectx4lx_cmdif_ctx_pack(const struct connectx4lx_cmdif_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_unpack(struct connectx4lx_cmdif_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_ctx_print(const struct connectx4lx_cmdif_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_ctx_size(void);
#define CONNECTX4LX_CMDIF_CTX_SIZE    (0x40)
void connectx4lx_cmdif_ctx_dump(const struct connectx4lx_cmdif_ctx *ptr_struct, FILE* file);
/* comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto */
void connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto_pack(const union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto_unpack(union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto_print(const union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto *ptr_struct, FILE* file, int indent_level);
int connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto_size(void);
#define CONNECTX4LX_COMP_EVENT_DCT_EVENTS_QP_EVENTS_WQE_ASSOCIATED_PAGE_FAULT_EVENT_RDMA_PAGE_FAULT_EVENT_CQ_ERROR_DROPPED_PACKET_LOGGED_PORT_STATE_CHANGE_EVENT_GPIO_EVENT_PORT_MODULE_EVENT_DCBX_CHANGE_EVENT_TEMP_WARNING_EVENT_DB_BF_CONGESTION_EVENT_STALL_VL_EVENT_CMD_INTER_COMP_EVENT_PAGES_REQ_EVENT_NIC_VPORT_CHANGE_EVENT_FPGA_ERROR_EVENT_FPGA_QP_ERROR_EVENT_GENERAL_NOTIFICATION_DELAY_DROP_EVENT_AUTO_SIZE    (0x1c)
void connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto_dump(const union connectx4lx_comp_event_dct_events_qp_events_wqe_associated_page_fault_event_rdma_page_fault_event_cq_error_dropped_packet_logged_port_state_change_event_gpio_event_port_module_event_dcbx_change_event_temp_warning_event_db_bf_congestion_event_stall_vl_event_cmd_inter_comp_event_pages_req_event_nic_vport_change_event_fpga_error_event_fpga_qp_error_event_general_notification_delay_drop_event_auto *ptr_struct, FILE* file);
/* ncsi_response_payload */
void connectx4lx_ncsi_response_payload_pack(const union connectx4lx_ncsi_response_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_response_payload_unpack(union connectx4lx_ncsi_response_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_response_payload_print(const union connectx4lx_ncsi_response_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_response_payload_size(void);
#define CONNECTX4LX_NCSI_RESPONSE_PAYLOAD_SIZE    (0x100)
void connectx4lx_ncsi_response_payload_dump(const union connectx4lx_ncsi_response_payload *ptr_struct, FILE* file);
/* ncsi_hdr */
void connectx4lx_ncsi_hdr_pack(const struct connectx4lx_ncsi_hdr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_hdr_unpack(struct connectx4lx_ncsi_hdr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_hdr_print(const struct connectx4lx_ncsi_hdr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_hdr_size(void);
#define CONNECTX4LX_NCSI_HDR_SIZE    (0x10)
void connectx4lx_ncsi_hdr_dump(const struct connectx4lx_ncsi_hdr *ptr_struct, FILE* file);
/* ncsi_cmd_payload */
void connectx4lx_ncsi_cmd_payload_pack(const union connectx4lx_ncsi_cmd_payload *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_cmd_payload_unpack(union connectx4lx_ncsi_cmd_payload *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_cmd_payload_print(const union connectx4lx_ncsi_cmd_payload *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_cmd_payload_size(void);
#define CONNECTX4LX_NCSI_CMD_PAYLOAD_SIZE    (0x100)
void connectx4lx_ncsi_cmd_payload_dump(const union connectx4lx_ncsi_cmd_payload *ptr_struct, FILE* file);
/* icmd_generic_reg_access_reg_tlv_data */
void connectx4lx_icmd_generic_reg_access_reg_tlv_data_pack(const union connectx4lx_icmd_generic_reg_access_reg_tlv_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_reg_access_reg_tlv_data_unpack(union connectx4lx_icmd_generic_reg_access_reg_tlv_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_reg_access_reg_tlv_data_print(const union connectx4lx_icmd_generic_reg_access_reg_tlv_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_generic_reg_access_reg_tlv_data_size(void);
#define CONNECTX4LX_ICMD_GENERIC_REG_ACCESS_REG_TLV_DATA_SIZE    (0x110)
void connectx4lx_icmd_generic_reg_access_reg_tlv_data_dump(const union connectx4lx_icmd_generic_reg_access_reg_tlv_data *ptr_struct, FILE* file);
/* reg_access_tlv */
void connectx4lx_reg_access_tlv_pack(const struct connectx4lx_reg_access_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reg_access_tlv_unpack(struct connectx4lx_reg_access_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reg_access_tlv_print(const struct connectx4lx_reg_access_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reg_access_tlv_size(void);
#define CONNECTX4LX_REG_ACCESS_TLV_SIZE    (0x4)
void connectx4lx_reg_access_tlv_dump(const struct connectx4lx_reg_access_tlv *ptr_struct, FILE* file);
/* IB_TID */
void connectx4lx_IB_TID_pack(const struct connectx4lx_IB_TID *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_IB_TID_unpack(struct connectx4lx_IB_TID *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_IB_TID_print(const struct connectx4lx_IB_TID *ptr_struct, FILE* file, int indent_level);
int connectx4lx_IB_TID_size(void);
#define CONNECTX4LX_IB_TID_SIZE    (0x8)
void connectx4lx_IB_TID_dump(const struct connectx4lx_IB_TID *ptr_struct, FILE* file);
/* icmd_kdnet_ctrl_out */
void connectx4lx_icmd_kdnet_ctrl_out_pack(const struct connectx4lx_icmd_kdnet_ctrl_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_out_unpack(struct connectx4lx_icmd_kdnet_ctrl_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_out_print(const struct connectx4lx_icmd_kdnet_ctrl_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_kdnet_ctrl_out_size(void);
#define CONNECTX4LX_ICMD_KDNET_CTRL_OUT_SIZE    (0x4)
void connectx4lx_icmd_kdnet_ctrl_out_dump(const struct connectx4lx_icmd_kdnet_ctrl_out *ptr_struct, FILE* file);
/* icmd_kdnet_ctrl_in */
void connectx4lx_icmd_kdnet_ctrl_in_pack(const struct connectx4lx_icmd_kdnet_ctrl_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_in_unpack(struct connectx4lx_icmd_kdnet_ctrl_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_in_print(const struct connectx4lx_icmd_kdnet_ctrl_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_kdnet_ctrl_in_size(void);
#define CONNECTX4LX_ICMD_KDNET_CTRL_IN_SIZE    (0x4)
void connectx4lx_icmd_kdnet_ctrl_in_dump(const struct connectx4lx_icmd_kdnet_ctrl_in *ptr_struct, FILE* file);
/* itrace_ctrl */
void connectx4lx_itrace_ctrl_pack(const struct connectx4lx_itrace_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itrace_ctrl_unpack(struct connectx4lx_itrace_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itrace_ctrl_print(const struct connectx4lx_itrace_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itrace_ctrl_size(void);
#define CONNECTX4LX_ITRACE_CTRL_SIZE    (0x4)
void connectx4lx_itrace_ctrl_dump(const struct connectx4lx_itrace_ctrl *ptr_struct, FILE* file);
/* output_inline_standart */
void connectx4lx_output_inline_standart_pack(const struct connectx4lx_output_inline_standart *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_output_inline_standart_unpack(struct connectx4lx_output_inline_standart *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_output_inline_standart_print(const struct connectx4lx_output_inline_standart *ptr_struct, FILE* file, int indent_level);
int connectx4lx_output_inline_standart_size(void);
#define CONNECTX4LX_OUTPUT_INLINE_STANDART_SIZE    (0x10)
void connectx4lx_output_inline_standart_dump(const struct connectx4lx_output_inline_standart *ptr_struct, FILE* file);
/* input_inline_standart */
void connectx4lx_input_inline_standart_pack(const struct connectx4lx_input_inline_standart *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_input_inline_standart_unpack(struct connectx4lx_input_inline_standart *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_input_inline_standart_print(const struct connectx4lx_input_inline_standart *ptr_struct, FILE* file, int indent_level);
int connectx4lx_input_inline_standart_size(void);
#define CONNECTX4LX_INPUT_INLINE_STANDART_SIZE    (0x10)
void connectx4lx_input_inline_standart_dump(const struct connectx4lx_input_inline_standart *ptr_struct, FILE* file);
/* g_rse_decoders_as_dwords */
void connectx4lx_g_rse_decoders_as_dwords_pack(const struct connectx4lx_g_rse_decoders_as_dwords *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_g_rse_decoders_as_dwords_unpack(struct connectx4lx_g_rse_decoders_as_dwords *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_g_rse_decoders_as_dwords_print(const struct connectx4lx_g_rse_decoders_as_dwords *ptr_struct, FILE* file, int indent_level);
int connectx4lx_g_rse_decoders_as_dwords_size(void);
#define CONNECTX4LX_G_RSE_DECODERS_AS_DWORDS_SIZE    (0x100)
void connectx4lx_g_rse_decoders_as_dwords_dump(const struct connectx4lx_g_rse_decoders_as_dwords *ptr_struct, FILE* file);
/* rxs_rxt_desc_decoder */
void connectx4lx_rxs_rxt_desc_decoder_pack(const struct connectx4lx_rxs_rxt_desc_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rxs_rxt_desc_decoder_unpack(struct connectx4lx_rxs_rxt_desc_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rxs_rxt_desc_decoder_print(const struct connectx4lx_rxs_rxt_desc_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rxs_rxt_desc_decoder_size(void);
#define CONNECTX4LX_RXS_RXT_DESC_DECODER_SIZE    (0x40)
void connectx4lx_rxs_rxt_desc_decoder_dump(const struct connectx4lx_rxs_rxt_desc_decoder *ptr_struct, FILE* file);
/* rxt_context_fetch_qp_desc_decoder */
void connectx4lx_rxt_context_fetch_qp_desc_decoder_pack(const struct connectx4lx_rxt_context_fetch_qp_desc_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rxt_context_fetch_qp_desc_decoder_unpack(struct connectx4lx_rxt_context_fetch_qp_desc_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rxt_context_fetch_qp_desc_decoder_print(const struct connectx4lx_rxt_context_fetch_qp_desc_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rxt_context_fetch_qp_desc_decoder_size(void);
#define CONNECTX4LX_RXT_CONTEXT_FETCH_QP_DESC_DECODER_SIZE    (0x10)
void connectx4lx_rxt_context_fetch_qp_desc_decoder_dump(const struct connectx4lx_rxt_context_fetch_qp_desc_decoder *ptr_struct, FILE* file);
/* rxt_checks_steering_results_decoder */
void connectx4lx_rxt_checks_steering_results_decoder_pack(const struct connectx4lx_rxt_checks_steering_results_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rxt_checks_steering_results_decoder_unpack(struct connectx4lx_rxt_checks_steering_results_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rxt_checks_steering_results_decoder_print(const struct connectx4lx_rxt_checks_steering_results_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rxt_checks_steering_results_decoder_size(void);
#define CONNECTX4LX_RXT_CHECKS_STEERING_RESULTS_DECODER_SIZE    (0x20)
void connectx4lx_rxt_checks_steering_results_decoder_dump(const struct connectx4lx_rxt_checks_steering_results_decoder *ptr_struct, FILE* file);
/* rxt_steering_context_decoder */
void connectx4lx_rxt_steering_context_decoder_pack(const struct connectx4lx_rxt_steering_context_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rxt_steering_context_decoder_unpack(struct connectx4lx_rxt_steering_context_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rxt_steering_context_decoder_print(const struct connectx4lx_rxt_steering_context_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rxt_steering_context_decoder_size(void);
#define CONNECTX4LX_RXT_STEERING_CONTEXT_DECODER_SIZE    (0x40)
void connectx4lx_rxt_steering_context_decoder_dump(const struct connectx4lx_rxt_steering_context_decoder *ptr_struct, FILE* file);
/* rxt_checks_packet_descriptor_decoder */
void connectx4lx_rxt_checks_packet_descriptor_decoder_pack(const struct connectx4lx_rxt_checks_packet_descriptor_decoder *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rxt_checks_packet_descriptor_decoder_unpack(struct connectx4lx_rxt_checks_packet_descriptor_decoder *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rxt_checks_packet_descriptor_decoder_print(const struct connectx4lx_rxt_checks_packet_descriptor_decoder *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rxt_checks_packet_descriptor_decoder_size(void);
#define CONNECTX4LX_RXT_CHECKS_PACKET_DESCRIPTOR_DECODER_SIZE    (0x40)
void connectx4lx_rxt_checks_packet_descriptor_decoder_dump(const struct connectx4lx_rxt_checks_packet_descriptor_decoder *ptr_struct, FILE* file);
/* ctx_as_dwords */
void connectx4lx_ctx_as_dwords_pack(const struct connectx4lx_ctx_as_dwords *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ctx_as_dwords_unpack(struct connectx4lx_ctx_as_dwords *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ctx_as_dwords_print(const struct connectx4lx_ctx_as_dwords *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ctx_as_dwords_size(void);
#define CONNECTX4LX_CTX_AS_DWORDS_SIZE    (0x40)
void connectx4lx_ctx_as_dwords_dump(const struct connectx4lx_ctx_as_dwords *ptr_struct, FILE* file);
/* fw_resource_context */
void connectx4lx_fw_resource_context_pack(const union connectx4lx_fw_resource_context *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_resource_context_unpack(union connectx4lx_fw_resource_context *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_resource_context_print(const union connectx4lx_fw_resource_context *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_resource_context_size(void);
#define CONNECTX4LX_FW_RESOURCE_CONTEXT_SIZE    (0x40)
void connectx4lx_fw_resource_context_dump(const union connectx4lx_fw_resource_context *ptr_struct, FILE* file);
/* hw_hca_contexts */
void connectx4lx_hw_hca_contexts_pack(const union connectx4lx_hw_hca_contexts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_hca_contexts_unpack(union connectx4lx_hw_hca_contexts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_hca_contexts_print(const union connectx4lx_hw_hca_contexts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_hca_contexts_size(void);
#define CONNECTX4LX_HW_HCA_CONTEXTS_SIZE    (0x40)
void connectx4lx_hw_hca_contexts_dump(const union connectx4lx_hw_hca_contexts *ptr_struct, FILE* file);
/* bath_debug */
void connectx4lx_bath_debug_pack(const struct connectx4lx_bath_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_bath_debug_unpack(struct connectx4lx_bath_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_bath_debug_print(const struct connectx4lx_bath_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_bath_debug_size(void);
#define CONNECTX4LX_BATH_DEBUG_SIZE    (0x10)
void connectx4lx_bath_debug_dump(const struct connectx4lx_bath_debug *ptr_struct, FILE* file);
/* local_best_rx_set */
void connectx4lx_local_best_rx_set_pack(const struct connectx4lx_local_best_rx_set *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_local_best_rx_set_unpack(struct connectx4lx_local_best_rx_set *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_local_best_rx_set_print(const struct connectx4lx_local_best_rx_set *ptr_struct, FILE* file, int indent_level);
int connectx4lx_local_best_rx_set_size(void);
#define CONNECTX4LX_LOCAL_BEST_RX_SET_SIZE    (0x3c)
void connectx4lx_local_best_rx_set_dump(const struct connectx4lx_local_best_rx_set *ptr_struct, FILE* file);
/* field_boundary */
void connectx4lx_field_boundary_pack(const struct connectx4lx_field_boundary *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_field_boundary_unpack(struct connectx4lx_field_boundary *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_field_boundary_print(const struct connectx4lx_field_boundary *ptr_struct, FILE* file, int indent_level);
int connectx4lx_field_boundary_size(void);
#define CONNECTX4LX_FIELD_BOUNDARY_SIZE    (0x4)
void connectx4lx_field_boundary_dump(const struct connectx4lx_field_boundary *ptr_struct, FILE* file);
/* add_data */
void connectx4lx_add_data_pack(const struct connectx4lx_add_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_add_data_unpack(struct connectx4lx_add_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_add_data_print(const struct connectx4lx_add_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_add_data_size(void);
#define CONNECTX4LX_ADD_DATA_SIZE    (0x4)
void connectx4lx_add_data_dump(const struct connectx4lx_add_data *ptr_struct, FILE* file);
/* compare_mask_data */
void connectx4lx_compare_mask_data_pack(const struct connectx4lx_compare_mask_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_compare_mask_data_unpack(struct connectx4lx_compare_mask_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_compare_mask_data_print(const struct connectx4lx_compare_mask_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_compare_mask_data_size(void);
#define CONNECTX4LX_COMPARE_MASK_DATA_SIZE    (0x4)
void connectx4lx_compare_mask_data_dump(const struct connectx4lx_compare_mask_data *ptr_struct, FILE* file);
/* swap_mask_data */
void connectx4lx_swap_mask_data_pack(const struct connectx4lx_swap_mask_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_swap_mask_data_unpack(struct connectx4lx_swap_mask_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_swap_mask_data_print(const struct connectx4lx_swap_mask_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_swap_mask_data_size(void);
#define CONNECTX4LX_SWAP_MASK_DATA_SIZE    (0x4)
void connectx4lx_swap_mask_data_dump(const struct connectx4lx_swap_mask_data *ptr_struct, FILE* file);
/* compare_data */
void connectx4lx_compare_data_pack(const struct connectx4lx_compare_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_compare_data_unpack(struct connectx4lx_compare_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_compare_data_print(const struct connectx4lx_compare_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_compare_data_size(void);
#define CONNECTX4LX_COMPARE_DATA_SIZE    (0x4)
void connectx4lx_compare_data_dump(const struct connectx4lx_compare_data *ptr_struct, FILE* file);
/* swap_data */
void connectx4lx_swap_data_pack(const struct connectx4lx_swap_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_swap_data_unpack(struct connectx4lx_swap_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_swap_data_print(const struct connectx4lx_swap_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_swap_data_size(void);
#define CONNECTX4LX_SWAP_DATA_SIZE    (0x4)
void connectx4lx_swap_data_dump(const struct connectx4lx_swap_data *ptr_struct, FILE* file);
/* component_authentication_configuration */
void connectx4lx_component_authentication_configuration_pack(const struct connectx4lx_component_authentication_configuration *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_component_authentication_configuration_unpack(struct connectx4lx_component_authentication_configuration *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_component_authentication_configuration_print(const struct connectx4lx_component_authentication_configuration *ptr_struct, FILE* file, int indent_level);
int connectx4lx_component_authentication_configuration_size(void);
#define CONNECTX4LX_COMPONENT_AUTHENTICATION_CONFIGURATION_SIZE    (0x4)
void connectx4lx_component_authentication_configuration_dump(const struct connectx4lx_component_authentication_configuration *ptr_struct, FILE* file);
/* nv_data_pointer */
void connectx4lx_nv_data_pointer_pack(const struct connectx4lx_nv_data_pointer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_data_pointer_unpack(struct connectx4lx_nv_data_pointer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_data_pointer_print(const struct connectx4lx_nv_data_pointer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_data_pointer_size(void);
#define CONNECTX4LX_NV_DATA_POINTER_SIZE    (0x4)
void connectx4lx_nv_data_pointer_dump(const struct connectx4lx_nv_data_pointer *ptr_struct, FILE* file);
/* pll_consts */
void connectx4lx_pll_consts_pack(const struct connectx4lx_pll_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pll_consts_unpack(struct connectx4lx_pll_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pll_consts_print(const struct connectx4lx_pll_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pll_consts_size(void);
#define CONNECTX4LX_PLL_CONSTS_SIZE    (0x320)
void connectx4lx_pll_consts_dump(const struct connectx4lx_pll_consts *ptr_struct, FILE* file);
/* lane_consts */
void connectx4lx_lane_consts_pack(const struct connectx4lx_lane_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_consts_unpack(struct connectx4lx_lane_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_consts_print(const struct connectx4lx_lane_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_consts_size(void);
#define CONNECTX4LX_LANE_CONSTS_SIZE    (0x2c0)
void connectx4lx_lane_consts_dump(const struct connectx4lx_lane_consts *ptr_struct, FILE* file);
/* port_shared_const_sd_params */
void connectx4lx_port_shared_const_sd_params_pack(const struct connectx4lx_port_shared_const_sd_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_shared_const_sd_params_unpack(struct connectx4lx_port_shared_const_sd_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_shared_const_sd_params_print(const struct connectx4lx_port_shared_const_sd_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_shared_const_sd_params_size(void);
#define CONNECTX4LX_PORT_SHARED_CONST_SD_PARAMS_SIZE    (0x870)
void connectx4lx_port_shared_const_sd_params_dump(const struct connectx4lx_port_shared_const_sd_params *ptr_struct, FILE* file);
/* pcie_subroutines_db */
void connectx4lx_pcie_subroutines_db_pack(const union connectx4lx_pcie_subroutines_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_unpack(union connectx4lx_pcie_subroutines_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_subroutines_db_print(const union connectx4lx_pcie_subroutines_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_subroutines_db_size(void);
#define CONNECTX4LX_PCIE_SUBROUTINES_DB_SIZE    (0x20)
void connectx4lx_pcie_subroutines_db_dump(const union connectx4lx_pcie_subroutines_db *ptr_struct, FILE* file);
/* jump_addresses */
void connectx4lx_jump_addresses_pack(const struct connectx4lx_jump_addresses *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_jump_addresses_unpack(struct connectx4lx_jump_addresses *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_jump_addresses_print(const struct connectx4lx_jump_addresses *ptr_struct, FILE* file, int indent_level);
int connectx4lx_jump_addresses_size(void);
#define CONNECTX4LX_JUMP_ADDRESSES_SIZE    (0x1c)
void connectx4lx_jump_addresses_dump(const struct connectx4lx_jump_addresses *ptr_struct, FILE* file);
/* eqlz_ph3_array_force_single_entry */
void connectx4lx_eqlz_ph3_array_force_single_entry_pack(const struct connectx4lx_eqlz_ph3_array_force_single_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eqlz_ph3_array_force_single_entry_unpack(struct connectx4lx_eqlz_ph3_array_force_single_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eqlz_ph3_array_force_single_entry_print(const struct connectx4lx_eqlz_ph3_array_force_single_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eqlz_ph3_array_force_single_entry_size(void);
#define CONNECTX4LX_EQLZ_PH3_ARRAY_FORCE_SINGLE_ENTRY_SIZE    (0x8)
void connectx4lx_eqlz_ph3_array_force_single_entry_dump(const struct connectx4lx_eqlz_ph3_array_force_single_entry *ptr_struct, FILE* file);
/* capi_ini */
void connectx4lx_capi_ini_pack(const struct connectx4lx_capi_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_capi_ini_unpack(struct connectx4lx_capi_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_capi_ini_print(const struct connectx4lx_capi_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_capi_ini_size(void);
#define CONNECTX4LX_CAPI_INI_SIZE    (0x4)
void connectx4lx_capi_ini_dump(const struct connectx4lx_capi_ini *ptr_struct, FILE* file);
/* gen4_spec_0_5 */
void connectx4lx_gen4_spec_0_5_pack(const struct connectx4lx_gen4_spec_0_5 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gen4_spec_0_5_unpack(struct connectx4lx_gen4_spec_0_5 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gen4_spec_0_5_print(const struct connectx4lx_gen4_spec_0_5 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gen4_spec_0_5_size(void);
#define CONNECTX4LX_GEN4_SPEC_0_5_SIZE    (0x4)
void connectx4lx_gen4_spec_0_5_dump(const struct connectx4lx_gen4_spec_0_5 *ptr_struct, FILE* file);
/* eqlz_ctrl_gen4 */
void connectx4lx_eqlz_ctrl_gen4_pack(const struct connectx4lx_eqlz_ctrl_gen4 *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eqlz_ctrl_gen4_unpack(struct connectx4lx_eqlz_ctrl_gen4 *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eqlz_ctrl_gen4_print(const struct connectx4lx_eqlz_ctrl_gen4 *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eqlz_ctrl_gen4_size(void);
#define CONNECTX4LX_EQLZ_CTRL_GEN4_SIZE    (0x8)
void connectx4lx_eqlz_ctrl_gen4_dump(const struct connectx4lx_eqlz_ctrl_gen4 *ptr_struct, FILE* file);
/* eqlz_ctrl */
void connectx4lx_eqlz_ctrl_pack(const struct connectx4lx_eqlz_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eqlz_ctrl_unpack(struct connectx4lx_eqlz_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eqlz_ctrl_print(const struct connectx4lx_eqlz_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eqlz_ctrl_size(void);
#define CONNECTX4LX_EQLZ_CTRL_SIZE    (0x8)
void connectx4lx_eqlz_ctrl_dump(const struct connectx4lx_eqlz_ctrl *ptr_struct, FILE* file);
/* pcie_rx_sets */
void connectx4lx_pcie_rx_sets_pack(const struct connectx4lx_pcie_rx_sets *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_rx_sets_unpack(struct connectx4lx_pcie_rx_sets *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_rx_sets_print(const struct connectx4lx_pcie_rx_sets *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_rx_sets_size(void);
#define CONNECTX4LX_PCIE_RX_SETS_SIZE    (0x54)
void connectx4lx_pcie_rx_sets_dump(const struct connectx4lx_pcie_rx_sets *ptr_struct, FILE* file);
/* pcie_tx_sets */
void connectx4lx_pcie_tx_sets_pack(const struct connectx4lx_pcie_tx_sets *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_tx_sets_unpack(struct connectx4lx_pcie_tx_sets *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_tx_sets_print(const struct connectx4lx_pcie_tx_sets *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_tx_sets_size(void);
#define CONNECTX4LX_PCIE_TX_SETS_SIZE    (0x14)
void connectx4lx_pcie_tx_sets_dump(const struct connectx4lx_pcie_tx_sets *ptr_struct, FILE* file);
/* power_configuration */
void connectx4lx_power_configuration_pack(const struct connectx4lx_power_configuration *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_power_configuration_unpack(struct connectx4lx_power_configuration *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_power_configuration_print(const struct connectx4lx_power_configuration *ptr_struct, FILE* file, int indent_level);
int connectx4lx_power_configuration_size(void);
#define CONNECTX4LX_POWER_CONFIGURATION_SIZE    (0x2)
void connectx4lx_power_configuration_dump(const struct connectx4lx_power_configuration *ptr_struct, FILE* file);
/* enforce_pn_list_st */
void connectx4lx_enforce_pn_list_st_pack(const struct connectx4lx_enforce_pn_list_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_enforce_pn_list_st_unpack(struct connectx4lx_enforce_pn_list_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_enforce_pn_list_st_print(const struct connectx4lx_enforce_pn_list_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_enforce_pn_list_st_size(void);
#define CONNECTX4LX_ENFORCE_PN_LIST_ST_SIZE    (0x30)
void connectx4lx_enforce_pn_list_st_dump(const struct connectx4lx_enforce_pn_list_st *ptr_struct, FILE* file);
/* power_supply_monitoring */
void connectx4lx_power_supply_monitoring_pack(const struct connectx4lx_power_supply_monitoring *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_power_supply_monitoring_unpack(struct connectx4lx_power_supply_monitoring *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_power_supply_monitoring_print(const struct connectx4lx_power_supply_monitoring *ptr_struct, FILE* file, int indent_level);
int connectx4lx_power_supply_monitoring_size(void);
#define CONNECTX4LX_POWER_SUPPLY_MONITORING_SIZE    (0x4)
void connectx4lx_power_supply_monitoring_dump(const struct connectx4lx_power_supply_monitoring *ptr_struct, FILE* file);
/* i2c_devices_smbus_slv_ix */
void connectx4lx_i2c_devices_smbus_slv_ix_pack(const struct connectx4lx_i2c_devices_smbus_slv_ix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_i2c_devices_smbus_slv_ix_unpack(struct connectx4lx_i2c_devices_smbus_slv_ix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_i2c_devices_smbus_slv_ix_print(const struct connectx4lx_i2c_devices_smbus_slv_ix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_i2c_devices_smbus_slv_ix_size(void);
#define CONNECTX4LX_I2C_DEVICES_SMBUS_SLV_IX_SIZE    (0x8)
void connectx4lx_i2c_devices_smbus_slv_ix_dump(const struct connectx4lx_i2c_devices_smbus_slv_ix *ptr_struct, FILE* file);
/* jtag_ini */
void connectx4lx_jtag_ini_pack(const struct connectx4lx_jtag_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_jtag_ini_unpack(struct connectx4lx_jtag_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_jtag_ini_print(const struct connectx4lx_jtag_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_jtag_ini_size(void);
#define CONNECTX4LX_JTAG_INI_SIZE    (0x8)
void connectx4lx_jtag_ini_dump(const struct connectx4lx_jtag_ini *ptr_struct, FILE* file);
/* yu_shift_register_init */
void connectx4lx_yu_shift_register_init_pack(const struct connectx4lx_yu_shift_register_init *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_yu_shift_register_init_unpack(struct connectx4lx_yu_shift_register_init *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_yu_shift_register_init_print(const struct connectx4lx_yu_shift_register_init *ptr_struct, FILE* file, int indent_level);
int connectx4lx_yu_shift_register_init_size(void);
#define CONNECTX4LX_YU_SHIFT_REGISTER_INIT_SIZE    (0xc)
void connectx4lx_yu_shift_register_init_dump(const struct connectx4lx_yu_shift_register_init *ptr_struct, FILE* file);
/* gpio_conf_st */
void connectx4lx_gpio_conf_st_pack(const struct connectx4lx_gpio_conf_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gpio_conf_st_unpack(struct connectx4lx_gpio_conf_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gpio_conf_st_print(const struct connectx4lx_gpio_conf_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gpio_conf_st_size(void);
#define CONNECTX4LX_GPIO_CONF_ST_SIZE    (0xa0)
void connectx4lx_gpio_conf_st_dump(const struct connectx4lx_gpio_conf_st *ptr_struct, FILE* file);
/* gpio_functions */
void connectx4lx_gpio_functions_pack(const struct connectx4lx_gpio_functions *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gpio_functions_unpack(struct connectx4lx_gpio_functions *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gpio_functions_print(const struct connectx4lx_gpio_functions *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gpio_functions_size(void);
#define CONNECTX4LX_GPIO_FUNCTIONS_SIZE    (0xc8)
void connectx4lx_gpio_functions_dump(const struct connectx4lx_gpio_functions *ptr_struct, FILE* file);
/* i2c_device_entry */
void connectx4lx_i2c_device_entry_pack(const struct connectx4lx_i2c_device_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_i2c_device_entry_unpack(struct connectx4lx_i2c_device_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_i2c_device_entry_print(const struct connectx4lx_i2c_device_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_i2c_device_entry_size(void);
#define CONNECTX4LX_I2C_DEVICE_ENTRY_SIZE    (0x4)
void connectx4lx_i2c_device_entry_dump(const struct connectx4lx_i2c_device_entry *ptr_struct, FILE* file);
/* module_data */
void connectx4lx_module_data_pack(const struct connectx4lx_module_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_data_unpack(struct connectx4lx_module_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_data_print(const struct connectx4lx_module_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_data_size(void);
#define CONNECTX4LX_MODULE_DATA_SIZE    (0x40)
void connectx4lx_module_data_dump(const struct connectx4lx_module_data *ptr_struct, FILE* file);
/* diode_st */
void connectx4lx_diode_st_pack(const struct connectx4lx_diode_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_diode_st_unpack(struct connectx4lx_diode_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_diode_st_print(const struct connectx4lx_diode_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_diode_st_size(void);
#define CONNECTX4LX_DIODE_ST_SIZE    (0x1)
void connectx4lx_diode_st_dump(const struct connectx4lx_diode_st *ptr_struct, FILE* file);
/* iopx_power */
void connectx4lx_iopx_power_pack(const struct connectx4lx_iopx_power *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_iopx_power_unpack(struct connectx4lx_iopx_power *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_iopx_power_print(const struct connectx4lx_iopx_power *ptr_struct, FILE* file, int indent_level);
int connectx4lx_iopx_power_size(void);
#define CONNECTX4LX_IOPX_POWER_SIZE    (0x4)
void connectx4lx_iopx_power_dump(const struct connectx4lx_iopx_power *ptr_struct, FILE* file);
/* iopl_power */
void connectx4lx_iopl_power_pack(const struct connectx4lx_iopl_power *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_iopl_power_unpack(struct connectx4lx_iopl_power *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_iopl_power_print(const struct connectx4lx_iopl_power *ptr_struct, FILE* file, int indent_level);
int connectx4lx_iopl_power_size(void);
#define CONNECTX4LX_IOPL_POWER_SIZE    (0x4)
void connectx4lx_iopl_power_dump(const struct connectx4lx_iopl_power *ptr_struct, FILE* file);
/* port_mlpn_db */
void connectx4lx_port_mlpn_db_pack(const struct connectx4lx_port_mlpn_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_mlpn_db_unpack(struct connectx4lx_port_mlpn_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_mlpn_db_print(const struct connectx4lx_port_mlpn_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_mlpn_db_size(void);
#define CONNECTX4LX_PORT_MLPN_DB_SIZE    (0x10)
void connectx4lx_port_mlpn_db_dump(const struct connectx4lx_port_mlpn_db *ptr_struct, FILE* file);
/* pll_params */
void connectx4lx_pll_params_pack(const struct connectx4lx_pll_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pll_params_unpack(struct connectx4lx_pll_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pll_params_print(const struct connectx4lx_pll_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pll_params_size(void);
#define CONNECTX4LX_PLL_PARAMS_SIZE    (0x24)
void connectx4lx_pll_params_dump(const struct connectx4lx_pll_params *ptr_struct, FILE* file);
/* logic_serdes_mapping_node_ini */
void connectx4lx_logic_serdes_mapping_node_ini_pack(const struct connectx4lx_logic_serdes_mapping_node_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_logic_serdes_mapping_node_ini_unpack(struct connectx4lx_logic_serdes_mapping_node_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_logic_serdes_mapping_node_ini_print(const struct connectx4lx_logic_serdes_mapping_node_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_logic_serdes_mapping_node_ini_size(void);
#define CONNECTX4LX_LOGIC_SERDES_MAPPING_NODE_INI_SIZE    (0x40)
void connectx4lx_logic_serdes_mapping_node_ini_dump(const struct connectx4lx_logic_serdes_mapping_node_ini *ptr_struct, FILE* file);
/* phy_hw_main_config_ip */
void connectx4lx_phy_hw_main_config_ip_pack(const struct connectx4lx_phy_hw_main_config_ip *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_hw_main_config_ip_unpack(struct connectx4lx_phy_hw_main_config_ip *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_hw_main_config_ip_print(const struct connectx4lx_phy_hw_main_config_ip *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_hw_main_config_ip_size(void);
#define CONNECTX4LX_PHY_HW_MAIN_CONFIG_IP_SIZE    (0x180)
void connectx4lx_phy_hw_main_config_ip_dump(const struct connectx4lx_phy_hw_main_config_ip *ptr_struct, FILE* file);
/* nv_config_boot_port_settings */
void connectx4lx_nv_config_boot_port_settings_pack(const struct connectx4lx_nv_config_boot_port_settings *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_port_settings_unpack(struct connectx4lx_nv_config_boot_port_settings *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_port_settings_print(const struct connectx4lx_nv_config_boot_port_settings *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_boot_port_settings_size(void);
#define CONNECTX4LX_NV_CONFIG_BOOT_PORT_SETTINGS_SIZE    (0x4)
void connectx4lx_nv_config_boot_port_settings_dump(const struct connectx4lx_nv_config_boot_port_settings *ptr_struct, FILE* file);
/* nv_config_boot_global */
void connectx4lx_nv_config_boot_global_pack(const struct connectx4lx_nv_config_boot_global *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_global_unpack(struct connectx4lx_nv_config_boot_global *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_global_print(const struct connectx4lx_nv_config_boot_global *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_boot_global_size(void);
#define CONNECTX4LX_NV_CONFIG_BOOT_GLOBAL_SIZE    (0x30)
void connectx4lx_nv_config_boot_global_dump(const struct connectx4lx_nv_config_boot_global *ptr_struct, FILE* file);
/* pci_cfg_space_ini */
void connectx4lx_pci_cfg_space_ini_pack(const struct connectx4lx_pci_cfg_space_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_space_ini_unpack(struct connectx4lx_pci_cfg_space_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_space_ini_print(const struct connectx4lx_pci_cfg_space_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pci_cfg_space_ini_size(void);
#define CONNECTX4LX_PCI_CFG_SPACE_INI_SIZE    (0x3c)
void connectx4lx_pci_cfg_space_ini_dump(const struct connectx4lx_pci_cfg_space_ini *ptr_struct, FILE* file);
/* logger_init_info */
void connectx4lx_logger_init_info_pack(const struct connectx4lx_logger_init_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_logger_init_info_unpack(struct connectx4lx_logger_init_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_logger_init_info_print(const struct connectx4lx_logger_init_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_logger_init_info_size(void);
#define CONNECTX4LX_LOGGER_INIT_INFO_SIZE    (0x4)
void connectx4lx_logger_init_info_dump(const struct connectx4lx_logger_init_info *ptr_struct, FILE* file);
/* mh_host_mapping */
void connectx4lx_mh_host_mapping_pack(const struct connectx4lx_mh_host_mapping *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mh_host_mapping_unpack(struct connectx4lx_mh_host_mapping *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mh_host_mapping_print(const struct connectx4lx_mh_host_mapping *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mh_host_mapping_size(void);
#define CONNECTX4LX_MH_HOST_MAPPING_SIZE    (0x4)
void connectx4lx_mh_host_mapping_dump(const struct connectx4lx_mh_host_mapping *ptr_struct, FILE* file);
/* fw_block_behavior */
void connectx4lx_fw_block_behavior_pack(const union connectx4lx_fw_block_behavior *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_unpack(union connectx4lx_fw_block_behavior *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_block_behavior_print(const union connectx4lx_fw_block_behavior *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_block_behavior_size(void);
#define CONNECTX4LX_FW_BLOCK_BEHAVIOR_SIZE    (0x4)
void connectx4lx_fw_block_behavior_dump(const union connectx4lx_fw_block_behavior *ptr_struct, FILE* file);
/* nv_config_main_fw_data */
void connectx4lx_nv_config_main_fw_data_pack(const struct connectx4lx_nv_config_main_fw_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_main_fw_data_unpack(struct connectx4lx_nv_config_main_fw_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_main_fw_data_print(const struct connectx4lx_nv_config_main_fw_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_main_fw_data_size(void);
#define CONNECTX4LX_NV_CONFIG_MAIN_FW_DATA_SIZE    (0x300)
void connectx4lx_nv_config_main_fw_data_dump(const struct connectx4lx_nv_config_main_fw_data *ptr_struct, FILE* file);
/* serdes_fw_main_config_ip */
void connectx4lx_serdes_fw_main_config_ip_pack(const struct connectx4lx_serdes_fw_main_config_ip *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_serdes_fw_main_config_ip_unpack(struct connectx4lx_serdes_fw_main_config_ip *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_serdes_fw_main_config_ip_print(const struct connectx4lx_serdes_fw_main_config_ip *ptr_struct, FILE* file, int indent_level);
int connectx4lx_serdes_fw_main_config_ip_size(void);
#define CONNECTX4LX_SERDES_FW_MAIN_CONFIG_IP_SIZE    (0x20)
void connectx4lx_serdes_fw_main_config_ip_dump(const struct connectx4lx_serdes_fw_main_config_ip *ptr_struct, FILE* file);
/* serdes_fw_main_config_prj */
void connectx4lx_serdes_fw_main_config_prj_pack(const struct connectx4lx_serdes_fw_main_config_prj *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_serdes_fw_main_config_prj_unpack(struct connectx4lx_serdes_fw_main_config_prj *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_serdes_fw_main_config_prj_print(const struct connectx4lx_serdes_fw_main_config_prj *ptr_struct, FILE* file, int indent_level);
int connectx4lx_serdes_fw_main_config_prj_size(void);
#define CONNECTX4LX_SERDES_FW_MAIN_CONFIG_PRJ_SIZE    (0x20)
void connectx4lx_serdes_fw_main_config_prj_dump(const struct connectx4lx_serdes_fw_main_config_prj *ptr_struct, FILE* file);
/* phy_fw_main_config_ip */
void connectx4lx_phy_fw_main_config_ip_pack(const struct connectx4lx_phy_fw_main_config_ip *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_ip_unpack(struct connectx4lx_phy_fw_main_config_ip *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_ip_print(const struct connectx4lx_phy_fw_main_config_ip *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_fw_main_config_ip_size(void);
#define CONNECTX4LX_PHY_FW_MAIN_CONFIG_IP_SIZE    (0x180)
void connectx4lx_phy_fw_main_config_ip_dump(const struct connectx4lx_phy_fw_main_config_ip *ptr_struct, FILE* file);
/* phy_fw_main_config_shomron */
void connectx4lx_phy_fw_main_config_shomron_pack(const struct connectx4lx_phy_fw_main_config_shomron *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_shomron_unpack(struct connectx4lx_phy_fw_main_config_shomron *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_shomron_print(const struct connectx4lx_phy_fw_main_config_shomron *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_fw_main_config_shomron_size(void);
#define CONNECTX4LX_PHY_FW_MAIN_CONFIG_SHOMRON_SIZE    (0x100)
void connectx4lx_phy_fw_main_config_shomron_dump(const struct connectx4lx_phy_fw_main_config_shomron *ptr_struct, FILE* file);
/* pldm_ini */
void connectx4lx_pldm_ini_pack(const struct connectx4lx_pldm_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pldm_ini_unpack(struct connectx4lx_pldm_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pldm_ini_print(const struct connectx4lx_pldm_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pldm_ini_size(void);
#define CONNECTX4LX_PLDM_INI_SIZE    (0xc)
void connectx4lx_pldm_ini_dump(const struct connectx4lx_pldm_ini *ptr_struct, FILE* file);
/* wol_cap_host_port */
void connectx4lx_wol_cap_host_port_pack(const struct connectx4lx_wol_cap_host_port *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wol_cap_host_port_unpack(struct connectx4lx_wol_cap_host_port *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wol_cap_host_port_print(const struct connectx4lx_wol_cap_host_port *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wol_cap_host_port_size(void);
#define CONNECTX4LX_WOL_CAP_HOST_PORT_SIZE    (0x4)
void connectx4lx_wol_cap_host_port_dump(const struct connectx4lx_wol_cap_host_port *ptr_struct, FILE* file);
/* mctp_ini */
void connectx4lx_mctp_ini_pack(const struct connectx4lx_mctp_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mctp_ini_unpack(struct connectx4lx_mctp_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mctp_ini_print(const struct connectx4lx_mctp_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mctp_ini_size(void);
#define CONNECTX4LX_MCTP_INI_SIZE    (0x8)
void connectx4lx_mctp_ini_dump(const struct connectx4lx_mctp_ini *ptr_struct, FILE* file);
/* ibm_thermal_config */
void connectx4lx_ibm_thermal_config_pack(const struct connectx4lx_ibm_thermal_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ibm_thermal_config_unpack(struct connectx4lx_ibm_thermal_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ibm_thermal_config_print(const struct connectx4lx_ibm_thermal_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ibm_thermal_config_size(void);
#define CONNECTX4LX_IBM_THERMAL_CONFIG_SIZE    (0x1c)
void connectx4lx_ibm_thermal_config_dump(const struct connectx4lx_ibm_thermal_config *ptr_struct, FILE* file);
/* ocsd_config */
void connectx4lx_ocsd_config_pack(const struct connectx4lx_ocsd_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ocsd_config_unpack(struct connectx4lx_ocsd_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ocsd_config_print(const struct connectx4lx_ocsd_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ocsd_config_size(void);
#define CONNECTX4LX_OCSD_CONFIG_SIZE    (0x14)
void connectx4lx_ocsd_config_dump(const struct connectx4lx_ocsd_config *ptr_struct, FILE* file);
/* ncsi_ini */
void connectx4lx_ncsi_ini_pack(const struct connectx4lx_ncsi_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_ini_unpack(struct connectx4lx_ncsi_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_ini_print(const struct connectx4lx_ncsi_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_ini_size(void);
#define CONNECTX4LX_NCSI_INI_SIZE    (0x10)
void connectx4lx_ncsi_ini_dump(const struct connectx4lx_ncsi_ini *ptr_struct, FILE* file);
/* fw_vport0_ini */
void connectx4lx_fw_vport0_ini_pack(const struct connectx4lx_fw_vport0_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_vport0_ini_unpack(struct connectx4lx_fw_vport0_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_vport0_ini_print(const struct connectx4lx_fw_vport0_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_vport0_ini_size(void);
#define CONNECTX4LX_FW_VPORT0_INI_SIZE    (0x4)
void connectx4lx_fw_vport0_ini_dump(const struct connectx4lx_fw_vport0_ini *ptr_struct, FILE* file);
/* apollo_ini */
void connectx4lx_apollo_ini_pack(const struct connectx4lx_apollo_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_apollo_ini_unpack(struct connectx4lx_apollo_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_apollo_ini_print(const struct connectx4lx_apollo_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_apollo_ini_size(void);
#define CONNECTX4LX_APOLLO_INI_SIZE    (0x20)
void connectx4lx_apollo_ini_dump(const struct connectx4lx_apollo_ini *ptr_struct, FILE* file);
/* extended_port_info_ini */
void connectx4lx_extended_port_info_ini_pack(const struct connectx4lx_extended_port_info_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_extended_port_info_ini_unpack(struct connectx4lx_extended_port_info_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_extended_port_info_ini_print(const struct connectx4lx_extended_port_info_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_extended_port_info_ini_size(void);
#define CONNECTX4LX_EXTENDED_PORT_INFO_INI_SIZE    (0x4)
void connectx4lx_extended_port_info_ini_dump(const struct connectx4lx_extended_port_info_ini *ptr_struct, FILE* file);
/* ovonel_ini */
void connectx4lx_ovonel_ini_pack(const struct connectx4lx_ovonel_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ovonel_ini_unpack(struct connectx4lx_ovonel_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ovonel_ini_print(const struct connectx4lx_ovonel_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ovonel_ini_size(void);
#define CONNECTX4LX_OVONEL_INI_SIZE    (0x8)
void connectx4lx_ovonel_ini_dump(const struct connectx4lx_ovonel_ini *ptr_struct, FILE* file);
/* expander_ini */
void connectx4lx_expander_ini_pack(const struct connectx4lx_expander_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_expander_ini_unpack(struct connectx4lx_expander_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_expander_ini_print(const struct connectx4lx_expander_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_expander_ini_size(void);
#define CONNECTX4LX_EXPANDER_INI_SIZE    (0x10)
void connectx4lx_expander_ini_dump(const struct connectx4lx_expander_ini *ptr_struct, FILE* file);
/* ib_port_info_ini */
void connectx4lx_ib_port_info_ini_pack(const struct connectx4lx_ib_port_info_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ib_port_info_ini_unpack(struct connectx4lx_ib_port_info_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ib_port_info_ini_print(const struct connectx4lx_ib_port_info_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ib_port_info_ini_size(void);
#define CONNECTX4LX_IB_PORT_INFO_INI_SIZE    (0x1c)
void connectx4lx_ib_port_info_ini_dump(const struct connectx4lx_ib_port_info_ini *ptr_struct, FILE* file);
/* node_info_ini */
void connectx4lx_node_info_ini_pack(const struct connectx4lx_node_info_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_node_info_ini_unpack(struct connectx4lx_node_info_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_node_info_ini_print(const struct connectx4lx_node_info_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_node_info_ini_size(void);
#define CONNECTX4LX_NODE_INFO_INI_SIZE    (0x40)
void connectx4lx_node_info_ini_dump(const struct connectx4lx_node_info_ini *ptr_struct, FILE* file);
/* port_leds_offsets */
void connectx4lx_port_leds_offsets_pack(const struct connectx4lx_port_leds_offsets *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_leds_offsets_unpack(struct connectx4lx_port_leds_offsets *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_leds_offsets_print(const struct connectx4lx_port_leds_offsets *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_leds_offsets_size(void);
#define CONNECTX4LX_PORT_LEDS_OFFSETS_SIZE    (0x2)
void connectx4lx_port_leds_offsets_dump(const struct connectx4lx_port_leds_offsets *ptr_struct, FILE* file);
/* leds_patterns */
void connectx4lx_leds_patterns_pack(const struct connectx4lx_leds_patterns *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_leds_patterns_unpack(struct connectx4lx_leds_patterns *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_leds_patterns_print(const struct connectx4lx_leds_patterns *ptr_struct, FILE* file, int indent_level);
int connectx4lx_leds_patterns_size(void);
#define CONNECTX4LX_LEDS_PATTERNS_SIZE    (0x48)
void connectx4lx_leds_patterns_dump(const struct connectx4lx_leds_patterns *ptr_struct, FILE* file);
/* uid_entry */
void connectx4lx_uid_entry_pack(const struct connectx4lx_uid_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_uid_entry_unpack(struct connectx4lx_uid_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_uid_entry_print(const struct connectx4lx_uid_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_uid_entry_size(void);
#define CONNECTX4LX_UID_ENTRY_SIZE    (0x10)
void connectx4lx_uid_entry_dump(const struct connectx4lx_uid_entry *ptr_struct, FILE* file);
/* module_version */
void connectx4lx_module_version_pack(const struct connectx4lx_module_version *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_version_unpack(struct connectx4lx_module_version *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_version_print(const struct connectx4lx_module_version *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_version_size(void);
#define CONNECTX4LX_MODULE_VERSION_SIZE    (0x4)
void connectx4lx_module_version_dump(const struct connectx4lx_module_version *ptr_struct, FILE* file);
/* reset_level_info */
void connectx4lx_reset_level_info_pack(const struct connectx4lx_reset_level_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reset_level_info_unpack(struct connectx4lx_reset_level_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reset_level_info_print(const struct connectx4lx_reset_level_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reset_level_info_size(void);
#define CONNECTX4LX_RESET_LEVEL_INFO_SIZE    (0x10)
void connectx4lx_reset_level_info_dump(const struct connectx4lx_reset_level_info *ptr_struct, FILE* file);
/* sysport_packet_data */
void connectx4lx_sysport_packet_data_pack(const struct connectx4lx_sysport_packet_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sysport_packet_data_unpack(struct connectx4lx_sysport_packet_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sysport_packet_data_print(const struct connectx4lx_sysport_packet_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sysport_packet_data_size(void);
#define CONNECTX4LX_SYSPORT_PACKET_DATA_SIZE    (0x2dc)
void connectx4lx_sysport_packet_data_dump(const struct connectx4lx_sysport_packet_data *ptr_struct, FILE* file);
/* sysport_packet_properties */
void connectx4lx_sysport_packet_properties_pack(const struct connectx4lx_sysport_packet_properties *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sysport_packet_properties_unpack(struct connectx4lx_sysport_packet_properties *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sysport_packet_properties_print(const struct connectx4lx_sysport_packet_properties *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sysport_packet_properties_size(void);
#define CONNECTX4LX_SYSPORT_PACKET_PROPERTIES_SIZE    (0x20)
void connectx4lx_sysport_packet_properties_dump(const struct connectx4lx_sysport_packet_properties *ptr_struct, FILE* file);
/* rw_gvmi_fw_ctx_sub_structs */
void connectx4lx_rw_gvmi_fw_ctx_sub_structs_pack(const union connectx4lx_rw_gvmi_fw_ctx_sub_structs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rw_gvmi_fw_ctx_sub_structs_unpack(union connectx4lx_rw_gvmi_fw_ctx_sub_structs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rw_gvmi_fw_ctx_sub_structs_print(const union connectx4lx_rw_gvmi_fw_ctx_sub_structs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rw_gvmi_fw_ctx_sub_structs_size(void);
#define CONNECTX4LX_RW_GVMI_FW_CTX_SUB_STRUCTS_SIZE    (0x40)
void connectx4lx_rw_gvmi_fw_ctx_sub_structs_dump(const union connectx4lx_rw_gvmi_fw_ctx_sub_structs *ptr_struct, FILE* file);
/* disable_mask */
void connectx4lx_disable_mask_pack(const union connectx4lx_disable_mask *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_disable_mask_unpack(union connectx4lx_disable_mask *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_disable_mask_print(const union connectx4lx_disable_mask *ptr_struct, FILE* file, int indent_level);
int connectx4lx_disable_mask_size(void);
#define CONNECTX4LX_DISABLE_MASK_SIZE    (0x4)
void connectx4lx_disable_mask_dump(const union connectx4lx_disable_mask *ptr_struct, FILE* file);
/* drivers_mask_arr */
void connectx4lx_drivers_mask_arr_pack(const struct connectx4lx_drivers_mask_arr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_drivers_mask_arr_unpack(struct connectx4lx_drivers_mask_arr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_drivers_mask_arr_print(const struct connectx4lx_drivers_mask_arr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_drivers_mask_arr_size(void);
#define CONNECTX4LX_DRIVERS_MASK_ARR_SIZE    (0x8)
void connectx4lx_drivers_mask_arr_dump(const struct connectx4lx_drivers_mask_arr *ptr_struct, FILE* file);
/* icmd_mctp_vnd_pci_debug_data */
void connectx4lx_icmd_mctp_vnd_pci_debug_data_pack(const union connectx4lx_icmd_mctp_vnd_pci_debug_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_data_unpack(union connectx4lx_icmd_mctp_vnd_pci_debug_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_data_print(const union connectx4lx_icmd_mctp_vnd_pci_debug_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mctp_vnd_pci_debug_data_size(void);
#define CONNECTX4LX_ICMD_MCTP_VND_PCI_DEBUG_DATA_SIZE    (0x100)
void connectx4lx_icmd_mctp_vnd_pci_debug_data_dump(const union connectx4lx_icmd_mctp_vnd_pci_debug_data *ptr_struct, FILE* file);
/* tlv_data */
void connectx4lx_tlv_data_pack(const union connectx4lx_tlv_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_tlv_data_unpack(union connectx4lx_tlv_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_tlv_data_print(const union connectx4lx_tlv_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_tlv_data_size(void);
#define CONNECTX4LX_TLV_DATA_SIZE    (0x80)
void connectx4lx_tlv_data_dump(const union connectx4lx_tlv_data *ptr_struct, FILE* file);
/* lldp_tlv_extended_type */
void connectx4lx_lldp_tlv_extended_type_pack(const union connectx4lx_lldp_tlv_extended_type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_unpack(union connectx4lx_lldp_tlv_extended_type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lldp_tlv_extended_type_print(const union connectx4lx_lldp_tlv_extended_type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lldp_tlv_extended_type_size(void);
#define CONNECTX4LX_LLDP_TLV_EXTENDED_TYPE_SIZE    (0x8)
void connectx4lx_lldp_tlv_extended_type_dump(const union connectx4lx_lldp_tlv_extended_type *ptr_struct, FILE* file);
/* vport_info */
void connectx4lx_vport_info_pack(const struct connectx4lx_vport_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vport_info_unpack(struct connectx4lx_vport_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vport_info_print(const struct connectx4lx_vport_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vport_info_size(void);
#define CONNECTX4LX_VPORT_INFO_SIZE    (0x40)
void connectx4lx_vport_info_dump(const struct connectx4lx_vport_info *ptr_struct, FILE* file);
/* vport_shadow */
void connectx4lx_vport_shadow_pack(const struct connectx4lx_vport_shadow *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vport_shadow_unpack(struct connectx4lx_vport_shadow *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vport_shadow_print(const struct connectx4lx_vport_shadow *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vport_shadow_size(void);
#define CONNECTX4LX_VPORT_SHADOW_SIZE    (0x20)
void connectx4lx_vport_shadow_dump(const struct connectx4lx_vport_shadow *ptr_struct, FILE* file);
/* ocbb_pci_data */
void connectx4lx_ocbb_pci_data_pack(const struct connectx4lx_ocbb_pci_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ocbb_pci_data_unpack(struct connectx4lx_ocbb_pci_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ocbb_pci_data_print(const struct connectx4lx_ocbb_pci_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ocbb_pci_data_size(void);
#define CONNECTX4LX_OCBB_PCI_DATA_SIZE    (0x2c)
void connectx4lx_ocbb_pci_data_dump(const struct connectx4lx_ocbb_pci_data *ptr_struct, FILE* file);
/* ocbb_fields */
void connectx4lx_ocbb_fields_pack(const struct connectx4lx_ocbb_fields *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ocbb_fields_unpack(struct connectx4lx_ocbb_fields *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ocbb_fields_print(const struct connectx4lx_ocbb_fields *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ocbb_fields_size(void);
#define CONNECTX4LX_OCBB_FIELDS_SIZE    (0x200)
void connectx4lx_ocbb_fields_dump(const struct connectx4lx_ocbb_fields *ptr_struct, FILE* file);
/* module_db_pre_define_st */
void connectx4lx_module_db_pre_define_st_pack(const struct connectx4lx_module_db_pre_define_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_db_pre_define_st_unpack(struct connectx4lx_module_db_pre_define_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_db_pre_define_st_print(const struct connectx4lx_module_db_pre_define_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_db_pre_define_st_size(void);
#define CONNECTX4LX_MODULE_DB_PRE_DEFINE_ST_SIZE    (0x38)
void connectx4lx_module_db_pre_define_st_dump(const struct connectx4lx_module_db_pre_define_st *ptr_struct, FILE* file);
/* fw_driver_version */
void connectx4lx_fw_driver_version_pack(const struct connectx4lx_fw_driver_version *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_driver_version_unpack(struct connectx4lx_fw_driver_version *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_driver_version_print(const struct connectx4lx_fw_driver_version *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_driver_version_size(void);
#define CONNECTX4LX_FW_DRIVER_VERSION_SIZE    (0x40)
void connectx4lx_fw_driver_version_dump(const struct connectx4lx_fw_driver_version *ptr_struct, FILE* file);
/* iterator_result */
void connectx4lx_iterator_result_pack(const struct connectx4lx_iterator_result *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_iterator_result_unpack(struct connectx4lx_iterator_result *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_iterator_result_print(const struct connectx4lx_iterator_result *ptr_struct, FILE* file, int indent_level);
int connectx4lx_iterator_result_size(void);
#define CONNECTX4LX_ITERATOR_RESULT_SIZE    (0x8)
void connectx4lx_iterator_result_dump(const struct connectx4lx_iterator_result *ptr_struct, FILE* file);
/* general_fault_injector_pair */
void connectx4lx_general_fault_injector_pair_pack(const struct connectx4lx_general_fault_injector_pair *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_general_fault_injector_pair_unpack(struct connectx4lx_general_fault_injector_pair *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_general_fault_injector_pair_print(const struct connectx4lx_general_fault_injector_pair *ptr_struct, FILE* file, int indent_level);
int connectx4lx_general_fault_injector_pair_size(void);
#define CONNECTX4LX_GENERAL_FAULT_INJECTOR_PAIR_SIZE    (0x4)
void connectx4lx_general_fault_injector_pair_dump(const struct connectx4lx_general_fault_injector_pair *ptr_struct, FILE* file);
/* dmfs_gvmi_ctx */
void connectx4lx_dmfs_gvmi_ctx_pack(const struct connectx4lx_dmfs_gvmi_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_gvmi_ctx_unpack(struct connectx4lx_dmfs_gvmi_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_gvmi_ctx_print(const struct connectx4lx_dmfs_gvmi_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_gvmi_ctx_size(void);
#define CONNECTX4LX_DMFS_GVMI_CTX_SIZE    (0x40)
void connectx4lx_dmfs_gvmi_ctx_dump(const struct connectx4lx_dmfs_gvmi_ctx *ptr_struct, FILE* file);
/* dmfs_data */
void connectx4lx_dmfs_data_pack(const struct connectx4lx_dmfs_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dmfs_data_unpack(struct connectx4lx_dmfs_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dmfs_data_print(const struct connectx4lx_dmfs_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dmfs_data_size(void);
#define CONNECTX4LX_DMFS_DATA_SIZE    (0x20)
void connectx4lx_dmfs_data_dump(const struct connectx4lx_dmfs_data *ptr_struct, FILE* file);
/* icmd_get_ste_resources_list_out */
void connectx4lx_icmd_get_ste_resources_list_out_pack(const struct connectx4lx_icmd_get_ste_resources_list_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_out_unpack(struct connectx4lx_icmd_get_ste_resources_list_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_out_print(const struct connectx4lx_icmd_get_ste_resources_list_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_resources_list_out_size(void);
#define CONNECTX4LX_ICMD_GET_STE_RESOURCES_LIST_OUT_SIZE    (0x100)
void connectx4lx_icmd_get_ste_resources_list_out_dump(const struct connectx4lx_icmd_get_ste_resources_list_out *ptr_struct, FILE* file);
/* icmd_get_ste_resources_list_in */
void connectx4lx_icmd_get_ste_resources_list_in_pack(const struct connectx4lx_icmd_get_ste_resources_list_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_in_unpack(struct connectx4lx_icmd_get_ste_resources_list_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_in_print(const struct connectx4lx_icmd_get_ste_resources_list_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_resources_list_in_size(void);
#define CONNECTX4LX_ICMD_GET_STE_RESOURCES_LIST_IN_SIZE    (0x10)
void connectx4lx_icmd_get_ste_resources_list_in_dump(const struct connectx4lx_icmd_get_ste_resources_list_in *ptr_struct, FILE* file);
/* icmd_get_ste_open_resources_out */
void connectx4lx_icmd_get_ste_open_resources_out_pack(const struct connectx4lx_icmd_get_ste_open_resources_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_out_unpack(struct connectx4lx_icmd_get_ste_open_resources_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_out_print(const struct connectx4lx_icmd_get_ste_open_resources_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_open_resources_out_size(void);
#define CONNECTX4LX_ICMD_GET_STE_OPEN_RESOURCES_OUT_SIZE    (0x300)
void connectx4lx_icmd_get_ste_open_resources_out_dump(const struct connectx4lx_icmd_get_ste_open_resources_out *ptr_struct, FILE* file);
/* icmd_get_ste_open_resources_in */
void connectx4lx_icmd_get_ste_open_resources_in_pack(const struct connectx4lx_icmd_get_ste_open_resources_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_in_unpack(struct connectx4lx_icmd_get_ste_open_resources_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_in_print(const struct connectx4lx_icmd_get_ste_open_resources_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_open_resources_in_size(void);
#define CONNECTX4LX_ICMD_GET_STE_OPEN_RESOURCES_IN_SIZE    (0x10)
void connectx4lx_icmd_get_ste_open_resources_in_dump(const struct connectx4lx_icmd_get_ste_open_resources_in *ptr_struct, FILE* file);
/* icmd_get_fte_out */
void connectx4lx_icmd_get_fte_out_pack(const struct connectx4lx_icmd_get_fte_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_out_unpack(struct connectx4lx_icmd_get_fte_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_out_print(const struct connectx4lx_icmd_get_fte_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_out_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_OUT_SIZE    (0x300)
void connectx4lx_icmd_get_fte_out_dump(const struct connectx4lx_icmd_get_fte_out *ptr_struct, FILE* file);
/* icmd_get_fte_in */
void connectx4lx_icmd_get_fte_in_pack(const struct connectx4lx_icmd_get_fte_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_in_unpack(struct connectx4lx_icmd_get_fte_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_in_print(const struct connectx4lx_icmd_get_fte_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_in_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_IN_SIZE    (0x10)
void connectx4lx_icmd_get_fte_in_dump(const struct connectx4lx_icmd_get_fte_in *ptr_struct, FILE* file);
/* icmd_get_fte_list_out */
void connectx4lx_icmd_get_fte_list_out_pack(const struct connectx4lx_icmd_get_fte_list_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_out_unpack(struct connectx4lx_icmd_get_fte_list_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_out_print(const struct connectx4lx_icmd_get_fte_list_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_list_out_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_LIST_OUT_SIZE    (0x10)
void connectx4lx_icmd_get_fte_list_out_dump(const struct connectx4lx_icmd_get_fte_list_out *ptr_struct, FILE* file);
/* icmd_get_fte_list_in */
void connectx4lx_icmd_get_fte_list_in_pack(const struct connectx4lx_icmd_get_fte_list_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_in_unpack(struct connectx4lx_icmd_get_fte_list_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_in_print(const struct connectx4lx_icmd_get_fte_list_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_list_in_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_LIST_IN_SIZE    (0x10)
void connectx4lx_icmd_get_fte_list_in_dump(const struct connectx4lx_icmd_get_fte_list_in *ptr_struct, FILE* file);
/* icmd_get_fg_out */
void connectx4lx_icmd_get_fg_out_pack(const struct connectx4lx_icmd_get_fg_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_out_unpack(struct connectx4lx_icmd_get_fg_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_out_print(const struct connectx4lx_icmd_get_fg_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_out_size(void);
#define CONNECTX4LX_ICMD_GET_FG_OUT_SIZE    (0x100)
void connectx4lx_icmd_get_fg_out_dump(const struct connectx4lx_icmd_get_fg_out *ptr_struct, FILE* file);
/* icmd_get_fg_in */
void connectx4lx_icmd_get_fg_in_pack(const struct connectx4lx_icmd_get_fg_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_in_unpack(struct connectx4lx_icmd_get_fg_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_in_print(const struct connectx4lx_icmd_get_fg_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_in_size(void);
#define CONNECTX4LX_ICMD_GET_FG_IN_SIZE    (0x10)
void connectx4lx_icmd_get_fg_in_dump(const struct connectx4lx_icmd_get_fg_in *ptr_struct, FILE* file);
/* icmd_get_fg_list_out */
void connectx4lx_icmd_get_fg_list_out_pack(const struct connectx4lx_icmd_get_fg_list_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_out_unpack(struct connectx4lx_icmd_get_fg_list_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_out_print(const struct connectx4lx_icmd_get_fg_list_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_list_out_size(void);
#define CONNECTX4LX_ICMD_GET_FG_LIST_OUT_SIZE    (0x10)
void connectx4lx_icmd_get_fg_list_out_dump(const struct connectx4lx_icmd_get_fg_list_out *ptr_struct, FILE* file);
/* icmd_get_fg_list_in */
void connectx4lx_icmd_get_fg_list_in_pack(const struct connectx4lx_icmd_get_fg_list_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_in_unpack(struct connectx4lx_icmd_get_fg_list_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_in_print(const struct connectx4lx_icmd_get_fg_list_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_list_in_size(void);
#define CONNECTX4LX_ICMD_GET_FG_LIST_IN_SIZE    (0x10)
void connectx4lx_icmd_get_fg_list_in_dump(const struct connectx4lx_icmd_get_fg_list_in *ptr_struct, FILE* file);
/* icmd_get_ft_info_out */
void connectx4lx_icmd_get_ft_info_out_pack(const struct connectx4lx_icmd_get_ft_info_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_out_unpack(struct connectx4lx_icmd_get_ft_info_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_out_print(const struct connectx4lx_icmd_get_ft_info_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_info_out_size(void);
#define CONNECTX4LX_ICMD_GET_FT_INFO_OUT_SIZE    (0x10)
void connectx4lx_icmd_get_ft_info_out_dump(const struct connectx4lx_icmd_get_ft_info_out *ptr_struct, FILE* file);
/* icmd_get_ft_info_in */
void connectx4lx_icmd_get_ft_info_in_pack(const struct connectx4lx_icmd_get_ft_info_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_in_unpack(struct connectx4lx_icmd_get_ft_info_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_in_print(const struct connectx4lx_icmd_get_ft_info_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_info_in_size(void);
#define CONNECTX4LX_ICMD_GET_FT_INFO_IN_SIZE    (0x10)
void connectx4lx_icmd_get_ft_info_in_dump(const struct connectx4lx_icmd_get_ft_info_in *ptr_struct, FILE* file);
/* icmd_get_ft_list_out */
void connectx4lx_icmd_get_ft_list_out_pack(const struct connectx4lx_icmd_get_ft_list_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_out_unpack(struct connectx4lx_icmd_get_ft_list_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_out_print(const struct connectx4lx_icmd_get_ft_list_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_list_out_size(void);
#define CONNECTX4LX_ICMD_GET_FT_LIST_OUT_SIZE    (0x10)
void connectx4lx_icmd_get_ft_list_out_dump(const struct connectx4lx_icmd_get_ft_list_out *ptr_struct, FILE* file);
/* icmd_get_ft_list_in */
void connectx4lx_icmd_get_ft_list_in_pack(const struct connectx4lx_icmd_get_ft_list_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_in_unpack(struct connectx4lx_icmd_get_ft_list_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_in_print(const struct connectx4lx_icmd_get_ft_list_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_list_in_size(void);
#define CONNECTX4LX_ICMD_GET_FT_LIST_IN_SIZE    (0x10)
void connectx4lx_icmd_get_ft_list_in_dump(const struct connectx4lx_icmd_get_ft_list_in *ptr_struct, FILE* file);
/* led_control_data */
void connectx4lx_led_control_data_pack(const struct connectx4lx_led_control_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_led_control_data_unpack(struct connectx4lx_led_control_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_led_control_data_print(const struct connectx4lx_led_control_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_led_control_data_size(void);
#define CONNECTX4LX_LED_CONTROL_DATA_SIZE    (0x40)
void connectx4lx_led_control_data_dump(const struct connectx4lx_led_control_data *ptr_struct, FILE* file);
/* pll_varactor_config_value */
void connectx4lx_pll_varactor_config_value_pack(const struct connectx4lx_pll_varactor_config_value *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pll_varactor_config_value_unpack(struct connectx4lx_pll_varactor_config_value *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pll_varactor_config_value_print(const struct connectx4lx_pll_varactor_config_value *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pll_varactor_config_value_size(void);
#define CONNECTX4LX_PLL_VARACTOR_CONFIG_VALUE_SIZE    (0x4)
void connectx4lx_pll_varactor_config_value_dump(const struct connectx4lx_pll_varactor_config_value *ptr_struct, FILE* file);
/* phy_uc_array_line */
void connectx4lx_phy_uc_array_line_pack(const struct connectx4lx_phy_uc_array_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_uc_array_line_unpack(struct connectx4lx_phy_uc_array_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_uc_array_line_print(const struct connectx4lx_phy_uc_array_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_uc_array_line_size(void);
#define CONNECTX4LX_PHY_UC_ARRAY_LINE_SIZE    (0xc)
void connectx4lx_phy_uc_array_line_dump(const struct connectx4lx_phy_uc_array_line *ptr_struct, FILE* file);
/* pll_status */
void connectx4lx_pll_status_pack(const struct connectx4lx_pll_status *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pll_status_unpack(struct connectx4lx_pll_status *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pll_status_print(const struct connectx4lx_pll_status *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pll_status_size(void);
#define CONNECTX4LX_PLL_STATUS_SIZE    (0x8)
void connectx4lx_pll_status_dump(const struct connectx4lx_pll_status *ptr_struct, FILE* file);
/* module_params */
void connectx4lx_module_params_pack(const struct connectx4lx_module_params *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_params_unpack(struct connectx4lx_module_params *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_params_print(const struct connectx4lx_module_params *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_params_size(void);
#define CONNECTX4LX_MODULE_PARAMS_SIZE    (0x14)
void connectx4lx_module_params_dump(const struct connectx4lx_module_params *ptr_struct, FILE* file);
/* best_rx_set */
void connectx4lx_best_rx_set_pack(const struct connectx4lx_best_rx_set *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_best_rx_set_unpack(struct connectx4lx_best_rx_set *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_best_rx_set_print(const struct connectx4lx_best_rx_set *ptr_struct, FILE* file, int indent_level);
int connectx4lx_best_rx_set_size(void);
#define CONNECTX4LX_BEST_RX_SET_SIZE    (0x40)
void connectx4lx_best_rx_set_dump(const struct connectx4lx_best_rx_set *ptr_struct, FILE* file);
/* temperature_fields_st */
void connectx4lx_temperature_fields_st_pack(const struct connectx4lx_temperature_fields_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_temperature_fields_st_unpack(struct connectx4lx_temperature_fields_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_temperature_fields_st_print(const struct connectx4lx_temperature_fields_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_temperature_fields_st_size(void);
#define CONNECTX4LX_TEMPERATURE_FIELDS_ST_SIZE    (0x14)
void connectx4lx_temperature_fields_st_dump(const struct connectx4lx_temperature_fields_st *ptr_struct, FILE* file);
/* admin_fields_st */
void connectx4lx_admin_fields_st_pack(const struct connectx4lx_admin_fields_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_admin_fields_st_unpack(struct connectx4lx_admin_fields_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_admin_fields_st_print(const struct connectx4lx_admin_fields_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_admin_fields_st_size(void);
#define CONNECTX4LX_ADMIN_FIELDS_ST_SIZE    (0x4)
void connectx4lx_admin_fields_st_dump(const struct connectx4lx_admin_fields_st *ptr_struct, FILE* file);
/* com_codes_st */
void connectx4lx_com_codes_st_pack(const union connectx4lx_com_codes_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_com_codes_st_unpack(union connectx4lx_com_codes_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_com_codes_st_print(const union connectx4lx_com_codes_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_com_codes_st_size(void);
#define CONNECTX4LX_COM_CODES_ST_SIZE    (0x4)
void connectx4lx_com_codes_st_dump(const union connectx4lx_com_codes_st *ptr_struct, FILE* file);
/* fpga_flex_nic_ctrl_data */
void connectx4lx_fpga_flex_nic_ctrl_data_pack(const struct connectx4lx_fpga_flex_nic_ctrl_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fpga_flex_nic_ctrl_data_unpack(struct connectx4lx_fpga_flex_nic_ctrl_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fpga_flex_nic_ctrl_data_print(const struct connectx4lx_fpga_flex_nic_ctrl_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fpga_flex_nic_ctrl_data_size(void);
#define CONNECTX4LX_FPGA_FLEX_NIC_CTRL_DATA_SIZE    (0x80)
void connectx4lx_fpga_flex_nic_ctrl_data_dump(const struct connectx4lx_fpga_flex_nic_ctrl_data *ptr_struct, FILE* file);
/* steering_table_info */
void connectx4lx_steering_table_info_pack(const struct connectx4lx_steering_table_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_steering_table_info_unpack(struct connectx4lx_steering_table_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_steering_table_info_print(const struct connectx4lx_steering_table_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_steering_table_info_size(void);
#define CONNECTX4LX_STEERING_TABLE_INFO_SIZE    (0x40)
void connectx4lx_steering_table_info_dump(const struct connectx4lx_steering_table_info *ptr_struct, FILE* file);
/* dcr_info */
void connectx4lx_dcr_info_pack(const struct connectx4lx_dcr_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dcr_info_unpack(struct connectx4lx_dcr_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dcr_info_print(const struct connectx4lx_dcr_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dcr_info_size(void);
#define CONNECTX4LX_DCR_INFO_SIZE    (0x4)
void connectx4lx_dcr_info_dump(const struct connectx4lx_dcr_info *ptr_struct, FILE* file);
/* icmd_ver_data_cmd_specific */
void connectx4lx_icmd_ver_data_cmd_specific_pack(const union connectx4lx_icmd_ver_data_cmd_specific *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_cmd_specific_unpack(union connectx4lx_icmd_ver_data_cmd_specific *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_cmd_specific_print(const union connectx4lx_icmd_ver_data_cmd_specific *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ver_data_cmd_specific_size(void);
#define CONNECTX4LX_ICMD_VER_DATA_CMD_SPECIFIC_SIZE    (0x40)
void connectx4lx_icmd_ver_data_cmd_specific_dump(const union connectx4lx_icmd_ver_data_cmd_specific *ptr_struct, FILE* file);
/* icmd_pcie_ver_frequency */
void connectx4lx_icmd_pcie_ver_frequency_pack(const struct connectx4lx_icmd_pcie_ver_frequency *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_frequency_unpack(struct connectx4lx_icmd_pcie_ver_frequency *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_frequency_print(const struct connectx4lx_icmd_pcie_ver_frequency *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pcie_ver_frequency_size(void);
#define CONNECTX4LX_ICMD_PCIE_VER_FREQUENCY_SIZE    (0x10)
void connectx4lx_icmd_pcie_ver_frequency_dump(const struct connectx4lx_icmd_pcie_ver_frequency *ptr_struct, FILE* file);
/* icmd_pcie_ver_cables */
void connectx4lx_icmd_pcie_ver_cables_pack(const struct connectx4lx_icmd_pcie_ver_cables *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_cables_unpack(struct connectx4lx_icmd_pcie_ver_cables *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_cables_print(const struct connectx4lx_icmd_pcie_ver_cables *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pcie_ver_cables_size(void);
#define CONNECTX4LX_ICMD_PCIE_VER_CABLES_SIZE    (0x10)
void connectx4lx_icmd_pcie_ver_cables_dump(const struct connectx4lx_icmd_pcie_ver_cables *ptr_struct, FILE* file);
/* icmd_pcie_ver_device */
void connectx4lx_icmd_pcie_ver_device_pack(const struct connectx4lx_icmd_pcie_ver_device *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_device_unpack(struct connectx4lx_icmd_pcie_ver_device *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_device_print(const struct connectx4lx_icmd_pcie_ver_device *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pcie_ver_device_size(void);
#define CONNECTX4LX_ICMD_PCIE_VER_DEVICE_SIZE    (0x10)
void connectx4lx_icmd_pcie_ver_device_dump(const struct connectx4lx_icmd_pcie_ver_device *ptr_struct, FILE* file);
/* error_flow_trigger_union */
void connectx4lx_error_flow_trigger_union_pack(const struct connectx4lx_error_flow_trigger_union *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_union_unpack(struct connectx4lx_error_flow_trigger_union *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_error_flow_trigger_union_print(const struct connectx4lx_error_flow_trigger_union *ptr_struct, FILE* file, int indent_level);
int connectx4lx_error_flow_trigger_union_size(void);
#define CONNECTX4LX_ERROR_FLOW_TRIGGER_UNION_SIZE    (0x40)
void connectx4lx_error_flow_trigger_union_dump(const struct connectx4lx_error_flow_trigger_union *ptr_struct, FILE* file);
/* code_coverage_control */
void connectx4lx_code_coverage_control_pack(const struct connectx4lx_code_coverage_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_code_coverage_control_unpack(struct connectx4lx_code_coverage_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_code_coverage_control_print(const struct connectx4lx_code_coverage_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_code_coverage_control_size(void);
#define CONNECTX4LX_CODE_COVERAGE_CONTROL_SIZE    (0x8)
void connectx4lx_code_coverage_control_dump(const struct connectx4lx_code_coverage_control *ptr_struct, FILE* file);
/* vport_real_state */
void connectx4lx_vport_real_state_pack(const struct connectx4lx_vport_real_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vport_real_state_unpack(struct connectx4lx_vport_real_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vport_real_state_print(const struct connectx4lx_vport_real_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vport_real_state_size(void);
#define CONNECTX4LX_VPORT_REAL_STATE_SIZE    (0x80)
void connectx4lx_vport_real_state_dump(const struct connectx4lx_vport_real_state *ptr_struct, FILE* file);
/* fw_esw */
void connectx4lx_fw_esw_pack(const struct connectx4lx_fw_esw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_esw_unpack(struct connectx4lx_fw_esw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_esw_print(const struct connectx4lx_fw_esw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_esw_size(void);
#define CONNECTX4LX_FW_ESW_SIZE    (0x200)
void connectx4lx_fw_esw_dump(const struct connectx4lx_fw_esw *ptr_struct, FILE* file);
/* gvmix_sub_structs */
void connectx4lx_gvmix_sub_structs_pack(const union connectx4lx_gvmix_sub_structs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_gvmix_sub_structs_unpack(union connectx4lx_gvmix_sub_structs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_gvmix_sub_structs_print(const union connectx4lx_gvmix_sub_structs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_gvmix_sub_structs_size(void);
#define CONNECTX4LX_GVMIX_SUB_STRUCTS_SIZE    (0x40)
void connectx4lx_gvmix_sub_structs_dump(const union connectx4lx_gvmix_sub_structs *ptr_struct, FILE* file);
/* sw_eqe */
void connectx4lx_sw_eqe_pack(const struct connectx4lx_sw_eqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_eqe_unpack(struct connectx4lx_sw_eqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_eqe_print(const struct connectx4lx_sw_eqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_eqe_size(void);
#define CONNECTX4LX_SW_EQE_SIZE    (0x40)
void connectx4lx_sw_eqe_dump(const struct connectx4lx_sw_eqe *ptr_struct, FILE* file);
/* ncsi_response */
void connectx4lx_ncsi_response_pack(const struct connectx4lx_ncsi_response *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_response_unpack(struct connectx4lx_ncsi_response *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_response_print(const struct connectx4lx_ncsi_response *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_response_size(void);
#define CONNECTX4LX_NCSI_RESPONSE_SIZE    (0x114)
void connectx4lx_ncsi_response_dump(const struct connectx4lx_ncsi_response *ptr_struct, FILE* file);
/* ncsi_cmd */
void connectx4lx_ncsi_cmd_pack(const struct connectx4lx_ncsi_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ncsi_cmd_unpack(struct connectx4lx_ncsi_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ncsi_cmd_print(const struct connectx4lx_ncsi_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ncsi_cmd_size(void);
#define CONNECTX4LX_NCSI_CMD_SIZE    (0x110)
void connectx4lx_ncsi_cmd_dump(const struct connectx4lx_ncsi_cmd *ptr_struct, FILE* file);
/* lock_tag */
void connectx4lx_lock_tag_pack(const struct connectx4lx_lock_tag *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lock_tag_unpack(struct connectx4lx_lock_tag *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lock_tag_print(const struct connectx4lx_lock_tag *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lock_tag_size(void);
#define CONNECTX4LX_LOCK_TAG_SIZE    (0x4)
void connectx4lx_lock_tag_dump(const struct connectx4lx_lock_tag *ptr_struct, FILE* file);
/* icmd_generic_reg_access_reg_tlv */
void connectx4lx_icmd_generic_reg_access_reg_tlv_pack(const struct connectx4lx_icmd_generic_reg_access_reg_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_reg_access_reg_tlv_unpack(struct connectx4lx_icmd_generic_reg_access_reg_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_reg_access_reg_tlv_print(const struct connectx4lx_icmd_generic_reg_access_reg_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_generic_reg_access_reg_tlv_size(void);
#define CONNECTX4LX_ICMD_GENERIC_REG_ACCESS_REG_TLV_SIZE    (0x114)
void connectx4lx_icmd_generic_reg_access_reg_tlv_dump(const struct connectx4lx_icmd_generic_reg_access_reg_tlv *ptr_struct, FILE* file);
/* reg_access_oper_tlv */
void connectx4lx_reg_access_oper_tlv_pack(const struct connectx4lx_reg_access_oper_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reg_access_oper_tlv_unpack(struct connectx4lx_reg_access_oper_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reg_access_oper_tlv_print(const struct connectx4lx_reg_access_oper_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reg_access_oper_tlv_size(void);
#define CONNECTX4LX_REG_ACCESS_OPER_TLV_SIZE    (0x10)
void connectx4lx_reg_access_oper_tlv_dump(const struct connectx4lx_reg_access_oper_tlv *ptr_struct, FILE* file);
/* icmd_kdnet_ctrl_io */
void connectx4lx_icmd_kdnet_ctrl_io_pack(const union connectx4lx_icmd_kdnet_ctrl_io *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_io_unpack(union connectx4lx_icmd_kdnet_ctrl_io *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_io_print(const union connectx4lx_icmd_kdnet_ctrl_io *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_kdnet_ctrl_io_size(void);
#define CONNECTX4LX_ICMD_KDNET_CTRL_IO_SIZE    (0x4)
void connectx4lx_icmd_kdnet_ctrl_io_dump(const union connectx4lx_icmd_kdnet_ctrl_io *ptr_struct, FILE* file);
/* icmd_query_cap_general */
void connectx4lx_icmd_query_cap_general_pack(const struct connectx4lx_icmd_query_cap_general *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_query_cap_general_unpack(struct connectx4lx_icmd_query_cap_general *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_query_cap_general_print(const struct connectx4lx_icmd_query_cap_general *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_query_cap_general_size(void);
#define CONNECTX4LX_ICMD_QUERY_CAP_GENERAL_SIZE    (0x8)
void connectx4lx_icmd_query_cap_general_dump(const struct connectx4lx_icmd_query_cap_general *ptr_struct, FILE* file);
/* icmd_query_cap_in */
void connectx4lx_icmd_query_cap_in_pack(const struct connectx4lx_icmd_query_cap_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_query_cap_in_unpack(struct connectx4lx_icmd_query_cap_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_query_cap_in_print(const struct connectx4lx_icmd_query_cap_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_query_cap_in_size(void);
#define CONNECTX4LX_ICMD_QUERY_CAP_IN_SIZE    (0x4)
void connectx4lx_icmd_query_cap_in_dump(const struct connectx4lx_icmd_query_cap_in *ptr_struct, FILE* file);
/* cable_info */
void connectx4lx_cable_info_pack(const struct connectx4lx_cable_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cable_info_unpack(struct connectx4lx_cable_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cable_info_print(const struct connectx4lx_cable_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cable_info_size(void);
#define CONNECTX4LX_CABLE_INFO_SIZE    (0x40)
void connectx4lx_cable_info_dump(const struct connectx4lx_cable_info *ptr_struct, FILE* file);
/* grepper_dwords */
void connectx4lx_grepper_dwords_pack(const struct connectx4lx_grepper_dwords *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_grepper_dwords_unpack(struct connectx4lx_grepper_dwords *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_grepper_dwords_print(const struct connectx4lx_grepper_dwords *ptr_struct, FILE* file, int indent_level);
int connectx4lx_grepper_dwords_size(void);
#define CONNECTX4LX_GREPPER_DWORDS_SIZE    (0x40)
void connectx4lx_grepper_dwords_dump(const struct connectx4lx_grepper_dwords *ptr_struct, FILE* file);
/* itrace */
void connectx4lx_itrace_pack(const struct connectx4lx_itrace *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itrace_unpack(struct connectx4lx_itrace *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itrace_print(const struct connectx4lx_itrace *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itrace_size(void);
#define CONNECTX4LX_ITRACE_SIZE    (0x10)
void connectx4lx_itrace_dump(const struct connectx4lx_itrace *ptr_struct, FILE* file);
/* cc_table_entry */
void connectx4lx_cc_table_entry_pack(const struct connectx4lx_cc_table_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cc_table_entry_unpack(struct connectx4lx_cc_table_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cc_table_entry_print(const struct connectx4lx_cc_table_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cc_table_entry_size(void);
#define CONNECTX4LX_CC_TABLE_ENTRY_SIZE    (0x2)
void connectx4lx_cc_table_entry_dump(const struct connectx4lx_cc_table_entry *ptr_struct, FILE* file);
/* ca_congestion_entry */
void connectx4lx_ca_congestion_entry_pack(const struct connectx4lx_ca_congestion_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ca_congestion_entry_unpack(struct connectx4lx_ca_congestion_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ca_congestion_entry_print(const struct connectx4lx_ca_congestion_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ca_congestion_entry_size(void);
#define CONNECTX4LX_CA_CONGESTION_ENTRY_SIZE    (0x8)
void connectx4lx_ca_congestion_entry_dump(const struct connectx4lx_ca_congestion_entry *ptr_struct, FILE* file);
/* congestion_log_event_entry */
void connectx4lx_congestion_log_event_entry_pack(const struct connectx4lx_congestion_log_event_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_congestion_log_event_entry_unpack(struct connectx4lx_congestion_log_event_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_congestion_log_event_entry_print(const struct connectx4lx_congestion_log_event_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_congestion_log_event_entry_size(void);
#define CONNECTX4LX_CONGESTION_LOG_EVENT_ENTRY_SIZE    (0x10)
void connectx4lx_congestion_log_event_entry_dump(const struct connectx4lx_congestion_log_event_entry *ptr_struct, FILE* file);
/* special_qps */
void connectx4lx_special_qps_pack(const struct connectx4lx_special_qps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_special_qps_unpack(struct connectx4lx_special_qps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_special_qps_print(const struct connectx4lx_special_qps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_special_qps_size(void);
#define CONNECTX4LX_SPECIAL_QPS_SIZE    (0x20)
void connectx4lx_special_qps_dump(const struct connectx4lx_special_qps *ptr_struct, FILE* file);
/* cmdif_hdr */
void connectx4lx_cmdif_hdr_pack(const struct connectx4lx_cmdif_hdr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cmdif_hdr_unpack(struct connectx4lx_cmdif_hdr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cmdif_hdr_print(const struct connectx4lx_cmdif_hdr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cmdif_hdr_size(void);
#define CONNECTX4LX_CMDIF_HDR_SIZE    (0x40)
void connectx4lx_cmdif_hdr_dump(const struct connectx4lx_cmdif_hdr *ptr_struct, FILE* file);
/* icmd_header_capture_checks */
void connectx4lx_icmd_header_capture_checks_pack(const struct connectx4lx_icmd_header_capture_checks *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_checks_unpack(struct connectx4lx_icmd_header_capture_checks *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_checks_print(const struct connectx4lx_icmd_header_capture_checks *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_header_capture_checks_size(void);
#define CONNECTX4LX_ICMD_HEADER_CAPTURE_CHECKS_SIZE    (0x40)
void connectx4lx_icmd_header_capture_checks_dump(const struct connectx4lx_icmd_header_capture_checks *ptr_struct, FILE* file);
/* icmd_header_capture_headers */
void connectx4lx_icmd_header_capture_headers_pack(const struct connectx4lx_icmd_header_capture_headers *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_headers_unpack(struct connectx4lx_icmd_header_capture_headers *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_headers_print(const struct connectx4lx_icmd_header_capture_headers *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_header_capture_headers_size(void);
#define CONNECTX4LX_ICMD_HEADER_CAPTURE_HEADERS_SIZE    (0x80)
void connectx4lx_icmd_header_capture_headers_dump(const struct connectx4lx_icmd_header_capture_headers *ptr_struct, FILE* file);
/* g_rse_hw_decoders */
void connectx4lx_g_rse_hw_decoders_pack(const union connectx4lx_g_rse_hw_decoders *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_g_rse_hw_decoders_unpack(union connectx4lx_g_rse_hw_decoders *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_g_rse_hw_decoders_print(const union connectx4lx_g_rse_hw_decoders *ptr_struct, FILE* file, int indent_level);
int connectx4lx_g_rse_hw_decoders_size(void);
#define CONNECTX4LX_G_RSE_HW_DECODERS_SIZE    (0x100)
void connectx4lx_g_rse_hw_decoders_dump(const union connectx4lx_g_rse_hw_decoders *ptr_struct, FILE* file);
/* FW_VERSION */
void connectx4lx_FW_VERSION_pack(const struct connectx4lx_FW_VERSION *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_FW_VERSION_unpack(struct connectx4lx_FW_VERSION *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_FW_VERSION_print(const struct connectx4lx_FW_VERSION *ptr_struct, FILE* file, int indent_level);
int connectx4lx_FW_VERSION_size(void);
#define CONNECTX4LX_FW_VERSION_SIZE    (0x10)
void connectx4lx_FW_VERSION_dump(const struct connectx4lx_FW_VERSION *ptr_struct, FILE* file);
/* golan_hw_fw_ctx */
void connectx4lx_golan_hw_fw_ctx_pack(const union connectx4lx_golan_hw_fw_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_golan_hw_fw_ctx_unpack(union connectx4lx_golan_hw_fw_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_golan_hw_fw_ctx_print(const union connectx4lx_golan_hw_fw_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_golan_hw_fw_ctx_size(void);
#define CONNECTX4LX_GOLAN_HW_FW_CTX_SIZE    (0x40)
void connectx4lx_golan_hw_fw_ctx_dump(const union connectx4lx_golan_hw_fw_ctx *ptr_struct, FILE* file);
/* best_rx_debug */
void connectx4lx_best_rx_debug_pack(const struct connectx4lx_best_rx_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_best_rx_debug_unpack(struct connectx4lx_best_rx_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_best_rx_debug_print(const struct connectx4lx_best_rx_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_best_rx_debug_size(void);
#define CONNECTX4LX_BEST_RX_DEBUG_SIZE    (0x90)
void connectx4lx_best_rx_debug_dump(const struct connectx4lx_best_rx_debug *ptr_struct, FILE* file);
/* data_line */
void connectx4lx_data_line_pack(const struct connectx4lx_data_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_data_line_unpack(struct connectx4lx_data_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_data_line_print(const struct connectx4lx_data_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_data_line_size(void);
#define CONNECTX4LX_DATA_LINE_SIZE    (0x4)
void connectx4lx_data_line_dump(const struct connectx4lx_data_line *ptr_struct, FILE* file);
/* start_point_data */
void connectx4lx_start_point_data_pack(const struct connectx4lx_start_point_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_start_point_data_unpack(struct connectx4lx_start_point_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_start_point_data_print(const struct connectx4lx_start_point_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_start_point_data_size(void);
#define CONNECTX4LX_START_POINT_DATA_SIZE    (0x40)
void connectx4lx_start_point_data_dump(const struct connectx4lx_start_point_data *ptr_struct, FILE* file);
/* lane_search_vars */
void connectx4lx_lane_search_vars_pack(const struct connectx4lx_lane_search_vars *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_search_vars_unpack(struct connectx4lx_lane_search_vars *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_search_vars_print(const struct connectx4lx_lane_search_vars *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_search_vars_size(void);
#define CONNECTX4LX_LANE_SEARCH_VARS_SIZE    (0x50)
void connectx4lx_lane_search_vars_dump(const struct connectx4lx_lane_search_vars *ptr_struct, FILE* file);
/* opamp_data */
void connectx4lx_opamp_data_pack(const struct connectx4lx_opamp_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_opamp_data_unpack(struct connectx4lx_opamp_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_opamp_data_print(const struct connectx4lx_opamp_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_opamp_data_size(void);
#define CONNECTX4LX_OPAMP_DATA_SIZE    (0x4)
void connectx4lx_opamp_data_dump(const struct connectx4lx_opamp_data *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_128byte */
void connectx4lx_wqe_extended_atomic_fetch_add_128byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_128byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_128byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_128byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_128byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_128byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_128byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_128BYTE_SIZE    (0x100)
void connectx4lx_wqe_extended_atomic_fetch_add_128byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_128byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_64byte */
void connectx4lx_wqe_extended_atomic_fetch_add_64byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_64byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_64byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_64byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_64byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_64byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_64byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_64BYTE_SIZE    (0x80)
void connectx4lx_wqe_extended_atomic_fetch_add_64byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_64byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_32byte */
void connectx4lx_wqe_extended_atomic_fetch_add_32byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_32byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_32byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_32byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_32byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_32byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_32byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_32BYTE_SIZE    (0x40)
void connectx4lx_wqe_extended_atomic_fetch_add_32byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_32byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_16byte */
void connectx4lx_wqe_extended_atomic_fetch_add_16byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_16byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_16byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_16byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_16byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_16byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_16byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_16BYTE_SIZE    (0x20)
void connectx4lx_wqe_extended_atomic_fetch_add_16byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_16byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_8byte */
void connectx4lx_wqe_extended_atomic_fetch_add_8byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_8byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_8byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_8byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_8byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_8byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_8byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_8BYTE_SIZE    (0x10)
void connectx4lx_wqe_extended_atomic_fetch_add_8byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_8byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add_4byte */
void connectx4lx_wqe_extended_atomic_fetch_add_4byte_pack(const struct connectx4lx_wqe_extended_atomic_fetch_add_4byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_4byte_unpack(struct connectx4lx_wqe_extended_atomic_fetch_add_4byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_4byte_print(const struct connectx4lx_wqe_extended_atomic_fetch_add_4byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_4byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_4BYTE_SIZE    (0x10)
void connectx4lx_wqe_extended_atomic_fetch_add_4byte_dump(const struct connectx4lx_wqe_extended_atomic_fetch_add_4byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_128byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_128byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_128byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_128byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_128byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_128BYTE_SIZE    (0x200)
void connectx4lx_wqe_extended_atomic_cmp_swap_128byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_128byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_64byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_64byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_64byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_64byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_64byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_64BYTE_SIZE    (0x100)
void connectx4lx_wqe_extended_atomic_cmp_swap_64byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_64byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_32byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_32byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_32byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_32byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_32byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_32BYTE_SIZE    (0x80)
void connectx4lx_wqe_extended_atomic_cmp_swap_32byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_32byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_16byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_16byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_16byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_16byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_16byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_16BYTE_SIZE    (0x40)
void connectx4lx_wqe_extended_atomic_cmp_swap_16byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_16byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_8byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_8byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_8byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_8byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_8byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_8BYTE_SIZE    (0x20)
void connectx4lx_wqe_extended_atomic_cmp_swap_8byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_8byte *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap_4byte */
void connectx4lx_wqe_extended_atomic_cmp_swap_4byte_pack(const struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_4byte_unpack(struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_4byte_print(const struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_4byte_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_4BYTE_SIZE    (0x10)
void connectx4lx_wqe_extended_atomic_cmp_swap_4byte_dump(const struct connectx4lx_wqe_extended_atomic_cmp_swap_4byte *ptr_struct, FILE* file);
/* file_public_keys */
void connectx4lx_file_public_keys_pack(const struct connectx4lx_file_public_keys *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_file_public_keys_unpack(struct connectx4lx_file_public_keys *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_file_public_keys_print(const struct connectx4lx_file_public_keys *ptr_struct, FILE* file, int indent_level);
int connectx4lx_file_public_keys_size(void);
#define CONNECTX4LX_FILE_PUBLIC_KEYS_SIZE    (0x120)
void connectx4lx_file_public_keys_dump(const struct connectx4lx_file_public_keys *ptr_struct, FILE* file);
/* nv_config_header */
void connectx4lx_nv_config_header_pack(const struct connectx4lx_nv_config_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_header_unpack(struct connectx4lx_nv_config_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_header_print(const struct connectx4lx_nv_config_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_header_size(void);
#define CONNECTX4LX_NV_CONFIG_HEADER_SIZE    (0x40)
void connectx4lx_nv_config_header_dump(const struct connectx4lx_nv_config_header *ptr_struct, FILE* file);
/* cluster_consts */
void connectx4lx_cluster_consts_pack(const struct connectx4lx_cluster_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_cluster_consts_unpack(struct connectx4lx_cluster_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_cluster_consts_print(const struct connectx4lx_cluster_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_cluster_consts_size(void);
#define CONNECTX4LX_CLUSTER_CONSTS_SIZE    (0x2a00)
void connectx4lx_cluster_consts_dump(const struct connectx4lx_cluster_consts *ptr_struct, FILE* file);
/* shared_consts */
void connectx4lx_shared_consts_pack(const struct connectx4lx_shared_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_shared_consts_unpack(struct connectx4lx_shared_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_shared_consts_print(const struct connectx4lx_shared_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_shared_consts_size(void);
#define CONNECTX4LX_SHARED_CONSTS_SIZE    (0x280)
void connectx4lx_shared_consts_dump(const struct connectx4lx_shared_consts *ptr_struct, FILE* file);
/* pcie_phy_uc_config */
void connectx4lx_pcie_phy_uc_config_pack(const struct connectx4lx_pcie_phy_uc_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_phy_uc_config_unpack(struct connectx4lx_pcie_phy_uc_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_phy_uc_config_print(const struct connectx4lx_pcie_phy_uc_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_phy_uc_config_size(void);
#define CONNECTX4LX_PCIE_PHY_UC_CONFIG_SIZE    (0x30)
void connectx4lx_pcie_phy_uc_config_dump(const struct connectx4lx_pcie_phy_uc_config *ptr_struct, FILE* file);
/* pcie_uc_consts */
void connectx4lx_pcie_uc_consts_pack(const struct connectx4lx_pcie_uc_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_uc_consts_unpack(struct connectx4lx_pcie_uc_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_uc_consts_print(const struct connectx4lx_pcie_uc_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_uc_consts_size(void);
#define CONNECTX4LX_PCIE_UC_CONSTS_SIZE    (0x10)
void connectx4lx_pcie_uc_consts_dump(const struct connectx4lx_pcie_uc_consts *ptr_struct, FILE* file);
/* fw_image */
void connectx4lx_fw_image_pack(const struct connectx4lx_fw_image *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_image_unpack(struct connectx4lx_fw_image *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_image_print(const struct connectx4lx_fw_image *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_image_size(void);
#define CONNECTX4LX_FW_IMAGE_SIZE    (0x20)
void connectx4lx_fw_image_dump(const struct connectx4lx_fw_image *ptr_struct, FILE* file);
/* pcie_cfg_shomron */
void connectx4lx_pcie_cfg_shomron_pack(const struct connectx4lx_pcie_cfg_shomron *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_cfg_shomron_unpack(struct connectx4lx_pcie_cfg_shomron *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_cfg_shomron_print(const struct connectx4lx_pcie_cfg_shomron *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_cfg_shomron_size(void);
#define CONNECTX4LX_PCIE_CFG_SHOMRON_SIZE    (0xc0)
void connectx4lx_pcie_cfg_shomron_dump(const struct connectx4lx_pcie_cfg_shomron *ptr_struct, FILE* file);
/* vpd_eeprom_info */
void connectx4lx_vpd_eeprom_info_pack(const struct connectx4lx_vpd_eeprom_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_vpd_eeprom_info_unpack(struct connectx4lx_vpd_eeprom_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_vpd_eeprom_info_print(const struct connectx4lx_vpd_eeprom_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_vpd_eeprom_info_size(void);
#define CONNECTX4LX_VPD_EEPROM_INFO_SIZE    (0x8)
void connectx4lx_vpd_eeprom_info_dump(const struct connectx4lx_vpd_eeprom_info *ptr_struct, FILE* file);
/* flex_nic_ini */
void connectx4lx_flex_nic_ini_pack(const struct connectx4lx_flex_nic_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_flex_nic_ini_unpack(struct connectx4lx_flex_nic_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_flex_nic_ini_print(const struct connectx4lx_flex_nic_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_flex_nic_ini_size(void);
#define CONNECTX4LX_FLEX_NIC_INI_SIZE    (0x40)
void connectx4lx_flex_nic_ini_dump(const struct connectx4lx_flex_nic_ini *ptr_struct, FILE* file);
/* boards_management */
void connectx4lx_boards_management_pack(const struct connectx4lx_boards_management *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_boards_management_unpack(struct connectx4lx_boards_management *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_boards_management_print(const struct connectx4lx_boards_management *ptr_struct, FILE* file, int indent_level);
int connectx4lx_boards_management_size(void);
#define CONNECTX4LX_BOARDS_MANAGEMENT_SIZE    (0x70)
void connectx4lx_boards_management_dump(const struct connectx4lx_boards_management *ptr_struct, FILE* file);
/* ini_gpios */
void connectx4lx_ini_gpios_pack(const struct connectx4lx_ini_gpios *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ini_gpios_unpack(struct connectx4lx_ini_gpios *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ini_gpios_print(const struct connectx4lx_ini_gpios *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ini_gpios_size(void);
#define CONNECTX4LX_INI_GPIOS_SIZE    (0x174)
void connectx4lx_ini_gpios_dump(const struct connectx4lx_ini_gpios *ptr_struct, FILE* file);
/* i2c_devices_db */
void connectx4lx_i2c_devices_db_pack(const struct connectx4lx_i2c_devices_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_i2c_devices_db_unpack(struct connectx4lx_i2c_devices_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_i2c_devices_db_print(const struct connectx4lx_i2c_devices_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_i2c_devices_db_size(void);
#define CONNECTX4LX_I2C_DEVICES_DB_SIZE    (0x80)
void connectx4lx_i2c_devices_db_dump(const struct connectx4lx_i2c_devices_db *ptr_struct, FILE* file);
/* module_database */
void connectx4lx_module_database_pack(const struct connectx4lx_module_database *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_database_unpack(struct connectx4lx_module_database *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_database_print(const struct connectx4lx_module_database *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_database_size(void);
#define CONNECTX4LX_MODULE_DATABASE_SIZE    (0x80)
void connectx4lx_module_database_dump(const struct connectx4lx_module_database *ptr_struct, FILE* file);
/* thermal_config_shomron */
void connectx4lx_thermal_config_shomron_pack(const struct connectx4lx_thermal_config_shomron *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_thermal_config_shomron_unpack(struct connectx4lx_thermal_config_shomron *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_thermal_config_shomron_print(const struct connectx4lx_thermal_config_shomron *ptr_struct, FILE* file, int indent_level);
int connectx4lx_thermal_config_shomron_size(void);
#define CONNECTX4LX_THERMAL_CONFIG_SHOMRON_SIZE    (0x10)
void connectx4lx_thermal_config_shomron_dump(const struct connectx4lx_thermal_config_shomron *ptr_struct, FILE* file);
/* system_mng_shomron */
void connectx4lx_system_mng_shomron_pack(const struct connectx4lx_system_mng_shomron *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_system_mng_shomron_unpack(struct connectx4lx_system_mng_shomron *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_system_mng_shomron_print(const struct connectx4lx_system_mng_shomron *ptr_struct, FILE* file, int indent_level);
int connectx4lx_system_mng_shomron_size(void);
#define CONNECTX4LX_SYSTEM_MNG_SHOMRON_SIZE    (0x4)
void connectx4lx_system_mng_shomron_dump(const struct connectx4lx_system_mng_shomron *ptr_struct, FILE* file);
/* power */
void connectx4lx_power_pack(const struct connectx4lx_power *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_power_unpack(struct connectx4lx_power *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_power_print(const struct connectx4lx_power *ptr_struct, FILE* file, int indent_level);
int connectx4lx_power_size(void);
#define CONNECTX4LX_POWER_SIZE    (0x10)
void connectx4lx_power_dump(const struct connectx4lx_power *ptr_struct, FILE* file);
/* port_serdes */
void connectx4lx_port_serdes_pack(const struct connectx4lx_port_serdes *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_serdes_unpack(struct connectx4lx_port_serdes *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_serdes_print(const struct connectx4lx_port_serdes *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_serdes_size(void);
#define CONNECTX4LX_PORT_SERDES_SIZE    (0x700)
void connectx4lx_port_serdes_dump(const struct connectx4lx_port_serdes *ptr_struct, FILE* file);
/* nv_config_boot */
void connectx4lx_nv_config_boot_pack(const struct connectx4lx_nv_config_boot *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_unpack(struct connectx4lx_nv_config_boot *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_boot_print(const struct connectx4lx_nv_config_boot *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_boot_size(void);
#define CONNECTX4LX_NV_CONFIG_BOOT_SIZE    (0x40)
void connectx4lx_nv_config_boot_dump(const struct connectx4lx_nv_config_boot *ptr_struct, FILE* file);
/* pcie_power_management */
void connectx4lx_pcie_power_management_pack(const struct connectx4lx_pcie_power_management *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_power_management_unpack(struct connectx4lx_pcie_power_management *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_power_management_print(const struct connectx4lx_pcie_power_management *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_power_management_size(void);
#define CONNECTX4LX_PCIE_POWER_MANAGEMENT_SIZE    (0x4)
void connectx4lx_pcie_power_management_dump(const struct connectx4lx_pcie_power_management *ptr_struct, FILE* file);
/* pci_cfg_ini */
void connectx4lx_pci_cfg_ini_pack(const struct connectx4lx_pci_cfg_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_ini_unpack(struct connectx4lx_pci_cfg_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pci_cfg_ini_print(const struct connectx4lx_pci_cfg_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pci_cfg_ini_size(void);
#define CONNECTX4LX_PCI_CFG_INI_SIZE    (0x40)
void connectx4lx_pci_cfg_ini_dump(const struct connectx4lx_pci_cfg_ini *ptr_struct, FILE* file);
/* pcie_transaction */
void connectx4lx_pcie_transaction_pack(const struct connectx4lx_pcie_transaction *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_transaction_unpack(struct connectx4lx_pcie_transaction *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_transaction_print(const struct connectx4lx_pcie_transaction *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_transaction_size(void);
#define CONNECTX4LX_PCIE_TRANSACTION_SIZE    (0x8)
void connectx4lx_pcie_transaction_dump(const struct connectx4lx_pcie_transaction *ptr_struct, FILE* file);
/* multi_function */
void connectx4lx_multi_function_pack(const struct connectx4lx_multi_function *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_multi_function_unpack(struct connectx4lx_multi_function *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_multi_function_print(const struct connectx4lx_multi_function *ptr_struct, FILE* file, int indent_level);
int connectx4lx_multi_function_size(void);
#define CONNECTX4LX_MULTI_FUNCTION_SIZE    (0xc)
void connectx4lx_multi_function_dump(const struct connectx4lx_multi_function *ptr_struct, FILE* file);
/* secure_fw */
void connectx4lx_secure_fw_pack(const struct connectx4lx_secure_fw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_secure_fw_unpack(struct connectx4lx_secure_fw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_secure_fw_print(const struct connectx4lx_secure_fw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_secure_fw_size(void);
#define CONNECTX4LX_SECURE_FW_SIZE    (0x8)
void connectx4lx_secure_fw_dump(const struct connectx4lx_secure_fw *ptr_struct, FILE* file);
/* exprom_config */
void connectx4lx_exprom_config_pack(const struct connectx4lx_exprom_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_exprom_config_unpack(struct connectx4lx_exprom_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_exprom_config_print(const struct connectx4lx_exprom_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_exprom_config_size(void);
#define CONNECTX4LX_EXPROM_CONFIG_SIZE    (0x100)
void connectx4lx_exprom_config_dump(const struct connectx4lx_exprom_config *ptr_struct, FILE* file);
/* nv_config_main */
void connectx4lx_nv_config_main_pack(const struct connectx4lx_nv_config_main *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_config_main_unpack(struct connectx4lx_nv_config_main *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_config_main_print(const struct connectx4lx_nv_config_main *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_config_main_size(void);
#define CONNECTX4LX_NV_CONFIG_MAIN_SIZE    (0x300)
void connectx4lx_nv_config_main_dump(const struct connectx4lx_nv_config_main *ptr_struct, FILE* file);
/* phy_fw_main_config */
void connectx4lx_phy_fw_main_config_pack(const struct connectx4lx_phy_fw_main_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_unpack(struct connectx4lx_phy_fw_main_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_fw_main_config_print(const struct connectx4lx_phy_fw_main_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_fw_main_config_size(void);
#define CONNECTX4LX_PHY_FW_MAIN_CONFIG_SIZE    (0x2d0)
void connectx4lx_phy_fw_main_config_dump(const struct connectx4lx_phy_fw_main_config *ptr_struct, FILE* file);
/* host_management */
void connectx4lx_host_management_pack(const struct connectx4lx_host_management *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_host_management_unpack(struct connectx4lx_host_management *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_host_management_print(const struct connectx4lx_host_management *ptr_struct, FILE* file, int indent_level);
int connectx4lx_host_management_size(void);
#define CONNECTX4LX_HOST_MANAGEMENT_SIZE    (0x80)
void connectx4lx_host_management_dump(const struct connectx4lx_host_management *ptr_struct, FILE* file);
/* management */
void connectx4lx_management_pack(const struct connectx4lx_management *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_management_unpack(struct connectx4lx_management *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_management_print(const struct connectx4lx_management *ptr_struct, FILE* file, int indent_level);
int connectx4lx_management_size(void);
#define CONNECTX4LX_MANAGEMENT_SIZE    (0x180)
void connectx4lx_management_dump(const struct connectx4lx_management *ptr_struct, FILE* file);
/* customization */
void connectx4lx_customization_pack(const struct connectx4lx_customization *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_customization_unpack(struct connectx4lx_customization *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_customization_print(const struct connectx4lx_customization *ptr_struct, FILE* file, int indent_level);
int connectx4lx_customization_size(void);
#define CONNECTX4LX_CUSTOMIZATION_SIZE    (0x40)
void connectx4lx_customization_dump(const struct connectx4lx_customization *ptr_struct, FILE* file);
/* leds */
void connectx4lx_leds_pack(const struct connectx4lx_leds *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_leds_unpack(struct connectx4lx_leds *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_leds_print(const struct connectx4lx_leds *ptr_struct, FILE* file, int indent_level);
int connectx4lx_leds_size(void);
#define CONNECTX4LX_LEDS_SIZE    (0x50)
void connectx4lx_leds_dump(const struct connectx4lx_leds *ptr_struct, FILE* file);
/* static_config */
void connectx4lx_static_config_pack(const struct connectx4lx_static_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_static_config_unpack(struct connectx4lx_static_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_static_config_print(const struct connectx4lx_static_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_static_config_size(void);
#define CONNECTX4LX_STATIC_CONFIG_SIZE    (0x10)
void connectx4lx_static_config_dump(const struct connectx4lx_static_config *ptr_struct, FILE* file);
/* guids */
void connectx4lx_guids_pack(const struct connectx4lx_guids *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_guids_unpack(struct connectx4lx_guids *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_guids_print(const struct connectx4lx_guids *ptr_struct, FILE* file, int indent_level);
int connectx4lx_guids_size(void);
#define CONNECTX4LX_GUIDS_SIZE    (0x40)
void connectx4lx_guids_dump(const struct connectx4lx_guids *ptr_struct, FILE* file);
/* module_versions */
void connectx4lx_module_versions_pack(const struct connectx4lx_module_versions *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_module_versions_unpack(struct connectx4lx_module_versions *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_module_versions_print(const struct connectx4lx_module_versions *ptr_struct, FILE* file, int indent_level);
int connectx4lx_module_versions_size(void);
#define CONNECTX4LX_MODULE_VERSIONS_SIZE    (0x40)
void connectx4lx_module_versions_dump(const struct connectx4lx_module_versions *ptr_struct, FILE* file);
/* image_size */
void connectx4lx_image_size_pack(const struct connectx4lx_image_size *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_image_size_unpack(struct connectx4lx_image_size *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_image_size_print(const struct connectx4lx_image_size *ptr_struct, FILE* file, int indent_level);
int connectx4lx_image_size_size(void);
#define CONNECTX4LX_IMAGE_SIZE_SIZE    (0x8)
void connectx4lx_image_size_dump(const struct connectx4lx_image_size *ptr_struct, FILE* file);
/* TRIPPLE_VERSION */
void connectx4lx_TRIPPLE_VERSION_pack(const struct connectx4lx_TRIPPLE_VERSION *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_TRIPPLE_VERSION_unpack(struct connectx4lx_TRIPPLE_VERSION *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_TRIPPLE_VERSION_print(const struct connectx4lx_TRIPPLE_VERSION *ptr_struct, FILE* file, int indent_level);
int connectx4lx_TRIPPLE_VERSION_size(void);
#define CONNECTX4LX_TRIPPLE_VERSION_SIZE    (0x8)
void connectx4lx_TRIPPLE_VERSION_dump(const struct connectx4lx_TRIPPLE_VERSION *ptr_struct, FILE* file);
/* operation_key */
void connectx4lx_operation_key_pack(const struct connectx4lx_operation_key *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_operation_key_unpack(struct connectx4lx_operation_key *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_operation_key_print(const struct connectx4lx_operation_key *ptr_struct, FILE* file, int indent_level);
int connectx4lx_operation_key_size(void);
#define CONNECTX4LX_OPERATION_KEY_SIZE    (0x10)
void connectx4lx_operation_key_dump(const struct connectx4lx_operation_key *ptr_struct, FILE* file);
/* toc_data */
void connectx4lx_toc_data_pack(const struct connectx4lx_toc_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_toc_data_unpack(struct connectx4lx_toc_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_toc_data_print(const struct connectx4lx_toc_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_toc_data_size(void);
#define CONNECTX4LX_TOC_DATA_SIZE    (0x8)
void connectx4lx_toc_data_dump(const struct connectx4lx_toc_data *ptr_struct, FILE* file);
/* rst_api_ver */
void connectx4lx_rst_api_ver_pack(const struct connectx4lx_rst_api_ver *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_rst_api_ver_unpack(struct connectx4lx_rst_api_ver *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_rst_api_ver_print(const struct connectx4lx_rst_api_ver *ptr_struct, FILE* file, int indent_level);
int connectx4lx_rst_api_ver_size(void);
#define CONNECTX4LX_RST_API_VER_SIZE    (0x80)
void connectx4lx_rst_api_ver_dump(const struct connectx4lx_rst_api_ver *ptr_struct, FILE* file);
/* reset_capabilities */
void connectx4lx_reset_capabilities_pack(const struct connectx4lx_reset_capabilities *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reset_capabilities_unpack(struct connectx4lx_reset_capabilities *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reset_capabilities_print(const struct connectx4lx_reset_capabilities *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reset_capabilities_size(void);
#define CONNECTX4LX_RESET_CAPABILITIES_SIZE    (0x4)
void connectx4lx_reset_capabilities_dump(const struct connectx4lx_reset_capabilities *ptr_struct, FILE* file);
/* icmd_get_gvmi_rl_ctx_ix */
void connectx4lx_icmd_get_gvmi_rl_ctx_ix_pack(const struct connectx4lx_icmd_get_gvmi_rl_ctx_ix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_gvmi_rl_ctx_ix_unpack(struct connectx4lx_icmd_get_gvmi_rl_ctx_ix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_gvmi_rl_ctx_ix_print(const struct connectx4lx_icmd_get_gvmi_rl_ctx_ix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_gvmi_rl_ctx_ix_size(void);
#define CONNECTX4LX_ICMD_GET_GVMI_RL_CTX_IX_SIZE    (0x8)
void connectx4lx_icmd_get_gvmi_rl_ctx_ix_dump(const struct connectx4lx_icmd_get_gvmi_rl_ctx_ix *ptr_struct, FILE* file);
/* icmd_sysport */
void connectx4lx_icmd_sysport_pack(const struct connectx4lx_icmd_sysport *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_sysport_unpack(struct connectx4lx_icmd_sysport *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_sysport_print(const struct connectx4lx_icmd_sysport *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_sysport_size(void);
#define CONNECTX4LX_ICMD_SYSPORT_SIZE    (0x300)
void connectx4lx_icmd_sysport_dump(const struct connectx4lx_icmd_sysport *ptr_struct, FILE* file);
/* icmd_drop_counter_read */
void connectx4lx_icmd_drop_counter_read_pack(const struct connectx4lx_icmd_drop_counter_read *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_drop_counter_read_unpack(struct connectx4lx_icmd_drop_counter_read *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_drop_counter_read_print(const struct connectx4lx_icmd_drop_counter_read *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_drop_counter_read_size(void);
#define CONNECTX4LX_ICMD_DROP_COUNTER_READ_SIZE    (0x4)
void connectx4lx_icmd_drop_counter_read_dump(const struct connectx4lx_icmd_drop_counter_read *ptr_struct, FILE* file);
/* icmd_rw_gvmi_fw_ctx */
void connectx4lx_icmd_rw_gvmi_fw_ctx_pack(const struct connectx4lx_icmd_rw_gvmi_fw_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_rw_gvmi_fw_ctx_unpack(struct connectx4lx_icmd_rw_gvmi_fw_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_rw_gvmi_fw_ctx_print(const struct connectx4lx_icmd_rw_gvmi_fw_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_rw_gvmi_fw_ctx_size(void);
#define CONNECTX4LX_ICMD_RW_GVMI_FW_CTX_SIZE    (0x80)
void connectx4lx_icmd_rw_gvmi_fw_ctx_dump(const struct connectx4lx_icmd_rw_gvmi_fw_ctx *ptr_struct, FILE* file);
/* icmd_mh_sync */
void connectx4lx_icmd_mh_sync_pack(const struct connectx4lx_icmd_mh_sync *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mh_sync_unpack(struct connectx4lx_icmd_mh_sync *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mh_sync_print(const struct connectx4lx_icmd_mh_sync *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mh_sync_size(void);
#define CONNECTX4LX_ICMD_MH_SYNC_SIZE    (0x10)
void connectx4lx_icmd_mh_sync_dump(const struct connectx4lx_icmd_mh_sync *ptr_struct, FILE* file);
/* icmd_asn1_force_port_state */
void connectx4lx_icmd_asn1_force_port_state_pack(const struct connectx4lx_icmd_asn1_force_port_state *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_asn1_force_port_state_unpack(struct connectx4lx_icmd_asn1_force_port_state *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_asn1_force_port_state_print(const struct connectx4lx_icmd_asn1_force_port_state *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_asn1_force_port_state_size(void);
#define CONNECTX4LX_ICMD_ASN1_FORCE_PORT_STATE_SIZE    (0x4)
void connectx4lx_icmd_asn1_force_port_state_dump(const struct connectx4lx_icmd_asn1_force_port_state *ptr_struct, FILE* file);
/* icmd_port_admin_state_mng */
void connectx4lx_icmd_port_admin_state_mng_pack(const struct connectx4lx_icmd_port_admin_state_mng *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_port_admin_state_mng_unpack(struct connectx4lx_icmd_port_admin_state_mng *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_port_admin_state_mng_print(const struct connectx4lx_icmd_port_admin_state_mng *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_port_admin_state_mng_size(void);
#define CONNECTX4LX_ICMD_PORT_ADMIN_STATE_MNG_SIZE    (0x20)
void connectx4lx_icmd_port_admin_state_mng_dump(const struct connectx4lx_icmd_port_admin_state_mng *ptr_struct, FILE* file);
/* icmd_get_packet_pacing_debug_info */
void connectx4lx_icmd_get_packet_pacing_debug_info_pack(const struct connectx4lx_icmd_get_packet_pacing_debug_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_packet_pacing_debug_info_unpack(struct connectx4lx_icmd_get_packet_pacing_debug_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_packet_pacing_debug_info_print(const struct connectx4lx_icmd_get_packet_pacing_debug_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_packet_pacing_debug_info_size(void);
#define CONNECTX4LX_ICMD_GET_PACKET_PACING_DEBUG_INFO_SIZE    (0x64)
void connectx4lx_icmd_get_packet_pacing_debug_info_dump(const struct connectx4lx_icmd_get_packet_pacing_debug_info *ptr_struct, FILE* file);
/* icmd_map_event_eq */
void connectx4lx_icmd_map_event_eq_pack(const struct connectx4lx_icmd_map_event_eq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_map_event_eq_unpack(struct connectx4lx_icmd_map_event_eq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_map_event_eq_print(const struct connectx4lx_icmd_map_event_eq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_map_event_eq_size(void);
#define CONNECTX4LX_ICMD_MAP_EVENT_EQ_SIZE    (0x10)
void connectx4lx_icmd_map_event_eq_dump(const struct connectx4lx_icmd_map_event_eq *ptr_struct, FILE* file);
/* icmd_internal_query_cap */
void connectx4lx_icmd_internal_query_cap_pack(const struct connectx4lx_icmd_internal_query_cap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_internal_query_cap_unpack(struct connectx4lx_icmd_internal_query_cap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_internal_query_cap_print(const struct connectx4lx_icmd_internal_query_cap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_internal_query_cap_size(void);
#define CONNECTX4LX_ICMD_INTERNAL_QUERY_CAP_SIZE    (0x8)
void connectx4lx_icmd_internal_query_cap_dump(const struct connectx4lx_icmd_internal_query_cap *ptr_struct, FILE* file);
/* icmd_detect_gvmi_in_qpc_and_icmc */
void connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc_pack(const struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc_unpack(struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc_print(const struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc_size(void);
#define CONNECTX4LX_ICMD_DETECT_GVMI_IN_QPC_AND_ICMC_SIZE    (0x20)
void connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc_dump(const struct connectx4lx_icmd_detect_gvmi_in_qpc_and_icmc *ptr_struct, FILE* file);
/* icmd_temp_warn_gen_event */
void connectx4lx_icmd_temp_warn_gen_event_pack(const struct connectx4lx_icmd_temp_warn_gen_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_temp_warn_gen_event_unpack(struct connectx4lx_icmd_temp_warn_gen_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_temp_warn_gen_event_print(const struct connectx4lx_icmd_temp_warn_gen_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_temp_warn_gen_event_size(void);
#define CONNECTX4LX_ICMD_TEMP_WARN_GEN_EVENT_SIZE    (0x10)
void connectx4lx_icmd_temp_warn_gen_event_dump(const struct connectx4lx_icmd_temp_warn_gen_event *ptr_struct, FILE* file);
/* icmd_cable_error_gen_event */
void connectx4lx_icmd_cable_error_gen_event_pack(const struct connectx4lx_icmd_cable_error_gen_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_error_gen_event_unpack(struct connectx4lx_icmd_cable_error_gen_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_error_gen_event_print(const struct connectx4lx_icmd_cable_error_gen_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_cable_error_gen_event_size(void);
#define CONNECTX4LX_ICMD_CABLE_ERROR_GEN_EVENT_SIZE    (0x4)
void connectx4lx_icmd_cable_error_gen_event_dump(const struct connectx4lx_icmd_cable_error_gen_event *ptr_struct, FILE* file);
/* icmd_mctp_vnd_pci_debug */
void connectx4lx_icmd_mctp_vnd_pci_debug_pack(const struct connectx4lx_icmd_mctp_vnd_pci_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_unpack(struct connectx4lx_icmd_mctp_vnd_pci_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mctp_vnd_pci_debug_print(const struct connectx4lx_icmd_mctp_vnd_pci_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mctp_vnd_pci_debug_size(void);
#define CONNECTX4LX_ICMD_MCTP_VND_PCI_DEBUG_SIZE    (0x110)
void connectx4lx_icmd_mctp_vnd_pci_debug_dump(const struct connectx4lx_icmd_mctp_vnd_pci_debug *ptr_struct, FILE* file);
/* icmd_lldp_set_get_tlv */
void connectx4lx_icmd_lldp_set_get_tlv_pack(const struct connectx4lx_icmd_lldp_set_get_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_lldp_set_get_tlv_unpack(struct connectx4lx_icmd_lldp_set_get_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_lldp_set_get_tlv_print(const struct connectx4lx_icmd_lldp_set_get_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_lldp_set_get_tlv_size(void);
#define CONNECTX4LX_ICMD_LLDP_SET_GET_TLV_SIZE    (0x90)
void connectx4lx_icmd_lldp_set_get_tlv_dump(const struct connectx4lx_icmd_lldp_set_get_tlv *ptr_struct, FILE* file);
/* icmd_lldp_debug */
void connectx4lx_icmd_lldp_debug_pack(const struct connectx4lx_icmd_lldp_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_lldp_debug_unpack(struct connectx4lx_icmd_lldp_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_lldp_debug_print(const struct connectx4lx_icmd_lldp_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_lldp_debug_size(void);
#define CONNECTX4LX_ICMD_LLDP_DEBUG_SIZE    (0x120)
void connectx4lx_icmd_lldp_debug_dump(const struct connectx4lx_icmd_lldp_debug *ptr_struct, FILE* file);
/* icmd_access_register_nodnic_queue_info */
void connectx4lx_icmd_access_register_nodnic_queue_info_pack(const struct connectx4lx_icmd_access_register_nodnic_queue_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_nodnic_queue_info_unpack(struct connectx4lx_icmd_access_register_nodnic_queue_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_nodnic_queue_info_print(const struct connectx4lx_icmd_access_register_nodnic_queue_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_nodnic_queue_info_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_NODNIC_QUEUE_INFO_SIZE    (0x40)
void connectx4lx_icmd_access_register_nodnic_queue_info_dump(const struct connectx4lx_icmd_access_register_nodnic_queue_info *ptr_struct, FILE* file);
/* icmd_set_get_debug_pf_mac */
void connectx4lx_icmd_set_get_debug_pf_mac_pack(const struct connectx4lx_icmd_set_get_debug_pf_mac *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_get_debug_pf_mac_unpack(struct connectx4lx_icmd_set_get_debug_pf_mac *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_get_debug_pf_mac_print(const struct connectx4lx_icmd_set_get_debug_pf_mac *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_get_debug_pf_mac_size(void);
#define CONNECTX4LX_ICMD_SET_GET_DEBUG_PF_MAC_SIZE    (0x20)
void connectx4lx_icmd_set_get_debug_pf_mac_dump(const struct connectx4lx_icmd_set_get_debug_pf_mac *ptr_struct, FILE* file);
/* icmd_ocbb_set_event */
void connectx4lx_icmd_ocbb_set_event_pack(const struct connectx4lx_icmd_ocbb_set_event *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_set_event_unpack(struct connectx4lx_icmd_ocbb_set_event *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_set_event_print(const struct connectx4lx_icmd_ocbb_set_event *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_set_event_size(void);
#define CONNECTX4LX_ICMD_OCBB_SET_EVENT_SIZE    (0xc)
void connectx4lx_icmd_ocbb_set_event_dump(const struct connectx4lx_icmd_ocbb_set_event *ptr_struct, FILE* file);
/* icmd_ocbb_query_header_stats_out */
void connectx4lx_icmd_ocbb_query_header_stats_out_pack(const struct connectx4lx_icmd_ocbb_query_header_stats_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_query_header_stats_out_unpack(struct connectx4lx_icmd_ocbb_query_header_stats_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_query_header_stats_out_print(const struct connectx4lx_icmd_ocbb_query_header_stats_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_query_header_stats_out_size(void);
#define CONNECTX4LX_ICMD_OCBB_QUERY_HEADER_STATS_OUT_SIZE    (0x100)
void connectx4lx_icmd_ocbb_query_header_stats_out_dump(const struct connectx4lx_icmd_ocbb_query_header_stats_out *ptr_struct, FILE* file);
/* icmd_ocbb_query_etoc_stats_out */
void connectx4lx_icmd_ocbb_query_etoc_stats_out_pack(const struct connectx4lx_icmd_ocbb_query_etoc_stats_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_query_etoc_stats_out_unpack(struct connectx4lx_icmd_ocbb_query_etoc_stats_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_query_etoc_stats_out_print(const struct connectx4lx_icmd_ocbb_query_etoc_stats_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_query_etoc_stats_out_size(void);
#define CONNECTX4LX_ICMD_OCBB_QUERY_ETOC_STATS_OUT_SIZE    (0x100)
void connectx4lx_icmd_ocbb_query_etoc_stats_out_dump(const struct connectx4lx_icmd_ocbb_query_etoc_stats_out *ptr_struct, FILE* file);
/* icmd_ocbb_init_in */
void connectx4lx_icmd_ocbb_init_in_pack(const struct connectx4lx_icmd_ocbb_init_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_init_in_unpack(struct connectx4lx_icmd_ocbb_init_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_init_in_print(const struct connectx4lx_icmd_ocbb_init_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_init_in_size(void);
#define CONNECTX4LX_ICMD_OCBB_INIT_IN_SIZE    (0x100)
void connectx4lx_icmd_ocbb_init_in_dump(const struct connectx4lx_icmd_ocbb_init_in *ptr_struct, FILE* file);
/* icmd_set_wol_rol_in */
void connectx4lx_icmd_set_wol_rol_in_pack(const struct connectx4lx_icmd_set_wol_rol_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_wol_rol_in_unpack(struct connectx4lx_icmd_set_wol_rol_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_wol_rol_in_print(const struct connectx4lx_icmd_set_wol_rol_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_wol_rol_in_size(void);
#define CONNECTX4LX_ICMD_SET_WOL_ROL_IN_SIZE    (0x100)
void connectx4lx_icmd_set_wol_rol_in_dump(const struct connectx4lx_icmd_set_wol_rol_in *ptr_struct, FILE* file);
/* icmd_set_wol_rol_out */
void connectx4lx_icmd_set_wol_rol_out_pack(const struct connectx4lx_icmd_set_wol_rol_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_wol_rol_out_unpack(struct connectx4lx_icmd_set_wol_rol_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_wol_rol_out_print(const struct connectx4lx_icmd_set_wol_rol_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_wol_rol_out_size(void);
#define CONNECTX4LX_ICMD_SET_WOL_ROL_OUT_SIZE    (0xc)
void connectx4lx_icmd_set_wol_rol_out_dump(const struct connectx4lx_icmd_set_wol_rol_out *ptr_struct, FILE* file);
/* icmd_set_virtual_mac_in */
void connectx4lx_icmd_set_virtual_mac_in_pack(const struct connectx4lx_icmd_set_virtual_mac_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_virtual_mac_in_unpack(struct connectx4lx_icmd_set_virtual_mac_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_virtual_mac_in_print(const struct connectx4lx_icmd_set_virtual_mac_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_virtual_mac_in_size(void);
#define CONNECTX4LX_ICMD_SET_VIRTUAL_MAC_IN_SIZE    (0x100)
void connectx4lx_icmd_set_virtual_mac_in_dump(const struct connectx4lx_icmd_set_virtual_mac_in *ptr_struct, FILE* file);
/* icmd_query_virtual_mac_out */
void connectx4lx_icmd_query_virtual_mac_out_pack(const struct connectx4lx_icmd_query_virtual_mac_out *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_query_virtual_mac_out_unpack(struct connectx4lx_icmd_query_virtual_mac_out *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_query_virtual_mac_out_print(const struct connectx4lx_icmd_query_virtual_mac_out *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_query_virtual_mac_out_size(void);
#define CONNECTX4LX_ICMD_QUERY_VIRTUAL_MAC_OUT_SIZE    (0x100)
void connectx4lx_icmd_query_virtual_mac_out_dump(const struct connectx4lx_icmd_query_virtual_mac_out *ptr_struct, FILE* file);
/* icmd_get_pf_ctx */
void connectx4lx_icmd_get_pf_ctx_pack(const struct connectx4lx_icmd_get_pf_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_pf_ctx_unpack(struct connectx4lx_icmd_get_pf_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_pf_ctx_print(const struct connectx4lx_icmd_get_pf_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_pf_ctx_size(void);
#define CONNECTX4LX_ICMD_GET_PF_CTX_SIZE    (0x80)
void connectx4lx_icmd_get_pf_ctx_dump(const struct connectx4lx_icmd_get_pf_ctx *ptr_struct, FILE* file);
/* icmd_ocbb_get_pci_api */
void connectx4lx_icmd_ocbb_get_pci_api_pack(const struct connectx4lx_icmd_ocbb_get_pci_api *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_get_pci_api_unpack(struct connectx4lx_icmd_ocbb_get_pci_api *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_get_pci_api_print(const struct connectx4lx_icmd_ocbb_get_pci_api *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_get_pci_api_size(void);
#define CONNECTX4LX_ICMD_OCBB_GET_PCI_API_SIZE    (0x30)
void connectx4lx_icmd_ocbb_get_pci_api_dump(const struct connectx4lx_icmd_ocbb_get_pci_api *ptr_struct, FILE* file);
/* icmd_read_ncsi_rdma_counters */
void connectx4lx_icmd_read_ncsi_rdma_counters_pack(const struct connectx4lx_icmd_read_ncsi_rdma_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_ncsi_rdma_counters_unpack(struct connectx4lx_icmd_read_ncsi_rdma_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_ncsi_rdma_counters_print(const struct connectx4lx_icmd_read_ncsi_rdma_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_ncsi_rdma_counters_size(void);
#define CONNECTX4LX_ICMD_READ_NCSI_RDMA_COUNTERS_SIZE    (0x100)
void connectx4lx_icmd_read_ncsi_rdma_counters_dump(const struct connectx4lx_icmd_read_ncsi_rdma_counters *ptr_struct, FILE* file);
/* icmd_ocbb_rndc_get_core_api */
void connectx4lx_icmd_ocbb_rndc_get_core_api_pack(const struct connectx4lx_icmd_ocbb_rndc_get_core_api *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_rndc_get_core_api_unpack(struct connectx4lx_icmd_ocbb_rndc_get_core_api *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ocbb_rndc_get_core_api_print(const struct connectx4lx_icmd_ocbb_rndc_get_core_api *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ocbb_rndc_get_core_api_size(void);
#define CONNECTX4LX_ICMD_OCBB_RNDC_GET_CORE_API_SIZE    (0x300)
void connectx4lx_icmd_ocbb_rndc_get_core_api_dump(const struct connectx4lx_icmd_ocbb_rndc_get_core_api *ptr_struct, FILE* file);
/* icmd_pre_define_module_db */
void connectx4lx_icmd_pre_define_module_db_pack(const struct connectx4lx_icmd_pre_define_module_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pre_define_module_db_unpack(struct connectx4lx_icmd_pre_define_module_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pre_define_module_db_print(const struct connectx4lx_icmd_pre_define_module_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pre_define_module_db_size(void);
#define CONNECTX4LX_ICMD_PRE_DEFINE_MODULE_DB_SIZE    (0x3c)
void connectx4lx_icmd_pre_define_module_db_dump(const struct connectx4lx_icmd_pre_define_module_db *ptr_struct, FILE* file);
/* icmd_pmlp_query */
void connectx4lx_icmd_pmlp_query_pack(const struct connectx4lx_icmd_pmlp_query *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pmlp_query_unpack(struct connectx4lx_icmd_pmlp_query *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pmlp_query_print(const struct connectx4lx_icmd_pmlp_query *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pmlp_query_size(void);
#define CONNECTX4LX_ICMD_PMLP_QUERY_SIZE    (0x24)
void connectx4lx_icmd_pmlp_query_dump(const struct connectx4lx_icmd_pmlp_query *ptr_struct, FILE* file);
/* icmd_get_fw_driver_version */
void connectx4lx_icmd_get_fw_driver_version_pack(const struct connectx4lx_icmd_get_fw_driver_version *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fw_driver_version_unpack(struct connectx4lx_icmd_get_fw_driver_version *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fw_driver_version_print(const struct connectx4lx_icmd_get_fw_driver_version *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fw_driver_version_size(void);
#define CONNECTX4LX_ICMD_GET_FW_DRIVER_VERSION_SIZE    (0x50)
void connectx4lx_icmd_get_fw_driver_version_dump(const struct connectx4lx_icmd_get_fw_driver_version *ptr_struct, FILE* file);
/* icmd_set_oc_int */
void connectx4lx_icmd_set_oc_int_pack(const struct connectx4lx_icmd_set_oc_int *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_oc_int_unpack(struct connectx4lx_icmd_set_oc_int *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_oc_int_print(const struct connectx4lx_icmd_set_oc_int *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_oc_int_size(void);
#define CONNECTX4LX_ICMD_SET_OC_INT_SIZE    (0x4)
void connectx4lx_icmd_set_oc_int_dump(const struct connectx4lx_icmd_set_oc_int *ptr_struct, FILE* file);
/* icmd_gen_assert */
void connectx4lx_icmd_gen_assert_pack(const struct connectx4lx_icmd_gen_assert *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_gen_assert_unpack(struct connectx4lx_icmd_gen_assert *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_gen_assert_print(const struct connectx4lx_icmd_gen_assert *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_gen_assert_size(void);
#define CONNECTX4LX_ICMD_GEN_ASSERT_SIZE    (0x8)
void connectx4lx_icmd_gen_assert_dump(const struct connectx4lx_icmd_gen_assert *ptr_struct, FILE* file);
/* icmd_read_write_varb_ctx */
void connectx4lx_icmd_read_write_varb_ctx_pack(const struct connectx4lx_icmd_read_write_varb_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_write_varb_ctx_unpack(struct connectx4lx_icmd_read_write_varb_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_write_varb_ctx_print(const struct connectx4lx_icmd_read_write_varb_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_write_varb_ctx_size(void);
#define CONNECTX4LX_ICMD_READ_WRITE_VARB_CTX_SIZE    (0x44)
void connectx4lx_icmd_read_write_varb_ctx_dump(const struct connectx4lx_icmd_read_write_varb_ctx *ptr_struct, FILE* file);
/* icmd_debug_calc_sqn */
void connectx4lx_icmd_debug_calc_sqn_pack(const struct connectx4lx_icmd_debug_calc_sqn *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_debug_calc_sqn_unpack(struct connectx4lx_icmd_debug_calc_sqn *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_debug_calc_sqn_print(const struct connectx4lx_icmd_debug_calc_sqn *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_debug_calc_sqn_size(void);
#define CONNECTX4LX_ICMD_DEBUG_CALC_SQN_SIZE    (0x300)
void connectx4lx_icmd_debug_calc_sqn_dump(const struct connectx4lx_icmd_debug_calc_sqn *ptr_struct, FILE* file);
/* icmd_mini_flow_activator */
void connectx4lx_icmd_mini_flow_activator_pack(const struct connectx4lx_icmd_mini_flow_activator *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mini_flow_activator_unpack(struct connectx4lx_icmd_mini_flow_activator *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mini_flow_activator_print(const struct connectx4lx_icmd_mini_flow_activator *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mini_flow_activator_size(void);
#define CONNECTX4LX_ICMD_MINI_FLOW_ACTIVATOR_SIZE    (0x8)
void connectx4lx_icmd_mini_flow_activator_dump(const struct connectx4lx_icmd_mini_flow_activator *ptr_struct, FILE* file);
/* icmd_general_fault_injector */
void connectx4lx_icmd_general_fault_injector_pack(const struct connectx4lx_icmd_general_fault_injector *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_general_fault_injector_unpack(struct connectx4lx_icmd_general_fault_injector *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_general_fault_injector_print(const struct connectx4lx_icmd_general_fault_injector *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_general_fault_injector_size(void);
#define CONNECTX4LX_ICMD_GENERAL_FAULT_INJECTOR_SIZE    (0x10)
void connectx4lx_icmd_general_fault_injector_dump(const struct connectx4lx_icmd_general_fault_injector *ptr_struct, FILE* file);
/* icmd_access_register_pvlc */
void connectx4lx_icmd_access_register_pvlc_pack(const struct connectx4lx_icmd_access_register_pvlc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pvlc_unpack(struct connectx4lx_icmd_access_register_pvlc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pvlc_print(const struct connectx4lx_icmd_access_register_pvlc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pvlc_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PVLC_SIZE    (0x14)
void connectx4lx_icmd_access_register_pvlc_dump(const struct connectx4lx_icmd_access_register_pvlc *ptr_struct, FILE* file);
/* icmd_parse_icm_address */
void connectx4lx_icmd_parse_icm_address_pack(const struct connectx4lx_icmd_parse_icm_address *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_parse_icm_address_unpack(struct connectx4lx_icmd_parse_icm_address *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_parse_icm_address_print(const struct connectx4lx_icmd_parse_icm_address *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_parse_icm_address_size(void);
#define CONNECTX4LX_ICMD_PARSE_ICM_ADDRESS_SIZE    (0x40)
void connectx4lx_icmd_parse_icm_address_dump(const struct connectx4lx_icmd_parse_icm_address *ptr_struct, FILE* file);
/* icmd_get_steering_info */
void connectx4lx_icmd_get_steering_info_pack(const struct connectx4lx_icmd_get_steering_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_steering_info_unpack(struct connectx4lx_icmd_get_steering_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_steering_info_print(const struct connectx4lx_icmd_get_steering_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_steering_info_size(void);
#define CONNECTX4LX_ICMD_GET_STEERING_INFO_SIZE    (0x80)
void connectx4lx_icmd_get_steering_info_dump(const struct connectx4lx_icmd_get_steering_info *ptr_struct, FILE* file);
/* icmd_read_ste */
void connectx4lx_icmd_read_ste_pack(const struct connectx4lx_icmd_read_ste *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_ste_unpack(struct connectx4lx_icmd_read_ste *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_ste_print(const struct connectx4lx_icmd_read_ste *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_ste_size(void);
#define CONNECTX4LX_ICMD_READ_STE_SIZE    (0x50)
void connectx4lx_icmd_read_ste_dump(const struct connectx4lx_icmd_read_ste *ptr_struct, FILE* file);
/* icmd_get_ste_resources_list */
void connectx4lx_icmd_get_ste_resources_list_pack(const union connectx4lx_icmd_get_ste_resources_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_unpack(union connectx4lx_icmd_get_ste_resources_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_resources_list_print(const union connectx4lx_icmd_get_ste_resources_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_resources_list_size(void);
#define CONNECTX4LX_ICMD_GET_STE_RESOURCES_LIST_SIZE    (0x100)
void connectx4lx_icmd_get_ste_resources_list_dump(const union connectx4lx_icmd_get_ste_resources_list *ptr_struct, FILE* file);
/* icmd_get_ste_open_resources */
void connectx4lx_icmd_get_ste_open_resources_pack(const union connectx4lx_icmd_get_ste_open_resources *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_unpack(union connectx4lx_icmd_get_ste_open_resources *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ste_open_resources_print(const union connectx4lx_icmd_get_ste_open_resources *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ste_open_resources_size(void);
#define CONNECTX4LX_ICMD_GET_STE_OPEN_RESOURCES_SIZE    (0x300)
void connectx4lx_icmd_get_ste_open_resources_dump(const union connectx4lx_icmd_get_ste_open_resources *ptr_struct, FILE* file);
/* icmd_get_fte */
void connectx4lx_icmd_get_fte_pack(const union connectx4lx_icmd_get_fte *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_unpack(union connectx4lx_icmd_get_fte *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_print(const union connectx4lx_icmd_get_fte *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_SIZE    (0x300)
void connectx4lx_icmd_get_fte_dump(const union connectx4lx_icmd_get_fte *ptr_struct, FILE* file);
/* icmd_get_fte_list */
void connectx4lx_icmd_get_fte_list_pack(const union connectx4lx_icmd_get_fte_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_unpack(union connectx4lx_icmd_get_fte_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fte_list_print(const union connectx4lx_icmd_get_fte_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fte_list_size(void);
#define CONNECTX4LX_ICMD_GET_FTE_LIST_SIZE    (0x10)
void connectx4lx_icmd_get_fte_list_dump(const union connectx4lx_icmd_get_fte_list *ptr_struct, FILE* file);
/* icmd_get_fg */
void connectx4lx_icmd_get_fg_pack(const union connectx4lx_icmd_get_fg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_unpack(union connectx4lx_icmd_get_fg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_print(const union connectx4lx_icmd_get_fg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_size(void);
#define CONNECTX4LX_ICMD_GET_FG_SIZE    (0x100)
void connectx4lx_icmd_get_fg_dump(const union connectx4lx_icmd_get_fg *ptr_struct, FILE* file);
/* icmd_get_fg_list */
void connectx4lx_icmd_get_fg_list_pack(const union connectx4lx_icmd_get_fg_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_unpack(union connectx4lx_icmd_get_fg_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fg_list_print(const union connectx4lx_icmd_get_fg_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fg_list_size(void);
#define CONNECTX4LX_ICMD_GET_FG_LIST_SIZE    (0x10)
void connectx4lx_icmd_get_fg_list_dump(const union connectx4lx_icmd_get_fg_list *ptr_struct, FILE* file);
/* icmd_get_ft_info */
void connectx4lx_icmd_get_ft_info_pack(const union connectx4lx_icmd_get_ft_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_unpack(union connectx4lx_icmd_get_ft_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_info_print(const union connectx4lx_icmd_get_ft_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_info_size(void);
#define CONNECTX4LX_ICMD_GET_FT_INFO_SIZE    (0x10)
void connectx4lx_icmd_get_ft_info_dump(const union connectx4lx_icmd_get_ft_info *ptr_struct, FILE* file);
/* icmd_get_ft_list */
void connectx4lx_icmd_get_ft_list_pack(const union connectx4lx_icmd_get_ft_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_unpack(union connectx4lx_icmd_get_ft_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_ft_list_print(const union connectx4lx_icmd_get_ft_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_ft_list_size(void);
#define CONNECTX4LX_ICMD_GET_FT_LIST_SIZE    (0x10)
void connectx4lx_icmd_get_ft_list_dump(const union connectx4lx_icmd_get_ft_list *ptr_struct, FILE* file);
/* icmd_led_control_mad */
void connectx4lx_icmd_led_control_mad_pack(const struct connectx4lx_icmd_led_control_mad *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_led_control_mad_unpack(struct connectx4lx_icmd_led_control_mad *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_led_control_mad_print(const struct connectx4lx_icmd_led_control_mad *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_led_control_mad_size(void);
#define CONNECTX4LX_ICMD_LED_CONTROL_MAD_SIZE    (0x48)
void connectx4lx_icmd_led_control_mad_dump(const struct connectx4lx_icmd_led_control_mad *ptr_struct, FILE* file);
/* icmd_led_cmd */
void connectx4lx_icmd_led_cmd_pack(const struct connectx4lx_icmd_led_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_led_cmd_unpack(struct connectx4lx_icmd_led_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_led_cmd_print(const struct connectx4lx_icmd_led_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_led_cmd_size(void);
#define CONNECTX4LX_ICMD_LED_CMD_SIZE    (0x8)
void connectx4lx_icmd_led_cmd_dump(const struct connectx4lx_icmd_led_cmd *ptr_struct, FILE* file);
/* icmd_set_get_port_cntr */
void connectx4lx_icmd_set_get_port_cntr_pack(const struct connectx4lx_icmd_set_get_port_cntr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_get_port_cntr_unpack(struct connectx4lx_icmd_set_get_port_cntr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_get_port_cntr_print(const struct connectx4lx_icmd_set_get_port_cntr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_get_port_cntr_size(void);
#define CONNECTX4LX_ICMD_SET_GET_PORT_CNTR_SIZE    (0x18)
void connectx4lx_icmd_set_get_port_cntr_dump(const struct connectx4lx_icmd_set_get_port_cntr *ptr_struct, FILE* file);
/* icmd_access_register_ppcnt */
void connectx4lx_icmd_access_register_ppcnt_pack(const struct connectx4lx_icmd_access_register_ppcnt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppcnt_unpack(struct connectx4lx_icmd_access_register_ppcnt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppcnt_print(const struct connectx4lx_icmd_access_register_ppcnt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_ppcnt_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPCNT_SIZE    (0x10c)
void connectx4lx_icmd_access_register_ppcnt_dump(const struct connectx4lx_icmd_access_register_ppcnt *ptr_struct, FILE* file);
/* icmd_activate_pll */
void connectx4lx_icmd_activate_pll_pack(const struct connectx4lx_icmd_activate_pll *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_activate_pll_unpack(struct connectx4lx_icmd_activate_pll *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_activate_pll_print(const struct connectx4lx_icmd_activate_pll *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_activate_pll_size(void);
#define CONNECTX4LX_ICMD_ACTIVATE_PLL_SIZE    (0xc)
void connectx4lx_icmd_activate_pll_dump(const struct connectx4lx_icmd_activate_pll *ptr_struct, FILE* file);
/* icmd_measure_frequency */
void connectx4lx_icmd_measure_frequency_pack(const struct connectx4lx_icmd_measure_frequency *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_measure_frequency_unpack(struct connectx4lx_icmd_measure_frequency *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_measure_frequency_print(const struct connectx4lx_icmd_measure_frequency *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_measure_frequency_size(void);
#define CONNECTX4LX_ICMD_MEASURE_FREQUENCY_SIZE    (0xc)
void connectx4lx_icmd_measure_frequency_dump(const struct connectx4lx_icmd_measure_frequency *ptr_struct, FILE* file);
/* restore_phy_registers */
void connectx4lx_restore_phy_registers_pack(const struct connectx4lx_restore_phy_registers *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_restore_phy_registers_unpack(struct connectx4lx_restore_phy_registers *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_restore_phy_registers_print(const struct connectx4lx_restore_phy_registers *ptr_struct, FILE* file, int indent_level);
int connectx4lx_restore_phy_registers_size(void);
#define CONNECTX4LX_RESTORE_PHY_REGISTERS_SIZE    (0x20)
void connectx4lx_restore_phy_registers_dump(const struct connectx4lx_restore_phy_registers *ptr_struct, FILE* file);
/* phy_design_ver_if */
void connectx4lx_phy_design_ver_if_pack(const struct connectx4lx_phy_design_ver_if *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_design_ver_if_unpack(struct connectx4lx_phy_design_ver_if *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_design_ver_if_print(const struct connectx4lx_phy_design_ver_if *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_design_ver_if_size(void);
#define CONNECTX4LX_PHY_DESIGN_VER_IF_SIZE    (0x20)
void connectx4lx_phy_design_ver_if_dump(const struct connectx4lx_phy_design_ver_if *ptr_struct, FILE* file);
/* icmd_run_hyb_eye_opener */
void connectx4lx_icmd_run_hyb_eye_opener_pack(const struct connectx4lx_icmd_run_hyb_eye_opener *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_run_hyb_eye_opener_unpack(struct connectx4lx_icmd_run_hyb_eye_opener *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_run_hyb_eye_opener_print(const struct connectx4lx_icmd_run_hyb_eye_opener *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_run_hyb_eye_opener_size(void);
#define CONNECTX4LX_ICMD_RUN_HYB_EYE_OPENER_SIZE    (0xc)
void connectx4lx_icmd_run_hyb_eye_opener_dump(const struct connectx4lx_icmd_run_hyb_eye_opener *ptr_struct, FILE* file);
/* icmd_varac_calib */
void connectx4lx_icmd_varac_calib_pack(const struct connectx4lx_icmd_varac_calib *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_varac_calib_unpack(struct connectx4lx_icmd_varac_calib *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_varac_calib_print(const struct connectx4lx_icmd_varac_calib *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_varac_calib_size(void);
#define CONNECTX4LX_ICMD_VARAC_CALIB_SIZE    (0x14)
void connectx4lx_icmd_varac_calib_dump(const struct connectx4lx_icmd_varac_calib *ptr_struct, FILE* file);
/* icmd_phy_uc_activate_uc */
void connectx4lx_icmd_phy_uc_activate_uc_pack(const struct connectx4lx_icmd_phy_uc_activate_uc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_activate_uc_unpack(struct connectx4lx_icmd_phy_uc_activate_uc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_activate_uc_print(const struct connectx4lx_icmd_phy_uc_activate_uc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_activate_uc_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_ACTIVATE_UC_SIZE    (0x8)
void connectx4lx_icmd_phy_uc_activate_uc_dump(const struct connectx4lx_icmd_phy_uc_activate_uc *ptr_struct, FILE* file);
/* icmd_phy_uc_get_status */
void connectx4lx_icmd_phy_uc_get_status_pack(const struct connectx4lx_icmd_phy_uc_get_status *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_get_status_unpack(struct connectx4lx_icmd_phy_uc_get_status *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_get_status_print(const struct connectx4lx_icmd_phy_uc_get_status *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_get_status_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_GET_STATUS_SIZE    (0xc)
void connectx4lx_icmd_phy_uc_get_status_dump(const struct connectx4lx_icmd_phy_uc_get_status *ptr_struct, FILE* file);
/* icmd_phy_uc_get_array_prop */
void connectx4lx_icmd_phy_uc_get_array_prop_pack(const struct connectx4lx_icmd_phy_uc_get_array_prop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_get_array_prop_unpack(struct connectx4lx_icmd_phy_uc_get_array_prop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_get_array_prop_print(const struct connectx4lx_icmd_phy_uc_get_array_prop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_get_array_prop_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_GET_ARRAY_PROP_SIZE    (0x2c)
void connectx4lx_icmd_phy_uc_get_array_prop_dump(const struct connectx4lx_icmd_phy_uc_get_array_prop *ptr_struct, FILE* file);
/* icmd_phy_uc_set_get_data_field */
void connectx4lx_icmd_phy_uc_set_get_data_field_pack(const struct connectx4lx_icmd_phy_uc_set_get_data_field *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_get_data_field_unpack(struct connectx4lx_icmd_phy_uc_set_get_data_field *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_get_data_field_print(const struct connectx4lx_icmd_phy_uc_set_get_data_field *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_set_get_data_field_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_SET_GET_DATA_FIELD_SIZE    (0xc)
void connectx4lx_icmd_phy_uc_set_get_data_field_dump(const struct connectx4lx_icmd_phy_uc_set_get_data_field *ptr_struct, FILE* file);
/* icmd_phy_uc_set_get_data */
void connectx4lx_icmd_phy_uc_set_get_data_pack(const struct connectx4lx_icmd_phy_uc_set_get_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_get_data_unpack(struct connectx4lx_icmd_phy_uc_set_get_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_get_data_print(const struct connectx4lx_icmd_phy_uc_set_get_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_set_get_data_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_SET_GET_DATA_SIZE    (0xc4)
void connectx4lx_icmd_phy_uc_set_get_data_dump(const struct connectx4lx_icmd_phy_uc_set_get_data *ptr_struct, FILE* file);
/* icmd_phy_uc_set_del_bp */
void connectx4lx_icmd_phy_uc_set_del_bp_pack(const struct connectx4lx_icmd_phy_uc_set_del_bp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_del_bp_unpack(struct connectx4lx_icmd_phy_uc_set_del_bp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_set_del_bp_print(const struct connectx4lx_icmd_phy_uc_set_del_bp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_set_del_bp_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_SET_DEL_BP_SIZE    (0x4)
void connectx4lx_icmd_phy_uc_set_del_bp_dump(const struct connectx4lx_icmd_phy_uc_set_del_bp *ptr_struct, FILE* file);
/* icmd_phy_uc_do_step */
void connectx4lx_icmd_phy_uc_do_step_pack(const struct connectx4lx_icmd_phy_uc_do_step *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_do_step_unpack(struct connectx4lx_icmd_phy_uc_do_step *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_do_step_print(const struct connectx4lx_icmd_phy_uc_do_step *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_do_step_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_DO_STEP_SIZE    (0x4)
void connectx4lx_icmd_phy_uc_do_step_dump(const struct connectx4lx_icmd_phy_uc_do_step *ptr_struct, FILE* file);
/* icmd_phy_uc_do_continue */
void connectx4lx_icmd_phy_uc_do_continue_pack(const struct connectx4lx_icmd_phy_uc_do_continue *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_do_continue_unpack(struct connectx4lx_icmd_phy_uc_do_continue *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_uc_do_continue_print(const struct connectx4lx_icmd_phy_uc_do_continue *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_uc_do_continue_size(void);
#define CONNECTX4LX_ICMD_PHY_UC_DO_CONTINUE_SIZE    (0x4)
void connectx4lx_icmd_phy_uc_do_continue_dump(const struct connectx4lx_icmd_phy_uc_do_continue *ptr_struct, FILE* file);
/* icmd_phy_get_pddr */
void connectx4lx_icmd_phy_get_pddr_pack(const struct connectx4lx_icmd_phy_get_pddr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_pddr_unpack(struct connectx4lx_icmd_phy_get_pddr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_pddr_print(const struct connectx4lx_icmd_phy_get_pddr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_get_pddr_size(void);
#define CONNECTX4LX_ICMD_PHY_GET_PDDR_SIZE    (0x104)
void connectx4lx_icmd_phy_get_pddr_dump(const struct connectx4lx_icmd_phy_get_pddr *ptr_struct, FILE* file);
/* phy_reg_ppll */
void connectx4lx_phy_reg_ppll_pack(const struct connectx4lx_phy_reg_ppll *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_reg_ppll_unpack(struct connectx4lx_phy_reg_ppll *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_reg_ppll_print(const struct connectx4lx_phy_reg_ppll *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_reg_ppll_size(void);
#define CONNECTX4LX_PHY_REG_PPLL_SIZE    (0x28)
void connectx4lx_phy_reg_ppll_dump(const struct connectx4lx_phy_reg_ppll *ptr_struct, FILE* file);
/* icmd_phy_set_get_ptas */
void connectx4lx_icmd_phy_set_get_ptas_pack(const struct connectx4lx_icmd_phy_set_get_ptas *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_ptas_unpack(struct connectx4lx_icmd_phy_set_get_ptas *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_ptas_print(const struct connectx4lx_icmd_phy_set_get_ptas *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_set_get_ptas_size(void);
#define CONNECTX4LX_ICMD_PHY_SET_GET_PTAS_SIZE    (0x30)
void connectx4lx_icmd_phy_set_get_ptas_dump(const struct connectx4lx_icmd_phy_set_get_ptas *ptr_struct, FILE* file);
/* icmd_phy_get_grade_info */
void connectx4lx_icmd_phy_get_grade_info_pack(const struct connectx4lx_icmd_phy_get_grade_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_grade_info_unpack(struct connectx4lx_icmd_phy_get_grade_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_grade_info_print(const struct connectx4lx_icmd_phy_get_grade_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_get_grade_info_size(void);
#define CONNECTX4LX_ICMD_PHY_GET_GRADE_INFO_SIZE    (0xa4)
void connectx4lx_icmd_phy_get_grade_info_dump(const struct connectx4lx_icmd_phy_get_grade_info *ptr_struct, FILE* file);
/* icmd_phy_get_clear_counters */
void connectx4lx_icmd_phy_get_clear_counters_pack(const struct connectx4lx_icmd_phy_get_clear_counters *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_clear_counters_unpack(struct connectx4lx_icmd_phy_get_clear_counters *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_clear_counters_print(const struct connectx4lx_icmd_phy_get_clear_counters *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_get_clear_counters_size(void);
#define CONNECTX4LX_ICMD_PHY_GET_CLEAR_COUNTERS_SIZE    (0x118)
void connectx4lx_icmd_phy_get_clear_counters_dump(const struct connectx4lx_icmd_phy_get_clear_counters *ptr_struct, FILE* file);
/* icmd_phy_transmit_or_sync_on_pattern */
void connectx4lx_icmd_phy_transmit_or_sync_on_pattern_pack(const struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_transmit_or_sync_on_pattern_unpack(struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_transmit_or_sync_on_pattern_print(const struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_transmit_or_sync_on_pattern_size(void);
#define CONNECTX4LX_ICMD_PHY_TRANSMIT_OR_SYNC_ON_PATTERN_SIZE    (0x4)
void connectx4lx_icmd_phy_transmit_or_sync_on_pattern_dump(const struct connectx4lx_icmd_phy_transmit_or_sync_on_pattern *ptr_struct, FILE* file);
/* icmd_phy_set_get_rx_sd */
void connectx4lx_icmd_phy_set_get_rx_sd_pack(const struct connectx4lx_icmd_phy_set_get_rx_sd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_rx_sd_unpack(struct connectx4lx_icmd_phy_set_get_rx_sd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_rx_sd_print(const struct connectx4lx_icmd_phy_set_get_rx_sd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_set_get_rx_sd_size(void);
#define CONNECTX4LX_ICMD_PHY_SET_GET_RX_SD_SIZE    (0x54)
void connectx4lx_icmd_phy_set_get_rx_sd_dump(const struct connectx4lx_icmd_phy_set_get_rx_sd *ptr_struct, FILE* file);
/* icmd_phy_set_get_tx_sd */
void connectx4lx_icmd_phy_set_get_tx_sd_pack(const struct connectx4lx_icmd_phy_set_get_tx_sd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_tx_sd_unpack(struct connectx4lx_icmd_phy_set_get_tx_sd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_set_get_tx_sd_print(const struct connectx4lx_icmd_phy_set_get_tx_sd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_set_get_tx_sd_size(void);
#define CONNECTX4LX_ICMD_PHY_SET_GET_TX_SD_SIZE    (0x38)
void connectx4lx_icmd_phy_set_get_tx_sd_dump(const struct connectx4lx_icmd_phy_set_get_tx_sd *ptr_struct, FILE* file);
/* icmd_phy_halt_fsm */
void connectx4lx_icmd_phy_halt_fsm_pack(const struct connectx4lx_icmd_phy_halt_fsm *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_halt_fsm_unpack(struct connectx4lx_icmd_phy_halt_fsm *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_halt_fsm_print(const struct connectx4lx_icmd_phy_halt_fsm *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_halt_fsm_size(void);
#define CONNECTX4LX_ICMD_PHY_HALT_FSM_SIZE    (0x4)
void connectx4lx_icmd_phy_halt_fsm_dump(const struct connectx4lx_icmd_phy_halt_fsm *ptr_struct, FILE* file);
/* icmd_phy_open_close_port */
void connectx4lx_icmd_phy_open_close_port_pack(const struct connectx4lx_icmd_phy_open_close_port *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_open_close_port_unpack(struct connectx4lx_icmd_phy_open_close_port *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_open_close_port_print(const struct connectx4lx_icmd_phy_open_close_port *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_open_close_port_size(void);
#define CONNECTX4LX_ICMD_PHY_OPEN_CLOSE_PORT_SIZE    (0x4)
void connectx4lx_icmd_phy_open_close_port_dump(const struct connectx4lx_icmd_phy_open_close_port *ptr_struct, FILE* file);
/* icmd_phy_get_link_status */
void connectx4lx_icmd_phy_get_link_status_pack(const struct connectx4lx_icmd_phy_get_link_status *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_link_status_unpack(struct connectx4lx_icmd_phy_get_link_status *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_get_link_status_print(const struct connectx4lx_icmd_phy_get_link_status *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_get_link_status_size(void);
#define CONNECTX4LX_ICMD_PHY_GET_LINK_STATUS_SIZE    (0x24)
void connectx4lx_icmd_phy_get_link_status_dump(const struct connectx4lx_icmd_phy_get_link_status *ptr_struct, FILE* file);
/* icmd_phy_activate_rx_adap */
void connectx4lx_icmd_phy_activate_rx_adap_pack(const struct connectx4lx_icmd_phy_activate_rx_adap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_activate_rx_adap_unpack(struct connectx4lx_icmd_phy_activate_rx_adap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_activate_rx_adap_print(const struct connectx4lx_icmd_phy_activate_rx_adap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_activate_rx_adap_size(void);
#define CONNECTX4LX_ICMD_PHY_ACTIVATE_RX_ADAP_SIZE    (0x104)
void connectx4lx_icmd_phy_activate_rx_adap_dump(const struct connectx4lx_icmd_phy_activate_rx_adap *ptr_struct, FILE* file);
/* icmd_pmaos */
void connectx4lx_icmd_pmaos_pack(const struct connectx4lx_icmd_pmaos *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pmaos_unpack(struct connectx4lx_icmd_pmaos *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pmaos_print(const struct connectx4lx_icmd_pmaos *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pmaos_size(void);
#define CONNECTX4LX_ICMD_PMAOS_SIZE    (0xc)
void connectx4lx_icmd_pmaos_dump(const struct connectx4lx_icmd_pmaos *ptr_struct, FILE* file);
/* icmd_sspl_hook */
void connectx4lx_icmd_sspl_hook_pack(const struct connectx4lx_icmd_sspl_hook *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_sspl_hook_unpack(struct connectx4lx_icmd_sspl_hook *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_sspl_hook_print(const struct connectx4lx_icmd_sspl_hook *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_sspl_hook_size(void);
#define CONNECTX4LX_ICMD_SSPL_HOOK_SIZE    (0x10)
void connectx4lx_icmd_sspl_hook_dump(const struct connectx4lx_icmd_sspl_hook *ptr_struct, FILE* file);
/* icmd_temp_hook */
void connectx4lx_icmd_temp_hook_pack(const struct connectx4lx_icmd_temp_hook *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_temp_hook_unpack(struct connectx4lx_icmd_temp_hook *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_temp_hook_print(const struct connectx4lx_icmd_temp_hook *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_temp_hook_size(void);
#define CONNECTX4LX_ICMD_TEMP_HOOK_SIZE    (0x10)
void connectx4lx_icmd_temp_hook_dump(const struct connectx4lx_icmd_temp_hook *ptr_struct, FILE* file);
/* icmd_mminit */
void connectx4lx_icmd_mminit_pack(const struct connectx4lx_icmd_mminit *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mminit_unpack(struct connectx4lx_icmd_mminit *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mminit_print(const struct connectx4lx_icmd_mminit *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mminit_size(void);
#define CONNECTX4LX_ICMD_MMINIT_SIZE    (0x5c)
void connectx4lx_icmd_mminit_dump(const struct connectx4lx_icmd_mminit *ptr_struct, FILE* file);
/* icmd_gpio_func */
void connectx4lx_icmd_gpio_func_pack(const struct connectx4lx_icmd_gpio_func *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_gpio_func_unpack(struct connectx4lx_icmd_gpio_func *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_gpio_func_print(const struct connectx4lx_icmd_gpio_func *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_gpio_func_size(void);
#define CONNECTX4LX_ICMD_GPIO_FUNC_SIZE    (0x4c)
void connectx4lx_icmd_gpio_func_dump(const struct connectx4lx_icmd_gpio_func *ptr_struct, FILE* file);
/* icmd_access_reg_ptys */
void connectx4lx_icmd_access_reg_ptys_pack(const struct connectx4lx_icmd_access_reg_ptys *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_reg_ptys_unpack(struct connectx4lx_icmd_access_reg_ptys *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_reg_ptys_print(const struct connectx4lx_icmd_access_reg_ptys *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_reg_ptys_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REG_PTYS_SIZE    (0x44)
void connectx4lx_icmd_access_reg_ptys_dump(const struct connectx4lx_icmd_access_reg_ptys *ptr_struct, FILE* file);
/* icmd_access_register_pmtu */
void connectx4lx_icmd_access_register_pmtu_pack(const struct connectx4lx_icmd_access_register_pmtu *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pmtu_unpack(struct connectx4lx_icmd_access_register_pmtu *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pmtu_print(const struct connectx4lx_icmd_access_register_pmtu *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pmtu_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PMTU_SIZE    (0x14)
void connectx4lx_icmd_access_register_pmtu_dump(const struct connectx4lx_icmd_access_register_pmtu *ptr_struct, FILE* file);
/* icmd_access_register_mlcr */
void connectx4lx_icmd_access_register_mlcr_pack(const struct connectx4lx_icmd_access_register_mlcr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_mlcr_unpack(struct connectx4lx_icmd_access_register_mlcr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_mlcr_print(const struct connectx4lx_icmd_access_register_mlcr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_mlcr_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_MLCR_SIZE    (0x10)
void connectx4lx_icmd_access_register_mlcr_dump(const struct connectx4lx_icmd_access_register_mlcr *ptr_struct, FILE* file);
/* icmd_access_register_plpc */
void connectx4lx_icmd_access_register_plpc_pack(const struct connectx4lx_icmd_access_register_plpc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_plpc_unpack(struct connectx4lx_icmd_access_register_plpc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_plpc_print(const struct connectx4lx_icmd_access_register_plpc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_plpc_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PLPC_SIZE    (0x30)
void connectx4lx_icmd_access_register_plpc_dump(const struct connectx4lx_icmd_access_register_plpc *ptr_struct, FILE* file);
/* icmd_access_register_pplm */
void connectx4lx_icmd_access_register_pplm_pack(const struct connectx4lx_icmd_access_register_pplm *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pplm_unpack(struct connectx4lx_icmd_access_register_pplm *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pplm_print(const struct connectx4lx_icmd_access_register_pplm *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pplm_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPLM_SIZE    (0x30)
void connectx4lx_icmd_access_register_pplm_dump(const struct connectx4lx_icmd_access_register_pplm *ptr_struct, FILE* file);
/* icmd_access_register_pplr */
void connectx4lx_icmd_access_register_pplr_pack(const struct connectx4lx_icmd_access_register_pplr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pplr_unpack(struct connectx4lx_icmd_access_register_pplr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pplr_print(const struct connectx4lx_icmd_access_register_pplr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pplr_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPLR_SIZE    (0x30)
void connectx4lx_icmd_access_register_pplr_dump(const struct connectx4lx_icmd_access_register_pplr *ptr_struct, FILE* file);
/* icmd_access_register_ppamp */
void connectx4lx_icmd_access_register_ppamp_pack(const struct connectx4lx_icmd_access_register_ppamp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppamp_unpack(struct connectx4lx_icmd_access_register_ppamp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppamp_print(const struct connectx4lx_icmd_access_register_ppamp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_ppamp_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPAMP_SIZE    (0x30)
void connectx4lx_icmd_access_register_ppamp_dump(const struct connectx4lx_icmd_access_register_ppamp *ptr_struct, FILE* file);
/* icmd_access_register_ptas */
void connectx4lx_icmd_access_register_ptas_pack(const struct connectx4lx_icmd_access_register_ptas *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ptas_unpack(struct connectx4lx_icmd_access_register_ptas *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ptas_print(const struct connectx4lx_icmd_access_register_ptas *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_ptas_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PTAS_SIZE    (0x30)
void connectx4lx_icmd_access_register_ptas_dump(const struct connectx4lx_icmd_access_register_ptas *ptr_struct, FILE* file);
/* icmd_access_register_ppaos */
void connectx4lx_icmd_access_register_ppaos_pack(const struct connectx4lx_icmd_access_register_ppaos *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppaos_unpack(struct connectx4lx_icmd_access_register_ppaos *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_ppaos_print(const struct connectx4lx_icmd_access_register_ppaos *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_ppaos_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPAOS_SIZE    (0x14)
void connectx4lx_icmd_access_register_ppaos_dump(const struct connectx4lx_icmd_access_register_ppaos *ptr_struct, FILE* file);
/* icmd_access_register_pprt */
void connectx4lx_icmd_access_register_pprt_pack(const struct connectx4lx_icmd_access_register_pprt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pprt_unpack(struct connectx4lx_icmd_access_register_pprt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pprt_print(const struct connectx4lx_icmd_access_register_pprt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pprt_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPRT_SIZE    (0x2c)
void connectx4lx_icmd_access_register_pprt_dump(const struct connectx4lx_icmd_access_register_pprt *ptr_struct, FILE* file);
/* icmd_access_register_pptt */
void connectx4lx_icmd_access_register_pptt_pack(const struct connectx4lx_icmd_access_register_pptt *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pptt_unpack(struct connectx4lx_icmd_access_register_pptt *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_pptt_print(const struct connectx4lx_icmd_access_register_pptt *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_pptt_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PPTT_SIZE    (0x20)
void connectx4lx_icmd_access_register_pptt_dump(const struct connectx4lx_icmd_access_register_pptt *ptr_struct, FILE* file);
/* icmd_access_register_slrg */
void connectx4lx_icmd_access_register_slrg_pack(const struct connectx4lx_icmd_access_register_slrg *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_slrg_unpack(struct connectx4lx_icmd_access_register_slrg *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_slrg_print(const struct connectx4lx_icmd_access_register_slrg *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_slrg_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_SLRG_SIZE    (0x2c)
void connectx4lx_icmd_access_register_slrg_dump(const struct connectx4lx_icmd_access_register_slrg *ptr_struct, FILE* file);
/* icmd_access_register_sltp */
void connectx4lx_icmd_access_register_sltp_pack(const struct connectx4lx_icmd_access_register_sltp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_sltp_unpack(struct connectx4lx_icmd_access_register_sltp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_sltp_print(const struct connectx4lx_icmd_access_register_sltp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_sltp_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_SLTP_SIZE    (0x18)
void connectx4lx_icmd_access_register_sltp_dump(const struct connectx4lx_icmd_access_register_sltp *ptr_struct, FILE* file);
/* icmd_access_register_slrp */
void connectx4lx_icmd_access_register_slrp_pack(const struct connectx4lx_icmd_access_register_slrp *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_slrp_unpack(struct connectx4lx_icmd_access_register_slrp *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_slrp_print(const struct connectx4lx_icmd_access_register_slrp *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_slrp_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_SLRP_SIZE    (0x30)
void connectx4lx_icmd_access_register_slrp_dump(const struct connectx4lx_icmd_access_register_slrp *ptr_struct, FILE* file);
/* icmd_access_register_paos */
void connectx4lx_icmd_access_register_paos_pack(const struct connectx4lx_icmd_access_register_paos *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_paos_unpack(struct connectx4lx_icmd_access_register_paos *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_register_paos_print(const struct connectx4lx_icmd_access_register_paos *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_register_paos_size(void);
#define CONNECTX4LX_ICMD_ACCESS_REGISTER_PAOS_SIZE    (0x14)
void connectx4lx_icmd_access_register_paos_dump(const struct connectx4lx_icmd_access_register_paos *ptr_struct, FILE* file);
/* icmd_enable_tools_pf */
void connectx4lx_icmd_enable_tools_pf_pack(const struct connectx4lx_icmd_enable_tools_pf *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_enable_tools_pf_unpack(struct connectx4lx_icmd_enable_tools_pf *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_enable_tools_pf_print(const struct connectx4lx_icmd_enable_tools_pf *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_enable_tools_pf_size(void);
#define CONNECTX4LX_ICMD_ENABLE_TOOLS_PF_SIZE    (0x4)
void connectx4lx_icmd_enable_tools_pf_dump(const struct connectx4lx_icmd_enable_tools_pf *ptr_struct, FILE* file);
/* icmd_set_toolpf_tracer */
void connectx4lx_icmd_set_toolpf_tracer_pack(const struct connectx4lx_icmd_set_toolpf_tracer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_toolpf_tracer_unpack(struct connectx4lx_icmd_set_toolpf_tracer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_toolpf_tracer_print(const struct connectx4lx_icmd_set_toolpf_tracer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_toolpf_tracer_size(void);
#define CONNECTX4LX_ICMD_SET_TOOLPF_TRACER_SIZE    (0x40)
void connectx4lx_icmd_set_toolpf_tracer_dump(const struct connectx4lx_icmd_set_toolpf_tracer *ptr_struct, FILE* file);
/* icmd_nvcfg_rw_tlv */
void connectx4lx_icmd_nvcfg_rw_tlv_pack(const struct connectx4lx_icmd_nvcfg_rw_tlv *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_nvcfg_rw_tlv_unpack(struct connectx4lx_icmd_nvcfg_rw_tlv *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_nvcfg_rw_tlv_print(const struct connectx4lx_icmd_nvcfg_rw_tlv *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_nvcfg_rw_tlv_size(void);
#define CONNECTX4LX_ICMD_NVCFG_RW_TLV_SIZE    (0x110)
void connectx4lx_icmd_nvcfg_rw_tlv_dump(const struct connectx4lx_icmd_nvcfg_rw_tlv *ptr_struct, FILE* file);
/* icmd_fpga_flex_nic_ctrl */
void connectx4lx_icmd_fpga_flex_nic_ctrl_pack(const struct connectx4lx_icmd_fpga_flex_nic_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_fpga_flex_nic_ctrl_unpack(struct connectx4lx_icmd_fpga_flex_nic_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_fpga_flex_nic_ctrl_print(const struct connectx4lx_icmd_fpga_flex_nic_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_fpga_flex_nic_ctrl_size(void);
#define CONNECTX4LX_ICMD_FPGA_FLEX_NIC_CTRL_SIZE    (0x100)
void connectx4lx_icmd_fpga_flex_nic_ctrl_dump(const struct connectx4lx_icmd_fpga_flex_nic_ctrl *ptr_struct, FILE* file);
/* icmd_mng_smbus_freq */
void connectx4lx_icmd_mng_smbus_freq_pack(const struct connectx4lx_icmd_mng_smbus_freq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_mng_smbus_freq_unpack(struct connectx4lx_icmd_mng_smbus_freq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_mng_smbus_freq_print(const struct connectx4lx_icmd_mng_smbus_freq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_mng_smbus_freq_size(void);
#define CONNECTX4LX_ICMD_MNG_SMBUS_FREQ_SIZE    (0x4)
void connectx4lx_icmd_mng_smbus_freq_dump(const struct connectx4lx_icmd_mng_smbus_freq *ptr_struct, FILE* file);
/* icmd_smbus_master_access */
void connectx4lx_icmd_smbus_master_access_pack(const struct connectx4lx_icmd_smbus_master_access *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_smbus_master_access_unpack(struct connectx4lx_icmd_smbus_master_access *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_smbus_master_access_print(const struct connectx4lx_icmd_smbus_master_access *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_smbus_master_access_size(void);
#define CONNECTX4LX_ICMD_SMBUS_MASTER_ACCESS_SIZE    (0x140)
void connectx4lx_icmd_smbus_master_access_dump(const struct connectx4lx_icmd_smbus_master_access *ptr_struct, FILE* file);
/* icmd_xport_xonfig */
void connectx4lx_icmd_xport_xonfig_pack(const struct connectx4lx_icmd_xport_xonfig *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_xport_xonfig_unpack(struct connectx4lx_icmd_xport_xonfig *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_xport_xonfig_print(const struct connectx4lx_icmd_xport_xonfig *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_xport_xonfig_size(void);
#define CONNECTX4LX_ICMD_XPORT_XONFIG_SIZE    (0x10)
void connectx4lx_icmd_xport_xonfig_dump(const struct connectx4lx_icmd_xport_xonfig *ptr_struct, FILE* file);
/* icmd_get_gvmi_via_vsec */
void connectx4lx_icmd_get_gvmi_via_vsec_pack(const struct connectx4lx_icmd_get_gvmi_via_vsec *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_gvmi_via_vsec_unpack(struct connectx4lx_icmd_get_gvmi_via_vsec *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_gvmi_via_vsec_print(const struct connectx4lx_icmd_get_gvmi_via_vsec *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_gvmi_via_vsec_size(void);
#define CONNECTX4LX_ICMD_GET_GVMI_VIA_VSEC_SIZE    (0x10)
void connectx4lx_icmd_get_gvmi_via_vsec_dump(const struct connectx4lx_icmd_get_gvmi_via_vsec *ptr_struct, FILE* file);
/* icmd_steering_table_info */
void connectx4lx_icmd_steering_table_info_pack(const struct connectx4lx_icmd_steering_table_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_steering_table_info_unpack(struct connectx4lx_icmd_steering_table_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_steering_table_info_print(const struct connectx4lx_icmd_steering_table_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_steering_table_info_size(void);
#define CONNECTX4LX_ICMD_STEERING_TABLE_INFO_SIZE    (0x50)
void connectx4lx_icmd_steering_table_info_dump(const struct connectx4lx_icmd_steering_table_info *ptr_struct, FILE* file);
/* icmd_access_steering_root */
void connectx4lx_icmd_access_steering_root_pack(const struct connectx4lx_icmd_access_steering_root *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_steering_root_unpack(struct connectx4lx_icmd_access_steering_root *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_steering_root_print(const struct connectx4lx_icmd_access_steering_root *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_steering_root_size(void);
#define CONNECTX4LX_ICMD_ACCESS_STEERING_ROOT_SIZE    (0x44)
void connectx4lx_icmd_access_steering_root_dump(const struct connectx4lx_icmd_access_steering_root *ptr_struct, FILE* file);
/* icmd_phy_update_calib_vals */
void connectx4lx_icmd_phy_update_calib_vals_pack(const struct connectx4lx_icmd_phy_update_calib_vals *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_update_calib_vals_unpack(struct connectx4lx_icmd_phy_update_calib_vals *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_update_calib_vals_print(const struct connectx4lx_icmd_phy_update_calib_vals *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_update_calib_vals_size(void);
#define CONNECTX4LX_ICMD_PHY_UPDATE_CALIB_VALS_SIZE    (0x30)
void connectx4lx_icmd_phy_update_calib_vals_dump(const struct connectx4lx_icmd_phy_update_calib_vals *ptr_struct, FILE* file);
/* icmd_dcr_ll_next_dcr_list */
void connectx4lx_icmd_dcr_ll_next_dcr_list_pack(const struct connectx4lx_icmd_dcr_ll_next_dcr_list *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_dcr_ll_next_dcr_list_unpack(struct connectx4lx_icmd_dcr_ll_next_dcr_list *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_dcr_ll_next_dcr_list_print(const struct connectx4lx_icmd_dcr_ll_next_dcr_list *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_dcr_ll_next_dcr_list_size(void);
#define CONNECTX4LX_ICMD_DCR_LL_NEXT_DCR_LIST_SIZE    (0x300)
void connectx4lx_icmd_dcr_ll_next_dcr_list_dump(const struct connectx4lx_icmd_dcr_ll_next_dcr_list *ptr_struct, FILE* file);
/* icmd_dcr_ll_trvrs */
void connectx4lx_icmd_dcr_ll_trvrs_pack(const struct connectx4lx_icmd_dcr_ll_trvrs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_dcr_ll_trvrs_unpack(struct connectx4lx_icmd_dcr_ll_trvrs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_dcr_ll_trvrs_print(const struct connectx4lx_icmd_dcr_ll_trvrs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_dcr_ll_trvrs_size(void);
#define CONNECTX4LX_ICMD_DCR_LL_TRVRS_SIZE    (0x10)
void connectx4lx_icmd_dcr_ll_trvrs_dump(const struct connectx4lx_icmd_dcr_ll_trvrs *ptr_struct, FILE* file);
/* icmd_flr_debug */
void connectx4lx_icmd_flr_debug_pack(const struct connectx4lx_icmd_flr_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_flr_debug_unpack(struct connectx4lx_icmd_flr_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_flr_debug_print(const struct connectx4lx_icmd_flr_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_flr_debug_size(void);
#define CONNECTX4LX_ICMD_FLR_DEBUG_SIZE    (0x20)
void connectx4lx_icmd_flr_debug_dump(const struct connectx4lx_icmd_flr_debug *ptr_struct, FILE* file);
/* icmd_push_db */
void connectx4lx_icmd_push_db_pack(const struct connectx4lx_icmd_push_db *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_push_db_unpack(struct connectx4lx_icmd_push_db *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_push_db_print(const struct connectx4lx_icmd_push_db *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_push_db_size(void);
#define CONNECTX4LX_ICMD_PUSH_DB_SIZE    (0x8)
void connectx4lx_icmd_push_db_dump(const struct connectx4lx_icmd_push_db *ptr_struct, FILE* file);
/* icmd_ver_data */
void connectx4lx_icmd_ver_data_pack(const struct connectx4lx_icmd_ver_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_unpack(struct connectx4lx_icmd_ver_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ver_data_print(const struct connectx4lx_icmd_ver_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ver_data_size(void);
#define CONNECTX4LX_ICMD_VER_DATA_SIZE    (0x50)
void connectx4lx_icmd_ver_data_dump(const struct connectx4lx_icmd_ver_data *ptr_struct, FILE* file);
/* icmd_pcie_ver_data */
void connectx4lx_icmd_pcie_ver_data_pack(const struct connectx4lx_icmd_pcie_ver_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_data_unpack(struct connectx4lx_icmd_pcie_ver_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_pcie_ver_data_print(const struct connectx4lx_icmd_pcie_ver_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_pcie_ver_data_size(void);
#define CONNECTX4LX_ICMD_PCIE_VER_DATA_SIZE    (0x40)
void connectx4lx_icmd_pcie_ver_data_dump(const struct connectx4lx_icmd_pcie_ver_data *ptr_struct, FILE* file);
/* icmd_error_flow_trigger */
void connectx4lx_icmd_error_flow_trigger_pack(const struct connectx4lx_icmd_error_flow_trigger *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_error_flow_trigger_unpack(struct connectx4lx_icmd_error_flow_trigger *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_error_flow_trigger_print(const struct connectx4lx_icmd_error_flow_trigger *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_error_flow_trigger_size(void);
#define CONNECTX4LX_ICMD_ERROR_FLOW_TRIGGER_SIZE    (0x100)
void connectx4lx_icmd_error_flow_trigger_dump(const struct connectx4lx_icmd_error_flow_trigger *ptr_struct, FILE* file);
/* icmd_stop_toggler */
void connectx4lx_icmd_stop_toggler_pack(const struct connectx4lx_icmd_stop_toggler *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_stop_toggler_unpack(struct connectx4lx_icmd_stop_toggler *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_stop_toggler_print(const struct connectx4lx_icmd_stop_toggler *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_stop_toggler_size(void);
#define CONNECTX4LX_ICMD_STOP_TOGGLER_SIZE    (0x100)
void connectx4lx_icmd_stop_toggler_dump(const struct connectx4lx_icmd_stop_toggler *ptr_struct, FILE* file);
/* icmd_code_coverage_read */
void connectx4lx_icmd_code_coverage_read_pack(const struct connectx4lx_icmd_code_coverage_read *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_code_coverage_read_unpack(struct connectx4lx_icmd_code_coverage_read *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_code_coverage_read_print(const struct connectx4lx_icmd_code_coverage_read *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_code_coverage_read_size(void);
#define CONNECTX4LX_ICMD_CODE_COVERAGE_READ_SIZE    (0x108)
void connectx4lx_icmd_code_coverage_read_dump(const struct connectx4lx_icmd_code_coverage_read *ptr_struct, FILE* file);
/* icmd_code_coverage_control */
void connectx4lx_icmd_code_coverage_control_pack(const struct connectx4lx_icmd_code_coverage_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_code_coverage_control_unpack(struct connectx4lx_icmd_code_coverage_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_code_coverage_control_print(const struct connectx4lx_icmd_code_coverage_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_code_coverage_control_size(void);
#define CONNECTX4LX_ICMD_CODE_COVERAGE_CONTROL_SIZE    (0x10)
void connectx4lx_icmd_code_coverage_control_dump(const struct connectx4lx_icmd_code_coverage_control *ptr_struct, FILE* file);
/* icmd_esw */
void connectx4lx_icmd_esw_pack(const struct connectx4lx_icmd_esw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_esw_unpack(struct connectx4lx_icmd_esw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_esw_print(const struct connectx4lx_icmd_esw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_esw_size(void);
#define CONNECTX4LX_ICMD_ESW_SIZE    (0x300)
void connectx4lx_icmd_esw_dump(const struct connectx4lx_icmd_esw *ptr_struct, FILE* file);
/* icmd_rw_gvmix */
void connectx4lx_icmd_rw_gvmix_pack(const struct connectx4lx_icmd_rw_gvmix *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_rw_gvmix_unpack(struct connectx4lx_icmd_rw_gvmix *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_rw_gvmix_print(const struct connectx4lx_icmd_rw_gvmix *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_rw_gvmix_size(void);
#define CONNECTX4LX_ICMD_RW_GVMIX_SIZE    (0x80)
void connectx4lx_icmd_rw_gvmix_dump(const struct connectx4lx_icmd_rw_gvmix *ptr_struct, FILE* file);
/* icmd_gen_eqe */
void connectx4lx_icmd_gen_eqe_pack(const struct connectx4lx_icmd_gen_eqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_gen_eqe_unpack(struct connectx4lx_icmd_gen_eqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_gen_eqe_print(const struct connectx4lx_icmd_gen_eqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_gen_eqe_size(void);
#define CONNECTX4LX_ICMD_GEN_EQE_SIZE    (0x50)
void connectx4lx_icmd_gen_eqe_dump(const struct connectx4lx_icmd_gen_eqe *ptr_struct, FILE* file);
/* pcie_tools_pointers */
void connectx4lx_pcie_tools_pointers_pack(const struct connectx4lx_pcie_tools_pointers *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_pcie_tools_pointers_unpack(struct connectx4lx_pcie_tools_pointers *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_pcie_tools_pointers_print(const struct connectx4lx_pcie_tools_pointers *ptr_struct, FILE* file, int indent_level);
int connectx4lx_pcie_tools_pointers_size(void);
#define CONNECTX4LX_PCIE_TOOLS_POINTERS_SIZE    (0x40)
void connectx4lx_pcie_tools_pointers_dump(const struct connectx4lx_pcie_tools_pointers *ptr_struct, FILE* file);
/* icmd_phy_ver_overwrite */
void connectx4lx_icmd_phy_ver_overwrite_pack(const struct connectx4lx_icmd_phy_ver_overwrite *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_ver_overwrite_unpack(struct connectx4lx_icmd_phy_ver_overwrite *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_phy_ver_overwrite_print(const struct connectx4lx_icmd_phy_ver_overwrite *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_phy_ver_overwrite_size(void);
#define CONNECTX4LX_ICMD_PHY_VER_OVERWRITE_SIZE    (0x8)
void connectx4lx_icmd_phy_ver_overwrite_dump(const struct connectx4lx_icmd_phy_ver_overwrite *ptr_struct, FILE* file);
/* icmd_init_ocsd */
void connectx4lx_icmd_init_ocsd_pack(const struct connectx4lx_icmd_init_ocsd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_init_ocsd_unpack(struct connectx4lx_icmd_init_ocsd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_init_ocsd_print(const struct connectx4lx_icmd_init_ocsd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_init_ocsd_size(void);
#define CONNECTX4LX_ICMD_INIT_OCSD_SIZE    (0xc)
void connectx4lx_icmd_init_ocsd_dump(const struct connectx4lx_icmd_init_ocsd *ptr_struct, FILE* file);
/* inject_ncsi */
void connectx4lx_inject_ncsi_pack(const struct connectx4lx_inject_ncsi *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_inject_ncsi_unpack(struct connectx4lx_inject_ncsi *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_inject_ncsi_print(const struct connectx4lx_inject_ncsi *ptr_struct, FILE* file, int indent_level);
int connectx4lx_inject_ncsi_size(void);
#define CONNECTX4LX_INJECT_NCSI_SIZE    (0x22c)
void connectx4lx_inject_ncsi_dump(const struct connectx4lx_inject_ncsi *ptr_struct, FILE* file);
/* init_ncsi */
void connectx4lx_init_ncsi_pack(const struct connectx4lx_init_ncsi *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_init_ncsi_unpack(struct connectx4lx_init_ncsi *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_init_ncsi_print(const struct connectx4lx_init_ncsi *ptr_struct, FILE* file, int indent_level);
int connectx4lx_init_ncsi_size(void);
#define CONNECTX4LX_INIT_NCSI_SIZE    (0x8)
void connectx4lx_init_ncsi_dump(const struct connectx4lx_init_ncsi *ptr_struct, FILE* file);
/* icmd_dc_config */
void connectx4lx_icmd_dc_config_pack(const struct connectx4lx_icmd_dc_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_dc_config_unpack(struct connectx4lx_icmd_dc_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_dc_config_print(const struct connectx4lx_icmd_dc_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_dc_config_size(void);
#define CONNECTX4LX_ICMD_DC_CONFIG_SIZE    (0x80)
void connectx4lx_icmd_dc_config_dump(const struct connectx4lx_icmd_dc_config *ptr_struct, FILE* file);
/* icmd_read_icmc_tags_and_info */
void connectx4lx_icmd_read_icmc_tags_and_info_pack(const struct connectx4lx_icmd_read_icmc_tags_and_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icmc_tags_and_info_unpack(struct connectx4lx_icmd_read_icmc_tags_and_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icmc_tags_and_info_print(const struct connectx4lx_icmd_read_icmc_tags_and_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_icmc_tags_and_info_size(void);
#define CONNECTX4LX_ICMD_READ_ICMC_TAGS_AND_INFO_SIZE    (0x300)
void connectx4lx_icmd_read_icmc_tags_and_info_dump(const struct connectx4lx_icmd_read_icmc_tags_and_info *ptr_struct, FILE* file);
/* icmd_access_icm_line */
void connectx4lx_icmd_access_icm_line_pack(const struct connectx4lx_icmd_access_icm_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_icm_line_unpack(struct connectx4lx_icmd_access_icm_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_icm_line_print(const struct connectx4lx_icmd_access_icm_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_icm_line_size(void);
#define CONNECTX4LX_ICMD_ACCESS_ICM_LINE_SIZE    (0x50)
void connectx4lx_icmd_access_icm_line_dump(const struct connectx4lx_icmd_access_icm_line *ptr_struct, FILE* file);
/* icmd_check_sqpc_status */
void connectx4lx_icmd_check_sqpc_status_pack(const struct connectx4lx_icmd_check_sqpc_status *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_check_sqpc_status_unpack(struct connectx4lx_icmd_check_sqpc_status *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_check_sqpc_status_print(const struct connectx4lx_icmd_check_sqpc_status *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_check_sqpc_status_size(void);
#define CONNECTX4LX_ICMD_CHECK_SQPC_STATUS_SIZE    (0x10)
void connectx4lx_icmd_check_sqpc_status_dump(const struct connectx4lx_icmd_check_sqpc_status *ptr_struct, FILE* file);
/* icmd_lock_unlock_resource */
void connectx4lx_icmd_lock_unlock_resource_pack(const struct connectx4lx_icmd_lock_unlock_resource *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_lock_unlock_resource_unpack(struct connectx4lx_icmd_lock_unlock_resource *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_lock_unlock_resource_print(const struct connectx4lx_icmd_lock_unlock_resource *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_lock_unlock_resource_size(void);
#define CONNECTX4LX_ICMD_LOCK_UNLOCK_RESOURCE_SIZE    (0x10)
void connectx4lx_icmd_lock_unlock_resource_dump(const struct connectx4lx_icmd_lock_unlock_resource *ptr_struct, FILE* file);
/* icmd_generic_access_register */
void connectx4lx_icmd_generic_access_register_pack(const struct connectx4lx_icmd_generic_access_register *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_access_register_unpack(struct connectx4lx_icmd_generic_access_register *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_generic_access_register_print(const struct connectx4lx_icmd_generic_access_register *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_generic_access_register_size(void);
#define CONNECTX4LX_ICMD_GENERIC_ACCESS_REGISTER_SIZE    (0x128)
void connectx4lx_icmd_generic_access_register_dump(const struct connectx4lx_icmd_generic_access_register *ptr_struct, FILE* file);
/* icmd_kdnet_ctrl */
void connectx4lx_icmd_kdnet_ctrl_pack(const struct connectx4lx_icmd_kdnet_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_unpack(struct connectx4lx_icmd_kdnet_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_kdnet_ctrl_print(const struct connectx4lx_icmd_kdnet_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_kdnet_ctrl_size(void);
#define CONNECTX4LX_ICMD_KDNET_CTRL_SIZE    (0x8)
void connectx4lx_icmd_kdnet_ctrl_dump(const struct connectx4lx_icmd_kdnet_ctrl *ptr_struct, FILE* file);
/* icmd_query_capabilities */
void connectx4lx_icmd_query_capabilities_pack(const union connectx4lx_icmd_query_capabilities *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_query_capabilities_unpack(union connectx4lx_icmd_query_capabilities *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_query_capabilities_print(const union connectx4lx_icmd_query_capabilities *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_query_capabilities_size(void);
#define CONNECTX4LX_ICMD_QUERY_CAPABILITIES_SIZE    (0x8)
void connectx4lx_icmd_query_capabilities_dump(const union connectx4lx_icmd_query_capabilities *ptr_struct, FILE* file);
/* icmd_get_icm_ctx_addr */
void connectx4lx_icmd_get_icm_ctx_addr_pack(const struct connectx4lx_icmd_get_icm_ctx_addr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_icm_ctx_addr_unpack(struct connectx4lx_icmd_get_icm_ctx_addr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_icm_ctx_addr_print(const struct connectx4lx_icmd_get_icm_ctx_addr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_icm_ctx_addr_size(void);
#define CONNECTX4LX_ICMD_GET_ICM_CTX_ADDR_SIZE    (0x18)
void connectx4lx_icmd_get_icm_ctx_addr_dump(const struct connectx4lx_icmd_get_icm_ctx_addr *ptr_struct, FILE* file);
/* phy_nego_ctrl_st */
void connectx4lx_phy_nego_ctrl_st_pack(const struct connectx4lx_phy_nego_ctrl_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_nego_ctrl_st_unpack(struct connectx4lx_phy_nego_ctrl_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_nego_ctrl_st_print(const struct connectx4lx_phy_nego_ctrl_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_nego_ctrl_st_size(void);
#define CONNECTX4LX_PHY_NEGO_CTRL_ST_SIZE    (0x4)
void connectx4lx_phy_nego_ctrl_st_dump(const struct connectx4lx_phy_nego_ctrl_st *ptr_struct, FILE* file);
/* eye_opening_read_st */
void connectx4lx_eye_opening_read_st_pack(const struct connectx4lx_eye_opening_read_st *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eye_opening_read_st_unpack(struct connectx4lx_eye_opening_read_st *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eye_opening_read_st_print(const struct connectx4lx_eye_opening_read_st *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eye_opening_read_st_size(void);
#define CONNECTX4LX_EYE_OPENING_READ_ST_SIZE    (0x10)
void connectx4lx_eye_opening_read_st_dump(const struct connectx4lx_eye_opening_read_st *ptr_struct, FILE* file);
/* icmd_alloc_dealloc_resource */
void connectx4lx_icmd_alloc_dealloc_resource_pack(const struct connectx4lx_icmd_alloc_dealloc_resource *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_alloc_dealloc_resource_unpack(struct connectx4lx_icmd_alloc_dealloc_resource *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_alloc_dealloc_resource_print(const struct connectx4lx_icmd_alloc_dealloc_resource *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_alloc_dealloc_resource_size(void);
#define CONNECTX4LX_ICMD_ALLOC_DEALLOC_RESOURCE_SIZE    (0x18)
void connectx4lx_icmd_alloc_dealloc_resource_dump(const struct connectx4lx_icmd_alloc_dealloc_resource *ptr_struct, FILE* file);
/* icmd_get_icm_res_prop */
void connectx4lx_icmd_get_icm_res_prop_pack(const struct connectx4lx_icmd_get_icm_res_prop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_icm_res_prop_unpack(struct connectx4lx_icmd_get_icm_res_prop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_icm_res_prop_print(const struct connectx4lx_icmd_get_icm_res_prop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_icm_res_prop_size(void);
#define CONNECTX4LX_ICMD_GET_ICM_RES_PROP_SIZE    (0x24)
void connectx4lx_icmd_get_icm_res_prop_dump(const struct connectx4lx_icmd_get_icm_res_prop *ptr_struct, FILE* file);
/* icmd_emad_mcia */
void connectx4lx_icmd_emad_mcia_pack(const struct connectx4lx_icmd_emad_mcia *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_emad_mcia_unpack(struct connectx4lx_icmd_emad_mcia *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_emad_mcia_print(const struct connectx4lx_icmd_emad_mcia *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_emad_mcia_size(void);
#define CONNECTX4LX_ICMD_EMAD_MCIA_SIZE    (0x48)
void connectx4lx_icmd_emad_mcia_dump(const struct connectx4lx_icmd_emad_mcia *ptr_struct, FILE* file);
/* icmd_cable_info */
void connectx4lx_icmd_cable_info_pack(const struct connectx4lx_icmd_cable_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_info_unpack(struct connectx4lx_icmd_cable_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_info_print(const struct connectx4lx_icmd_cable_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_cable_info_size(void);
#define CONNECTX4LX_ICMD_CABLE_INFO_SIZE    (0x80)
void connectx4lx_icmd_cable_info_dump(const struct connectx4lx_icmd_cable_info *ptr_struct, FILE* file);
/* icmd_cable_plug_out_in */
void connectx4lx_icmd_cable_plug_out_in_pack(const struct connectx4lx_icmd_cable_plug_out_in *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_plug_out_in_unpack(struct connectx4lx_icmd_cable_plug_out_in *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_cable_plug_out_in_print(const struct connectx4lx_icmd_cable_plug_out_in *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_cable_plug_out_in_size(void);
#define CONNECTX4LX_ICMD_CABLE_PLUG_OUT_IN_SIZE    (0x4)
void connectx4lx_icmd_cable_plug_out_in_dump(const struct connectx4lx_icmd_cable_plug_out_in *ptr_struct, FILE* file);
/* icmd_standby */
void connectx4lx_icmd_standby_pack(const struct connectx4lx_icmd_standby *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_standby_unpack(struct connectx4lx_icmd_standby *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_standby_print(const struct connectx4lx_icmd_standby *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_standby_size(void);
#define CONNECTX4LX_ICMD_STANDBY_SIZE    (0x20)
void connectx4lx_icmd_standby_dump(const struct connectx4lx_icmd_standby *ptr_struct, FILE* file);
/* icmd_grepper */
void connectx4lx_icmd_grepper_pack(const struct connectx4lx_icmd_grepper *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_grepper_unpack(struct connectx4lx_icmd_grepper *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_grepper_print(const struct connectx4lx_icmd_grepper *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_grepper_size(void);
#define CONNECTX4LX_ICMD_GREPPER_SIZE    (0x200)
void connectx4lx_icmd_grepper_dump(const struct connectx4lx_icmd_grepper *ptr_struct, FILE* file);
/* icmd_packet_drop */
void connectx4lx_icmd_packet_drop_pack(const struct connectx4lx_icmd_packet_drop *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_packet_drop_unpack(struct connectx4lx_icmd_packet_drop *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_packet_drop_print(const struct connectx4lx_icmd_packet_drop *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_packet_drop_size(void);
#define CONNECTX4LX_ICMD_PACKET_DROP_SIZE    (0x4)
void connectx4lx_icmd_packet_drop_dump(const struct connectx4lx_icmd_packet_drop *ptr_struct, FILE* file);
/* icmd_execute_fw_log */
void connectx4lx_icmd_execute_fw_log_pack(const struct connectx4lx_icmd_execute_fw_log *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_execute_fw_log_unpack(struct connectx4lx_icmd_execute_fw_log *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_execute_fw_log_print(const struct connectx4lx_icmd_execute_fw_log *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_execute_fw_log_size(void);
#define CONNECTX4LX_ICMD_EXECUTE_FW_LOG_SIZE    (0x30)
void connectx4lx_icmd_execute_fw_log_dump(const struct connectx4lx_icmd_execute_fw_log *ptr_struct, FILE* file);
/* icmd_debug_fw_tracer */
void connectx4lx_icmd_debug_fw_tracer_pack(const struct connectx4lx_icmd_debug_fw_tracer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_debug_fw_tracer_unpack(struct connectx4lx_icmd_debug_fw_tracer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_debug_fw_tracer_print(const struct connectx4lx_icmd_debug_fw_tracer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_debug_fw_tracer_size(void);
#define CONNECTX4LX_ICMD_DEBUG_FW_TRACER_SIZE    (0x30)
void connectx4lx_icmd_debug_fw_tracer_dump(const struct connectx4lx_icmd_debug_fw_tracer *ptr_struct, FILE* file);
/* icmd_get_highest_index */
void connectx4lx_icmd_get_highest_index_pack(const struct connectx4lx_icmd_get_highest_index *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_highest_index_unpack(struct connectx4lx_icmd_get_highest_index *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_highest_index_print(const struct connectx4lx_icmd_get_highest_index *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_highest_index_size(void);
#define CONNECTX4LX_ICMD_GET_HIGHEST_INDEX_SIZE    (0x20)
void connectx4lx_icmd_get_highest_index_dump(const struct connectx4lx_icmd_get_highest_index *ptr_struct, FILE* file);
/* icmd_get_open_resources */
void connectx4lx_icmd_get_open_resources_pack(const struct connectx4lx_icmd_get_open_resources *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_open_resources_unpack(struct connectx4lx_icmd_get_open_resources *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_open_resources_print(const struct connectx4lx_icmd_get_open_resources *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_open_resources_size(void);
#define CONNECTX4LX_ICMD_GET_OPEN_RESOURCES_SIZE    (0x300)
void connectx4lx_icmd_get_open_resources_dump(const struct connectx4lx_icmd_get_open_resources *ptr_struct, FILE* file);
/* icmd_read_icm_dummy_addr */
void connectx4lx_icmd_read_icm_dummy_addr_pack(const struct connectx4lx_icmd_read_icm_dummy_addr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icm_dummy_addr_unpack(struct connectx4lx_icmd_read_icm_dummy_addr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icm_dummy_addr_print(const struct connectx4lx_icmd_read_icm_dummy_addr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_icm_dummy_addr_size(void);
#define CONNECTX4LX_ICMD_READ_ICM_DUMMY_ADDR_SIZE    (0x20)
void connectx4lx_icmd_read_icm_dummy_addr_dump(const struct connectx4lx_icmd_read_icm_dummy_addr *ptr_struct, FILE* file);
/* icmd_read_icm_tlb_line */
void connectx4lx_icmd_read_icm_tlb_line_pack(const struct connectx4lx_icmd_read_icm_tlb_line *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icm_tlb_line_unpack(struct connectx4lx_icmd_read_icm_tlb_line *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_icm_tlb_line_print(const struct connectx4lx_icmd_read_icm_tlb_line *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_icm_tlb_line_size(void);
#define CONNECTX4LX_ICMD_READ_ICM_TLB_LINE_SIZE    (0x50)
void connectx4lx_icmd_read_icm_tlb_line_dump(const struct connectx4lx_icmd_read_icm_tlb_line *ptr_struct, FILE* file);
/* icmd_config_cc */
void connectx4lx_icmd_config_cc_pack(const struct connectx4lx_icmd_config_cc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_config_cc_unpack(struct connectx4lx_icmd_config_cc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_config_cc_print(const struct connectx4lx_icmd_config_cc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_config_cc_size(void);
#define CONNECTX4LX_ICMD_CONFIG_CC_SIZE    (0x300)
void connectx4lx_icmd_config_cc_dump(const struct connectx4lx_icmd_config_cc *ptr_struct, FILE* file);
/* icmd_ud_to_raw */
void connectx4lx_icmd_ud_to_raw_pack(const struct connectx4lx_icmd_ud_to_raw *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ud_to_raw_unpack(struct connectx4lx_icmd_ud_to_raw *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ud_to_raw_print(const struct connectx4lx_icmd_ud_to_raw *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ud_to_raw_size(void);
#define CONNECTX4LX_ICMD_UD_TO_RAW_SIZE    (0x40)
void connectx4lx_icmd_ud_to_raw_dump(const struct connectx4lx_icmd_ud_to_raw *ptr_struct, FILE* file);
/* icmd_update_rq_ci */
void connectx4lx_icmd_update_rq_ci_pack(const struct connectx4lx_icmd_update_rq_ci *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_update_rq_ci_unpack(struct connectx4lx_icmd_update_rq_ci *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_update_rq_ci_print(const struct connectx4lx_icmd_update_rq_ci *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_update_rq_ci_size(void);
#define CONNECTX4LX_ICMD_UPDATE_RQ_CI_SIZE    (0x40)
void connectx4lx_icmd_update_rq_ci_dump(const struct connectx4lx_icmd_update_rq_ci *ptr_struct, FILE* file);
/* icmd_write_dc_cnak_lid */
void connectx4lx_icmd_write_dc_cnak_lid_pack(const struct connectx4lx_icmd_write_dc_cnak_lid *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_write_dc_cnak_lid_unpack(struct connectx4lx_icmd_write_dc_cnak_lid *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_write_dc_cnak_lid_print(const struct connectx4lx_icmd_write_dc_cnak_lid *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_write_dc_cnak_lid_size(void);
#define CONNECTX4LX_ICMD_WRITE_DC_CNAK_LID_SIZE    (0x40)
void connectx4lx_icmd_write_dc_cnak_lid_dump(const struct connectx4lx_icmd_write_dc_cnak_lid *ptr_struct, FILE* file);
/* icmd_congestion_log */
void connectx4lx_icmd_congestion_log_pack(const struct connectx4lx_icmd_congestion_log *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_congestion_log_unpack(struct connectx4lx_icmd_congestion_log *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_congestion_log_print(const struct connectx4lx_icmd_congestion_log *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_congestion_log_size(void);
#define CONNECTX4LX_ICMD_CONGESTION_LOG_SIZE    (0x40)
void connectx4lx_icmd_congestion_log_dump(const struct connectx4lx_icmd_congestion_log *ptr_struct, FILE* file);
/* icmd_get_port_sniffer */
void connectx4lx_icmd_get_port_sniffer_pack(const struct connectx4lx_icmd_get_port_sniffer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_port_sniffer_unpack(struct connectx4lx_icmd_get_port_sniffer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_port_sniffer_print(const struct connectx4lx_icmd_get_port_sniffer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_port_sniffer_size(void);
#define CONNECTX4LX_ICMD_GET_PORT_SNIFFER_SIZE    (0x10)
void connectx4lx_icmd_get_port_sniffer_dump(const struct connectx4lx_icmd_get_port_sniffer *ptr_struct, FILE* file);
/* icmd_set_port_sniffer */
void connectx4lx_icmd_set_port_sniffer_pack(const struct connectx4lx_icmd_set_port_sniffer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_set_port_sniffer_unpack(struct connectx4lx_icmd_set_port_sniffer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_set_port_sniffer_print(const struct connectx4lx_icmd_set_port_sniffer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_set_port_sniffer_size(void);
#define CONNECTX4LX_ICMD_SET_PORT_SNIFFER_SIZE    (0x10)
void connectx4lx_icmd_set_port_sniffer_dump(const struct connectx4lx_icmd_set_port_sniffer *ptr_struct, FILE* file);
/* icmd_special_qps */
void connectx4lx_icmd_special_qps_pack(const struct connectx4lx_icmd_special_qps *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_special_qps_unpack(struct connectx4lx_icmd_special_qps *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_special_qps_print(const struct connectx4lx_icmd_special_qps *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_special_qps_size(void);
#define CONNECTX4LX_ICMD_SPECIAL_QPS_SIZE    (0x104)
void connectx4lx_icmd_special_qps_dump(const struct connectx4lx_icmd_special_qps *ptr_struct, FILE* file);
/* eqn4type */
void connectx4lx_eqn4type_pack(const struct connectx4lx_eqn4type *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_eqn4type_unpack(struct connectx4lx_eqn4type *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_eqn4type_print(const struct connectx4lx_eqn4type *ptr_struct, FILE* file, int indent_level);
int connectx4lx_eqn4type_size(void);
#define CONNECTX4LX_EQN4TYPE_SIZE    (0x104)
void connectx4lx_eqn4type_dump(const struct connectx4lx_eqn4type *ptr_struct, FILE* file);
/* icmd_access_cmdq */
void connectx4lx_icmd_access_cmdq_pack(const struct connectx4lx_icmd_access_cmdq *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_cmdq_unpack(struct connectx4lx_icmd_access_cmdq *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_cmdq_print(const struct connectx4lx_icmd_access_cmdq *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_cmdq_size(void);
#define CONNECTX4LX_ICMD_ACCESS_CMDQ_SIZE    (0x48)
void connectx4lx_icmd_access_cmdq_dump(const struct connectx4lx_icmd_access_cmdq *ptr_struct, FILE* file);
/* icmd_read_sx_wq_buffer */
void connectx4lx_icmd_read_sx_wq_buffer_pack(const struct connectx4lx_icmd_read_sx_wq_buffer *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_sx_wq_buffer_unpack(struct connectx4lx_icmd_read_sx_wq_buffer *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_sx_wq_buffer_print(const struct connectx4lx_icmd_read_sx_wq_buffer *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_sx_wq_buffer_size(void);
#define CONNECTX4LX_ICMD_READ_SX_WQ_BUFFER_SIZE    (0x48)
void connectx4lx_icmd_read_sx_wq_buffer_dump(const struct connectx4lx_icmd_read_sx_wq_buffer *ptr_struct, FILE* file);
/* icmd_header_capture */
void connectx4lx_icmd_header_capture_pack(const struct connectx4lx_icmd_header_capture *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_unpack(struct connectx4lx_icmd_header_capture *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_header_capture_print(const struct connectx4lx_icmd_header_capture *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_header_capture_size(void);
#define CONNECTX4LX_ICMD_HEADER_CAPTURE_SIZE    (0xc0)
void connectx4lx_icmd_header_capture_dump(const struct connectx4lx_icmd_header_capture *ptr_struct, FILE* file);
/* print_icm */
void connectx4lx_print_icm_pack(const struct connectx4lx_print_icm *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_print_icm_unpack(struct connectx4lx_print_icm *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_print_icm_print(const struct connectx4lx_print_icm *ptr_struct, FILE* file, int indent_level);
int connectx4lx_print_icm_size(void);
#define CONNECTX4LX_PRINT_ICM_SIZE    (0x8)
void connectx4lx_print_icm_dump(const struct connectx4lx_print_icm *ptr_struct, FILE* file);
/* icmd_allowed_madifc_on_all_pfs */
void connectx4lx_icmd_allowed_madifc_on_all_pfs_pack(const struct connectx4lx_icmd_allowed_madifc_on_all_pfs *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_allowed_madifc_on_all_pfs_unpack(struct connectx4lx_icmd_allowed_madifc_on_all_pfs *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_allowed_madifc_on_all_pfs_print(const struct connectx4lx_icmd_allowed_madifc_on_all_pfs *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_allowed_madifc_on_all_pfs_size(void);
#define CONNECTX4LX_ICMD_ALLOWED_MADIFC_ON_ALL_PFS_SIZE    (0x8)
void connectx4lx_icmd_allowed_madifc_on_all_pfs_dump(const struct connectx4lx_icmd_allowed_madifc_on_all_pfs *ptr_struct, FILE* file);
/* icmd_fw_reset */
void connectx4lx_icmd_fw_reset_pack(const struct connectx4lx_icmd_fw_reset *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_fw_reset_unpack(struct connectx4lx_icmd_fw_reset *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_fw_reset_print(const struct connectx4lx_icmd_fw_reset *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_fw_reset_size(void);
#define CONNECTX4LX_ICMD_FW_RESET_SIZE    (0x8)
void connectx4lx_icmd_fw_reset_dump(const struct connectx4lx_icmd_fw_reset *ptr_struct, FILE* file);
/* icmd_read_g_rse_slice_desc */
void connectx4lx_icmd_read_g_rse_slice_desc_pack(const struct connectx4lx_icmd_read_g_rse_slice_desc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_g_rse_slice_desc_unpack(struct connectx4lx_icmd_read_g_rse_slice_desc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_g_rse_slice_desc_print(const struct connectx4lx_icmd_read_g_rse_slice_desc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_g_rse_slice_desc_size(void);
#define CONNECTX4LX_ICMD_READ_G_RSE_SLICE_DESC_SIZE    (0x108)
void connectx4lx_icmd_read_g_rse_slice_desc_dump(const struct connectx4lx_icmd_read_g_rse_slice_desc *ptr_struct, FILE* file);
/* icmd_read_rx_slice_packet */
void connectx4lx_icmd_read_rx_slice_packet_pack(const struct connectx4lx_icmd_read_rx_slice_packet *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_rx_slice_packet_unpack(struct connectx4lx_icmd_read_rx_slice_packet *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_rx_slice_packet_print(const struct connectx4lx_icmd_read_rx_slice_packet *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_rx_slice_packet_size(void);
#define CONNECTX4LX_ICMD_READ_RX_SLICE_PACKET_SIZE    (0x20c)
void connectx4lx_icmd_read_rx_slice_packet_dump(const struct connectx4lx_icmd_read_rx_slice_packet *ptr_struct, FILE* file);
/* icmd_get_fw_info */
void connectx4lx_icmd_get_fw_info_pack(const struct connectx4lx_icmd_get_fw_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fw_info_unpack(struct connectx4lx_icmd_get_fw_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_fw_info_print(const struct connectx4lx_icmd_get_fw_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_fw_info_size(void);
#define CONNECTX4LX_ICMD_GET_FW_INFO_SIZE    (0x24)
void connectx4lx_icmd_get_fw_info_dump(const struct connectx4lx_icmd_get_fw_info *ptr_struct, FILE* file);
/* icmd_get_link_leds */
void connectx4lx_icmd_get_link_leds_pack(const struct connectx4lx_icmd_get_link_leds *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_link_leds_unpack(struct connectx4lx_icmd_get_link_leds *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_link_leds_print(const struct connectx4lx_icmd_get_link_leds *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_link_leds_size(void);
#define CONNECTX4LX_ICMD_GET_LINK_LEDS_SIZE    (0x8)
void connectx4lx_icmd_get_link_leds_dump(const struct connectx4lx_icmd_get_link_leds *ptr_struct, FILE* file);
/* icmd_get_boot_stage */
void connectx4lx_icmd_get_boot_stage_pack(const struct connectx4lx_icmd_get_boot_stage *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_boot_stage_unpack(struct connectx4lx_icmd_get_boot_stage *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_boot_stage_print(const struct connectx4lx_icmd_get_boot_stage *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_boot_stage_size(void);
#define CONNECTX4LX_ICMD_GET_BOOT_STAGE_SIZE    (0x4)
void connectx4lx_icmd_get_boot_stage_dump(const struct connectx4lx_icmd_get_boot_stage *ptr_struct, FILE* file);
/* icmd_get_irisc_heart_beat */
void connectx4lx_icmd_get_irisc_heart_beat_pack(const struct connectx4lx_icmd_get_irisc_heart_beat *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_irisc_heart_beat_unpack(struct connectx4lx_icmd_get_irisc_heart_beat *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_irisc_heart_beat_print(const struct connectx4lx_icmd_get_irisc_heart_beat *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_irisc_heart_beat_size(void);
#define CONNECTX4LX_ICMD_GET_IRISC_HEART_BEAT_SIZE    (0x4)
void connectx4lx_icmd_get_irisc_heart_beat_dump(const struct connectx4lx_icmd_get_irisc_heart_beat *ptr_struct, FILE* file);
/* icmd_read_q_entry */
void connectx4lx_icmd_read_q_entry_pack(const struct connectx4lx_icmd_read_q_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_read_q_entry_unpack(struct connectx4lx_icmd_read_q_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_read_q_entry_print(const struct connectx4lx_icmd_read_q_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_read_q_entry_size(void);
#define CONNECTX4LX_ICMD_READ_Q_ENTRY_SIZE    (0x20c)
void connectx4lx_icmd_read_q_entry_dump(const struct connectx4lx_icmd_read_q_entry *ptr_struct, FILE* file);
/* icmd_access_host_mem */
void connectx4lx_icmd_access_host_mem_pack(const struct connectx4lx_icmd_access_host_mem *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_host_mem_unpack(struct connectx4lx_icmd_access_host_mem *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_host_mem_print(const struct connectx4lx_icmd_access_host_mem *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_host_mem_size(void);
#define CONNECTX4LX_ICMD_ACCESS_HOST_MEM_SIZE    (0x128)
void connectx4lx_icmd_access_host_mem_dump(const struct connectx4lx_icmd_access_host_mem *ptr_struct, FILE* file);
/* icmd_get_pi_ci */
void connectx4lx_icmd_get_pi_ci_pack(const struct connectx4lx_icmd_get_pi_ci *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_get_pi_ci_unpack(struct connectx4lx_icmd_get_pi_ci *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_get_pi_ci_print(const struct connectx4lx_icmd_get_pi_ci *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_get_pi_ci_size(void);
#define CONNECTX4LX_ICMD_GET_PI_CI_SIZE    (0xc)
void connectx4lx_icmd_get_pi_ci_dump(const struct connectx4lx_icmd_get_pi_ci *ptr_struct, FILE* file);
/* icmd_access_icm_ctx */
void connectx4lx_icmd_access_icm_ctx_pack(const struct connectx4lx_icmd_access_icm_ctx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_access_icm_ctx_unpack(struct connectx4lx_icmd_access_icm_ctx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_access_icm_ctx_print(const struct connectx4lx_icmd_access_icm_ctx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_access_icm_ctx_size(void);
#define CONNECTX4LX_ICMD_ACCESS_ICM_CTX_SIZE    (0x60)
void connectx4lx_icmd_access_icm_ctx_dump(const struct connectx4lx_icmd_access_icm_ctx *ptr_struct, FILE* file);
/* icmd_cmd_as_dwords */
void connectx4lx_icmd_cmd_as_dwords_pack(const struct connectx4lx_icmd_cmd_as_dwords *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_cmd_as_dwords_unpack(struct connectx4lx_icmd_cmd_as_dwords *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_cmd_as_dwords_print(const struct connectx4lx_icmd_cmd_as_dwords *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_cmd_as_dwords_size(void);
#define CONNECTX4LX_ICMD_CMD_AS_DWORDS_SIZE    (0x300)
void connectx4lx_icmd_cmd_as_dwords_dump(const struct connectx4lx_icmd_cmd_as_dwords *ptr_struct, FILE* file);
/* sw_cqe_64b */
void connectx4lx_sw_cqe_64b_pack(const struct connectx4lx_sw_cqe_64b *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_64b_unpack(struct connectx4lx_sw_cqe_64b *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_64b_print(const struct connectx4lx_sw_cqe_64b *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_64b_size(void);
#define CONNECTX4LX_SW_CQE_64B_SIZE    (0x40)
void connectx4lx_sw_cqe_64b_dump(const struct connectx4lx_sw_cqe_64b *ptr_struct, FILE* file);
/* grh_inline_data */
void connectx4lx_grh_inline_data_pack(const struct connectx4lx_grh_inline_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_grh_inline_data_unpack(struct connectx4lx_grh_inline_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_grh_inline_data_print(const struct connectx4lx_grh_inline_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_grh_inline_data_size(void);
#define CONNECTX4LX_GRH_INLINE_DATA_SIZE    (0x40)
void connectx4lx_grh_inline_data_dump(const struct connectx4lx_grh_inline_data *ptr_struct, FILE* file);
/* subroutines_lifo */
void connectx4lx_subroutines_lifo_pack(const struct connectx4lx_subroutines_lifo *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_subroutines_lifo_unpack(struct connectx4lx_subroutines_lifo *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_subroutines_lifo_print(const struct connectx4lx_subroutines_lifo *ptr_struct, FILE* file, int indent_level);
int connectx4lx_subroutines_lifo_size(void);
#define CONNECTX4LX_SUBROUTINES_LIFO_SIZE    (0x70)
void connectx4lx_subroutines_lifo_dump(const struct connectx4lx_subroutines_lifo *ptr_struct, FILE* file);
/* lane_debug */
void connectx4lx_lane_debug_pack(const struct connectx4lx_lane_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_debug_unpack(struct connectx4lx_lane_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_debug_print(const struct connectx4lx_lane_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_debug_size(void);
#define CONNECTX4LX_LANE_DEBUG_SIZE    (0x90)
void connectx4lx_lane_debug_dump(const struct connectx4lx_lane_debug *ptr_struct, FILE* file);
/* lane_results */
void connectx4lx_lane_results_pack(const struct connectx4lx_lane_results *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_results_unpack(struct connectx4lx_lane_results *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_results_print(const struct connectx4lx_lane_results *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_results_size(void);
#define CONNECTX4LX_LANE_RESULTS_SIZE    (0x40)
void connectx4lx_lane_results_dump(const struct connectx4lx_lane_results *ptr_struct, FILE* file);
/* lane_vars */
void connectx4lx_lane_vars_pack(const struct connectx4lx_lane_vars *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_vars_unpack(struct connectx4lx_lane_vars *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_vars_print(const struct connectx4lx_lane_vars *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_vars_size(void);
#define CONNECTX4LX_LANE_VARS_SIZE    (0xa0)
void connectx4lx_lane_vars_dump(const struct connectx4lx_lane_vars *ptr_struct, FILE* file);
/* lane_static_vars */
void connectx4lx_lane_static_vars_pack(const struct connectx4lx_lane_static_vars *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_static_vars_unpack(struct connectx4lx_lane_static_vars *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_static_vars_print(const struct connectx4lx_lane_static_vars *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_static_vars_size(void);
#define CONNECTX4LX_LANE_STATIC_VARS_SIZE    (0x430)
void connectx4lx_lane_static_vars_dump(const struct connectx4lx_lane_static_vars *ptr_struct, FILE* file);
/* port_opamp_calibration_results */
void connectx4lx_port_opamp_calibration_results_pack(const struct connectx4lx_port_opamp_calibration_results *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_opamp_calibration_results_unpack(struct connectx4lx_port_opamp_calibration_results *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_opamp_calibration_results_print(const struct connectx4lx_port_opamp_calibration_results *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_opamp_calibration_results_size(void);
#define CONNECTX4LX_PORT_OPAMP_CALIBRATION_RESULTS_SIZE    (0x4c0)
void connectx4lx_port_opamp_calibration_results_dump(const struct connectx4lx_port_opamp_calibration_results *ptr_struct, FILE* file);
/* port_debug */
void connectx4lx_port_debug_pack(const struct connectx4lx_port_debug *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_debug_unpack(struct connectx4lx_port_debug *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_debug_print(const struct connectx4lx_port_debug *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_debug_size(void);
#define CONNECTX4LX_PORT_DEBUG_SIZE    (0x10)
void connectx4lx_port_debug_dump(const struct connectx4lx_port_debug *ptr_struct, FILE* file);
/* wqe_eth_segment */
void connectx4lx_wqe_eth_segment_pack(const struct connectx4lx_wqe_eth_segment *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_eth_segment_unpack(struct connectx4lx_wqe_eth_segment *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_eth_segment_print(const struct connectx4lx_wqe_eth_segment *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_eth_segment_size(void);
#define CONNECTX4LX_WQE_ETH_SEGMENT_SIZE    (0x10)
void connectx4lx_wqe_eth_segment_dump(const struct connectx4lx_wqe_eth_segment *ptr_struct, FILE* file);
/* wqe_inline_header */
void connectx4lx_wqe_inline_header_pack(const struct connectx4lx_wqe_inline_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_inline_header_unpack(struct connectx4lx_wqe_inline_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_inline_header_print(const struct connectx4lx_wqe_inline_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_inline_header_size(void);
#define CONNECTX4LX_WQE_INLINE_HEADER_SIZE    (0x4)
void connectx4lx_wqe_inline_header_dump(const struct connectx4lx_wqe_inline_header *ptr_struct, FILE* file);
/* wqe_gather_scatter_entry */
void connectx4lx_wqe_gather_scatter_entry_pack(const struct connectx4lx_wqe_gather_scatter_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_gather_scatter_entry_unpack(struct connectx4lx_wqe_gather_scatter_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_gather_scatter_entry_print(const struct connectx4lx_wqe_gather_scatter_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_gather_scatter_entry_size(void);
#define CONNECTX4LX_WQE_GATHER_SCATTER_ENTRY_SIZE    (0x10)
void connectx4lx_wqe_gather_scatter_entry_dump(const struct connectx4lx_wqe_gather_scatter_entry *ptr_struct, FILE* file);
/* wqe_srq_next */
void connectx4lx_wqe_srq_next_pack(const struct connectx4lx_wqe_srq_next *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_srq_next_unpack(struct connectx4lx_wqe_srq_next *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_srq_next_print(const struct connectx4lx_wqe_srq_next *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_srq_next_size(void);
#define CONNECTX4LX_WQE_SRQ_NEXT_SIZE    (0x10)
void connectx4lx_wqe_srq_next_dump(const struct connectx4lx_wqe_srq_next *ptr_struct, FILE* file);
/* wqe_signature */
void connectx4lx_wqe_signature_pack(const struct connectx4lx_wqe_signature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_signature_unpack(struct connectx4lx_wqe_signature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_signature_print(const struct connectx4lx_wqe_signature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_signature_size(void);
#define CONNECTX4LX_WQE_SIGNATURE_SIZE    (0x10)
void connectx4lx_wqe_signature_dump(const struct connectx4lx_wqe_signature *ptr_struct, FILE* file);
/* wqe_extended_atomic_fetch_add */
void connectx4lx_wqe_extended_atomic_fetch_add_pack(const union connectx4lx_wqe_extended_atomic_fetch_add *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_unpack(union connectx4lx_wqe_extended_atomic_fetch_add *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_fetch_add_print(const union connectx4lx_wqe_extended_atomic_fetch_add *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_fetch_add_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_FETCH_ADD_SIZE    (0x100)
void connectx4lx_wqe_extended_atomic_fetch_add_dump(const union connectx4lx_wqe_extended_atomic_fetch_add *ptr_struct, FILE* file);
/* wqe_atomic_fetch_add */
void connectx4lx_wqe_atomic_fetch_add_pack(const struct connectx4lx_wqe_atomic_fetch_add *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_atomic_fetch_add_unpack(struct connectx4lx_wqe_atomic_fetch_add *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_atomic_fetch_add_print(const struct connectx4lx_wqe_atomic_fetch_add *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_atomic_fetch_add_size(void);
#define CONNECTX4LX_WQE_ATOMIC_FETCH_ADD_SIZE    (0x10)
void connectx4lx_wqe_atomic_fetch_add_dump(const struct connectx4lx_wqe_atomic_fetch_add *ptr_struct, FILE* file);
/* wqe_extended_atomic_cmp_swap */
void connectx4lx_wqe_extended_atomic_cmp_swap_pack(const union connectx4lx_wqe_extended_atomic_cmp_swap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_unpack(union connectx4lx_wqe_extended_atomic_cmp_swap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_extended_atomic_cmp_swap_print(const union connectx4lx_wqe_extended_atomic_cmp_swap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_extended_atomic_cmp_swap_size(void);
#define CONNECTX4LX_WQE_EXTENDED_ATOMIC_CMP_SWAP_SIZE    (0x200)
void connectx4lx_wqe_extended_atomic_cmp_swap_dump(const union connectx4lx_wqe_extended_atomic_cmp_swap *ptr_struct, FILE* file);
/* wqe_atomic_cmp_swap */
void connectx4lx_wqe_atomic_cmp_swap_pack(const struct connectx4lx_wqe_atomic_cmp_swap *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_atomic_cmp_swap_unpack(struct connectx4lx_wqe_atomic_cmp_swap *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_atomic_cmp_swap_print(const struct connectx4lx_wqe_atomic_cmp_swap *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_atomic_cmp_swap_size(void);
#define CONNECTX4LX_WQE_ATOMIC_CMP_SWAP_SIZE    (0x10)
void connectx4lx_wqe_atomic_cmp_swap_dump(const struct connectx4lx_wqe_atomic_cmp_swap *ptr_struct, FILE* file);
/* wqe_rdma_read */
void connectx4lx_wqe_rdma_read_pack(const struct connectx4lx_wqe_rdma_read *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_rdma_read_unpack(struct connectx4lx_wqe_rdma_read *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_rdma_read_print(const struct connectx4lx_wqe_rdma_read *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_rdma_read_size(void);
#define CONNECTX4LX_WQE_RDMA_READ_SIZE    (0x10)
void connectx4lx_wqe_rdma_read_dump(const struct connectx4lx_wqe_rdma_read *ptr_struct, FILE* file);
/* wqe_address_vector_ext */
void connectx4lx_wqe_address_vector_ext_pack(const struct connectx4lx_wqe_address_vector_ext *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_address_vector_ext_unpack(struct connectx4lx_wqe_address_vector_ext *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_address_vector_ext_print(const struct connectx4lx_wqe_address_vector_ext *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_address_vector_ext_size(void);
#define CONNECTX4LX_WQE_ADDRESS_VECTOR_EXT_SIZE    (0x20)
void connectx4lx_wqe_address_vector_ext_dump(const struct connectx4lx_wqe_address_vector_ext *ptr_struct, FILE* file);
/* wqe_address_vector_basic */
void connectx4lx_wqe_address_vector_basic_pack(const struct connectx4lx_wqe_address_vector_basic *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_address_vector_basic_unpack(struct connectx4lx_wqe_address_vector_basic *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_address_vector_basic_print(const struct connectx4lx_wqe_address_vector_basic *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_address_vector_basic_size(void);
#define CONNECTX4LX_WQE_ADDRESS_VECTOR_BASIC_SIZE    (0x10)
void connectx4lx_wqe_address_vector_basic_dump(const struct connectx4lx_wqe_address_vector_basic *ptr_struct, FILE* file);
/* wqe_xrc */
void connectx4lx_wqe_xrc_pack(const struct connectx4lx_wqe_xrc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_xrc_unpack(struct connectx4lx_wqe_xrc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_xrc_print(const struct connectx4lx_wqe_xrc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_xrc_size(void);
#define CONNECTX4LX_WQE_XRC_SIZE    (0x10)
void connectx4lx_wqe_xrc_dump(const struct connectx4lx_wqe_xrc *ptr_struct, FILE* file);
/* wqe_mlx */
void connectx4lx_wqe_mlx_pack(const struct connectx4lx_wqe_mlx *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_mlx_unpack(struct connectx4lx_wqe_mlx *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_mlx_print(const struct connectx4lx_wqe_mlx *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_mlx_size(void);
#define CONNECTX4LX_WQE_MLX_SIZE    (0x10)
void connectx4lx_wqe_mlx_dump(const struct connectx4lx_wqe_mlx *ptr_struct, FILE* file);
/* wqe_control */
void connectx4lx_wqe_control_pack(const struct connectx4lx_wqe_control *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_wqe_control_unpack(struct connectx4lx_wqe_control *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_wqe_control_print(const struct connectx4lx_wqe_control *ptr_struct, FILE* file, int indent_level);
int connectx4lx_wqe_control_size(void);
#define CONNECTX4LX_WQE_CONTROL_SIZE    (0x10)
void connectx4lx_wqe_control_dump(const struct connectx4lx_wqe_control *ptr_struct, FILE* file);
/* public_keys */
void connectx4lx_public_keys_pack(const struct connectx4lx_public_keys *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_public_keys_unpack(struct connectx4lx_public_keys *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_public_keys_print(const struct connectx4lx_public_keys *ptr_struct, FILE* file, int indent_level);
int connectx4lx_public_keys_size(void);
#define CONNECTX4LX_PUBLIC_KEYS_SIZE    (0x900)
void connectx4lx_public_keys_dump(const struct connectx4lx_public_keys *ptr_struct, FILE* file);
/* image_signature */
void connectx4lx_image_signature_pack(const struct connectx4lx_image_signature *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_image_signature_unpack(struct connectx4lx_image_signature *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_image_signature_print(const struct connectx4lx_image_signature *ptr_struct, FILE* file, int indent_level);
int connectx4lx_image_signature_size(void);
#define CONNECTX4LX_IMAGE_SIGNATURE_SIZE    (0x140)
void connectx4lx_image_signature_dump(const struct connectx4lx_image_signature *ptr_struct, FILE* file);
/* nv_data */
void connectx4lx_nv_data_pack(const struct connectx4lx_nv_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_nv_data_unpack(struct connectx4lx_nv_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_nv_data_print(const struct connectx4lx_nv_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_nv_data_size(void);
#define CONNECTX4LX_NV_DATA_SIZE    (0x10000)
void connectx4lx_nv_data_dump(const struct connectx4lx_nv_data *ptr_struct, FILE* file);
/* phy_uc_consts */
void connectx4lx_phy_uc_consts_pack(const struct connectx4lx_phy_uc_consts *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_uc_consts_unpack(struct connectx4lx_phy_uc_consts *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_uc_consts_print(const struct connectx4lx_phy_uc_consts *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_uc_consts_size(void);
#define CONNECTX4LX_PHY_UC_CONSTS_SIZE    (0x2c80)
void connectx4lx_phy_uc_consts_dump(const struct connectx4lx_phy_uc_consts *ptr_struct, FILE* file);
/* hw_boot_config */
void connectx4lx_hw_boot_config_pack(const struct connectx4lx_hw_boot_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_boot_config_unpack(struct connectx4lx_hw_boot_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_boot_config_print(const struct connectx4lx_hw_boot_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_boot_config_size(void);
#define CONNECTX4LX_HW_BOOT_CONFIG_SIZE    (0x140)
void connectx4lx_hw_boot_config_dump(const struct connectx4lx_hw_boot_config *ptr_struct, FILE* file);
/* hw_main_config */
void connectx4lx_hw_main_config_pack(const struct connectx4lx_hw_main_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_hw_main_config_unpack(struct connectx4lx_hw_main_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_hw_main_config_print(const struct connectx4lx_hw_main_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_hw_main_config_size(void);
#define CONNECTX4LX_HW_MAIN_CONFIG_SIZE    (0xb00)
void connectx4lx_hw_main_config_dump(const struct connectx4lx_hw_main_config *ptr_struct, FILE* file);
/* fw_boot_config */
void connectx4lx_fw_boot_config_pack(const struct connectx4lx_fw_boot_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_boot_config_unpack(struct connectx4lx_fw_boot_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_boot_config_print(const struct connectx4lx_fw_boot_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_boot_config_size(void);
#define CONNECTX4LX_FW_BOOT_CONFIG_SIZE    (0x4c0)
void connectx4lx_fw_boot_config_dump(const struct connectx4lx_fw_boot_config *ptr_struct, FILE* file);
/* fw_main_config */
void connectx4lx_fw_main_config_pack(const struct connectx4lx_fw_main_config *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_fw_main_config_unpack(struct connectx4lx_fw_main_config *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_fw_main_config_print(const struct connectx4lx_fw_main_config *ptr_struct, FILE* file, int indent_level);
int connectx4lx_fw_main_config_size(void);
#define CONNECTX4LX_FW_MAIN_CONFIG_SIZE    (0x1000)
void connectx4lx_fw_main_config_dump(const struct connectx4lx_fw_main_config *ptr_struct, FILE* file);
/* mfg_info */
void connectx4lx_mfg_info_pack(const struct connectx4lx_mfg_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_mfg_info_unpack(struct connectx4lx_mfg_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_mfg_info_print(const struct connectx4lx_mfg_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_mfg_info_size(void);
#define CONNECTX4LX_MFG_INFO_SIZE    (0x140)
void connectx4lx_mfg_info_dump(const struct connectx4lx_mfg_info *ptr_struct, FILE* file);
/* image_info */
void connectx4lx_image_info_pack(const struct connectx4lx_image_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_image_info_unpack(struct connectx4lx_image_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_image_info_print(const struct connectx4lx_image_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_image_info_size(void);
#define CONNECTX4LX_IMAGE_INFO_SIZE    (0x400)
void connectx4lx_image_info_dump(const struct connectx4lx_image_info *ptr_struct, FILE* file);
/* device_info */
void connectx4lx_device_info_pack(const struct connectx4lx_device_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_device_info_unpack(struct connectx4lx_device_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_device_info_print(const struct connectx4lx_device_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_device_info_size(void);
#define CONNECTX4LX_DEVICE_INFO_SIZE    (0x200)
void connectx4lx_device_info_dump(const struct connectx4lx_device_info *ptr_struct, FILE* file);
/* dtoc_pointers */
void connectx4lx_dtoc_pointers_pack(const union connectx4lx_dtoc_pointers *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_dtoc_pointers_unpack(union connectx4lx_dtoc_pointers *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_dtoc_pointers_print(const union connectx4lx_dtoc_pointers *ptr_struct, FILE* file, int indent_level);
int connectx4lx_dtoc_pointers_size(void);
#define CONNECTX4LX_DTOC_POINTERS_SIZE    (0x100)
void connectx4lx_dtoc_pointers_dump(const union connectx4lx_dtoc_pointers *ptr_struct, FILE* file);
/* reset_info */
void connectx4lx_reset_info_pack(const struct connectx4lx_reset_info *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_reset_info_unpack(struct connectx4lx_reset_info *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_reset_info_print(const struct connectx4lx_reset_info *ptr_struct, FILE* file, int indent_level);
int connectx4lx_reset_info_size(void);
#define CONNECTX4LX_RESET_INFO_SIZE    (0x100)
void connectx4lx_reset_info_dump(const struct connectx4lx_reset_info *ptr_struct, FILE* file);
/* boot_record_dotan */
void connectx4lx_boot_record_dotan_pack(const struct connectx4lx_boot_record_dotan *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_boot_record_dotan_unpack(struct connectx4lx_boot_record_dotan *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_boot_record_dotan_print(const struct connectx4lx_boot_record_dotan *ptr_struct, FILE* file, int indent_level);
int connectx4lx_boot_record_dotan_size(void);
#define CONNECTX4LX_BOOT_RECORD_DOTAN_SIZE    (0x10)
void connectx4lx_boot_record_dotan_dump(const struct connectx4lx_boot_record_dotan *ptr_struct, FILE* file);
/* icmd_ctrl */
void connectx4lx_icmd_ctrl_pack(const struct connectx4lx_icmd_ctrl *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_ctrl_unpack(struct connectx4lx_icmd_ctrl *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_ctrl_print(const struct connectx4lx_icmd_ctrl *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_ctrl_size(void);
#define CONNECTX4LX_ICMD_CTRL_SIZE    (0x10)
void connectx4lx_icmd_ctrl_dump(const struct connectx4lx_icmd_ctrl *ptr_struct, FILE* file);
/* icmd_cmd */
void connectx4lx_icmd_cmd_pack(const union connectx4lx_icmd_cmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_cmd_unpack(union connectx4lx_icmd_cmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_cmd_print(const union connectx4lx_icmd_cmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_cmd_size(void);
#define CONNECTX4LX_ICMD_CMD_SIZE    (0x300)
void connectx4lx_icmd_cmd_dump(const union connectx4lx_icmd_cmd *ptr_struct, FILE* file);
/* sw_cqe_sigerr */
void connectx4lx_sw_cqe_sigerr_pack(const struct connectx4lx_sw_cqe_sigerr *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_sigerr_unpack(struct connectx4lx_sw_cqe_sigerr *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_sigerr_print(const struct connectx4lx_sw_cqe_sigerr *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_sigerr_size(void);
#define CONNECTX4LX_SW_CQE_SIGERR_SIZE    (0x40)
void connectx4lx_sw_cqe_sigerr_dump(const struct connectx4lx_sw_cqe_sigerr *ptr_struct, FILE* file);
/* sw_cqe_resize */
void connectx4lx_sw_cqe_resize_pack(const struct connectx4lx_sw_cqe_resize *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_resize_unpack(struct connectx4lx_sw_cqe_resize *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_resize_print(const struct connectx4lx_sw_cqe_resize *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_resize_size(void);
#define CONNECTX4LX_SW_CQE_RESIZE_SIZE    (0x40)
void connectx4lx_sw_cqe_resize_dump(const struct connectx4lx_sw_cqe_resize *ptr_struct, FILE* file);
/* sw_cqe_error */
void connectx4lx_sw_cqe_error_pack(const struct connectx4lx_sw_cqe_error *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_error_unpack(struct connectx4lx_sw_cqe_error *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_error_print(const struct connectx4lx_sw_cqe_error *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_error_size(void);
#define CONNECTX4LX_SW_CQE_ERROR_SIZE    (0x40)
void connectx4lx_sw_cqe_error_dump(const struct connectx4lx_sw_cqe_error *ptr_struct, FILE* file);
/* sw_cqe_128b */
void connectx4lx_sw_cqe_128b_pack(const struct connectx4lx_sw_cqe_128b *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_128b_unpack(struct connectx4lx_sw_cqe_128b *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_128b_print(const struct connectx4lx_sw_cqe_128b *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_128b_size(void);
#define CONNECTX4LX_SW_CQE_128B_SIZE    (0x80)
void connectx4lx_sw_cqe_128b_dump(const struct connectx4lx_sw_cqe_128b *ptr_struct, FILE* file);
/* itoc_entry */
void connectx4lx_itoc_entry_pack(const struct connectx4lx_itoc_entry *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itoc_entry_unpack(struct connectx4lx_itoc_entry *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itoc_entry_print(const struct connectx4lx_itoc_entry *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itoc_entry_size(void);
#define CONNECTX4LX_ITOC_ENTRY_SIZE    (0x20)
void connectx4lx_itoc_entry_dump(const struct connectx4lx_itoc_entry *ptr_struct, FILE* file);
/* itoc_header */
void connectx4lx_itoc_header_pack(const struct connectx4lx_itoc_header *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itoc_header_unpack(struct connectx4lx_itoc_header *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itoc_header_print(const struct connectx4lx_itoc_header *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itoc_header_size(void);
#define CONNECTX4LX_ITOC_HEADER_SIZE    (0x20)
void connectx4lx_itoc_header_dump(const struct connectx4lx_itoc_header *ptr_struct, FILE* file);
/* lane_data */
void connectx4lx_lane_data_pack(const struct connectx4lx_lane_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_lane_data_unpack(struct connectx4lx_lane_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_lane_data_print(const struct connectx4lx_lane_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_lane_data_size(void);
#define CONNECTX4LX_LANE_DATA_SIZE    (0x8e0)
void connectx4lx_lane_data_dump(const struct connectx4lx_lane_data *ptr_struct, FILE* file);
/* opamp_calibration_results_ports */
void connectx4lx_opamp_calibration_results_ports_pack(const struct connectx4lx_opamp_calibration_results_ports *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_opamp_calibration_results_ports_unpack(struct connectx4lx_opamp_calibration_results_ports *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_opamp_calibration_results_ports_print(const struct connectx4lx_opamp_calibration_results_ports *ptr_struct, FILE* file, int indent_level);
int connectx4lx_opamp_calibration_results_ports_size(void);
#define CONNECTX4LX_OPAMP_CALIBRATION_RESULTS_PORTS_SIZE    (0x980)
void connectx4lx_opamp_calibration_results_ports_dump(const struct connectx4lx_opamp_calibration_results_ports *ptr_struct, FILE* file);
/* port_data */
void connectx4lx_port_data_pack(const struct connectx4lx_port_data *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_port_data_unpack(struct connectx4lx_port_data *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_port_data_print(const struct connectx4lx_port_data *ptr_struct, FILE* file, int indent_level);
int connectx4lx_port_data_size(void);
#define CONNECTX4LX_PORT_DATA_SIZE    (0x880)
void connectx4lx_port_data_dump(const struct connectx4lx_port_data *ptr_struct, FILE* file);
/* sw_wqe */
void connectx4lx_sw_wqe_pack(const struct connectx4lx_sw_wqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_wqe_unpack(struct connectx4lx_sw_wqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_wqe_print(const struct connectx4lx_sw_wqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_wqe_size(void);
#define CONNECTX4LX_SW_WQE_SIZE    (0x400)
void connectx4lx_sw_wqe_dump(const struct connectx4lx_sw_wqe *ptr_struct, FILE* file);
/* ini */
void connectx4lx_ini_pack(const union connectx4lx_ini *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_ini_unpack(union connectx4lx_ini *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_ini_print(const union connectx4lx_ini *ptr_struct, FILE* file, int indent_level);
int connectx4lx_ini_size(void);
#define CONNECTX4LX_INI_SIZE    (0x10000)
void connectx4lx_ini_dump(const union connectx4lx_ini *ptr_struct, FILE* file);
/* a2d_core */
void connectx4lx_a2d_core_pack(const struct connectx4lx_a2d_core *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_a2d_core_unpack(struct connectx4lx_a2d_core *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_a2d_core_print(const struct connectx4lx_a2d_core *ptr_struct, FILE* file, int indent_level);
int connectx4lx_a2d_core_size(void);
#define CONNECTX4LX_A2D_CORE_SIZE    (0x40)
void connectx4lx_a2d_core_dump(const struct connectx4lx_a2d_core *ptr_struct, FILE* file);
/* icmd */
void connectx4lx_icmd_pack(const struct connectx4lx_icmd *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_icmd_unpack(struct connectx4lx_icmd *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_icmd_print(const struct connectx4lx_icmd *ptr_struct, FILE* file, int indent_level);
int connectx4lx_icmd_size(void);
#define CONNECTX4LX_ICMD_SIZE    (0x400)
void connectx4lx_icmd_dump(const struct connectx4lx_icmd *ptr_struct, FILE* file);
/* sw_cqe */
void connectx4lx_sw_cqe_pack(const union connectx4lx_sw_cqe *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_unpack(union connectx4lx_sw_cqe *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_sw_cqe_print(const union connectx4lx_sw_cqe *ptr_struct, FILE* file, int indent_level);
int connectx4lx_sw_cqe_size(void);
#define CONNECTX4LX_SW_CQE_SIZE    (0x80)
void connectx4lx_sw_cqe_dump(const union connectx4lx_sw_cqe *ptr_struct, FILE* file);
/* itoc */
void connectx4lx_itoc_pack(const union connectx4lx_itoc *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_itoc_unpack(union connectx4lx_itoc *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_itoc_print(const union connectx4lx_itoc *ptr_struct, FILE* file, int indent_level);
int connectx4lx_itoc_size(void);
#define CONNECTX4LX_ITOC_SIZE    (0x20)
void connectx4lx_itoc_dump(const union connectx4lx_itoc *ptr_struct, FILE* file);
/* phy_uc_data_ports */
void connectx4lx_phy_uc_data_ports_pack(const struct connectx4lx_phy_uc_data_ports *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_phy_uc_data_ports_unpack(struct connectx4lx_phy_uc_data_ports *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_phy_uc_data_ports_print(const struct connectx4lx_phy_uc_data_ports *ptr_struct, FILE* file, int indent_level);
int connectx4lx_phy_uc_data_ports_size(void);
#define CONNECTX4LX_PHY_UC_DATA_PORTS_SIZE    (0x6400)
void connectx4lx_phy_uc_data_ports_dump(const struct connectx4lx_phy_uc_data_ports *ptr_struct, FILE* file);
/* connectx4lx_Nodes */
void connectx4lx_connectx4lx_Nodes_pack(const union connectx4lx_connectx4lx_Nodes *ptr_struct, u_int8_t* ptr_buff);
void connectx4lx_connectx4lx_Nodes_unpack(union connectx4lx_connectx4lx_Nodes *ptr_struct, const u_int8_t* ptr_buff);
void connectx4lx_connectx4lx_Nodes_print(const union connectx4lx_connectx4lx_Nodes *ptr_struct, FILE* file, int indent_level);
int connectx4lx_connectx4lx_Nodes_size(void);
#define CONNECTX4LX_CONNECTX4LX_NODES_SIZE    (0x10000)
void connectx4lx_connectx4lx_Nodes_dump(const union connectx4lx_connectx4lx_Nodes *ptr_struct, FILE* file);


#ifdef __cplusplus
}
#endif

#endif // CONNECTX4LX_LAYOUTS_H
